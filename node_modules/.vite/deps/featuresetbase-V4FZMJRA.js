import {
  B,
  F,
  I as I2,
  L as L2,
  T,
  a as a2,
  a2 as a3,
  b,
  c,
  e,
  e2,
  f,
  g,
  j,
  k,
  k2,
  q as q2
} from "./chunk-3NMAAFNR.js";
import "./chunk-KMLN2BZX.js";
import {
  D as D2,
  u
} from "./chunk-GGNFNEIJ.js";
import "./chunk-JZRUQED2.js";
import {
  D
} from "./chunk-TXUI2PB2.js";
import {
  l
} from "./chunk-2SW44O36.js";
import {
  l as l2
} from "./chunk-QFUDSK3Q.js";
import "./chunk-EGJS4OMD.js";
import {
  t as t2
} from "./chunk-6643GOM6.js";
import {
  N
} from "./chunk-Z3CHIB6Q.js";
import {
  $,
  H,
  I2 as I,
  K,
  L,
  P2 as P,
  Q,
  U,
  X,
  a,
  be,
  ce,
  ge,
  ne,
  pe,
  q,
  qe,
  r,
  t,
  v2 as v,
  we,
  y as y2
} from "./chunk-24PJGGGS.js";
import "./chunk-RXV6RUH7.js";
import "./chunk-JF5KFXQA.js";
import "./chunk-SH5MUYBA.js";
import "./chunk-FDNAIASW.js";
import "./chunk-IHXVTF6I.js";
import "./chunk-MKRPXDII.js";
import "./chunk-S6CVQWN7.js";
import "./chunk-JWPJ4Y6I.js";
import "./chunk-OYPRFNII.js";
import "./chunk-747B2TEO.js";
import "./chunk-4NEWABLH.js";
import "./chunk-FW2Y26A2.js";
import "./chunk-5WG7GACT.js";
import {
  x
} from "./chunk-GXVWD6F2.js";
import {
  m
} from "./chunk-W4QVNWBV.js";
import "./chunk-LOGPPZUD.js";
import "./chunk-HYU6N3H3.js";
import {
  Ze
} from "./chunk-BPPKPMEP.js";
import "./chunk-ADNT35Y3.js";
import "./chunk-3F7Z2GZ4.js";
import "./chunk-BVTDQR4O.js";
import "./chunk-JDVR6MOC.js";
import "./chunk-DYYHVSPV.js";
import "./chunk-UIN5EOGE.js";
import "./chunk-ZRKSP45X.js";
import "./chunk-DT2VHQBL.js";
import "./chunk-FYSZRVYZ.js";
import "./chunk-6C2TVJRX.js";
import "./chunk-Z6LZMG5A.js";
import "./chunk-323PT7GB.js";
import "./chunk-TKJNJ6KH.js";
import "./chunk-36R5EC6A.js";
import "./chunk-KLPBCYCG.js";
import "./chunk-3HOLDCR2.js";
import "./chunk-DCL3YBJN.js";
import "./chunk-3ZWLSDVT.js";
import "./chunk-5DLICG33.js";
import "./chunk-ZILXWPAR.js";
import "./chunk-HPFRYEGX.js";
import "./chunk-F64GI7MS.js";
import "./chunk-4LDWKTSM.js";
import "./chunk-U4ONWLTG.js";
import "./chunk-POSLR7O2.js";
import "./chunk-VOYU5TTK.js";
import "./chunk-P5VIVFJT.js";
import "./chunk-SA3C7GIT.js";
import "./chunk-P3R45ANF.js";
import "./chunk-PIEUUBJ5.js";
import "./chunk-YIAYIZOZ.js";
import "./chunk-P5GW5DPX.js";
import "./chunk-VIOPOI6P.js";
import "./chunk-DMLVD5AS.js";
import "./chunk-DOALI2C2.js";
import "./chunk-E3I4MGUC.js";
import "./chunk-UHNBENSV.js";
import "./chunk-GDKL26HH.js";
import "./chunk-2CL4LRYG.js";
import "./chunk-64EQFPYJ.js";
import "./chunk-HKYMYCLL.js";
import "./chunk-ICVVQFO6.js";
import "./chunk-BYK6DXRK.js";
import "./chunk-IYJG2X3Y.js";
import "./chunk-UTCX6DGX.js";
import "./chunk-HBL2432S.js";
import "./chunk-T2S5L26W.js";
import "./chunk-7VNZ6V2N.js";
import "./chunk-VKTTTBW2.js";
import "./chunk-TTZWDXX5.js";
import "./chunk-OCLKX5SY.js";
import "./chunk-SEKLTVY5.js";
import "./chunk-HX5GOVNX.js";
import "./chunk-2Q2Q2Z4U.js";
import "./chunk-S6MJEC4A.js";
import "./chunk-HU7QYAVQ.js";
import "./chunk-45OAWGCA.js";
import "./chunk-R4LYFMZX.js";
import "./chunk-X2TA76Q5.js";
import "./chunk-T3Y5GTKO.js";
import {
  y
} from "./chunk-XN6LAULS.js";
import "./chunk-M7OEQQRX.js";
import "./chunk-CSWPLQ7Q.js";
import "./chunk-KWSMYM7P.js";
import "./chunk-RP5SAUAF.js";
import "./chunk-6BFXMZEZ.js";
import "./chunk-AMSVADDY.js";
import "./chunk-6B7VJB6C.js";
import "./chunk-GAJBN4TM.js";
import "./chunk-BADPOP5P.js";
import "./chunk-YXRSJYLG.js";
import "./chunk-KBKTS574.js";
import "./chunk-6ABSX3YY.js";
import "./chunk-OJ65P3EQ.js";
import "./chunk-24NOAXOQ.js";
import "./chunk-FWR4JURK.js";
import "./chunk-BELGAUAK.js";
import "./chunk-JHJVOI7Q.js";
import "./chunk-TWNBDJHC.js";
import "./chunk-HITXLR5N.js";
import "./chunk-WYZCKLOR.js";
import "./chunk-S6NERLXF.js";
import "./chunk-4TSAC52K.js";
import "./chunk-H4ZZ5S37.js";
import "./chunk-G557TGXY.js";
import "./chunk-2AXFVQBN.js";
import "./chunk-WOGT6UK2.js";
import "./chunk-RHT6WWRD.js";
import "./chunk-EUGXS5RE.js";
import "./chunk-IRNKV32L.js";
import "./chunk-OFRZSMZB.js";
import "./chunk-IATM3RCE.js";
import "./chunk-BEALJUHO.js";
import "./chunk-GRHSIT57.js";
import "./chunk-PJQIAD5D.js";
import "./chunk-Z6KIMOUA.js";
import "./chunk-SZAJDZCO.js";
import "./chunk-M7R7REMB.js";
import "./chunk-ZZYUEH57.js";
import "./chunk-VTWXDFFD.js";
import "./chunk-IPCIO3PX.js";
import "./chunk-EIY2DYTV.js";
import "./chunk-WJ4LS3YG.js";
import "./chunk-F6MD5VOH.js";
import "./chunk-V2RPSCV3.js";
import "./chunk-AOJ6OCPK.js";
import "./chunk-LMT5JII2.js";
import "./chunk-A43TI6AT.js";
import "./chunk-BHJVWW2P.js";
import "./chunk-4HKQSEUR.js";
import "./chunk-V3U4F2NL.js";
import "./chunk-ZB6PGKG5.js";
import "./chunk-OIIDE5GZ.js";
import "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import "./chunk-APYNYYQC.js";
import "./chunk-TBSVVR6M.js";
import "./chunk-6TJWLWLO.js";
import "./chunk-H7BKONNV.js";
import "./chunk-K6C6RVSV.js";
import "./chunk-KBJ5Z4R2.js";
import "./chunk-JUZJCTW2.js";
import "./chunk-423VNHLR.js";
import "./chunk-FN47E7YK.js";
import "./chunk-XZS3Q5K4.js";
import {
  j as j2
} from "./chunk-XXFXRXFH.js";
import "./chunk-CCXEAKIM.js";
import "./chunk-Y5D433JZ.js";
import "./chunk-QNOCEWCR.js";
import "./chunk-WURET5CW.js";
import "./chunk-QWPLZ3QH.js";
import "./chunk-HLGIRLYQ.js";
import "./chunk-N2K4VRZH.js";
import "./chunk-WL4VPODY.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import "./chunk-LXXF7K7W.js";
import "./chunk-SBW6NNVI.js";
import "./chunk-62CXLI6S.js";
import {
  E
} from "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import "./chunk-WJ3HJKNC.js";
import "./chunk-4V6374PV.js";
import "./chunk-A34O4XB5.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/arcade/functions/featuresetbase.js
function Y(e3, t3, n, a4) {
  if (1 === a4.length) {
    if (q(a4[0]))
      return l(e3, a4[0], -1);
    if ($(a4[0]))
      return l(e3, a4[0].toArray(), -1);
  }
  return l(e3, a4, -1);
}
async function X2(e3, t3, n) {
  const a4 = e3.getVariables();
  if (a4.length > 0) {
    const i = [];
    for (let e4 = 0; e4 < a4.length; e4++) {
      const r3 = { name: a4[e4] };
      i.push(await t3.evaluateIdentifier(n, r3));
    }
    const r2 = {};
    for (let e4 = 0; e4 < a4.length; e4++)
      r2[a4[e4]] = i[e4];
    return e3.parameters = r2, e3;
  }
  return e3;
}
function ee(e3, t3, n = null) {
  for (const a4 in e3)
    if (a4.toLowerCase() === t3.toLowerCase())
      return e3[a4];
  return n;
}
function te(e3) {
  if (null === e3)
    return null;
  const t3 = { type: ee(e3, "type", ""), name: ee(e3, "name", "") };
  if ("range" === t3.type)
    t3.range = ee(e3, "range", []);
  else {
    t3.codedValues = [];
    for (const n of ee(e3, "codedValues", []))
      t3.codedValues.push({ name: ee(n, "name", ""), code: ee(n, "code", null) });
  }
  return t3;
}
function ne2(e3) {
  if (null === e3)
    return null;
  const t3 = {}, n = ee(e3, "wkt", null);
  null !== n && (t3.wkt = n);
  const a4 = ee(e3, "wkid", null);
  return null !== a4 && (t3.wkid = a4), t3;
}
function ae(e3) {
  if (null === e3)
    return null;
  const t3 = { hasZ: ee(e3, "hasz", false), hasM: ee(e3, "hasm", false) }, n = ee(e3, "spatialreference", null);
  n && (t3.spatialReference = ne2(n));
  const a4 = ee(e3, "x", null);
  if (null !== a4)
    return t3.x = a4, t3.y = ee(e3, "y", null), t3;
  const i = ee(e3, "rings", null);
  if (null !== i)
    return t3.rings = i, t3;
  const r2 = ee(e3, "paths", null);
  if (null !== r2)
    return t3.paths = r2, t3;
  const s = ee(e3, "points", null);
  if (null !== s)
    return t3.points = s, t3;
  for (const o of ["xmin", "xmax", "ymin", "ymax", "zmin", "zmax", "mmin", "mmax"]) {
    const n2 = ee(e3, o, null);
    null !== n2 && (t3[o] = n2);
  }
  return t3;
}
function ie(e3, t3) {
  for (const n of t3)
    if (n === e3)
      return true;
  return false;
}
function re(e3) {
  return !!e3.layerDefinition && (!!e3.featureSet && (false !== ie(e3.layerDefinition.geometryType, ["", null, "esriGeometryNull", "esriGeometryPoint", "esriGeometryPolyline", "esriGeometryPolygon", "esriGeometryMultipoint", "esriGeometryEnvelope"]) && (false !== q(e3.layerDefinition.fields) && false !== q(e3.featureSet.features))));
}
function se(e3) {
  return "utc" === (e3 == null ? void 0 : e3.toLowerCase()) ? "UTC" : "unknown" === (e3 == null ? void 0 : e3.toLowerCase()) ? "Unknown" : e3;
}
function oe(q3) {
  "async" === q3.mode && (q3.functions.timezone = function(t3, r2) {
    return q3.standardFunctionAsync(t3, r2, async (s, o, l3) => {
      var _a, _b;
      if (ne(l3, 1, 2, t3, r2), K(l3[0]))
        return "Unknown";
      if (X(l3[0]))
        return "Unknown";
      if (H(l3[0])) {
        if (await l3[0].load(), 1 === l3.length || null === l3[1])
          return l3[0].datesInUnknownTimezone ? se("unknown") : se(l3[0].dateFieldsTimeZone);
        if (!(l3[1] instanceof N) || false === l3[1].hasField("type"))
          throw new a(t3, r.InvalidParameter, r2);
        const e3 = l3[1].field("type");
        if (false === P(e3))
          throw new a(t3, r.InvalidParameter, r2);
        switch (ce(e3).toLowerCase()) {
          case "preferredtimezone":
            return se(l3[0].preferredTimeZone);
          case "editfieldsinfo":
            return se(((_a = l3[0].editFieldsInfo) == null ? void 0 : _a.timeZone) ?? null);
          case "timeinfo":
            return se(((_b = l3[0].timeInfo) == null ? void 0 : _b.timeZone) ?? null);
          case "field":
            if (l3[1].hasField("fieldname") && P(l3[1].field("fieldname")))
              return se(l3[0].fieldTimeZone(ce(l3[1].field("fieldname"))));
        }
        throw new a(t3, r.InvalidParameter, r2);
      }
      const f2 = ge(l3[0], qe(t3));
      if (null === f2)
        return null;
      const u2 = f2.timeZone;
      return "system" === u2 ? m.systemTimeZoneCanonicalName : "utc" === u2.toLowerCase() ? "UTC" : "unknown" === u2.toLowerCase() ? "Unknown" : u2;
    });
  }, q3.functions.sqltimestamp = function(e3, t3) {
    return q3.standardFunctionAsync(e3, t3, async (n, r2, s) => {
      ne(s, 1, 3, e3, t3);
      const o = s[0];
      if (Q(o)) {
        if (1 === s.length)
          return o.toSQLWithKeyword();
        if (2 === s.length)
          return o.changeTimeZone(ce(s[1])).toSQLWithKeyword();
        throw new a(e3, r.InvalidParameter, t3);
      }
      if (X(o))
        return o.toSQLWithKeyword();
      if (H(o)) {
        if (3 !== s.length)
          throw new a(e3, r.InvalidParameter, t3);
        await o.load();
        const n2 = ce(s[1]);
        if (X(s[2]))
          return s[2].toSQLWithKeyword();
        if (false === Q(s[2]))
          throw new a(e3, r.InvalidParameter, t3);
        const r3 = o.fieldTimeZone(n2);
        return null === r3 ? s[2].toSQLWithKeyword() : s[2].changeTimeZone(r3).toSQLWithKeyword();
      }
      throw new a(e3, r.InvalidParameter, t3);
    });
  }, q3.signatures.push({ name: "sqltimestamp", min: 2, max: 4 }), q3.functions.featuresetbyid = function(e3, t3) {
    return q3.standardFunctionAsync(e3, t3, (n, r2, o) => {
      if (ne(o, 2, 4, e3, t3), o[0] instanceof e) {
        const n2 = ce(o[1]);
        let r3 = L(o[2], null);
        const s = be(L(o[3], true));
        if (null === r3 && (r3 = ["*"]), false === q(r3))
          throw new a(e3, r.InvalidParameter, t3);
        return o[0].featureSetById(n2, s, r3);
      }
      throw new a(e3, r.InvalidParameter, t3);
    });
  }, q3.signatures.push({ name: "featuresetbyid", min: 2, max: 4 }), q3.functions.getfeatureset = function(e3, t3) {
    return q3.standardFunctionAsync(e3, t3, (n, r2, s) => {
      if (ne(s, 1, 2, e3, t3), U(s[0])) {
        let t4 = L(s[1], "datasource");
        return null === t4 && (t4 = "datasource"), t4 = ce(t4).toLowerCase(), j(s[0].fullSchema(), t4, e3.lrucache, e3.interceptor, e3.spatialReference);
      }
      throw new a(e3, r.InvalidParameter, t3);
    });
  }, q3.signatures.push({ name: "getfeatureset", min: 1, max: 2 }), q3.functions.featuresetbyportalitem = function(e3, n) {
    return q3.standardFunctionAsync(e3, n, (r2, s, o) => {
      var _a, _b;
      if (ne(o, 2, 5, e3, n), null === o[0])
        throw new a(e3, r.PortalRequired, n);
      if (o[0] instanceof t2) {
        const t3 = ce(o[1]), r3 = ce(o[2]);
        let s2 = L(o[3], null);
        const f3 = be(L(o[4], true));
        if (null === s2 && (s2 = ["*"]), false === q(s2))
          throw new a(e3, r.InvalidParameter, n);
        let u3 = null;
        return u3 = ((_a = e3.services) == null ? void 0 : _a.portal) ? e3.services.portal : j2.getDefault(), u3 = l2(o[0], u3), q2(t3, r3, e3.spatialReference, s2, f3, u3, e3.lrucache, e3.interceptor);
      }
      if (false === P(o[0]))
        throw new a(e3, r.PortalRequired, n);
      const f2 = ce(o[0]), u2 = ce(o[1]);
      let c2 = L(o[2], null);
      const d = be(L(o[3], true));
      if (null === c2 && (c2 = ["*"]), false === q(c2))
        throw new a(e3, r.InvalidParameter, n);
      return q2(f2, u2, e3.spatialReference, c2, d, ((_b = e3.services) == null ? void 0 : _b.portal) ?? j2.getDefault(), e3.lrucache, e3.interceptor);
    });
  }, q3.signatures.push({ name: "featuresetbyportalitem", min: 2, max: 5 }), q3.functions.featuresetbyname = function(e3, t3) {
    return q3.standardFunctionAsync(e3, t3, (n, r2, o) => {
      if (ne(o, 2, 4, e3, t3), o[0] instanceof e) {
        const n2 = ce(o[1]);
        let r3 = L(o[2], null);
        const s = be(L(o[3], true));
        if (null === r3 && (r3 = ["*"]), false === q(r3))
          throw new a(e3, r.InvalidParameter, t3);
        return o[0].featureSetByName(n2, s, r3);
      }
      throw new a(e3, r.InvalidParameter, t3);
    });
  }, q3.signatures.push({ name: "featuresetbyname", min: 2, max: 4 }), q3.functions.featureset = function(e3, t3) {
    return q3.standardFunction(e3, t3, (r2, s, o) => {
      ne(o, 1, 1, e3, t3);
      let l3 = o[0];
      const f2 = { layerDefinition: { geometryType: "", objectIdField: "", hasM: false, hasZ: false, globalIdField: "", typeIdField: "", fields: [] }, featureSet: { geometryType: "", features: [] } };
      if (P(l3))
        l3 = JSON.parse(l3), void 0 !== l3.layerDefinition ? (f2.layerDefinition = l3.layerDefinition, f2.featureSet = l3.featureSet, l3.layerDefinition.spatialReference && (f2.layerDefinition.spatialReference = l3.layerDefinition.spatialReference)) : (f2.featureSet.features = l3.features, f2.featureSet.geometryType = l3.geometryType, f2.layerDefinition.geometryType = f2.featureSet.geometryType, f2.layerDefinition.objectIdField = l3.objectIdFieldName ?? "", f2.layerDefinition.typeIdField = l3.typeIdFieldName, f2.layerDefinition.globalIdField = l3.globalIdFieldName, f2.layerDefinition.fields = l3.fields, l3.spatialReference && (f2.layerDefinition.spatialReference = l3.spatialReference));
      else {
        if (!(o[0] instanceof N))
          throw new a(e3, r.InvalidParameter, t3);
        {
          l3 = JSON.parse(o[0].castToText(true));
          const e4 = ee(l3, "layerdefinition");
          if (null !== e4) {
            f2.layerDefinition.geometryType = ee(e4, "geometrytype", ""), f2.featureSet.geometryType = f2.layerDefinition.geometryType, f2.layerDefinition.globalIdField = ee(e4, "globalidfield", ""), f2.layerDefinition.objectIdField = ee(e4, "objectidfield", ""), f2.layerDefinition.typeIdField = ee(e4, "typeidfield", ""), f2.layerDefinition.hasZ = true === ee(e4, "hasz", false), f2.layerDefinition.hasM = true === ee(e4, "hasm", false);
            const t4 = ee(e4, "spatialreference", null);
            t4 && (f2.layerDefinition.spatialReference = ne2(t4));
            for (const a4 of ee(e4, "fields", [])) {
              const e5 = { name: ee(a4, "name", ""), alias: ee(a4, "alias", ""), type: ee(a4, "type", ""), nullable: ee(a4, "nullable", true), editable: ee(a4, "editable", true), length: ee(a4, "length", null), domain: te(ee(a4, "domain")) };
              f2.layerDefinition.fields.push(e5);
            }
            const n = ee(l3, "featureset", null);
            if (n) {
              const e5 = {};
              for (const t5 of f2.layerDefinition.fields)
                e5[t5.name.toLowerCase()] = t5.name;
              for (const t5 of ee(n, "features", [])) {
                const n2 = {}, a4 = ee(t5, "attributes", {});
                for (const t6 in a4)
                  n2[e5[t6.toLowerCase()]] = a4[t6];
                f2.featureSet.features.push({ attributes: n2, geometry: ae(ee(t5, "geometry", null)) });
              }
            }
          } else {
            f2.layerDefinition.hasZ = true === ee(l3, "hasz", false), f2.layerDefinition.hasM = true === ee(l3, "hasm", false), f2.layerDefinition.geometryType = ee(l3, "geometrytype", ""), f2.featureSet.geometryType = f2.layerDefinition.geometryType, f2.layerDefinition.objectIdField = ee(l3, "objectidfieldname", ""), f2.layerDefinition.typeIdField = ee(l3, "typeidfieldname", "");
            const e5 = ee(l3, "spatialreference", null);
            e5 && (f2.layerDefinition.spatialReference = ne2(e5));
            let t4 = ee(l3, "fields", null);
            if (q(t4))
              for (const i of t4) {
                const e6 = { name: ee(i, "name", ""), alias: ee(i, "alias", ""), type: ee(i, "type", ""), nullable: ee(i, "nullable", true), editable: ee(i, "editable", true), length: ee(i, "length", null), domain: te(ee(i, "domain")) };
                f2.layerDefinition.fields.push(e6);
              }
            else
              t4 = null, f2.layerDefinition.fields = t4;
            const n = {};
            for (const i of f2.layerDefinition.fields)
              n[i.name.toLowerCase()] = i.name;
            let a4 = ee(l3, "features", null);
            if (q(a4))
              for (const i of a4) {
                const e6 = {}, t5 = ee(i, "attributes", {});
                for (const a5 in t5)
                  e6[n[a5.toLowerCase()]] = t5[a5];
                f2.featureSet.features.push({ attributes: e6, geometry: ae(ee(i, "geometry", null)) });
              }
            else
              a4 = null, f2.featureSet.features = a4;
          }
        }
      }
      if (false === re(f2))
        throw new a(e3, r.InvalidParameter, t3);
      return f2.layerDefinition.geometryType || (f2.layerDefinition.geometryType = "esriGeometryNull"), f.create(f2, e3.spatialReference);
    });
  }, q3.signatures.push({ name: "featureset", min: 1, max: 1 }), q3.functions.filter = function(e3, t3) {
    return q3.standardFunctionAsync(e3, t3, async (n, r2, s) => {
      if (ne(s, 2, 2, e3, t3), q(s[0]) || $(s[0])) {
        const n2 = [];
        let r3 = s[0];
        r3 instanceof t && (r3 = r3.toArray());
        let o = null;
        if (!v(s[1]))
          throw new a(e3, r.InvalidParameter, t3);
        o = s[1].createFunction(e3);
        for (const e4 of r3) {
          const t4 = o(e4);
          E(t4) ? true === await t4 && n2.push(e4) : true === t4 && n2.push(e4);
        }
        return n2;
      }
      if (H(s[0])) {
        const t4 = await s[0].load(), n2 = x.create(s[1], t4.getFieldsIndex(), t4.dateFieldsTimeZoneDefaultUTC), a4 = n2.getVariables();
        if (a4.length > 0) {
          const t5 = [];
          for (let n3 = 0; n3 < a4.length; n3++) {
            const i2 = { name: a4[n3] };
            t5.push(await q3.evaluateIdentifier(e3, i2));
          }
          const i = {};
          for (let e4 = 0; e4 < a4.length; e4++)
            i[a4[e4]] = t5[e4];
          return n2.parameters = i, new c({ parentfeatureset: s[0], whereclause: n2 });
        }
        return new c({ parentfeatureset: s[0], whereclause: n2 });
      }
      throw new a(e3, r.InvalidParameter, t3);
    });
  }, q3.signatures.push({ name: "filter", min: 2, max: 2 }), q3.functions.orderby = function(e3, t3) {
    return q3.standardFunctionAsync(e3, t3, async (n, r2, s) => {
      if (ne(s, 2, 2, e3, t3), H(s[0])) {
        const e4 = new e2(s[1]);
        return new a2({ parentfeatureset: s[0], orderbyclause: e4 });
      }
      throw new a(e3, r.InvalidParameter, t3);
    });
  }, q3.signatures.push({ name: "orderby", min: 2, max: 2 }), q3.functions.top = function(e3, t3) {
    return q3.standardFunctionAsync(e3, t3, async (n, r2, s) => {
      if (ne(s, 2, 2, e3, t3), H(s[0]))
        return new a3({ parentfeatureset: s[0], topnum: s[1] });
      if (q(s[0]))
        return pe(s[1]) >= s[0].length ? s[0].slice(0) : s[0].slice(0, pe(s[1]));
      if ($(s[0]))
        return pe(s[1]) >= s[0].length() ? s[0].slice(0) : s[0].slice(0, pe(s[1]));
      throw new a(e3, r.InvalidParameter, t3);
    });
  }, q3.signatures.push({ name: "top", min: 2, max: 2 }), q3.functions.first = function(e3, t3) {
    return q3.standardFunctionAsync(e3, t3, async (n, a4, i) => {
      if (ne(i, 1, 1, e3, t3), H(i[0])) {
        const t4 = await i[0].first(n.abortSignal);
        if (null !== t4) {
          const n2 = D.createFromGraphicLikeObject(t4.geometry, t4.attributes, i[0], e3.timeZone);
          return n2._underlyingGraphic = t4, n2;
        }
        return t4;
      }
      return q(i[0]) ? 0 === i[0].length ? null : i[0][0] : $(i[0]) ? 0 === i[0].length() ? null : i[0].get(0) : null;
    });
  }, q3.signatures.push({ name: "first", min: 1, max: 1 }), q3.functions.attachments = function(e3, t3) {
    return q3.standardFunctionAsync(e3, t3, async (r2, s, o) => {
      ne(o, 1, 2, e3, t3);
      const l3 = { minsize: -1, maxsize: -1, types: null, returnMetadata: false };
      if (o.length > 1) {
        if (o[1] instanceof N) {
          if (o[1].hasField("minsize") && (l3.minsize = pe(o[1].field("minsize"))), o[1].hasField("metadata") && (l3.returnMetadata = be(o[1].field("metadata"))), o[1].hasField("maxsize") && (l3.maxsize = pe(o[1].field("maxsize"))), o[1].hasField("types")) {
            const e4 = we(o[1].field("types"), false);
            e4.length > 0 && (l3.types = e4);
          }
        } else if (null !== o[1])
          throw new a(e3, r.InvalidParameter, t3);
      }
      if (U(o[0])) {
        let t4 = o[0]._layer;
        return t4 instanceof Ze && (t4 = g(t4, e3.spatialReference, ["*"], true, e3.lrucache, e3.interceptor)), null === t4 ? [] : false === H(t4) ? [] : (await t4.load(), t4.queryAttachments(o[0].field(t4.objectIdField), l3.minsize, l3.maxsize, l3.types, l3.returnMetadata));
      }
      if (null === o[0])
        return [];
      throw new a(e3, r.InvalidParameter, t3);
    });
  }, q3.signatures.push({ name: "attachments", min: 1, max: 2 }), q3.functions.featuresetbyrelationshipname = function(e3, t3) {
    return q3.standardFunctionAsync(e3, t3, async (n, r2, s) => {
      ne(s, 2, 4, e3, t3);
      const o = s[0], l3 = ce(s[1]);
      let d = L(s[2], null);
      const m2 = be(L(s[3], true));
      if (null === d && (d = ["*"]), false === q(d))
        throw new a(e3, r.InvalidParameter, t3);
      if (null === s[0])
        return null;
      if (!U(s[0]))
        throw new a(e3, r.InvalidParameter, t3);
      let y3 = o._layer;
      if (y3 instanceof Ze && (y3 = g(y3, e3.spatialReference, ["*"], true, e3.lrucache, e3.interceptor)), null === y3)
        return null;
      if (false === H(y3))
        return null;
      y3 = await y3.load();
      const w = y3.relationshipMetaData().filter((e4) => e4.name === l3);
      if (0 === w.length)
        return null;
      if (void 0 !== w[0].relationshipTableId && null !== w[0].relationshipTableId && w[0].relationshipTableId > -1)
        return k2(y3, w[0], o.field(y3.objectIdField), y3.spatialReference, d, m2, e3.lrucache, e3.interceptor);
      let g2 = y3.serviceUrl();
      if (!g2)
        return null;
      g2 = "/" === g2.charAt(g2.length - 1) ? g2 + w[0].relatedTableId.toString() : g2 + "/" + w[0].relatedTableId.toString();
      const I3 = await F(g2, y3.spatialReference, d, m2, e3.lrucache, e3.interceptor);
      await I3.load();
      let D3 = I3.relationshipMetaData();
      if (D3 = D3.filter((e4) => e4.id === w[0].id), false === o.hasField(w[0].keyField) || null === o.field(w[0].keyField)) {
        const e4 = await y3.getFeatureByObjectId(o.field(y3.objectIdField), [w[0].keyField]);
        if (e4) {
          const t4 = x.create(D3[0].keyField + "= @id", I3.getFieldsIndex(), I3.dateFieldsTimeZoneDefaultUTC);
          return t4.parameters = { id: e4.attributes[w[0].keyField] }, I3.filter(t4);
        }
        return new u({ parentfeatureset: I3 });
      }
      const T2 = x.create(D3[0].keyField + "= @id", I3.getFieldsIndex(), I3.dateFieldsTimeZoneDefaultUTC);
      return T2.parameters = { id: o.field(w[0].keyField) }, I3.filter(T2);
    });
  }, q3.signatures.push({ name: "featuresetbyrelationshipname", min: 2, max: 4 }), q3.functions.featuresetbyassociation = function(e3, t3) {
    return q3.standardFunctionAsync(e3, t3, async (n, r2, s) => {
      ne(s, 2, 3, e3, t3);
      const o = s[0], l3 = ce(L(s[1], "")).toLowerCase(), u2 = P(s[2]) ? ce(s[2]) : null;
      if (null === s[0])
        return null;
      if (!U(s[0]))
        throw new a(e3, r.InvalidParameter, t3);
      let c2 = o._layer;
      if (c2 instanceof Ze && (c2 = g(c2, e3.spatialReference, ["*"], true, e3.lrucache, e3.interceptor)), null === c2)
        return null;
      if (false === H(c2))
        return null;
      await c2.load();
      const m2 = c2.serviceUrl(), y3 = await T(m2, e3.spatialReference);
      let w = null, I3 = null, D3 = false;
      if (null !== u2 && "" !== u2 && void 0 !== u2) {
        for (const e4 of y3.terminals)
          e4.terminalName === u2 && (I3 = e4.terminalId);
        null === I3 && (D3 = true);
      }
      const T2 = y3.associations.getFieldsIndex(), b2 = T2.get("TOGLOBALID").name, A = T2.get("FROMGLOBALID").name, x2 = T2.get("TOTERMINALID").name, L3 = T2.get("FROMTERMINALID").name, S = T2.get("FROMNETWORKSOURCEID").name, C = T2.get("TONETWORKSOURCEID").name, v2 = T2.get("ASSOCIATIONTYPE").name, M = T2.get("ISCONTENTVISIBLE").name, k3 = T2.get("OBJECTID").name;
      for (const e4 of c2.fields)
        if ("global-id" === e4.type) {
          w = o.field(e4.name);
          break;
        }
      let O = null, z = new B(new y({ name: "percentalong", alias: "percentalong", type: "double" }), x.create("0", y3.associations.getFieldsIndex(), y3.associations.dateFieldsTimeZoneDefaultUTC)), W = new B(new y({ name: "side", alias: "side", type: "string" }), x.create("''", y3.associations.getFieldsIndex(), y3.associations.dateFieldsTimeZoneDefaultUTC));
      const H2 = "globalid", _ = "globalId", q4 = {};
      for (const e4 in y3.lkp)
        q4[e4] = y3.lkp[e4].sourceId;
      const B2 = new b(new y({ name: "classname", alias: "classname", type: "string" }), null, q4);
      let J = "";
      switch (l3) {
        case "midspan": {
          J = `((${b2}='${w}') OR ( ${A}='${w}')) AND (${v2} IN (5))`, B2.codefield = x.create(`CASE WHEN (${b2}='${w}') THEN ${S} ELSE ${C} END`, y3.associations.getFieldsIndex(), y3.associations.dateFieldsTimeZoneDefaultUTC);
          const e4 = y2(L2.findField(y3.associations.fields, A));
          e4.name = H2, e4.alias = H2, O = new B(e4, x.create(`CASE WHEN (${A}='${w}') THEN ${b2} ELSE ${A} END`, y3.associations.getFieldsIndex(), y3.associations.dateFieldsTimeZoneDefaultUTC)), z = y3.unVersion >= 4 ? new I2(L2.findField(y3.associations.fields, T2.get("PERCENTALONG").name)) : new B(new y({ name: "percentalong", alias: "percentalong", type: "double" }), x.create("0", y3.associations.getFieldsIndex(), y3.associations.dateFieldsTimeZoneDefaultUTC));
          break;
        }
        case "junctionedge": {
          J = `((${b2}='${w}') OR ( ${A}='${w}')) AND (${v2} IN (4,6))`, B2.codefield = x.create(`CASE WHEN (${b2}='${w}') THEN ${S} ELSE ${C} END`, y3.associations.getFieldsIndex(), y3.associations.dateFieldsTimeZoneDefaultUTC);
          const e4 = y2(L2.findField(y3.associations.fields, A));
          e4.name = H2, e4.alias = H2, O = new B(e4, x.create(`CASE WHEN (${A}='${w}') THEN ${b2} ELSE ${A} END`, y3.associations.getFieldsIndex(), y3.associations.dateFieldsTimeZoneDefaultUTC)), W = new B(new y({ name: "side", alias: "side", type: "string" }), x.create(`CASE WHEN (${v2}=4) THEN 'from' ELSE 'to' END`, y3.associations.getFieldsIndex(), y3.associations.dateFieldsTimeZoneDefaultUTC));
          break;
        }
        case "connected": {
          let e4 = `${b2}='@T'`, t4 = `${A}='@T'`;
          null !== I3 && (e4 += ` AND ${x2}=@A`, t4 += ` AND ${L3}=@A`), J = "((" + e4 + ") OR (" + t4 + "))", J = I(J, "@T", w ?? ""), e4 = I(e4, "@T", w ?? ""), null !== I3 && (e4 = I(e4, "@A", I3.toString()), J = I(J, "@A", I3.toString())), B2.codefield = x.create("CASE WHEN " + e4 + ` THEN ${S} ELSE ${C} END`, y3.associations.getFieldsIndex(), y3.associations.dateFieldsTimeZoneDefaultUTC);
          const n2 = y2(L2.findField(y3.associations.fields, A));
          n2.name = H2, n2.alias = H2, O = new B(n2, x.create("CASE WHEN " + e4 + ` THEN ${A} ELSE ${b2} END`, y3.associations.getFieldsIndex(), y3.associations.dateFieldsTimeZoneDefaultUTC));
          break;
        }
        case "container":
          J = `${b2}='${w}' AND ${v2} = 2`, null !== I3 && (J += ` AND ${x2} = ` + I3.toString()), B2.codefield = S, J = "( " + J + " )", O = new k(L2.findField(y3.associations.fields, A), H2, H2);
          break;
        case "content":
          J = `(${A}='${w}' AND ${v2} = 2)`, null !== I3 && (J += ` AND ${L3} = ` + I3.toString()), B2.codefield = C, J = "( " + J + " )", O = new k(L2.findField(y3.associations.fields, b2), H2, H2);
          break;
        case "structure":
          J = `(${b2}='${w}' AND ${v2} = 3)`, null !== I3 && (J += ` AND ${x2} = ` + I3.toString()), B2.codefield = S, J = "( " + J + " )", O = new k(L2.findField(y3.associations.fields, A), H2, _);
          break;
        case "attached":
          J = `(${A}='${w}' AND ${v2} = 3)`, null !== I3 && (J += ` AND ${L3} = ` + I3.toString()), B2.codefield = C, J = "( " + J + " )", O = new k(L2.findField(y3.associations.fields, b2), H2, _);
          break;
        default:
          throw new a(e3, r.InvalidParameter, t3);
      }
      D3 && (J = "1 <> 1");
      return new L2({ parentfeatureset: y3.associations, adaptedFields: [new I2(L2.findField(y3.associations.fields, k3)), new I2(L2.findField(y3.associations.fields, M)), O, W, B2, z], extraFilter: J ? x.create(J, y3.associations.getFieldsIndex(), y3.associations.dateFieldsTimeZoneDefaultUTC) : null });
    });
  }, q3.signatures.push({ name: "featuresetbyassociation", min: 2, max: 6 }), q3.functions.groupby = function(e3, t3) {
    return q3.standardFunctionAsync(e3, t3, async (r2, s, o) => {
      if (ne(o, 3, 3, e3, t3), !H(o[0]))
        throw new a(e3, r.InvalidParameter, t3);
      const l3 = await o[0].load(), f2 = [], u2 = [];
      let c2 = false, d = [];
      if (P(o[1]))
        d.push(o[1]);
      else if (o[1] instanceof N)
        d.push(o[1]);
      else if (q(o[1]))
        d = o[1];
      else {
        if (!$(o[1]))
          throw new a(e3, r.InvalidParameter, t3);
        d = o[1].toArray();
      }
      for (const m2 of d)
        if (P(m2)) {
          const e4 = x.create(ce(m2), l3.getFieldsIndex(), l3.dateFieldsTimeZoneDefaultUTC), t4 = true === D2(e4) ? ce(m2) : "%%%%FIELDNAME";
          f2.push({ name: t4, expression: e4 }), "%%%%FIELDNAME" === t4 && (c2 = true);
        } else {
          if (!(m2 instanceof N))
            throw new a(e3, r.InvalidParameter, t3);
          {
            const n = m2.hasField("name") ? m2.field("name") : "%%%%FIELDNAME", r3 = m2.hasField("expression") ? m2.field("expression") : "";
            if ("%%%%FIELDNAME" === n && (c2 = true), !n)
              throw new a(e3, r.InvalidParameter, t3);
            f2.push({ name: n, expression: x.create(r3 || n, l3.getFieldsIndex(), l3.dateFieldsTimeZoneDefaultUTC) });
          }
        }
      if (d = [], P(o[2]))
        d.push(o[2]);
      else if (q(o[2]))
        d = o[2];
      else if ($(o[2]))
        d = o[2].toArray();
      else {
        if (!(o[2] instanceof N))
          throw new a(e3, r.InvalidParameter, t3);
        d.push(o[2]);
      }
      for (const m2 of d) {
        if (!(m2 instanceof N))
          throw new a(e3, r.InvalidParameter, t3);
        {
          const n = m2.hasField("name") ? m2.field("name") : "", r3 = m2.hasField("statistic") ? m2.field("statistic") : "", s2 = m2.hasField("expression") ? m2.field("expression") : "";
          if (!n || !r3 || !s2)
            throw new a(e3, r.InvalidParameter, t3);
          u2.push({ name: n, statistic: r3.toLowerCase(), expression: x.create(s2, l3.getFieldsIndex(), l3.dateFieldsTimeZoneDefaultUTC) });
        }
      }
      if (c2) {
        const e4 = {};
        for (const n of l3.fields)
          e4[n.name.toLowerCase()] = 1;
        for (const n of f2)
          "%%%%FIELDNAME" !== n.name && (e4[n.name.toLowerCase()] = 1);
        for (const n of u2)
          "%%%%FIELDNAME" !== n.name && (e4[n.name.toLowerCase()] = 1);
        let t4 = 0;
        for (const n of f2)
          if ("%%%%FIELDNAME" === n.name) {
            for (; 1 === e4["field_" + t4.toString()]; )
              t4++;
            e4["field_" + t4.toString()] = 1, n.name = "FIELD_" + t4.toString();
          }
      }
      for (const t4 of f2)
        await X2(t4.expression, q3, e3);
      for (const t4 of u2)
        await X2(t4.expression, q3, e3);
      return o[0].groupby(f2, u2);
    });
  }, q3.signatures.push({ name: "groupby", min: 3, max: 3 }), q3.functions.distinct = function(e3, t3) {
    return q3.standardFunctionAsync(e3, t3, async (r2, s, o) => {
      if (H(o[0])) {
        ne(o, 2, 2, e3, t3);
        const r3 = await o[0].load(), s2 = [];
        let l3 = [];
        if (P(o[1]))
          l3.push(o[1]);
        else if (o[1] instanceof N)
          l3.push(o[1]);
        else if (q(o[1]))
          l3 = o[1];
        else {
          if (!$(o[1]))
            throw new a(e3, r.InvalidParameter, t3);
          l3 = o[1].toArray();
        }
        let f2 = false;
        for (const o2 of l3)
          if (P(o2)) {
            const e4 = x.create(ce(o2), r3.getFieldsIndex(), r3.dateFieldsTimeZoneDefaultUTC), t4 = true === D2(e4) ? ce(o2) : "%%%%FIELDNAME";
            s2.push({ name: t4, expression: e4 }), "%%%%FIELDNAME" === t4 && (f2 = true);
          } else {
            if (!(o2 instanceof N))
              throw new a(e3, r.InvalidParameter, t3);
            {
              const n = o2.hasField("name") ? o2.field("name") : "%%%%FIELDNAME", l4 = o2.hasField("expression") ? o2.field("expression") : "";
              if ("%%%%FIELDNAME" === n && (f2 = true), !n)
                throw new a(e3, r.InvalidParameter, t3);
              s2.push({ name: n, expression: x.create(l4 || n, r3.getFieldsIndex(), r3.dateFieldsTimeZoneDefaultUTC) });
            }
          }
        if (f2) {
          const e4 = {};
          for (const n of r3.fields)
            e4[n.name.toLowerCase()] = 1;
          for (const n of s2)
            "%%%%FIELDNAME" !== n.name && (e4[n.name.toLowerCase()] = 1);
          let t4 = 0;
          for (const n of s2)
            if ("%%%%FIELDNAME" === n.name) {
              for (; 1 === e4["field_" + t4.toString()]; )
                t4++;
              e4["field_" + t4.toString()] = 1, n.name = "FIELD_" + t4.toString();
            }
        }
        for (const t4 of s2)
          await X2(t4.expression, q3, e3);
        return o[0].groupby(s2, []);
      }
      return Y("distinct", r2, s, o);
    });
  }), q3.functions.getfeaturesetinfo = function(e3, t3) {
    return q3.standardFunctionAsync(e3, t3, async (a4, i, r2) => {
      if (ne(r2, 1, 1, e3, t3), !H(r2[0]))
        return null;
      const s = await r2[0].getFeatureSetInfo();
      return s ? N.convertObjectToArcadeDictionary({ layerId: s.layerId, layerName: s.layerName, itemId: s.itemId, serviceLayerUrl: s.serviceLayerUrl, webMapLayerId: s.webMapLayerId ?? null, webMapLayerTitle: s.webMapLayerTitle ?? null, className: null, objectClassId: null }, qe(e3), false, false) : null;
    });
  }, q3.signatures.push({ name: "getfeaturesetinfo", min: 1, max: 1 });
}
export {
  oe as registerFunctions
};
//# sourceMappingURL=featuresetbase-V4FZMJRA.js.map
