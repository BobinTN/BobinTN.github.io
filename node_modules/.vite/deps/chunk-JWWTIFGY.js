import {
  l,
  l3 as l2,
  n as n2
} from "./chunk-DMXA3RSU.js";
import {
  S as S2,
  t as t2
} from "./chunk-NI23WAWZ.js";
import {
  c,
  e,
  f,
  i as i2,
  n,
  s as s4,
  u
} from "./chunk-TJGMKUCX.js";
import {
  W as W2
} from "./chunk-UMP4LYVN.js";
import {
  Q,
  R,
  S,
  V,
  W,
  t
} from "./chunk-XFC7DZXI.js";
import {
  U
} from "./chunk-RCLKRKWR.js";
import {
  It,
  Nt,
  et,
  it,
  nt,
  st
} from "./chunk-747B2TEO.js";
import {
  s as s3
} from "./chunk-FW2Y26A2.js";
import {
  h
} from "./chunk-XUD6H4VO.js";
import {
  a
} from "./chunk-SEKLTVY5.js";
import {
  Z
} from "./chunk-M7OEQQRX.js";
import {
  i
} from "./chunk-MKW4ORPJ.js";
import {
  C,
  b
} from "./chunk-RFPH3ZTZ.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import {
  has
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderJSON.js
function d({ coords: t3, lengths: e2 }) {
  let r3 = 0;
  for (const s5 of e2) {
    for (let e3 = 1; e3 < s5; e3++)
      t3[2 * (r3 + e3)] += t3[2 * (r3 + e3) - 2], t3[2 * (r3 + e3) + 1] += t3[2 * (r3 + e3) - 1];
    r3 += s5;
  }
}
var h2 = class _h extends S2 {
  static fromFeatures(e2, r3) {
    const { objectIdField: s5, geometryType: i3 } = r3, n4 = et([], e2, i3, false, false, s5);
    for (let t3 = 0; t3 < n4.length; t3++)
      n4[t3].displayId = e2[t3].displayId;
    return _h.fromOptimizedFeatures(n4, r3);
  }
  static fromFeatureSet(t3, r3) {
    const s5 = it(t3, r3.objectIdField);
    return _h.fromOptimizedFeatureSet(s5, r3);
  }
  static fromOptimizedFeatureSet(t3, e2) {
    const { features: r3 } = t3, s5 = _h.fromOptimizedFeatures(r3, e2);
    return s5._exceededTransferLimit = t3.exceededTransferLimit, s5._transform = t3.transform, s5._fieldsIndex = new Z(e2.fields), s5;
  }
  static fromOptimizedFeatures(t3, e2, r3) {
    const s5 = S2.createInstance(), i3 = new _h(s5, t3, e2);
    return i3._fieldsIndex = new Z(e2.fields), i3._transform = r3, i3;
  }
  constructor(t3, e2, r3) {
    super(t3, r3), this._exceededTransferLimit = false, this._featureIndex = -1, this._fieldsIndex = null, this._geometryType = r3 == null ? void 0 : r3.geometryType, this._features = e2;
  }
  get fields() {
    return this._fieldsIndex;
  }
  get _current() {
    return this._features[this._featureIndex];
  }
  get geometryType() {
    return this._geometryType;
  }
  get hasFeatures() {
    return !!this._features.length;
  }
  get hasNext() {
    return this._featureIndex + 1 < this._features.length;
  }
  get exceededTransferLimit() {
    return this._exceededTransferLimit;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  removeIds(t3) {
    const e2 = new Set(t3);
    this._features = this._features.filter((t4) => !(null != t4.objectId && e2.has(t4.objectId)));
  }
  append(t3) {
    for (const e2 of t3)
      this._features.push(e2);
  }
  getSize() {
    return this._features.length;
  }
  getCursor() {
    return this.copy();
  }
  getQuantizationTransform() {
    return this._transform;
  }
  getAttributeHash() {
    let t3 = "";
    for (const e2 in this._current.attributes)
      t3 += this._current.attributes[e2];
    return t3;
  }
  getIndex() {
    return this._featureIndex;
  }
  setIndex(t3) {
    this._featureIndex = t3;
  }
  getObjectId() {
    var _a;
    return (_a = this._current) == null ? void 0 : _a.objectId;
  }
  getDisplayId() {
    return this._current.displayId;
  }
  setDisplayId(t3) {
    this._current.displayId = t3;
  }
  getGroupId() {
    return this._current.groupId;
  }
  setGroupId(t3) {
    this._current.groupId = t3;
  }
  copy() {
    const t3 = new _h(this.instance, this._features, this.fullSchema());
    return this.copyInto(t3), t3;
  }
  next() {
    for (; ++this._featureIndex < this._features.length && !this._getExists(); )
      ;
    return this._featureIndex < this._features.length;
  }
  readLegacyFeature() {
    return nt(this._current, this.geometryType, this.hasZ, this.hasM);
  }
  readOptimizedFeature() {
    return this._current;
  }
  readLegacyPointGeometry() {
    return this.readGeometry() ? { x: this.getX(), y: this.getY() } : null;
  }
  readLegacyGeometry() {
    const t3 = this.readUnquantizedGeometry();
    return st(t3, this.geometryType, this.hasZ, this.hasM);
  }
  readLegacyCentroid() {
    const t3 = this.readCentroid();
    return null == t3 ? null : { x: t3.coords[0] * this._sx + this._tx, y: t3.coords[1] * this._sy + this._ty };
  }
  readGeometryArea() {
    return s3(this._current) ? Nt(this._current.geometry, 2) : 0;
  }
  readUnquantizedGeometry() {
    const t3 = this.readGeometry();
    if ("esriGeometryPoint" === this.geometryType || !t3)
      return t3;
    const e2 = t3.clone();
    return d(e2), e2;
  }
  readHydratedGeometry() {
    const t3 = this._current.geometry;
    if (null == t3)
      return null;
    const e2 = t3.clone();
    return null != this._transform && It(e2, e2, this.hasZ, this.hasM, this._transform), e2;
  }
  getXHydrated() {
    if (!s3(this._current))
      return 0;
    const t3 = this._current.geometry.coords[0], e2 = this.getQuantizationTransform();
    return null == e2 ? t3 : t3 * e2.scale[0] + e2.translate[0];
  }
  getYHydrated() {
    if (!s3(this._current))
      return 0;
    const t3 = this._current.geometry.coords[1], e2 = this.getQuantizationTransform();
    return null == e2 ? t3 : e2.translate[1] - t3 * e2.scale[1];
  }
  getX() {
    return s3(this._current) ? this._current.geometry.coords[0] * this._sx + this._tx : 0;
  }
  getY() {
    return s3(this._current) ? this._current.geometry.coords[1] * this._sy + this._ty : 0;
  }
  readGeometry() {
    if (!s3(this._current)) {
      if (null != this._current.centroid) {
        const [t4, e3] = this._current.centroid.coords;
        return this.createQuantizedExtrudedGeometry(t4, e3);
      }
      return null;
    }
    const t3 = this._current.geometry.clone();
    if (t3.isPoint)
      return t3.coords[0] = t3.coords[0] * this._sx + this._tx, t3.coords[1] = t3.coords[1] * this._sy + this._ty, t3;
    let e2 = 0;
    for (const r3 of t3.lengths)
      t3.coords[2 * e2] = t3.coords[2 * e2] * this._sx + this._tx, t3.coords[2 * e2 + 1] = t3.coords[2 * e2 + 1] * this._sy + this._ty, e2 += r3;
    return t3;
  }
  readCentroid() {
    return s3(this._current) ? this._computeCentroid() : this._current.centroid;
  }
  _readAttribute(t3, e2) {
    var _a;
    const r3 = this._fieldsIndex.get(t3);
    if (!r3)
      return;
    let s5 = this._current.attributes[r3.name];
    return null == s5 ? s5 : ("esriFieldTypeTimestampOffset" === ((_a = this.fields.get(t3)) == null ? void 0 : _a.type) && (s5 = this.parseTimestampOffset(s5)), e2 && this.fields.isDateField(t3) ? new Date(s5) : s5);
  }
  copyInto(t3) {
    super.copyInto(t3), t3._featureIndex = this._featureIndex, t3._transform = this._transform, t3._fieldsIndex = this._fieldsIndex;
  }
  _readAttributes() {
    return this._current.attributes;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/AttributeStore.js
var U2 = s.getLogger("esri.views.layers.2d.features.support.AttributeStore");
var A = n2(l, U2);
var E = { sharedArrayBuffer: has("esri-shared-array-buffer"), atomics: has("esri-atomics") };
function w(t3, e2) {
  return (i3) => e2(t3(i3));
}
var D = class {
  constructor(t3, e2, i3, s5) {
    this.size = 0, this.texelSize = 4, this.dirtyStart = 0, this.dirtyEnd = 0;
    const { pixelType: r3, layout: a2, textureOnly: n4 } = s5;
    this.textureOnly = n4 || false, this.pixelType = r3, this._ctype = e2, this.layout = a2, this._resetRange(), this._shared = t3, this.size = i3, n4 || (this.data = this._initData(r3, i3, t3, e2));
  }
  get buffer() {
    var _a;
    return (_a = this.data) == null ? void 0 : _a.buffer;
  }
  unsetComponentAllTexels(t3, e2) {
    const i3 = this.data;
    for (let s5 = 0; s5 < this.size * this.size; s5++)
      i3[s5 * this.texelSize + t3] &= ~e2;
    this.dirtyStart = 0, this.dirtyEnd = this.size * this.size - 1;
  }
  setComponentAllTexels(t3, e2) {
    const i3 = this.data;
    for (let s5 = 0; s5 < this.size * this.size; s5++)
      i3[s5 * this.texelSize + t3] |= 255 & e2;
    this.dirtyStart = 0, this.dirtyEnd = this.size * this.size - 1;
  }
  setComponent(t3, e2, i3) {
    const s5 = this.data;
    for (const r3 of i3)
      s5[r3 * this.texelSize + t3] |= e2, this.dirtyStart = Math.min(this.dirtyStart, r3), this.dirtyEnd = Math.max(this.dirtyEnd, r3);
  }
  setComponentTexel(t3, e2, i3) {
    this.data[i3 * this.texelSize + t3] |= e2, this.dirtyStart = Math.min(this.dirtyStart, i3), this.dirtyEnd = Math.max(this.dirtyEnd, i3);
  }
  unsetComponentTexel(t3, e2, i3) {
    this.data[i3 * this.texelSize + t3] &= ~e2, this.dirtyStart = Math.min(this.dirtyStart, i3), this.dirtyEnd = Math.max(this.dirtyEnd, i3);
  }
  getData(t3, e2) {
    const i3 = f(t3);
    return this.data[i3 * this.texelSize + e2];
  }
  setData(t3, e2, i3) {
    const s5 = f(t3), r3 = 1 << e2;
    0 != (this.layout & r3) ? null != this.data && (this.data[s5 * this.texelSize + e2] = i3, this.dirtyStart = Math.min(this.dirtyStart, s5), this.dirtyEnd = Math.max(this.dirtyEnd, s5)) : U2.error("mapview-attributes-store", "Tried to set a value for a texel's readonly component");
  }
  lock() {
    this.pixelType === U.UNSIGNED_BYTE && this._shared && E.atomics && "local" !== this._ctype && Atomics.store(this.data, 0, 1);
  }
  unlock() {
    this.pixelType === U.UNSIGNED_BYTE && this._shared && E.atomics && "local" !== this._ctype && Atomics.store(this.data, 0, 0);
  }
  expand(t3) {
    if (this.size = t3, !this.textureOnly) {
      const e2 = this._initData(this.pixelType, t3, this._shared, this._ctype), i3 = this.data;
      e2.set(i3), this.data = e2;
    }
  }
  toMessage() {
    const t3 = this.dirtyStart, e2 = this.dirtyEnd, i3 = this.texelSize;
    if (t3 > e2)
      return null;
    this._resetRange();
    const s5 = !(this._shared || "local" === this._ctype), r3 = this.pixelType, a2 = this.layout, n4 = this.data;
    return { start: t3, end: e2, data: s5 && n4.slice(t3 * i3, (e2 + 1) * i3) || null, pixelType: r3, layout: a2 };
  }
  _initData(t3, e2, i3, s5) {
    const r3 = i3 && "local" !== s5 ? SharedArrayBuffer : ArrayBuffer, a2 = W2(t3), n4 = new a2(new r3(e2 * e2 * 4 * a2.BYTES_PER_ELEMENT));
    for (let o = 0; o < n4.length; o += 4)
      n4[o + 1] = 255;
    return n4;
  }
  _resetRange() {
    this.dirtyStart = 2147483647, this.dirtyEnd = 0;
  }
};
var k = class {
  constructor(t3, e2) {
    this._client = t3, this.config = e2, this.updatingHandles = new h(), this._blocks = new Array(), this._filters = new Array(V), this._attributeComputeInfo = null, this._targetType = 0, this._abortController = new AbortController(), this._hasScaleExpr = false, this._size = 32, this._nextUpdate = null, this._currUpdate = null, this._idsToHighlight = /* @__PURE__ */ new Set();
    const i3 = e2.supportsTextureFloat ? U.FLOAT : U.UNSIGNED_BYTE;
    A(`Creating AttributeStore ${E.sharedArrayBuffer ? "with" : "without"} shared memory`), this._blockDescriptors = [{ pixelType: U.UNSIGNED_BYTE, layout: 1 }, { pixelType: U.UNSIGNED_BYTE, layout: 15, textureOnly: true }, { pixelType: U.UNSIGNED_BYTE, layout: 15, textureOnly: true }, { pixelType: i3, layout: 15 }, { pixelType: i3, layout: 15 }, { pixelType: i3, layout: 15 }, { pixelType: i3, layout: 15 }], this._blocks = this._blockDescriptors.map(() => null);
  }
  destroy() {
    this._abortController.abort(), this.updatingHandles.destroy();
  }
  get hasScaleExpr() {
    return this._hasScaleExpr;
  }
  get _signal() {
    return this._abortController.signal;
  }
  get hasHighlight() {
    return this._idsToHighlight.size > 0;
  }
  isUpdating() {
    const t3 = this.updatingHandles.updating || !!this._nextUpdate;
    return has("esri-2d-log-updating") && console.log(`Updating AttributeStore: ${t3}
  -> updatingHandles ${this.updatingHandles.updating} (currUpdate: ${!!this._currUpdate})
  -> nextUpdate: ${!!this._nextUpdate}
`), t3;
  }
  update(t3, e2) {
    this.config = e2;
    const i3 = e2.schema.processors[0].storage, s5 = a(this._schema, i3);
    if ((t3.targets.feature || t3.targets.aggregate) && (t3.storage.data = true), s5 && (has("esri-2d-update-debug") && console.debug("Applying Update - AttributeStore:", s5), t3.storage.data = true, this._schema = i3, this._attributeComputeInfo = null, null != i3)) {
      switch (i3.target) {
        case "feature":
          this._targetType = u;
          break;
        case "aggregate":
          this._targetType = c;
      }
      if ("subtype" === i3.type) {
        this._attributeComputeInfo = { isSubtype: true, subtypeField: i3.subtypeField, map: /* @__PURE__ */ new Map() };
        for (const t4 in i3.mapping) {
          const e3 = i3.mapping[t4];
          if (null != (e3 == null ? void 0 : e3.vvMapping))
            for (const i4 of e3.vvMapping)
              this._bindAttribute(i4, parseInt(t4, 10));
        }
      } else {
        if (this._attributeComputeInfo = { isSubtype: false, map: /* @__PURE__ */ new Map() }, null != i3.vvMapping)
          for (const t4 of i3.vvMapping)
            this._bindAttribute(t4);
        if (null != i3.attributeMapping)
          for (const t4 of i3.attributeMapping)
            this._bindAttribute(t4);
      }
    }
  }
  onTileData(t3, e2) {
    if (null == e2.addOrUpdate)
      return;
    const i3 = e2.addOrUpdate.getCursor();
    for (; i3.next(); ) {
      const t4 = i3.getDisplayId();
      this.setAttributeData(t4, i3);
    }
  }
  async setHighlight(t3, e2) {
    const i3 = 1, s5 = this._getBlock(0), r3 = e2.map((t4) => f(t4));
    s5.lock(), s5.unsetComponentAllTexels(0, i3), s5.setComponent(0, i3, r3), s5.unlock(), this._idsToHighlight.clear();
    for (const a2 of t3)
      this._idsToHighlight.add(a2);
    await this.sendUpdates();
  }
  async updateFilters(t3, e2, i3) {
    has("esri-2d-update-debug") && console.debug("AttributeStore::updateFilters");
    const { service: s5, spatialReference: r3 } = i3, { filters: a2 } = e2, n4 = a2.map((t4, e3) => this._updateFilter(t4, e3, s5, r3)), o = (await Promise.all(n4)).some((t4) => t4);
    has("esri-2d-update-debug") && console.debug("AttributeStore::updateFilters - finsihed"), o && (t3.storage.filters = true, has("esri-2d-update-debug") && console.debug("Applying Update - AttributeStore:", "Filters changed"));
  }
  setData(t3, e2, i3, s5) {
    const r3 = f(t3);
    this._ensureSizeForTexel(r3), this._getBlock(e2).setData(t3, i3, s5);
  }
  getData(t3, e2, i3) {
    return this._getBlock(e2).getData(t3, i3);
  }
  getHighlightFlag(t3) {
    return this._idsToHighlight.has(t3) ? W : 0;
  }
  unsetAttributeData(t3) {
    const e2 = f(t3);
    this._getBlock(0).setData(e2, 0, 0);
  }
  setAttributeData(t3, e2) {
    const s5 = f(t3);
    if (this._ensureSizeForTexel(s5), this._getBlock(0).setData(s5, 0, this.getFilterFlags(e2)), this._targetType !== e(t3))
      return;
    const r3 = this._attributeComputeInfo, a2 = this.config.supportsTextureFloat ? 1 : 2, n4 = 4;
    let o = null;
    r3 && (o = r3.isSubtype ? r3.map.get(e2.readAttribute(r3.subtypeField)) : r3.map, (o == null ? void 0 : o.size) && o.forEach((t4, r4) => {
      const o2 = r4 * a2 % n4, l3 = Math.floor(r4 * a2 / n4), h3 = this._getBlock(l3 + S), p = t4(e2);
      if (this.config.supportsTextureFloat)
        h3.setData(s5, o2, p);
      else if (p === t)
        h3.setData(s5, o2, 255), h3.setData(s5, o2 + 1, 255);
      else {
        const t5 = i(Math.round(p), -32767, 32766) + 32768, e3 = 255 & t5, r5 = (65280 & t5) >> 8;
        h3.setData(s5, o2, e3), h3.setData(s5, o2 + 1, r5);
      }
    }));
  }
  sendUpdates() {
    if (has("esri-2d-update-debug") && console.debug("AttributeStore::sendUpdate"), this._nextUpdate)
      return this._nextUpdate.promise;
    if (this._currUpdate)
      return this._nextUpdate = C(), this.updatingHandles.addPromise(this._nextUpdate.promise), this._nextUpdate.promise;
    const e2 = { blocks: this._blocks.map((t3) => null != t3 ? t3.toMessage() : null) };
    return this._currUpdate = this._createResources().then(() => {
      const t3 = () => {
        if (this._currUpdate = null, this._nextUpdate) {
          const t4 = this._nextUpdate;
          this._nextUpdate = null, this.sendUpdates().then(() => t4.resolve());
        } else
          has("esri-2d-update-debug") && console.debug("AttributeStore::sendUpdate::No additional updates queued");
      };
      has("esri-2d-update-debug") && console.debug("AttributeStore::sendUpdate::client.update");
      const i3 = this.updatingHandles.addPromise(this._client.update(e2, this._signal).then(t3).catch(t3));
      return this._client.render(this._signal), i3;
    }).catch((e3) => {
      if (b(e3))
        return this._createResourcesPromise = null, this._createResources();
      U2.error(new s2("mapview-attribute-store", "Encountered an error during client update", e3));
    }), this._currUpdate;
  }
  _ensureSizeForTexel(t3) {
    for (; t3 >= this._size * this._size; )
      if (this._expand())
        return;
  }
  _bindAttribute(t3, e2) {
    function i3() {
      const { normalizationField: e3 } = t3;
      return e3 ? (i4) => {
        const s6 = i4.readAttribute(e3);
        if (!s6)
          return null;
        return i4.readAttribute(t3.field) / s6;
      } : (e4) => e4.readAttribute(t3.field);
    }
    function s5() {
      return t3.normalizationField && U2.warn("mapview-arcade", "Ignoring normalizationField specified with an arcade expression which is not supported."), (e3) => e3.getComputedNumericAtIndex(t3.fieldIndex);
    }
    let r3;
    if (null != t3.fieldIndex)
      r3 = s5();
    else {
      if (!t3.field)
        return;
      r3 = i3();
    }
    const { valueRepresentation: a2 } = t3;
    if (a2) {
      r3 = w(r3, (t4) => l2(t4, a2));
    }
    const n4 = (t4) => null === t4 || isNaN(t4) || t4 === 1 / 0 || t4 === -1 / 0 ? t : t4, o = this._attributeComputeInfo;
    if (o.isSubtype) {
      const i4 = o.map.get(e2) ?? /* @__PURE__ */ new Map();
      i4.set(t3.binding, w(r3, n4)), o.map.set(e2, i4);
    } else
      o.map.set(t3.binding, w(r3, n4));
  }
  _createResources() {
    if (null != this._createResourcesPromise)
      return this._createResourcesPromise;
    this._getBlock(Q), this._getBlock(R), A("Initializing AttributeStore");
    const e2 = { shared: E.sharedArrayBuffer && !("local" === this._client.type), size: this._size, blocks: this._blocks.map((t3) => null != t3 ? { textureOnly: t3.textureOnly, buffer: t3.buffer, pixelType: t3.pixelType } : null) }, i3 = this._client.initialize(e2, this._signal).catch((e3) => {
      b(e3) ? this._createResourcesPromise = null : U2.error(new s2("mapview-attribute-store", "Encountered an error during client initialization", e3));
    });
    return this._createResourcesPromise = i3, i3.then(() => null == this._createResourcesPromise ? this._createResources() : void 0), i3;
  }
  _getBlock(t3) {
    const e2 = this._blocks[t3];
    if (null != e2)
      return e2;
    A(`Initializing AttributeBlock at index ${t3}`);
    const i3 = E.sharedArrayBuffer, s5 = this._client.type, r3 = new D(i3, s5, this._size, this._blockDescriptors[t3]);
    return this._blocks[t3] = r3, this._createResourcesPromise = null, r3;
  }
  _expand() {
    if (this._size < this.config.maxTextureSize) {
      const t3 = this._size <<= 1;
      A("Expanding block size to", t3, this._blocks);
      for (const e2 of this._blocks)
        e2 == null ? void 0 : e2.expand(t3);
      return this._createResourcesPromise = null, this._size = t3, 0;
    }
    return U2.error(new s2("mapview-limitations", "Maximum number of onscreen features exceeded.")), -1;
  }
  async _updateFilter(t3, e2, i3, s5) {
    const r3 = this._filters[e2], a2 = null != r3 && r3.hash;
    if (!r3 && !t3)
      return false;
    if (a2 === JSON.stringify(t3))
      return false;
    if (null == t3) {
      if (!r3)
        return false;
      const t4 = 1 << e2 + 1, i4 = this._getBlock(0);
      return this._filters[e2] = null, i4.setComponentAllTexels(0, t4), this.sendUpdates(), true;
    }
    const n4 = await this._getFilter(e2, i3);
    return await n4.update(t3, s5), true;
  }
  async _getFilter(t3, e2) {
    const i3 = this._filters[t3];
    if (null != i3)
      return i3;
    const { default: s5 } = await import("./FeatureFilter-KF4SJHPX.js"), r3 = new s5({ geometryType: e2.geometryType, hasM: false, hasZ: false, timeInfo: e2.timeInfo, fieldsIndex: Z.fromJSON(e2.fieldsIndex) });
    return this._filters[t3] = r3, r3;
  }
  isVisible(t3) {
    return !!(2 & this._getBlock(0).getData(t3, 0));
  }
  getFilterFlags(t3) {
    let e2 = 0;
    const i3 = i2(t3.getDisplayId());
    for (let r3 = 0; r3 < this._filters.length; r3++) {
      const s6 = !!(i3 & 1 << r3), a2 = this._filters[r3];
      e2 |= (!s6 || null == a2 || a2.check(t3) ? 1 : 0) << r3;
    }
    let s5 = 0;
    if (this._idsToHighlight.size) {
      const e3 = t3.getObjectId();
      s5 = this.getHighlightFlag(e3);
    }
    return e2 << 1 | s5;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/DisplayIdGenerator.js
var r = class {
  constructor() {
    this._freeIds = [], this._idCounter = 1;
  }
  createId(r3 = false) {
    return s4(this._getFreeId(), r3);
  }
  releaseId(e2) {
    this._freeIds.push(e2);
  }
  _getFreeId() {
    return this._freeIds.length ? this._freeIds.pop() : this._idCounter++;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/ComputedAttributeStorage.js
function n3(t3, e2, s5) {
  if (!(t3.length > e2))
    for (; t3.length <= e2; )
      t3.push(s5);
}
var r2 = class {
  constructor() {
    this._numerics = [], this._strings = [], this._idGenerator = new r(), this._allocatedSize = 256, this._bitsets = [], this._instanceIds = [], this._bounds = [];
  }
  createBitset() {
    const e2 = this._bitsets.length;
    return this._bitsets.push(t2.create(this._allocatedSize, n)), e2 + 1;
  }
  getBitset(t3) {
    return this._bitsets[t3 - 1];
  }
  _expand() {
    this._allocatedSize <<= 1;
    for (const t3 of this._bitsets)
      t3.resize(this._allocatedSize);
  }
  _ensureNumeric(t3, e2) {
    this._numerics[t3] || (this._numerics[t3] = []);
    n3(this._numerics[t3], e2, 0);
  }
  _ensureInstanceId(t3) {
    n3(this._instanceIds, t3, 0);
  }
  _ensureString(t3, e2) {
    this._strings[t3] || (this._strings[t3] = []);
    n3(this._strings[t3], e2, null);
  }
  createDisplayId(t3 = false) {
    const s5 = this._idGenerator.createId();
    return s5 > this._allocatedSize && this._expand(), s4(s5, t3);
  }
  releaseDisplayId(e2) {
    for (const t3 of this._bitsets)
      t3.unset(e2);
    return this._idGenerator.releaseId(e2 & n);
  }
  getComputedNumeric(e2, s5) {
    return this.getComputedNumericAtIndex(e2 & n, 0);
  }
  setComputedNumeric(e2, s5, i3) {
    return this.setComputedNumericAtIndex(e2 & n, i3, 0);
  }
  getComputedString(e2, s5) {
    return this.getComputedStringAtIndex(e2 & n, 0);
  }
  setComputedString(e2, s5, i3) {
    return this.setComputedStringAtIndex(e2 & n, 0, i3);
  }
  getComputedNumericAtIndex(e2, s5) {
    const i3 = e2 & n;
    return this._ensureNumeric(s5, i3), this._numerics[s5][i3];
  }
  setComputedNumericAtIndex(e2, s5, i3) {
    const n4 = e2 & n;
    this._ensureNumeric(s5, n4), this._numerics[s5][n4] = i3;
  }
  getInstanceId(e2) {
    const s5 = e2 & n;
    return this._ensureInstanceId(s5), this._instanceIds[s5];
  }
  setInstanceId(e2, s5) {
    const i3 = e2 & n;
    this._ensureInstanceId(i3), this._instanceIds[i3] = s5;
  }
  getComputedStringAtIndex(e2, s5) {
    const i3 = e2 & n;
    return this._ensureString(s5, i3), this._strings[s5][i3];
  }
  setComputedStringAtIndex(e2, s5, i3) {
    const n4 = e2 & n;
    this._ensureString(s5, n4), this._strings[s5][n4] = i3;
  }
  getXMin(e2) {
    return this._bounds[4 * (e2 & n)];
  }
  getYMin(e2) {
    return this._bounds[4 * (e2 & n) + 1];
  }
  getXMax(e2) {
    return this._bounds[4 * (e2 & n) + 2];
  }
  getYMax(e2) {
    return this._bounds[4 * (e2 & n) + 3];
  }
  setBounds(e2, s5) {
    const i3 = s5.readHydratedGeometry();
    if (!(i3 == null ? void 0 : i3.coords.length))
      return false;
    let r3 = 1 / 0, u2 = 1 / 0, o = -1 / 0, h3 = -1 / 0;
    i3.forEachVertex((t3, e3) => {
      r3 = Math.min(r3, t3), u2 = Math.min(u2, e3), o = Math.max(o, t3), h3 = Math.max(h3, e3);
    });
    const d2 = e2 & n;
    return n3(this._bounds, 4 * d2 + 4, 0), this._bounds[4 * d2] = r3, this._bounds[4 * d2 + 1] = u2, this._bounds[4 * d2 + 2] = o, this._bounds[4 * d2 + 3] = h3, true;
  }
};

export {
  h2 as h,
  k,
  r2 as r
};
//# sourceMappingURL=chunk-JWWTIFGY.js.map
