import {
  c as c2,
  e,
  f as f2,
  i as i2,
  r,
  s as s5,
  t as t2,
  w as w2
} from "./chunk-6ABSX3YY.js";
import {
  c
} from "./chunk-WL4VPODY.js";
import {
  a as a2
} from "./chunk-SJZIFARA.js";
import {
  D,
  _,
  a2 as a,
  f,
  i,
  j
} from "./chunk-R5DM4YAB.js";
import {
  t2 as t
} from "./chunk-SBW6NNVI.js";
import {
  E,
  b,
  s as s4,
  w
} from "./chunk-RFPH3ZTZ.js";
import {
  l
} from "./chunk-WGO3VFQP.js";
import {
  s,
  s2,
  s3
} from "./chunk-WJ3HJKNC.js";
import {
  has
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/core/workers/staticWorkerMessages.js
var a3 = { async request(a7, s7) {
  var _a, _b;
  const r2 = a7.options, n2 = r2.responseType;
  r2.signal = s7 == null ? void 0 : s7.signal, r2.responseType = "native" === n2 || "native-request-init" === n2 ? "native-request-init" : n2 && ["blob", "json", "text"].includes(n2) && ((_a = D(a7.url)) == null ? void 0 : _a.after) ? n2 : "array-buffer";
  const i3 = await j(a7.url, r2), o = { data: i3.data, httpStatus: i3.httpStatus, ssl: i3.ssl };
  switch ((_b = i3.requestOptions) == null ? void 0 : _b.responseType) {
    case "native-request-init":
      return delete o.data.signal, o;
    case "blob":
      o.data = await o.data.arrayBuffer();
      break;
    case "json":
      o.data = new TextEncoder().encode(JSON.stringify(o.data)).buffer;
      break;
    case "text":
      o.data = new TextEncoder().encode(o.data).buffer;
  }
  return { result: o, transferList: [o.data] };
} };

// node_modules/@arcgis/core/core/workers/loaderConfig.js
var a4 = {};
function e2(s7) {
  var _a;
  const e3 = { async: s7.async, isDebug: s7.isDebug, locale: s7.locale, baseUrl: s7.baseUrl, has: { ...s7.has }, map: { ...s7.map }, packages: ((_a = s7.packages) == null ? void 0 : _a.concat()) || [], paths: { ...s7.paths } };
  return s7.hasOwnProperty("async") || (e3.async = true), s7.hasOwnProperty("isDebug") || (e3.isDebug = false), s7.baseUrl || (e3.baseUrl = a4.baseUrl), e3;
}

// node_modules/@arcgis/core/core/workers/WorkerFallback.js
var n = class {
  constructor() {
    const e3 = document.createDocumentFragment();
    ["addEventListener", "dispatchEvent", "removeEventListener"].forEach((s7) => {
      this[s7] = (...r2) => e3[s7](...r2);
    });
  }
};
var a5 = class {
  constructor() {
    this._dispatcher = new n(), this._workerPostMessage({ type: t2.HANDSHAKE });
  }
  terminate() {
  }
  get onmessage() {
    return this._onmessageHandler;
  }
  set onmessage(e3) {
    this._onmessageHandler && this.removeEventListener("message", this._onmessageHandler), this._onmessageHandler = e3, e3 && this.addEventListener("message", e3);
  }
  get onmessageerror() {
    return this._onmessageerrorHandler;
  }
  set onmessageerror(e3) {
    this._onmessageerrorHandler && this.removeEventListener("messageerror", this._onmessageerrorHandler), this._onmessageerrorHandler = e3, e3 && this.addEventListener("messageerror", e3);
  }
  get onerror() {
    return this._onerrorHandler;
  }
  set onerror(e3) {
    this._onerrorHandler && this.removeEventListener("error", this._onerrorHandler), this._onerrorHandler = e3, e3 && this.addEventListener("error", e3);
  }
  postMessage(s7) {
    t(() => {
      this._workerMessageHandler(new MessageEvent("message", { data: s7 }));
    });
  }
  dispatchEvent(e3) {
    return this._dispatcher.dispatchEvent(e3);
  }
  addEventListener(e3, s7, r2) {
    this._dispatcher.addEventListener(e3, s7, r2);
  }
  removeEventListener(e3, s7, r2) {
    this._dispatcher.removeEventListener(e3, s7, r2);
  }
  _workerPostMessage(s7) {
    t(() => {
      this.dispatchEvent(new MessageEvent("message", { data: s7 }));
    });
  }
  async _workerMessageHandler(e3) {
    const n2 = i2(e3);
    if (n2 && n2.type === t2.OPEN) {
      const { modulePath: e4, jobId: t3 } = n2;
      let a7 = await w2.loadWorker(e4);
      a7 || (a7 = await import(
        /* @vite-ignore */
        /* webpackIgnore: true */
        e4
      ));
      const o = w2.connect(a7);
      this._workerPostMessage({ type: t2.OPENED, jobId: t3, data: o });
    }
  }
};

// node_modules/@arcgis/core/core/workers/workerFactory.js
var u = s2.getLogger("esri.core.workers.workerFactory");
var { HANDSHAKE: m } = t2;
var p = 'let globalId=0;const outgoing=new Map,configuration=JSON.parse("{CONFIGURATION}");self.esriConfig=configuration.esriConfig;const workerPath=self.esriConfig.workers.workerPath,HANDSHAKE=0,OPEN=1,OPENED=2,RESPONSE=3,INVOKE=4,ABORT=5;function createAbortError(){const e=new Error("Aborted");return e.name="AbortError",e}function receiveMessage(e){return e&&e.data?"string"==typeof e.data?JSON.parse(e.data):e.data:null}function invokeStaticMessage(e,o,r){const t=r&&r.signal,n=globalId++;return new Promise(((r,s)=>{if(t){if(t.aborted)return s(createAbortError());t.addEventListener("abort",(()=>{outgoing.get(n)&&(outgoing.delete(n),self.postMessage({type:ABORT,jobId:n}),s(createAbortError()))}))}outgoing.set(n,{resolve:r,reject:s}),self.postMessage({type:INVOKE,jobId:n,methodName:e,abortable:null!=t,data:o})}))}let workerRevisionChecked=!1;function checkWorkerRevision(e){if(!workerRevisionChecked&&e.kernelInfo){workerRevisionChecked=!0;const{revision:o,fullVersion:r}=configuration.kernelInfo,{revision:t,fullVersion:n,version:s}=e.kernelInfo;esriConfig.assetsPath!==esriConfig.defaultAssetsPath&&o!==t&&console.warn(`Version mismatch detected between ArcGIS Maps SDK for JavaScript modules and assets. For more information visit https://bit.ly/3QnsuSo.\\nModules version: ${r}\\nAssets version: ${n??s}\\nAssets path: ${esriConfig.assetsPath}`)}}function messageHandler(e){const o=receiveMessage(e);if(!o)return;const r=o.jobId;switch(o.type){case OPEN:let n;function t(e){const o=n.connect(e);self.postMessage({type:OPENED,jobId:r,data:o},[o])}"function"==typeof define&&define.amd?require([workerPath],(e=>{n=e.default||e,checkWorkerRevision(n),n.loadWorker(o.modulePath).then((e=>e||new Promise((e=>{require([o.modulePath],e)})))).then(t)})):"System"in self&&"function"==typeof System.import?System.import(workerPath).then((e=>(n=e.default,checkWorkerRevision(n),n.loadWorker(o.modulePath)))).then((e=>e||System.import(o.modulePath))).then(t):esriConfig.workers.useDynamicImport?import(workerPath).then((e=>{n=e.default||e,checkWorkerRevision(n),n.loadWorker(o.modulePath).then((e=>e||import(o.modulePath))).then(t)})):(self.RemoteClient||importScripts(workerPath),n=self.RemoteClient.default||self.RemoteClient,checkWorkerRevision(n),n.loadWorker(o.modulePath).then(t));break;case RESPONSE:if(outgoing.has(r)){const s=outgoing.get(r);outgoing.delete(r),o.error?s.reject(JSON.parse(o.error)):s.resolve(o.data)}}}self.dojoConfig=configuration.loaderConfig,esriConfig.workers.loaderUrl&&(self.importScripts(esriConfig.workers.loaderUrl),"function"==typeof require&&"function"==typeof require.config&&require.config(configuration.loaderConfig)),self.addEventListener("message",messageHandler),self.postMessage({type:0});';
var g;
var k;
var h = "Failed to create Worker. Fallback to execute module in main thread";
async function w3() {
  if (!has("esri-workers"))
    return y(new a5());
  if (!g && !k)
    try {
      const e4 = p.split('"{CONFIGURATION}"').join(`'${b2()}'`);
      g = URL.createObjectURL(new Blob([e4], { type: "text/javascript" }));
    } catch (r2) {
      k = r2 || {};
    }
  let e3;
  if (g)
    try {
      e3 = new Worker(g, { name: "esri-worker-" + v++ });
    } catch (r2) {
      u.warn(h, k), e3 = new a5();
    }
  else
    u.warn(h, k), e3 = new a5();
  return y(e3);
}
async function y(e3) {
  return new Promise((r2) => {
    function o(s7) {
      const n2 = i2(s7);
      n2 && n2.type === m && (e3.removeEventListener("message", o), e3.removeEventListener("error", t3), r2(e3));
    }
    function t3(r3) {
      r3.preventDefault(), e3.removeEventListener("message", o), e3.removeEventListener("error", t3), u.warn("Failed to create Worker. Fallback to execute module in main thread", r3), (e3 = new a5()).addEventListener("message", o), e3.addEventListener("error", t3);
    }
    e3.addEventListener("message", o), e3.addEventListener("error", t3);
  });
}
function b2() {
  let t3;
  if (null != s.default) {
    const e3 = { ...s };
    delete e3.default, t3 = JSON.parse(JSON.stringify(e3));
  } else
    t3 = JSON.parse(JSON.stringify(s));
  t3.assetsPath = _(t3.assetsPath), t3.defaultAssetsPath = t3.defaultAssetsPath ? _(t3.defaultAssetsPath) : void 0, t3.request.interceptors = [], t3.log.interceptors = [], t3.locale = c(), t3.has = { "esri-csp-restrictions": has("esri-csp-restrictions"), "esri-2d-debug": false, "esri-2d-update-debug": has("esri-2d-update-debug"), "esri-2d-log-updating": has("esri-2d-log-updating"), "featurelayer-pbf": has("featurelayer-pbf"), "featurelayer-simplify-thresholds": has("featurelayer-simplify-thresholds"), "featurelayer-simplify-payload-size-factors": has("featurelayer-simplify-payload-size-factors"), "featurelayer-simplify-mobile-factor": has("featurelayer-simplify-mobile-factor"), "esri-atomics": has("esri-atomics"), "esri-shared-array-buffer": has("esri-shared-array-buffer"), "esri-tiles-debug": has("esri-tiles-debug"), "esri-workers-arraybuffer-transfer": has("esri-workers-arraybuffer-transfer"), "feature-polyline-generalization-factor": has("feature-polyline-generalization-factor"), "host-webworker": 1 }, t3.workers.loaderUrl && (t3.workers.loaderUrl = _(t3.workers.loaderUrl)), t3.workers.workerPath ? t3.workers.workerPath = _(t3.workers.workerPath) : t3.workers.workerPath = _(a2("esri/core/workers/RemoteClient.js")), t3.workers.useDynamicImport = false;
  const i3 = s.workers.loaderConfig, a7 = e2({ baseUrl: i3 == null ? void 0 : i3.baseUrl, locale: c(), has: { "csp-restrictions": 1, "dojo-test-sniff": 0, "host-webworker": 1, ...i3 == null ? void 0 : i3.has }, map: { ...i3 == null ? void 0 : i3.map }, paths: { ...i3 == null ? void 0 : i3.paths }, packages: (i3 == null ? void 0 : i3.packages) || [] }), l3 = { buildDate: f, fullVersion: i, revision: a };
  return JSON.stringify({ esriConfig: t3, loaderConfig: a7, kernelInfo: l3 });
}
var v = 0;

// node_modules/@arcgis/core/core/workers/WorkerOwner.js
var { ABORT: b3, INVOKE: m2, OPEN: _2, OPENED: g2, RESPONSE: u2 } = t2;
var j2 = class _j {
  static async create(e3) {
    const t3 = await w3();
    return new _j(t3, e3);
  }
  constructor(e3, o) {
    this._outJobs = /* @__PURE__ */ new Map(), this._inJobs = /* @__PURE__ */ new Map(), this.worker = e3, this.id = o, e3.addEventListener("message", this._onMessage.bind(this)), e3.addEventListener("error", (e4) => {
      e4.preventDefault(), s2.getLogger("esri.core.workers.WorkerOwner").error(e4);
    });
  }
  terminate() {
    this.worker.terminate();
  }
  async open(e3, t3 = {}) {
    const { signal: o } = t3, r2 = r();
    return new Promise((t4, n2) => {
      const a7 = { resolve: t4, reject: n2, abortHandle: w(o, () => {
        this._outJobs.delete(r2), this._post({ type: b3, jobId: r2 });
      }) };
      this._outJobs.set(r2, a7), this._post({ type: _2, jobId: r2, modulePath: e3 });
    });
  }
  _onMessage(e3) {
    const t3 = i2(e3);
    if (t3)
      switch (t3.type) {
        case g2:
          this._onOpenedMessage(t3);
          break;
        case u2:
          this._onResponseMessage(t3);
          break;
        case b3:
          this._onAbortMessage(t3);
          break;
        case m2:
          this._onInvokeMessage(t3);
      }
  }
  _onAbortMessage(e3) {
    const t3 = this._inJobs, o = e3.jobId, s7 = t3.get(o);
    s7 && (s7.controller && s7.controller.abort(), t3.delete(o));
  }
  _onInvokeMessage(e3) {
    const { methodName: t3, jobId: o, data: s7, abortable: i3 } = e3, l3 = i3 ? new AbortController() : null, c4 = this._inJobs, h3 = a3[t3];
    let p3;
    try {
      if ("function" != typeof h3)
        throw new TypeError(`${t3} is not a function`);
      p3 = h3.call(null, s7, { signal: l3 ? l3.signal : null });
    } catch (b4) {
      return void this._post({ type: u2, jobId: o, error: s5(b4) });
    }
    E(p3) ? (c4.set(o, { controller: l3, promise: p3 }), p3.then((e4) => {
      c4.has(o) && (c4.delete(o), this._post({ type: u2, jobId: o }, e4));
    }, (e4) => {
      c4.has(o) && (c4.delete(o), e4 || (e4 = { message: "Error encountered at method" + t3 }), b(e4) || this._post({ type: u2, jobId: o, error: s5(e4 || { message: `Error encountered at method ${t3}` }) }));
    })) : this._post({ type: u2, jobId: o }, p3);
  }
  _onOpenedMessage(e3) {
    const { jobId: t3, data: s7 } = e3, r2 = this._outJobs.get(t3);
    r2 && (this._outJobs.delete(t3), l(r2.abortHandle), r2.resolve(s7));
  }
  _onResponseMessage(t3) {
    const { jobId: s7, error: r2, data: n2 } = t3, a7 = this._outJobs.get(s7);
    a7 && (this._outJobs.delete(s7), l(a7.abortHandle), r2 ? a7.reject(s3.fromJSON(JSON.parse(r2))) : a7.resolve(n2));
  }
  _post(e3, t3, o) {
    return f2(this.worker, e3, t3, o);
  }
};

// node_modules/@arcgis/core/core/workers/workers.js
var s6 = has("host-browser") ? Math.min(navigator.hardwareConcurrency - 1, has("workers-pool-size")) : 0;
var a6 = has("esri-mobile") ? Math.min(s6, 3) : s6;
a6 || (a6 = has("safari") && has("mac") ? 7 : 2);
var c3 = 0;
var l2 = [];
function m3() {
  g3();
}
async function u3(r2, t3) {
  const n2 = new c2(), { registryTarget: i3, ...s7 } = t3;
  return await n2.open(r2, s7), i3 && e(i3, n2), n2;
}
async function p2(o, e3 = {}) {
  if ("string" != typeof o)
    throw new s3("workers:undefined-module", "modulePath is missing");
  let i3 = e3.strategy || "distributed";
  if (has("host-webworker") && !has("esri-workers") && (i3 = "local"), "local" === i3) {
    let r2 = await w2.loadWorker(o);
    r2 || (r2 = await import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      o
    )), s4(e3.signal);
    const i4 = e3.client || r2;
    return u3([w2.connect(r2)], { ...e3, client: i4 });
  }
  if (await g3(), s4(e3.signal), "dedicated" === i3) {
    const r2 = c3++ % a6;
    return u3([await l2[r2].open(o, e3)], e3);
  }
  if (e3.maxNumWorkers && e3.maxNumWorkers > 0) {
    const r2 = Math.min(e3.maxNumWorkers, a6);
    if (r2 < a6) {
      const t3 = new Array(r2);
      for (let n2 = 0; n2 < r2; ++n2) {
        const r3 = c3++ % a6;
        t3[n2] = l2[r3].open(o, e3);
      }
      return u3(t3, e3);
    }
  }
  return u3(l2.map((r2) => r2.open(o, e3)), e3);
}
var h2;
var d = null;
async function g3() {
  if (d)
    return d;
  h2 = new AbortController();
  const r2 = [];
  for (let t3 = 0; t3 < a6; t3++) {
    const o = j2.create(t3).then((r3) => (l2[t3] = r3, r3));
    r2.push(o);
  }
  return d = Promise.all(r2), d;
}

export {
  m3 as m,
  p2 as p
};
//# sourceMappingURL=chunk-KBKTS574.js.map
