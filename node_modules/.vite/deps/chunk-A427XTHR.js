import {
  o as o2
} from "./chunk-QAQNFI3S.js";
import {
  h
} from "./chunk-K4NVR6KM.js";
import {
  yt
} from "./chunk-747B2TEO.js";
import {
  t
} from "./chunk-FW2Y26A2.js";
import {
  t as t2
} from "./chunk-5WG7GACT.js";
import {
  Z,
  i
} from "./chunk-IRNKV32L.js";
import {
  u
} from "./chunk-3XSRVKBX.js";
import {
  o
} from "./chunk-423VNHLR.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import {
  k
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/layers/graphics/centroid.js
function t3(t4, n2) {
  return t4 ? n2 ? 4 : 3 : n2 ? 3 : 2;
}
function n(n2, I2, o5, u3, N2) {
  if (!(I2 == null ? void 0 : I2.lengths.length))
    return null;
  const l = "upperLeft" === (N2 == null ? void 0 : N2.originPosition) ? -1 : 1;
  n2.lengths.length && (n2.lengths.length = 0), n2.coords.length && (n2.coords.length = 0);
  const s3 = n2.coords, c = [], f2 = o5 ? [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY] : [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY], { lengths: T, coords: i2 } = I2, h2 = t3(o5, u3);
  let g = 0;
  for (const t4 of T) {
    const n3 = e(f2, i2, g, t4, o5, u3, l);
    n3 && c.push(n3), g += t4 * h2;
  }
  if (c.sort((t4, n3) => {
    let e2 = l * t4[2] - l * n3[2];
    return 0 === e2 && o5 && (e2 = t4[4] - n3[4]), e2;
  }), c.length) {
    let t4 = 6 * c[0][2];
    s3[0] = c[0][0] / t4, s3[1] = c[0][1] / t4, o5 && (t4 = 6 * c[0][4], s3[2] = 0 !== t4 ? c[0][3] / t4 : 0), (s3[0] < f2[0] || s3[0] > f2[1] || s3[1] < f2[2] || s3[1] > f2[3] || o5 && (s3[2] < f2[4] || s3[2] > f2[5])) && (s3.length = 0);
  }
  if (!s3.length) {
    const t4 = I2.lengths[0] ? r(i2, 0, T[0], o5, u3) : null;
    if (!t4)
      return null;
    s3[0] = t4[0], s3[1] = t4[1], o5 && t4.length > 2 && (s3[2] = t4[2]);
  }
  return n2;
}
function e(n2, e2, r2, I2, o5, u3, N2 = 1) {
  const l = t3(o5, u3);
  let s3 = r2, c = r2 + l, f2 = 0, T = 0, i2 = 0, h2 = 0, g = 0;
  for (let t4 = 0, b = I2 - 1; t4 < b; t4++, s3 += l, c += l) {
    const t5 = e2[s3], r3 = e2[s3 + 1], I3 = e2[s3 + 2], u4 = e2[c], N3 = e2[c + 1], l2 = e2[c + 2];
    let E2 = t5 * N3 - u4 * r3;
    h2 += E2, f2 += (t5 + u4) * E2, T += (r3 + N3) * E2, o5 && (E2 = t5 * l2 - u4 * I3, i2 += (I3 + l2) * E2, g += E2), t5 < n2[0] && (n2[0] = t5), t5 > n2[1] && (n2[1] = t5), r3 < n2[2] && (n2[2] = r3), r3 > n2[3] && (n2[3] = r3), o5 && (I3 < n2[4] && (n2[4] = I3), I3 > n2[5] && (n2[5] = I3));
  }
  if (h2 * N2 > 0 && (h2 *= -1), g * N2 > 0 && (g *= -1), !h2)
    return null;
  const E = [f2, T, 0.5 * h2];
  return o5 && (E[3] = i2, E[4] = 0.5 * g), E;
}
function r(n2, e2, r2, l, s3) {
  const c = t3(l, s3);
  let f2 = e2, T = e2 + c, i2 = 0, h2 = 0, g = 0, E = 0;
  for (let t4 = 0, b = r2 - 1; t4 < b; t4++, f2 += c, T += c) {
    const t5 = n2[f2], e3 = n2[f2 + 1], r3 = n2[f2 + 2], s4 = n2[T], c2 = n2[T + 1], b2 = n2[T + 2], m2 = l ? o3(t5, e3, r3, s4, c2, b2) : I(t5, e3, s4, c2);
    if (m2)
      if (i2 += m2, l) {
        const n3 = N(t5, e3, r3, s4, c2, b2);
        h2 += m2 * n3[0], g += m2 * n3[1], E += m2 * n3[2];
      } else {
        const n3 = u2(t5, e3, s4, c2);
        h2 += m2 * n3[0], g += m2 * n3[1];
      }
  }
  return i2 > 0 ? l ? [h2 / i2, g / i2, E / i2] : [h2 / i2, g / i2] : r2 > 0 ? l ? [n2[e2], n2[e2 + 1], n2[e2 + 2]] : [n2[e2], n2[e2 + 1]] : null;
}
function I(t4, n2, e2, r2) {
  const I2 = e2 - t4, o5 = r2 - n2;
  return Math.sqrt(I2 * I2 + o5 * o5);
}
function o3(t4, n2, e2, r2, I2, o5) {
  const u3 = r2 - t4, N2 = I2 - n2, l = o5 - e2;
  return Math.sqrt(u3 * u3 + N2 * N2 + l * l);
}
function u2(t4, n2, e2, r2) {
  return [t4 + 0.5 * (e2 - t4), n2 + 0.5 * (r2 - n2)];
}
function N(t4, n2, e2, r2, I2, o5) {
  return [t4 + 0.5 * (r2 - t4), n2 + 0.5 * (I2 - n2), e2 + 0.5 * (o5 - e2)];
}

// node_modules/@arcgis/core/layers/graphics/data/optimizedFeatureQueryEngineAdapter.js
var o4 = { getObjectId: (t4) => t4.objectId, getAttributes: (t4) => t4.attributes, getAttribute: (t4, e2) => t4.attributes[e2], cloneWithGeometry: (t4, r2) => new t(r2, t4.attributes, null, t4.objectId), getGeometry: (t4) => t4.geometry, getCentroid: (e2, o5) => (null == e2.centroid && (e2.centroid = n(new t2(), e2.geometry, o5.hasZ, o5.hasM)), e2.centroid) };

// node_modules/@arcgis/core/layers/graphics/data/FeatureStore.js
var f = i();
var m = class {
  constructor(e2) {
    this.geometryInfo = e2, this._boundsStore = new o2(), this._featuresById = /* @__PURE__ */ new Map(), this._markedIds = /* @__PURE__ */ new Set(), this.events = new o(), this.featureAdapter = o4;
  }
  get geometryType() {
    return this.geometryInfo.geometryType;
  }
  get hasM() {
    return this.geometryInfo.hasM;
  }
  get hasZ() {
    return this.geometryInfo.hasZ;
  }
  get numFeatures() {
    return this._featuresById.size;
  }
  get fullBounds() {
    return this._boundsStore.fullBounds;
  }
  get storeStatistics() {
    let e2 = 0;
    return this._featuresById.forEach((t4) => {
      null != t4.geometry && t4.geometry.coords && (e2 += t4.geometry.coords.length);
    }), { featureCount: this._featuresById.size, vertexCount: e2 / (this.hasZ ? this.hasM ? 4 : 3 : this.hasM ? 3 : 2) };
  }
  getFullExtent(e2) {
    if (null == this.fullBounds)
      return null;
    const [t4, r2, s3, o5] = this.fullBounds;
    return { xmin: t4, ymin: r2, xmax: s3, ymax: o5, spatialReference: h(e2) };
  }
  add(e2) {
    this._add(e2), this._emitChanged();
  }
  addMany(e2) {
    for (const t4 of e2)
      this._add(t4);
    this._emitChanged();
  }
  upsertMany(t4) {
    const r2 = t4.map((e2) => this._upsert(e2));
    return this._emitChanged(), r2.filter(k);
  }
  clear() {
    this._featuresById.clear(), this._boundsStore.clear(), this._emitChanged();
  }
  removeById(e2) {
    const t4 = this._featuresById.get(e2);
    return t4 ? (this._remove(t4), this._emitChanged(), t4) : null;
  }
  removeManyById(e2) {
    this._boundsStore.invalidateIndex();
    for (const t4 of e2) {
      const e3 = this._featuresById.get(t4);
      e3 && this._remove(e3);
    }
    this._emitChanged();
  }
  forEachBounds(e2, t4) {
    for (const r2 of e2) {
      const e3 = this._boundsStore.get(r2.objectId);
      e3 && t4(Z(f, e3));
    }
  }
  getFeature(e2) {
    return this._featuresById.get(e2);
  }
  has(e2) {
    return this._featuresById.has(e2);
  }
  forEach(e2) {
    this._featuresById.forEach((t4) => e2(t4));
  }
  forEachInBounds(e2, t4) {
    this._boundsStore.forEachInBounds(e2, (e3) => {
      t4(this._featuresById.get(e3));
    });
  }
  startMarkingUsedFeatures() {
    this._boundsStore.invalidateIndex(), this._markedIds.clear();
  }
  sweep() {
    let e2 = false;
    this._featuresById.forEach((t4, r2) => {
      this._markedIds.has(r2) || (e2 = true, this._remove(t4));
    }), this._markedIds.clear(), e2 && this._emitChanged();
  }
  _emitChanged() {
    this.events.emit("changed", void 0);
  }
  _add(e2) {
    var _a, _b;
    if (!e2)
      return;
    const r2 = e2.objectId;
    if (null == r2)
      return void s.getLogger("esri.layers.graphics.data.FeatureStore").error(new s2("featurestore:invalid-feature", "feature id is missing", { feature: e2 }));
    const o5 = this._featuresById.get(r2);
    let i2;
    if (this._markedIds.add(r2), o5 ? (e2.displayId = o5.displayId, i2 = this._boundsStore.get(r2), this._boundsStore.delete(r2)) : null != this.onFeatureAdd && this.onFeatureAdd(e2), !((_b = (_a = e2.geometry) == null ? void 0 : _a.coords) == null ? void 0 : _b.length))
      return this._boundsStore.set(r2, null), void this._featuresById.set(r2, e2);
    i2 = yt(null != i2 ? i2 : u(), e2.geometry, this.geometryInfo.hasZ, this.geometryInfo.hasM), null != i2 && this._boundsStore.set(r2, i2), this._featuresById.set(r2, e2);
  }
  _upsert(e2) {
    const r2 = e2 == null ? void 0 : e2.objectId;
    if (null == r2)
      return s.getLogger("esri.layers.graphics.data.FeatureStore").error(new s2("featurestore:invalid-feature", "feature id is missing", { feature: e2 })), null;
    const o5 = this._featuresById.get(r2);
    if (!o5)
      return this._add(e2), e2;
    this._markedIds.add(r2);
    const { geometry: i2, attributes: d } = e2;
    for (const t4 in d)
      o5.attributes[t4] = d[t4];
    return i2 && (o5.geometry = i2, this._boundsStore.set(r2, yt(u(), i2, this.geometryInfo.hasZ, this.geometryInfo.hasM) ?? null)), o5;
  }
  _remove(e2) {
    null != this.onFeatureRemove && this.onFeatureRemove(e2);
    const t4 = e2.objectId;
    return this._markedIds.delete(t4), this._boundsStore.delete(t4), this._featuresById.delete(t4), e2;
  }
};

export {
  m
};
//# sourceMappingURL=chunk-A427XTHR.js.map
