import {
  l
} from "./chunk-WGO3VFQP.js";
import {
  s3 as s
} from "./chunk-WJ3HJKNC.js";

// node_modules/@arcgis/core/core/handleUtils.js
var n = { remove: () => {
} };
function e(e3) {
  return e3 ? { remove() {
    e3 && (e3(), e3 = void 0);
  } } : n;
}
function r(n3) {
  n3.forEach((n4) => n4 == null ? void 0 : n4.remove());
}
function t(n3) {
  return e(() => r(n3));
}

// node_modules/@arcgis/core/core/clock.js
function e2(e3) {
  return { setTimeout: (o2, r3) => {
    const i2 = e3.setTimeout(o2, r3);
    return e(() => e3.clearTimeout(i2));
  } };
}
var o = e2(globalThis);

// node_modules/@arcgis/core/core/events.js
function t2(e3) {
  return e3 && ("function" == typeof e3.on || "function" == typeof e3.addEventListener);
}
function r2(r3, n3, o2) {
  if (!t2(r3))
    throw new TypeError("target is not a Evented or EventTarget object");
  if ("on" in r3)
    return r3.on(n3, o2);
  if (Array.isArray(n3)) {
    const t3 = n3.slice();
    for (const e3 of t3)
      r3.addEventListener(e3, o2);
    return e(() => {
      for (const e3 of t3)
        r3.removeEventListener(e3, o2);
    });
  }
  return r3.addEventListener(n3, o2), e(() => r3.removeEventListener(n3, o2));
}
function n2(e3, n3, o2) {
  if (!t2(e3))
    throw new TypeError("target is not a Evented or EventTarget object");
  if ("once" in e3)
    return e3.once(n3, o2);
  const i2 = r2(e3, n3, (t3) => {
    i2.remove(), o2.call(e3, t3);
  });
  return i2;
}
var i = { Win: "Meta", Scroll: "ScrollLock", Spacebar: " ", Down: "ArrowDown", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Del: "Delete", Apps: "ContextMenu", Esc: "Escape", Multiply: "*", Add: "+", Subtract: "-", Decimal: ".", Divide: "/" };
function c({ key: e3 }) {
  return i[e3] || e3;
}

// node_modules/@arcgis/core/core/promiseUtils.js
function u(t3 = "Aborted") {
  return new s("AbortError", t3);
}
function s3(t3, e3 = "Aborted") {
  if (c2(t3))
    throw u(e3);
}
function l2(t3) {
  return null != t3 ? "aborted" in t3 ? t3 : t3.signal : t3;
}
function c2(t3) {
  const e3 = l2(t3);
  return null != e3 && e3.aborted;
}
function a(t3) {
  if (b(t3))
    throw t3;
}
function f(t3) {
  if (!b(t3))
    throw t3;
}
function m(t3, e3) {
  const n3 = l2(t3);
  if (null != n3) {
    if (!n3.aborted)
      return n2(n3, "abort", () => e3());
    e3();
  }
}
function w(t3, e3) {
  const n3 = l2(t3);
  if (null != n3)
    return s3(n3), n2(n3, "abort", () => e3(u()));
}
function h(t3, e3) {
  return null == l2(e3) ? t3 : new Promise((r3, n3) => {
    let i2 = m(e3, () => n3(u()));
    const s4 = () => {
      i2 = l(i2);
    };
    t3.then(s4, s4), t3.then(r3, n3);
  });
}
function b(t3) {
  return "AbortError" === (t3 == null ? void 0 : t3.name);
}
async function d(t3) {
  try {
    return await t3;
  } catch (e3) {
    if (!b(e3))
      throw e3;
    return;
  }
}
async function v(t3) {
  if (!t3)
    return;
  if ("function" != typeof t3.forEach) {
    const e4 = Object.keys(t3), r3 = e4.map((e5) => t3[e5]), n3 = await v(r3), o2 = {};
    return e4.map((t4, e5) => o2[t4] = n3[e5]), o2;
  }
  const e3 = t3;
  return Promise.allSettled(e3).then((t4) => Array.from(e3, (e4, r3) => {
    const n3 = t4[r3];
    return "fulfilled" === n3.status ? { promise: e4, value: n3.value } : { promise: e4, error: n3.reason };
  }));
}
async function j(t3) {
  return (await v(t3)).filter((t4) => !!t4.value).map((t4) => t4.value);
}
async function P(t3) {
  return (await Promise.allSettled(t3)).filter((t4) => "fulfilled" === t4.status).map((t4) => t4.value);
}
async function g(t3) {
  return (await Promise.allSettled(t3)).filter((t4) => "rejected" === t4.status).map((t4) => t4.reason);
}
function A(t3, e3 = void 0, r3) {
  const n3 = new AbortController();
  return m(r3, () => n3.abort()), new Promise((r4, o2) => {
    let i2 = setTimeout(() => {
      i2 = 0, r4(e3);
    }, t3);
    m(n3, () => {
      i2 && (clearTimeout(i2), o2(u()));
    });
  });
}
function E(t3) {
  return t3 && "function" == typeof t3.then;
}
function S(t3) {
  return E(t3) ? t3 : Promise.resolve(t3);
}
function k(t3, e3 = -1) {
  let r3, n3, o2, i2, s4 = null;
  const l3 = (...c3) => {
    if (r3) {
      n3 = c3, i2 && i2.reject(u()), i2 = C();
      const t4 = i2.promise;
      if (s4) {
        const t5 = s4;
        s4 = null, t5.abort();
      }
      return t4;
    }
    if (o2 = i2 || C(), i2 = null, e3 > 0) {
      const n4 = new AbortController();
      r3 = S(t3(...c3, n4.signal));
      const o3 = r3;
      A(e3).then(() => {
        r3 === o3 && (i2 ? n4.abort() : s4 = n4);
      });
    } else
      r3 = 1, r3 = S(t3(...c3));
    const a2 = () => {
      const t4 = n3;
      n3 = o2 = r3 = s4 = null, null != t4 && l3(...t4);
    }, f2 = r3, m2 = o2;
    return f2.then(a2, a2), f2.then(m2.resolve, m2.reject), m2.promise;
  };
  return l3;
}
function C() {
  let e3, r3;
  const n3 = new Promise((t3, n4) => {
    e3 = t3, r3 = n4;
  }), o2 = (t3) => {
    e3(t3);
  };
  return o2.resolve = (t3) => e3(t3), o2.reject = (t3) => r3(t3), o2.timeout = (e4, r4) => o.setTimeout(() => o2.reject(r4), e4), o2.promise = n3, o2;
}
async function x(t3) {
  await Promise.resolve(), s3(t3);
}

export {
  e,
  t,
  o,
  t2,
  r2 as r,
  n2 as n,
  c,
  u,
  s3 as s,
  c2,
  a,
  f,
  m,
  w,
  h,
  b,
  d,
  v,
  j,
  P,
  g,
  A,
  E,
  S,
  k,
  C,
  x
};
//# sourceMappingURL=chunk-RFPH3ZTZ.js.map
