import {
  e2 as e4
} from "./chunk-J7KPLT4Z.js";
import {
  i
} from "./chunk-AXYEFE3R.js";
import {
  O,
  e2 as e3
} from "./chunk-5LA3TYXZ.js";
import {
  b,
  n2
} from "./chunk-L7F73IMH.js";
import "./chunk-SF4VUK6B.js";
import "./chunk-DN2NYMXJ.js";
import "./chunk-UUFM7UDX.js";
import "./chunk-APYNYYQC.js";
import {
  d
} from "./chunk-TBSVVR6M.js";
import "./chunk-6TJWLWLO.js";
import {
  s as s3
} from "./chunk-H7BKONNV.js";
import "./chunk-K6C6RVSV.js";
import "./chunk-KBJ5Z4R2.js";
import "./chunk-JUZJCTW2.js";
import {
  o
} from "./chunk-423VNHLR.js";
import "./chunk-FN47E7YK.js";
import "./chunk-XZS3Q5K4.js";
import "./chunk-N2K4VRZH.js";
import "./chunk-WL4VPODY.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import {
  A,
  Et,
  F,
  I,
  K,
  T,
  _,
  et,
  j,
  n,
  t as t2,
  t3,
  v,
  x
} from "./chunk-R5DM4YAB.js";
import {
  f
} from "./chunk-NSRXJNTS.js";
import {
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c as c2
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  C,
  c2 as c,
  e as e2,
  m,
  r
} from "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  l,
  s,
  s3 as s2,
  t
} from "./chunk-WJ3HJKNC.js";
import "./chunk-4V6374PV.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/identity/IdentityForm.js
var p = "esri-identity-form";
var a = { base: p, group: `${p}__group`, label: `${p}__label`, footer: `${p}__footer`, esriInput: "esri-input", esriButton: "esri-button", esriButtonSecondary: "esri-button--secondary" };
var l2 = "ArcGIS Online";
var d2 = class extends O {
  constructor(s6, e6) {
    super(s6, e6), this._usernameInputNode = null, this._passwordInputNode = null, this.signingIn = false, this.server = null, this.resource = null, this.error = null, this.oAuthPrompt = false;
  }
  render() {
    var _a;
    const { error: s6, server: e6, resource: t5, signingIn: o2, oAuthPrompt: n3, messages: p3 } = this, d4 = n2("div", { class: a.group }, s3(n3 ? p3.oAuthInfo : p3.info, { server: e6 && /\.arcgis\.com/i.test(e6) ? l2 : e6, resource: `(${t5 || p3.lblItem})` })), c4 = n3 ? null : n2("div", { class: a.group, key: "username" }, n2("label", { class: a.label }, p3.lblUser, n2("input", { afterCreate: b, autocomplete: "off", bind: this, class: a.esriInput, "data-node-ref": "_usernameInputNode", required: true, spellcheck: false, type: "text", value: "" }))), m2 = n3 ? null : n2("div", { class: a.group, key: "password" }, n2("label", { class: a.label }, p3.lblPwd, n2("input", { afterCreate: b, bind: this, class: a.esriInput, "data-node-ref": "_passwordInputNode", required: true, type: "password", value: "" }))), h2 = n2("div", { class: this.classes(a.group, a.footer) }, n2("input", { class: a.esriButton, disabled: !!o2, type: "submit", value: o2 ? p3.lblSigning : p3.lblOk }), n2("input", { bind: this, class: this.classes(a.esriButton, a.esriButtonSecondary), onclick: this._cancel, type: "button", value: p3.lblCancel })), b3 = s6 ? n2("div", null, ((_a = s6.details) == null ? void 0 : _a.httpStatus) ? p3.invalidUser : p3.noAuthService) : null;
    return n2("form", { bind: this, class: a.base, onsubmit: this._submit }, d4, b3, c4, m2, h2);
  }
  _cancel() {
    this._set("signingIn", false), this._usernameInputNode && (this._usernameInputNode.value = ""), this._passwordInputNode && (this._passwordInputNode.value = ""), this.emit("cancel");
  }
  _submit(s6) {
    s6.preventDefault(), this._set("signingIn", true);
    const e6 = this.oAuthPrompt ? {} : { username: this._usernameInputNode && this._usernameInputNode.value, password: this._passwordInputNode && this._passwordInputNode.value };
    this.emit("submit", e6);
  }
};
e([y(), e3("esri/identity/t9n/identity")], d2.prototype, "messages", void 0), e([y()], d2.prototype, "signingIn", void 0), e([y()], d2.prototype, "server", void 0), e([y()], d2.prototype, "resource", void 0), e([y()], d2.prototype, "error", void 0), e([y()], d2.prototype, "oAuthPrompt", void 0), d2 = e([c2("esri.identity.IdentityForm")], d2);
var c3 = d2;

// node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var isInert = function isInert2(node, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result = inert || lookUp && node && isInert2(node.parentNode);
  return result;
};
var isContentEditable = function isContentEditable2(node) {
  var _node$getAttribute2;
  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el, includeContainer, filter) {
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      continue;
    }
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var hasTabIndex = function hasTabIndex2(node) {
  return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
};
var getTabIndex = function getTabIndex2(node) {
  if (!node) {
    throw new Error("No node provided");
  }
  if (node.tabIndex < 0) {
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
};
var getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
  var tabIndex = getTabIndex(node);
  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a2, b3) {
  return a2.tabIndex === b3.tabIndex ? a2.documentOrder - b3.documentOrder : a2.tabIndex - b3.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r3 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r3;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i3 = 0; i3 < nodes.length; i3++) {
    if (nodes[i3].checked && nodes[i3].form === form) {
      return nodes[i3];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isNodeAttached = function isNodeAttached2(node) {
  var _nodeRoot;
  var nodeRoot = node && getRootNode(node);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (isNodeAttached(node)) {
      return !node.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i3 = 0; i3 < parentNode.children.length; i3++) {
          var child = parentNode.children.item(i3);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i3) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i3,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");
var isFocusable = function isFocusable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};

// node_modules/focus-trap/dist/focus-trap.esm.js
function ownKeys(e6, r3) {
  var t5 = Object.keys(e6);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e6);
    r3 && (o2 = o2.filter(function(r4) {
      return Object.getOwnPropertyDescriptor(e6, r4).enumerable;
    })), t5.push.apply(t5, o2);
  }
  return t5;
}
function _objectSpread2(e6) {
  for (var r3 = 1; r3 < arguments.length; r3++) {
    var t5 = null != arguments[r3] ? arguments[r3] : {};
    r3 % 2 ? ownKeys(Object(t5), true).forEach(function(r4) {
      _defineProperty(e6, r4, t5[r4]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e6, Object.getOwnPropertyDescriptors(t5)) : ownKeys(Object(t5)).forEach(function(r4) {
      Object.defineProperty(e6, r4, Object.getOwnPropertyDescriptor(t5, r4));
    });
  }
  return e6;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
var activeFocusTraps = {
  activateTrap: function activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      var activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap.pause();
      }
    }
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap: function deactivateTrap(trapStack, trap) {
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0) {
      trapStack[trapStack.length - 1].unpause();
    }
  }
};
var isSelectableInput = function isSelectableInput2(node) {
  return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
};
var isEscapeEvent = function isEscapeEvent2(e6) {
  return (e6 === null || e6 === void 0 ? void 0 : e6.key) === "Escape" || (e6 === null || e6 === void 0 ? void 0 : e6.key) === "Esc" || (e6 === null || e6 === void 0 ? void 0 : e6.keyCode) === 27;
};
var isTabEvent = function isTabEvent2(e6) {
  return (e6 === null || e6 === void 0 ? void 0 : e6.key) === "Tab" || (e6 === null || e6 === void 0 ? void 0 : e6.keyCode) === 9;
};
var isKeyForward = function isKeyForward2(e6) {
  return isTabEvent(e6) && !e6.shiftKey;
};
var isKeyBackward = function isKeyBackward2(e6) {
  return isTabEvent(e6) && e6.shiftKey;
};
var delay = function delay2(fn) {
  return setTimeout(fn, 0);
};
var findIndex = function findIndex2(arr, fn) {
  var idx = -1;
  arr.every(function(value, i3) {
    if (fn(value)) {
      idx = i3;
      return false;
    }
    return true;
  });
  return idx;
};
var valueOrHandler = function valueOrHandler2(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === "function" ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget2(event) {
  return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
};
var internalTrapStack = [];
var createFocusTrap = function createFocusTrap2(elements, userOptions) {
  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
  var config = _objectSpread2({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true,
    isKeyForward,
    isKeyBackward
  }, userOptions);
  var state = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   posTabIndexesFound: boolean,
    //   firstTabbableNode: HTMLElement|undefined,
    //   lastTabbableNode: HTMLElement|undefined,
    //   firstDomTabbableNode: HTMLElement|undefined,
    //   lastDomTabbableNode: HTMLElement|undefined,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0,
    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
    recentNavEvent: void 0
  };
  var trap;
  var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
  };
  var findContainerIndex = function findContainerIndex2(element, event) {
    var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === "function" ? event.composedPath() : void 0;
    return state.containerGroups.findIndex(function(_ref) {
      var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
      return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      (composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function(node) {
        return node === element;
      });
    });
  };
  var getNodeForOption = function getNodeForOption2(optionName) {
    var optionValue = config[optionName];
    if (typeof optionValue === "function") {
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      optionValue = optionValue.apply(void 0, params);
    }
    if (optionValue === true) {
      optionValue = void 0;
    }
    if (!optionValue) {
      if (optionValue === void 0 || optionValue === false) {
        return optionValue;
      }
      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node = optionValue;
    if (typeof optionValue === "string") {
      node = doc.querySelector(optionValue);
      if (!node) {
        throw new Error("`".concat(optionName, "` as selector refers to no known node"));
      }
    }
    return node;
  };
  var getInitialFocusNode = function getInitialFocusNode2() {
    var node = getNodeForOption("initialFocus");
    if (node === false) {
      return false;
    }
    if (node === void 0 || !isFocusable(node, config.tabbableOptions)) {
      if (findContainerIndex(doc.activeElement) >= 0) {
        node = doc.activeElement;
      } else {
        var firstTabbableGroup = state.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
        node = firstTabbableNode || getNodeForOption("fallbackFocus");
      }
    }
    if (!node) {
      throw new Error("Your focus-trap needs to have at least one focusable element");
    }
    return node;
  };
  var updateTabbableNodes = function updateTabbableNodes2() {
    state.containerGroups = state.containers.map(function(container) {
      var tabbableNodes = tabbable(container, config.tabbableOptions);
      var focusableNodes = focusable(container, config.tabbableOptions);
      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
      var firstDomTabbableNode = focusableNodes.find(function(node) {
        return isTabbable(node);
      });
      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function(node) {
        return isTabbable(node);
      });
      var posTabIndexesFound = !!tabbableNodes.find(function(node) {
        return getTabIndex(node) > 0;
      });
      return {
        container,
        tabbableNodes,
        focusableNodes,
        /** True if at least one node with positive `tabindex` was found in this container. */
        posTabIndexesFound,
        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
        firstTabbableNode,
        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
        lastTabbableNode,
        // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
        //  because that API doesn't work with Shadow DOM as well as it should (@see
        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
        //  to address an edge case related to positive tabindex support, this seems like a much easier,
        //  "close enough most of the time" alternative for positive tabindexes which should generally
        //  be avoided anyway...
        /** First tabbable node in container, __DOM__ order; `undefined` if none. */
        firstDomTabbableNode,
        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
        lastDomTabbableNode,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function nextTabbableNode(node) {
          var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var nodeIdx = tabbableNodes.indexOf(node);
          if (nodeIdx < 0) {
            if (forward) {
              return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function(el) {
                return isTabbable(el);
              });
            }
            return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function(el) {
              return isTabbable(el);
            });
          }
          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
        }
      };
    });
    state.tabbableGroups = state.containerGroups.filter(function(group) {
      return group.tabbableNodes.length > 0;
    });
    if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    }
    if (state.containerGroups.find(function(g) {
      return g.posTabIndexesFound;
    }) && state.containerGroups.length > 1) {
      throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
    }
  };
  var getActiveElement = function getActiveElement2(el) {
    var activeElement = el.activeElement;
    if (!activeElement) {
      return;
    }
    if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
      return getActiveElement2(activeElement.shadowRoot);
    }
    return activeElement;
  };
  var tryFocus = function tryFocus2(node) {
    if (node === false) {
      return;
    }
    if (node === getActiveElement(document)) {
      return;
    }
    if (!node || !node.focus) {
      tryFocus2(getInitialFocusNode());
      return;
    }
    node.focus({
      preventScroll: !!config.preventScroll
    });
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
    var node = getNodeForOption("setReturnFocus", previousActiveElement);
    return node ? node : node === false ? false : previousActiveElement;
  };
  var findNextNavNode = function findNextNavNode2(_ref2) {
    var target = _ref2.target, event = _ref2.event, _ref2$isBackward = _ref2.isBackward, isBackward = _ref2$isBackward === void 0 ? false : _ref2$isBackward;
    target = target || getActualTarget(event);
    updateTabbableNodes();
    var destinationNode = null;
    if (state.tabbableGroups.length > 0) {
      var containerIndex = findContainerIndex(target, event);
      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
      if (containerIndex < 0) {
        if (isBackward) {
          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          destinationNode = state.tabbableGroups[0].firstTabbableNode;
        }
      } else if (isBackward) {
        var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
          var firstTabbableNode = _ref3.firstTabbableNode;
          return target === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state.tabbableGroups[destinationGroupIndex];
          destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
        } else if (!isTabEvent(event)) {
          destinationNode = containerGroup.nextTabbableNode(target, false);
        }
      } else {
        var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref4) {
          var lastTabbableNode = _ref4.lastTabbableNode;
          return target === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
          destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
        } else if (!isTabEvent(event)) {
          destinationNode = containerGroup.nextTabbableNode(target);
        }
      }
    } else {
      destinationNode = getNodeForOption("fallbackFocus");
    }
    return destinationNode;
  };
  var checkPointerDown = function checkPointerDown2(e6) {
    var target = getActualTarget(e6);
    if (findContainerIndex(target, e6) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e6)) {
      trap.deactivate({
        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
        //  which will result in the outside click setting focus to the node
        //  that was clicked (and if not focusable, to "nothing"); by setting
        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
        //  on activation (or the configured `setReturnFocus` node), whether the
        //  outside click was on a focusable node or not
        returnFocus: config.returnFocusOnDeactivate
      });
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e6)) {
      return;
    }
    e6.preventDefault();
  };
  var checkFocusIn = function checkFocusIn2(event) {
    var target = getActualTarget(event);
    var targetContained = findContainerIndex(target, event) >= 0;
    if (targetContained || target instanceof Document) {
      if (targetContained) {
        state.mostRecentlyFocusedNode = target;
      }
    } else {
      event.stopImmediatePropagation();
      var nextNode;
      var navAcrossContainers = true;
      if (state.mostRecentlyFocusedNode) {
        if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {
          var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);
          var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;
          if (tabbableNodes.length > 0) {
            var mruTabIdx = tabbableNodes.findIndex(function(node) {
              return node === state.mostRecentlyFocusedNode;
            });
            if (mruTabIdx >= 0) {
              if (config.isKeyForward(state.recentNavEvent)) {
                if (mruTabIdx + 1 < tabbableNodes.length) {
                  nextNode = tabbableNodes[mruTabIdx + 1];
                  navAcrossContainers = false;
                }
              } else {
                if (mruTabIdx - 1 >= 0) {
                  nextNode = tabbableNodes[mruTabIdx - 1];
                  navAcrossContainers = false;
                }
              }
            }
          }
        } else {
          if (!state.containerGroups.some(function(g) {
            return g.tabbableNodes.some(function(n3) {
              return getTabIndex(n3) > 0;
            });
          })) {
            navAcrossContainers = false;
          }
        }
      } else {
        navAcrossContainers = false;
      }
      if (navAcrossContainers) {
        nextNode = findNextNavNode({
          // move FROM the MRU node, not event-related node (which will be the node that is
          //  outside the trap causing the focus escape we're trying to fix)
          target: state.mostRecentlyFocusedNode,
          isBackward: config.isKeyBackward(state.recentNavEvent)
        });
      }
      if (nextNode) {
        tryFocus(nextNode);
      } else {
        tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
      }
    }
    state.recentNavEvent = void 0;
  };
  var checkKeyNav = function checkKeyNav2(event) {
    var isBackward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    state.recentNavEvent = event;
    var destinationNode = findNextNavNode({
      event,
      isBackward
    });
    if (destinationNode) {
      if (isTabEvent(event)) {
        event.preventDefault();
      }
      tryFocus(destinationNode);
    }
  };
  var checkKey = function checkKey2(event) {
    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {
      event.preventDefault();
      trap.deactivate();
      return;
    }
    if (config.isKeyForward(event) || config.isKeyBackward(event)) {
      checkKeyNav(event, config.isKeyBackward(event));
    }
  };
  var checkClick = function checkClick2(e6) {
    var target = getActualTarget(e6);
    if (findContainerIndex(target, e6) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e6)) {
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e6)) {
      return;
    }
    e6.preventDefault();
    e6.stopImmediatePropagation();
  };
  var addListeners = function addListeners2() {
    if (!state.active) {
      return;
    }
    activeFocusTraps.activateTrap(trapStack, trap);
    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
      tryFocus(getInitialFocusNode());
    }) : tryFocus(getInitialFocusNode());
    doc.addEventListener("focusin", checkFocusIn, true);
    doc.addEventListener("mousedown", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("touchstart", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("click", checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkKey, {
      capture: true,
      passive: false
    });
    return trap;
  };
  var removeListeners = function removeListeners2() {
    if (!state.active) {
      return;
    }
    doc.removeEventListener("focusin", checkFocusIn, true);
    doc.removeEventListener("mousedown", checkPointerDown, true);
    doc.removeEventListener("touchstart", checkPointerDown, true);
    doc.removeEventListener("click", checkClick, true);
    doc.removeEventListener("keydown", checkKey, true);
    return trap;
  };
  var checkDomRemoval = function checkDomRemoval2(mutations) {
    var isFocusedNodeRemoved = mutations.some(function(mutation) {
      var removedNodes = Array.from(mutation.removedNodes);
      return removedNodes.some(function(node) {
        return node === state.mostRecentlyFocusedNode;
      });
    });
    if (isFocusedNodeRemoved) {
      tryFocus(getInitialFocusNode());
    }
  };
  var mutationObserver = typeof window !== "undefined" && "MutationObserver" in window ? new MutationObserver(checkDomRemoval) : void 0;
  var updateObservedNodes = function updateObservedNodes2() {
    if (!mutationObserver) {
      return;
    }
    mutationObserver.disconnect();
    if (state.active && !state.paused) {
      state.containers.map(function(container) {
        mutationObserver.observe(container, {
          subtree: true,
          childList: true
        });
      });
    }
  };
  trap = {
    get active() {
      return state.active;
    },
    get paused() {
      return state.paused;
    },
    activate: function activate(activateOptions) {
      if (state.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, "onActivate");
      var onPostActivate = getOption(activateOptions, "onPostActivate");
      var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
      if (!checkCanFocusTrap) {
        updateTabbableNodes();
      }
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = doc.activeElement;
      onActivate === null || onActivate === void 0 || onActivate();
      var finishActivation = function finishActivation2() {
        if (checkCanFocusTrap) {
          updateTabbableNodes();
        }
        addListeners();
        updateObservedNodes();
        onPostActivate === null || onPostActivate === void 0 || onPostActivate();
      };
      if (checkCanFocusTrap) {
        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
        return this;
      }
      finishActivation();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state.active) {
        return this;
      }
      var options = _objectSpread2({
        onDeactivate: config.onDeactivate,
        onPostDeactivate: config.onPostDeactivate,
        checkCanReturnFocus: config.checkCanReturnFocus
      }, deactivateOptions);
      clearTimeout(state.delayInitialFocusTimer);
      state.delayInitialFocusTimer = void 0;
      removeListeners();
      state.active = false;
      state.paused = false;
      updateObservedNodes();
      activeFocusTraps.deactivateTrap(trapStack, trap);
      var onDeactivate = getOption(options, "onDeactivate");
      var onPostDeactivate = getOption(options, "onPostDeactivate");
      var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
      var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
      onDeactivate === null || onDeactivate === void 0 || onDeactivate();
      var finishDeactivation = function finishDeactivation2() {
        delay(function() {
          if (returnFocus) {
            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          }
          onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause(pauseOptions) {
      if (state.paused || !state.active) {
        return this;
      }
      var onPause = getOption(pauseOptions, "onPause");
      var onPostPause = getOption(pauseOptions, "onPostPause");
      state.paused = true;
      onPause === null || onPause === void 0 || onPause();
      removeListeners();
      updateObservedNodes();
      onPostPause === null || onPostPause === void 0 || onPostPause();
      return this;
    },
    unpause: function unpause(unpauseOptions) {
      if (!state.paused || !state.active) {
        return this;
      }
      var onUnpause = getOption(unpauseOptions, "onUnpause");
      var onPostUnpause = getOption(unpauseOptions, "onPostUnpause");
      state.paused = false;
      onUnpause === null || onUnpause === void 0 || onUnpause();
      updateTabbableNodes();
      addListeners();
      updateObservedNodes();
      onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
      return this;
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state.containers = elementsAsArray.map(function(element) {
        return typeof element === "string" ? doc.querySelector(element) : element;
      });
      if (state.active) {
        updateTabbableNodes();
      }
      updateObservedNodes();
      return this;
    }
  };
  trap.updateContainerElements(elements);
  return trap;
};

// node_modules/@arcgis/core/identity/IdentityModal.js
var d3 = "esri-identity-modal";
var p2 = { base: d3, open: `${d3}--open`, closed: `${d3}--closed`, title: `${d3}__title`, dialog: `${d3}__dialog`, content: `${d3}__content`, closeButton: `${d3}__close-button`, iconClose: "esri-icon-close" };
var u = class extends O {
  constructor(t5, e6) {
    super(t5, e6), this.container = document.createElement("div"), this.content = null, this.open = false, this._focusTrap = null, this._close = () => {
      this.open = false;
    }, document.body.appendChild(this.container), this.addHandles(d(() => this.open, () => this._toggleFocusTrap()));
  }
  destroy() {
    this._destroyFocusTrap();
  }
  get title() {
    var _a;
    return (_a = this.messages) == null ? void 0 : _a.auth.signIn;
  }
  render() {
    const t5 = this.id, { open: e6, content: o2, title: s6, messages: i3 } = this, r3 = e6 && !!o2, n3 = { [p2.open]: r3, [p2.closed]: !r3 }, a2 = n2("button", { "aria-label": i3.close, bind: this, class: p2.closeButton, onclick: this._close, title: i3.close, type: "button" }, n2("span", { "aria-hidden": "true", class: p2.iconClose })), l3 = `${t5}_title`, d4 = `${t5}_content`, u2 = s6 ? n2("h1", { class: p2.title, id: l3 }, s6) : null, h2 = r3 ? n2("div", { afterCreate: this._createFocusTrap, "aria-describedby": d4, "aria-labelledby": l3, bind: this, class: p2.dialog, role: "dialog" }, a2, u2, this._renderContent(d4)) : null;
    return n2("div", { class: this.classes(p2.base, n3), tabIndex: -1 }, h2);
  }
  _destroyFocusTrap() {
    var _a;
    (_a = this._focusTrap) == null ? void 0 : _a.deactivate({ onDeactivate: () => {
    } }), this._focusTrap = null;
  }
  _toggleFocusTrap() {
    const { _focusTrap: t5, open: e6 } = this;
    t5 && (e6 ? t5.activate() : t5.deactivate());
  }
  _createFocusTrap(t5) {
    this._destroyFocusTrap();
    const o2 = requestAnimationFrame(() => {
      this._focusTrap = createFocusTrap(t5, { initialFocus: "input", onDeactivate: this._close }), this._toggleFocusTrap();
    });
    this.addHandles(e2(() => cancelAnimationFrame(o2)));
  }
  _renderContent(t5) {
    const e6 = this.content;
    return "string" == typeof e6 ? n2("div", { class: p2.content, id: t5, innerHTML: e6 }) : e4(e6) ? n2("div", { class: p2.content, id: t5 }, e6.render()) : e6 instanceof HTMLElement ? n2("div", { afterCreate: this._attachToNode, bind: e6, class: p2.content, id: t5 }) : null;
  }
  _attachToNode(t5) {
    const e6 = this;
    t5.appendChild(e6);
  }
};
e([y({ readOnly: true })], u.prototype, "container", void 0), e([y()], u.prototype, "content", void 0), e([y()], u.prototype, "open", void 0), e([y(), e3("esri/t9n/common")], u.prototype, "messages", void 0), e([y()], u.prototype, "title", null), u = e([c2("esri.identity.IdentityModal")], u);
var h = u;

// node_modules/@arcgis/core/identity/OAuthCredential.js
var t4 = "esriJSAPIOAuth";
var e5 = class {
  constructor(t5, e6) {
    this.oAuthInfo = null, this.storage = null, this.appId = null, this.codeVerifier = null, this.expires = null, this.refreshToken = null, this.ssl = null, this.stateUID = null, this.token = null, this.userId = null, this.oAuthInfo = t5, this.storage = e6, this._init();
  }
  isValid() {
    let t5 = false;
    if (this.oAuthInfo && this.userId && (this.refreshToken || this.token)) {
      if (null == this.expires && this.refreshToken)
        t5 = true;
      else if (this.expires) {
        const e6 = Date.now();
        if (this.expires > e6) {
          (this.expires - e6) / 1e3 > 60 * this.oAuthInfo.minTimeUntilExpiration && (t5 = true);
        }
      }
    }
    return t5;
  }
  save() {
    if (!this.storage)
      return false;
    const e6 = this._load(), s6 = this.oAuthInfo;
    if (s6 && s6.authNamespace && s6.portalUrl) {
      let r3 = e6[s6.authNamespace];
      r3 || (r3 = e6[s6.authNamespace] = {}), this.appId || (this.appId = s6.appId), r3[s6.portalUrl] = { appId: this.appId, codeVerifier: this.codeVerifier, expires: this.expires, refreshToken: this.refreshToken, ssl: this.ssl, stateUID: this.stateUID, token: this.token, userId: this.userId };
      try {
        this.storage.setItem(t4, JSON.stringify(e6));
      } catch (i3) {
        return console.warn(i3), false;
      }
      return true;
    }
    return false;
  }
  destroy() {
    const e6 = this._load(), s6 = this.oAuthInfo;
    if ((s6 == null ? void 0 : s6.appId) && (s6 == null ? void 0 : s6.portalUrl) && (null == this.expires || this.expires > Date.now()) && (this.refreshToken || this.token)) {
      const t5 = s6.portalUrl.replace(/^http:/i, "https:") + "/sharing/rest/oauth2/revokeToken", e7 = new FormData();
      if (e7.append("f", "json"), e7.append("auth_token", this.refreshToken || this.token), e7.append("client_id", s6.appId), e7.append("token_type_hint", this.refreshToken ? "refresh_token" : "access_token"), "function" == typeof navigator.sendBeacon)
        navigator.sendBeacon(t5, e7);
      else {
        const s7 = new XMLHttpRequest();
        s7.open("POST", t5), s7.send(e7);
      }
    }
    if (s6 && s6.authNamespace && s6.portalUrl && this.storage) {
      const r3 = e6[s6.authNamespace];
      if (r3) {
        delete r3[s6.portalUrl];
        try {
          this.storage.setItem(t4, JSON.stringify(e6));
        } catch (i3) {
          console.log(i3);
        }
      }
    }
    s6 && (s6._oAuthCred = null, this.oAuthInfo = null);
  }
  _init() {
    const t5 = this._load(), e6 = this.oAuthInfo;
    if (e6 && e6.authNamespace && e6.portalUrl) {
      let s6 = t5[e6.authNamespace];
      s6 && (s6 = s6[e6.portalUrl], s6 && (this.appId = s6.appId, this.codeVerifier = s6.codeVerifier, this.expires = s6.expires, this.refreshToken = s6.refreshToken, this.ssl = s6.ssl, this.stateUID = s6.stateUID, this.token = s6.token, this.userId = s6.userId));
    }
  }
  _load() {
    let e6 = {};
    if (this.storage) {
      const i3 = this.storage.getItem(t4);
      if (i3)
        try {
          e6 = JSON.parse(i3);
        } catch (s6) {
          console.warn(s6);
        }
    }
    return e6;
  }
};
e5.prototype.declaredClass = "esri.identity.OAuthCredential";

// node_modules/@arcgis/core/identity/ServerInfo.js
var s4 = class extends f {
  constructor(o2) {
    super(o2), this.adminTokenServiceUrl = null, this.currentVersion = null, this.hasPortal = null, this.hasServer = null, this.owningSystemUrl = null, this.owningTenant = null, this.server = null, this.shortLivedTokenValidity = null, this.tokenServiceUrl = null, this.webTierAuth = null;
  }
};
e([y({ json: { write: true } })], s4.prototype, "adminTokenServiceUrl", void 0), e([y({ json: { write: true } })], s4.prototype, "currentVersion", void 0), e([y({ json: { write: true } })], s4.prototype, "hasPortal", void 0), e([y({ json: { write: true } })], s4.prototype, "hasServer", void 0), e([y({ json: { write: true } })], s4.prototype, "owningSystemUrl", void 0), e([y({ json: { write: true } })], s4.prototype, "owningTenant", void 0), e([y({ json: { write: true } })], s4.prototype, "server", void 0), e([y({ json: { write: true } })], s4.prototype, "shortLivedTokenValidity", void 0), e([y({ json: { write: true } })], s4.prototype, "tokenServiceUrl", void 0), e([y({ json: { write: true } })], s4.prototype, "webTierAuth", void 0), s4 = e([c2("esri.identity.ServerInfo")], s4);
var i2 = s4;

// node_modules/@arcgis/core/identity/IdentityManagerBase.js
var C2 = {};
var b2 = (e6) => {
  const t5 = new x(e6.owningSystemUrl).host, r3 = new x(e6.server).host, s6 = /.+\.arcgis\.com$/i;
  return s6.test(t5) && s6.test(r3);
};
var D = (e6, t5) => !!(b2(e6) && t5 && t5.some((t6) => t6.test(e6.server)));
var q = null;
var j2 = null;
try {
  q = window.localStorage, j2 = window.sessionStorage;
} catch {
}
var E = class extends o {
  constructor() {
    super(), this._portalConfig = globalThis.esriGeowConfig, this.serverInfos = [], this.oAuthInfos = [], this.credentials = [], this._soReqs = [], this._xoReqs = [], this._portals = [], this._defaultOAuthInfo = null, this._defaultTokenValidity = 60, this.dialog = null, this.formConstructor = c3, this.tokenValidity = null, this.normalizeWebTierAuth = false, this._appOrigin = "null" !== window.origin ? window.origin : window.location.origin, this._appUrlObj = I(window.location.href), this._busy = null, this._rejectOnPersistedPageShow = false, this._oAuthLocationParams = null, this._gwTokenUrl = "/sharing/rest/generateToken", this._agsRest = "/rest/services", this._agsPortal = /\/sharing(\/|$)/i, this._agsAdmin = /(https?:\/\/[^\/]+\/[^\/]+)\/admin\/?(\/.*)?$/i, this._adminSvcs = /\/rest\/admin\/services(\/|$)/i, this._gwDomains = [{ regex: /^https?:\/\/www\.arcgis\.com/i, customBaseUrl: "maps.arcgis.com", tokenServiceUrl: "https://www.arcgis.com/sharing/rest/generateToken" }, { regex: /^https?:\/\/(?:dev|[a-z\d-]+\.mapsdev)\.arcgis\.com/i, customBaseUrl: "mapsdev.arcgis.com", tokenServiceUrl: "https://dev.arcgis.com/sharing/rest/generateToken" }, { regex: /^https?:\/\/(?:devext|[a-z\d-]+\.mapsdevext)\.arcgis\.com/i, customBaseUrl: "mapsdevext.arcgis.com", tokenServiceUrl: "https://devext.arcgis.com/sharing/rest/generateToken" }, { regex: /^https?:\/\/(?:qaext|[a-z\d-]+\.mapsqa)\.arcgis\.com/i, customBaseUrl: "mapsqa.arcgis.com", tokenServiceUrl: "https://qaext.arcgis.com/sharing/rest/generateToken" }, { regex: /^https?:\/\/[a-z\d-]+\.maps\.arcgis\.com/i, customBaseUrl: "maps.arcgis.com", tokenServiceUrl: "https://www.arcgis.com/sharing/rest/generateToken" }], this._legacyFed = [], this._regexSDirUrl = /http.+\/rest\/services\/?/gi, this._regexServerType = /(\/(FeatureServer|GPServer|GeoDataServer|GeocodeServer|GeoenrichmentServer|GeometryServer|GlobeServer|ImageServer|KnowledgeGraphServer|MapServer|MissionServer|MobileServer|NAServer|NetworkDiagramServer|OGCFeatureServer|ParcelFabricServer|RelationalCatalogServer|SceneServer|StreamServer|UtilityNetworkServer|ValidationServer|VectorTileServer|VersionManagementServer|VideoServer)).*/gi, this._gwUser = /http.+\/users\/([^\/]+)\/?.*/i, this._gwItem = /http.+\/items\/([^\/]+)\/?.*/i, this._gwGroup = /http.+\/groups\/([^\/]+)\/?.*/i, this._rePortalTokenSvc = /\/sharing(\/rest)?\/generatetoken/i, this._createDefaultOAuthInfo = true, this._hasTestedIfAppIsOnPortal = false, this._getOAuthLocationParams(), window.addEventListener("pageshow", (e6) => {
      this._pageShowHandler(e6);
    });
  }
  registerServers(e6) {
    const t5 = this.serverInfos;
    t5 ? (e6 = e6.filter((e7) => !this.findServerInfo(e7.server)), this.serverInfos = t5.concat(e6)) : this.serverInfos = e6, e6.forEach((e7) => {
      e7.owningSystemUrl && this._portals.push(e7.owningSystemUrl), e7.hasPortal && this._portals.push(e7.server);
    });
  }
  registerOAuthInfos(e6) {
    const t5 = this.oAuthInfos;
    if (t5) {
      for (const r3 of e6) {
        const e7 = this.findOAuthInfo(r3.portalUrl);
        e7 && t5.splice(t5.indexOf(e7), 1);
      }
      this.oAuthInfos = t5.concat(e6);
    } else
      this.oAuthInfos = e6;
  }
  registerToken(e6) {
    e6 = { ...e6 };
    const t5 = this._sanitizeUrl(e6.server), r3 = this._isServerRsrc(t5);
    let s6, i3 = this.findServerInfo(t5), o2 = true;
    i3 || (i3 = new i2(), i3.server = this._getServerInstanceRoot(t5), r3 ? i3.hasServer = true : (i3.tokenServiceUrl = this._getTokenSvcUrl(t5), i3.hasPortal = true), this.registerServers([i3])), s6 = this._findCredential(t5), s6 ? (delete e6.server, Object.assign(s6, e6), o2 = false) : (s6 = new L({ userId: e6.userId, server: i3.server, token: e6.token, expires: e6.expires, ssl: e6.ssl, scope: r3 ? "server" : "portal" }), s6.resources = [t5], this.credentials.push(s6)), s6.emitTokenChange(false), o2 || s6.refreshServerTokens();
  }
  toJSON() {
    return l({ serverInfos: this.serverInfos.map((e6) => e6.toJSON()), oAuthInfos: this.oAuthInfos.map((e6) => e6.toJSON()), credentials: this.credentials.map((e6) => e6.toJSON()) });
  }
  initialize(e6) {
    if (!e6)
      return;
    "string" == typeof e6 && (e6 = JSON.parse(e6));
    const t5 = e6.serverInfos, r3 = e6.oAuthInfos, s6 = e6.credentials;
    if (t5) {
      const e7 = [];
      t5.forEach((t6) => {
        t6.server && t6.tokenServiceUrl && e7.push(t6.declaredClass ? t6 : new i2(t6));
      }), e7.length && this.registerServers(e7);
    }
    if (r3) {
      const e7 = [];
      r3.forEach((t6) => {
        t6.appId && e7.push(t6.declaredClass ? t6 : new i(t6));
      }), e7.length && this.registerOAuthInfos(e7);
    }
    s6 && s6.forEach((e7) => {
      e7.server && e7.token && e7.expires && e7.expires > Date.now() && ((e7 = e7.declaredClass ? e7 : new L(e7)).emitTokenChange(), this.credentials.push(e7));
    });
  }
  findServerInfo(e6) {
    let t5;
    e6 = this._sanitizeUrl(e6);
    for (const r3 of this.serverInfos)
      if (this._hasSameServerInstance(r3.server, e6)) {
        t5 = r3;
        break;
      }
    return t5;
  }
  findOAuthInfo(e6) {
    let t5;
    e6 = this._sanitizeUrl(e6);
    for (const r3 of this.oAuthInfos)
      if (this._hasSameServerInstance(r3.portalUrl, e6)) {
        t5 = r3;
        break;
      }
    return t5;
  }
  findCredential(e6, t5) {
    if (!e6)
      return;
    let r3;
    e6 = this._sanitizeUrl(e6);
    const s6 = this._isServerRsrc(e6) ? "server" : "portal";
    if (t5) {
      for (const i3 of this.credentials)
        if (this._hasSameServerInstance(i3.server, e6) && t5 === i3.userId && i3.scope === s6) {
          r3 = i3;
          break;
        }
    } else
      for (const i3 of this.credentials)
        if (this._hasSameServerInstance(i3.server, e6) && -1 !== this._getIdenticalSvcIdx(e6, i3) && i3.scope === s6) {
          r3 = i3;
          break;
        }
    return r3;
  }
  getCredential(e6, t5) {
    let r3, s6, o2 = true;
    t5 && (r3 = !!t5.token, s6 = t5.error, o2 = false !== t5.prompt), t5 = { ...t5 }, e6 = this._sanitizeUrl(e6);
    const n3 = new AbortController(), a2 = C();
    if (t5.signal && m(t5.signal, () => {
      n3.abort();
    }), m(n3, () => {
      a2.reject(new s2("identity-manager:user-aborted", "ABORTED"));
    }), c(n3))
      return a2.promise;
    t5.signal = n3.signal;
    const h2 = this._isAdminResource(e6), u2 = r3 ? this.findCredential(e6) : null;
    let p3;
    if (u2 && s6 && s6.details && 498 === s6.details.httpStatus)
      u2.destroy();
    else if (u2)
      return p3 = new s2("identity-manager:not-authorized", "You are currently signed in as: '" + u2.userId + "'. You do not have access to this resource: " + e6, { error: s6 }), a2.reject(p3), a2.promise;
    const g = this._findCredential(e6, t5);
    if (g)
      return a2.resolve(g), a2.promise;
    let f2 = this.findServerInfo(e6);
    if (f2)
      !f2.hasPortal && f2.server && f2.owningSystemUrl && this._hasSameServerInstance(f2.server, f2.owningSystemUrl) && (f2.hasPortal = true), !f2.hasServer && this._isServerRsrc(e6) && (f2._restInfoPms = this._getTokenSvcUrl(e6), f2.hasServer = true);
    else {
      const t6 = this._getTokenSvcUrl(e6);
      if (!t6)
        return p3 = new s2("identity-manager:unknown-resource", "Unknown resource - could not find token service endpoint."), a2.reject(p3), a2.promise;
      f2 = new i2(), f2.server = this._getServerInstanceRoot(e6), "string" == typeof t6 ? (f2.tokenServiceUrl = t6, f2.hasPortal = true) : (f2._restInfoPms = t6, f2.hasServer = true), this.registerServers([f2]);
    }
    return f2.hasPortal && void 0 === f2._selfReq && (o2 || F(f2.tokenServiceUrl, this._appOrigin) || this._gwDomains.some((e7) => e7.tokenServiceUrl === f2.tokenServiceUrl)) && (f2._selfReq = { owningTenant: t5 == null ? void 0 : t5.owningTenant, selfDfd: this._getPortalSelf(f2.tokenServiceUrl.replace(this._rePortalTokenSvc, "/sharing/rest/portals/self"), e6) }), this._enqueue(e6, f2, t5, a2, h2);
  }
  getResourceName(e6) {
    return this._isRESTService(e6) ? e6.replace(this._regexSDirUrl, "").replace(this._regexServerType, "") || "" : this._gwUser.test(e6) && e6.replace(this._gwUser, "$1") || this._gwItem.test(e6) && e6.replace(this._gwItem, "$1") || this._gwGroup.test(e6) && e6.replace(this._gwGroup, "$1") || "";
  }
  generateToken(e6, t5, r3) {
    const o2 = this._rePortalTokenSvc.test(e6.tokenServiceUrl), n3 = new x(this._appOrigin), a2 = e6.shortLivedTokenValidity;
    let h2, l3, c4, d4, u2, p3, f2, m2;
    t5 && (m2 = this.tokenValidity || a2 || this._defaultTokenValidity, m2 > a2 && a2 > 0 && (m2 = a2)), r3 && (h2 = r3.isAdmin, l3 = r3.serverUrl, c4 = r3.token, p3 = r3.signal, f2 = r3.ssl, e6.customParameters = r3.customParameters), h2 ? d4 = e6.adminTokenServiceUrl : (d4 = e6.tokenServiceUrl, u2 = new x(d4.toLowerCase()), e6.webTierAuth && (r3 == null ? void 0 : r3.serverUrl) && !f2 && "http" === n3.scheme && (F(n3.uri, d4, true) || "https" === u2.scheme && n3.host === u2.host && "7080" === n3.port && "7443" === u2.port) && (d4 = d4.replace(/^https:/i, "http:").replace(/:7443/i, ":7080")));
    const v2 = { query: { request: "getToken", username: t5 == null ? void 0 : t5.username, password: t5 == null ? void 0 : t5.password, serverUrl: l3, token: c4, expiration: m2, referer: h2 || o2 ? this._appOrigin : null, client: h2 ? "referer" : null, f: "json", ...e6.customParameters }, method: "post", authMode: "anonymous", useProxy: this._useProxy(e6, r3), signal: p3, ...r3 == null ? void 0 : r3.ioArgs };
    o2 || (v2.withCredentials = false);
    return j(d4, v2).then((r4) => {
      const s6 = r4.data;
      if (!(s6 == null ? void 0 : s6.token))
        return new s2("identity-manager:authentication-failed", "Unable to generate token");
      const o3 = e6.server;
      return C2[o3] || (C2[o3] = {}), t5 && (C2[o3][t5.username] = t5.password), s6.validity = m2, s6;
    });
  }
  isBusy() {
    return !!this._busy;
  }
  checkSignInStatus(e6) {
    return this.checkAppAccess(e6, "").then((e7) => e7.credential);
  }
  checkAppAccess(e6, t5, r3) {
    let o2 = false;
    return this.getCredential(e6, { prompt: false }).then((n3) => {
      let a2;
      const h2 = { f: "json" };
      if ("portal" === n3.scope)
        if (t5 && (this._doPortalSignIn(e6) || (r3 == null ? void 0 : r3.force)))
          a2 = n3.server + "/sharing/rest/oauth2/validateAppAccess", h2.client_id = t5;
        else {
          if (!n3.token)
            return { credential: n3 };
          a2 = n3.server + "/sharing/rest";
        }
      else {
        if (!n3.token)
          return { credential: n3 };
        a2 = n3.server + "/rest/services";
      }
      return n3.token && (h2.token = n3.token), j(a2, { query: h2, authMode: "anonymous" }).then((e7) => {
        if (false === e7.data.valid)
          throw new s2("identity-manager:not-authorized", `You are currently signed in as: '${n3.userId}'.`, e7.data);
        return o2 = !!e7.data.viewOnlyUserTypeApp, { credential: n3 };
      }).catch((e7) => {
        var _a;
        if ("identity-manager:not-authorized" === e7.name)
          throw e7;
        const t6 = (_a = e7.details) == null ? void 0 : _a.httpStatus;
        if (498 === t6)
          throw n3.destroy(), new s2("identity-manager:not-authenticated", "User is not signed in.");
        if (400 === t6)
          throw new s2("identity-manager:invalid-request");
        return { credential: n3 };
      });
    }).then((e7) => ({ credential: e7.credential, viewOnly: o2 }));
  }
  setOAuthResponseHash(e6) {
    e6 && ("#" === e6.charAt(0) && (e6 = e6.substring(1)), this._processOAuthPopupParams(A(e6)));
  }
  setOAuthRedirectionHandler(e6) {
    this._oAuthRedirectFunc = e6;
  }
  setProtocolErrorHandler(e6) {
    this._protocolFunc = e6;
  }
  signIn(e6, t5, r3 = {}) {
    const s6 = C(), o2 = () => {
      var _a;
      h2 == null ? void 0 : h2.remove(), d4 == null ? void 0 : d4.remove(), p3 == null ? void 0 : p3.remove(), a2 == null ? void 0 : a2.destroy(), (_a = this.dialog) == null ? void 0 : _a.destroy(), this.dialog = a2 = h2 = d4 = p3 = null;
    }, n3 = () => {
      o2(), this._oAuthDfd = null, s6.reject(new s2("identity-manager:user-aborted", "ABORTED"));
    };
    r3.signal && m(r3.signal, () => {
      n3();
    });
    let a2 = new this.formConstructor();
    a2.resource = this.getResourceName(e6), a2.server = t5.server, this.dialog = new h(), this.dialog.content = a2, this.dialog.open = true, this.emit("dialog-create");
    let h2 = a2.on("cancel", n3), d4 = d(() => this.dialog.open, n3), p3 = a2.on("submit", (e7) => {
      this.generateToken(t5, e7, { isAdmin: r3.isAdmin, signal: r3.signal }).then((i3) => {
        o2();
        const n4 = new L({ userId: e7.username, server: t5.server, token: i3.token, expires: null != i3.expires ? Number(i3.expires) : null, ssl: !!i3.ssl, isAdmin: r3.isAdmin, validity: i3.validity });
        s6.resolve(n4);
      }).catch((e8) => {
        a2.error = e8, a2.signingIn = false;
      });
    });
    return s6.promise;
  }
  oAuthSignIn(e6, t5, r3, s6) {
    this._oAuthDfd = C();
    const o2 = this._oAuthDfd;
    let n3;
    (s6 == null ? void 0 : s6.signal) && m(s6.signal, () => {
      const e7 = this._oAuthDfd && this._oAuthDfd.oAuthWin_;
      e7 && !e7.closed ? e7.close() : this.dialog && g();
    }), o2.resUrl_ = e6, o2.sinfo_ = t5, o2.oinfo_ = r3;
    const a2 = r3._oAuthCred;
    if (a2.storage && ("authorization-code" === r3.flowType || "auto" === r3.flowType && t5.currentVersion >= 8.4)) {
      let e7 = crypto.getRandomValues(new Uint8Array(32));
      n3 = et(e7), a2.codeVerifier = n3, e7 = crypto.getRandomValues(new Uint8Array(32)), a2.stateUID = et(e7), a2.save() || (a2.codeVerifier = n3 = null);
    } else
      a2.codeVerifier = null;
    let h2, d4, p3, _2;
    this._getCodeChallenge(n3).then((i3) => {
      const o3 = !s6 || false !== s6.oAuthPopupConfirmation;
      r3.popup && o3 ? (h2 = new this.formConstructor(), h2.oAuthPrompt = true, h2.server = t5.server, this.dialog = new h(), this.dialog.content = h2, this.dialog.open = true, this.emit("dialog-create"), d4 = h2.on("cancel", g), p3 = d(() => this.dialog.open, g), _2 = h2.on("submit", () => {
        f2(), this._doOAuthSignIn(e6, t5, r3, i3);
      })) : this._doOAuthSignIn(e6, t5, r3, i3);
    });
    const g = () => {
      f2(), this._oAuthDfd = null, o2.reject(new s2("identity-manager:user-aborted", "ABORTED"));
    }, f2 = () => {
      var _a;
      d4 == null ? void 0 : d4.remove(), p3 == null ? void 0 : p3.remove(), _2 == null ? void 0 : _2.remove(), h2 == null ? void 0 : h2.destroy(), (_a = this.dialog) == null ? void 0 : _a.destroy(), this.dialog = null;
    };
    return o2.promise;
  }
  destroyCredentials() {
    if (this.credentials) {
      this.credentials.slice().forEach((e6) => {
        e6.destroy();
      });
    }
    this.emit("credentials-destroy");
  }
  enablePostMessageAuth(e6 = "https://www.arcgis.com/sharing/rest") {
    this._postMessageAuthHandle && this._postMessageAuthHandle.remove(), this._postMessageAuthHandle = r(window, "message", (t5) => {
      var _a;
      if ((t5.origin === this._appOrigin || t5.origin.endsWith(".arcgis.com")) && "arcgis:auth:requestCredential" === ((_a = t5.data) == null ? void 0 : _a.type)) {
        const r3 = t5.source;
        this.getCredential(e6).then((e7) => {
          r3.postMessage({ type: "arcgis:auth:credential", credential: { expires: e7.expires, server: e7.server, ssl: e7.ssl, token: e7.token, userId: e7.userId } }, t5.origin);
        }).catch((e7) => {
          r3.postMessage({ type: "arcgis:auth:error", error: { name: e7.name, message: e7.message } }, t5.origin);
        });
      }
    });
  }
  disablePostMessageAuth() {
    this._postMessageAuthHandle && (this._postMessageAuthHandle.remove(), this._postMessageAuthHandle = null);
  }
  _getOAuthLocationParams() {
    var _a, _b;
    let e6 = window.location.hash;
    if (e6) {
      "#" === e6.charAt(0) && (e6 = e6.substring(1));
      const t6 = A(e6);
      let r3 = false;
      if (t6.access_token && t6.expires_in && t6.state && t6.hasOwnProperty("username"))
        try {
          t6.state = JSON.parse(t6.state), t6.state.portalUrl && (this._oAuthLocationParams = t6, r3 = true);
        } catch {
        }
      else if (t6.error && t6.error_description && (console.log("IdentityManager OAuth Error: ", t6.error, " - ", t6.error_description), "access_denied" === t6.error && (r3 = true, t6.state)))
        try {
          t6.state = JSON.parse(t6.state);
        } catch {
        }
      r3 && (window.location.hash = ((_a = t6.state) == null ? void 0 : _a.hash) || "");
    }
    let t5 = window.location.search;
    if (t5) {
      "?" === t5.charAt(0) && (t5 = t5.substring(1));
      const e7 = A(t5);
      let r3 = false;
      if (e7.code && e7.state)
        try {
          e7.state = JSON.parse(e7.state), e7.state.portalUrl && e7.state.uid && (this._oAuthLocationParams = e7, r3 = true);
        } catch {
        }
      else if (e7.error && e7.error_description && (console.log("IdentityManager OAuth Error: ", e7.error, " - ", e7.error_description), "access_denied" === e7.error && (r3 = true, e7.state)))
        try {
          e7.state = JSON.parse(e7.state);
        } catch {
        }
      if (r3) {
        const t6 = { ...e7 };
        ["code", "error", "error_description", "message_code", "persist", "state"].forEach((e8) => {
          delete t6[e8];
        });
        const r4 = v(t6), s6 = window.location.pathname + (r4 ? `?${r4}` : "") + (((_b = e7.state) == null ? void 0 : _b.hash) || "");
        window.history.replaceState(window.history.state, "", s6);
      }
    }
  }
  _getOAuthToken(e6, t5, r3, i3, o2) {
    return e6 = e6.replace(/^http:/i, "https:"), j(`${e6}/sharing/rest/oauth2/token`, { authMode: "anonymous", method: "post", query: i3 && o2 ? { grant_type: "authorization_code", code: t5, redirect_uri: i3, client_id: r3, code_verifier: o2 } : { grant_type: "refresh_token", refresh_token: t5, client_id: r3 } }).then((e7) => e7.data);
  }
  _getCodeChallenge(e6) {
    if (e6 && globalThis.isSecureContext) {
      const t5 = new TextEncoder().encode(e6);
      return crypto.subtle.digest("SHA-256", t5).then((e7) => et(new Uint8Array(e7)));
    }
    return Promise.resolve(null);
  }
  _pageShowHandler(e6) {
    if (e6.persisted && this.isBusy() && this._rejectOnPersistedPageShow) {
      const e7 = new s2("identity-manager:user-aborted", "ABORTED");
      this._errbackFunc(e7);
    }
  }
  _findCredential(e6, t5) {
    let r3, s6, i3, o2, n3 = -1;
    const a2 = t5 == null ? void 0 : t5.token, h2 = t5 == null ? void 0 : t5.resource, l3 = this._isServerRsrc(e6) ? "server" : "portal", c4 = this.credentials.filter((t6) => this._hasSameServerInstance(t6.server, e6) && t6.scope === l3);
    if (e6 = h2 || e6, c4.length)
      if (1 === c4.length) {
        if (r3 = c4[0], i3 = this.findServerInfo(r3.server), s6 = i3 == null ? void 0 : i3.owningSystemUrl, o2 = s6 ? this.findCredential(s6, r3.userId) : void 0, n3 = this._getIdenticalSvcIdx(e6, r3), !a2)
          return -1 === n3 && r3.resources.push(e6), this._addResource(e6, o2), r3;
        -1 !== n3 && (r3.resources.splice(n3, 1), this._removeResource(e6, o2));
      } else {
        let t6, r4;
        if (c4.some((a3) => (r4 = this._getIdenticalSvcIdx(e6, a3), -1 !== r4 && (t6 = a3, i3 = this.findServerInfo(t6.server), s6 = i3 == null ? void 0 : i3.owningSystemUrl, o2 = s6 ? this.findCredential(s6, t6.userId) : void 0, n3 = r4, true))), a2)
          t6 && (t6.resources.splice(n3, 1), this._removeResource(e6, o2));
        else if (t6)
          return this._addResource(e6, o2), t6;
      }
  }
  _findOAuthInfo(e6) {
    let t5 = this.findOAuthInfo(e6);
    if (!t5) {
      for (const r3 of this.oAuthInfos)
        if (this._isIdProvider(r3.portalUrl, e6)) {
          t5 = r3;
          break;
        }
    }
    return t5;
  }
  _addResource(e6, t5) {
    t5 && -1 === this._getIdenticalSvcIdx(e6, t5) && t5.resources.push(e6);
  }
  _removeResource(e6, t5) {
    let r3 = -1;
    t5 && (r3 = this._getIdenticalSvcIdx(e6, t5), r3 > -1 && t5.resources.splice(r3, 1));
  }
  _useProxy(e6, t5) {
    return (t5 == null ? void 0 : t5.isAdmin) && !F(e6.adminTokenServiceUrl, this._appOrigin) || !this._isPortalDomain(e6.tokenServiceUrl) && "10.1" === String(e6.currentVersion) && !F(e6.tokenServiceUrl, this._appOrigin);
  }
  _getOrigin(e6) {
    const t5 = new x(e6);
    return t5.scheme + "://" + t5.host + (null != t5.port ? ":" + t5.port : "");
  }
  _getServerInstanceRoot(e6) {
    const t5 = e6.toLowerCase();
    let r3 = t5.indexOf(this._agsRest);
    return -1 === r3 && this._isAdminResource(e6) && (r3 = this._agsAdmin.test(e6) ? e6.replace(this._agsAdmin, "$1").length : e6.search(this._adminSvcs)), -1 !== r3 || t2(t5) || (r3 = t5.indexOf("/sharing")), -1 === r3 && "/" === t5.substr(-1) && (r3 = t5.length - 1), r3 > -1 ? e6.substring(0, r3) : e6;
  }
  _hasSameServerInstance(e6, t5) {
    return "/" === e6.substr(-1) && (e6 = e6.slice(0, -1)), e6 = e6.toLowerCase(), t5 = this._getServerInstanceRoot(t5).toLowerCase(), e6 = this._normalizeAGOLorgDomain(e6), t5 = this._normalizeAGOLorgDomain(t5), (e6 = e6.substr(e6.indexOf(":"))) === (t5 = t5.substr(t5.indexOf(":")));
  }
  _normalizeAGOLorgDomain(e6) {
    const t5 = /^https?:\/\/(?:cdn|[a-z\d-]+\.maps)\.arcgis\.com/i, r3 = /^https?:\/\/(?:cdndev|[a-z\d-]+\.mapsdevext)\.arcgis\.com/i, s6 = /^https?:\/\/(?:cdnqa|[a-z\d-]+\.mapsqa)\.arcgis\.com/i;
    return t5.test(e6) ? e6 = e6.replace(t5, "https://www.arcgis.com") : r3.test(e6) ? e6 = e6.replace(r3, "https://devext.arcgis.com") : s6.test(e6) && (e6 = e6.replace(s6, "https://qaext.arcgis.com")), e6;
  }
  _sanitizeUrl(e6) {
    const r3 = (s.request.proxyUrl || "").toLowerCase(), s6 = r3 ? e6.toLowerCase().indexOf(r3 + "?") : -1;
    return -1 !== s6 && (e6 = e6.substring(s6 + r3.length + 1)), e6 = K(e6), I(e6).path;
  }
  _isRESTService(e6) {
    return e6.includes(this._agsRest);
  }
  _isAdminResource(e6) {
    return this._agsAdmin.test(e6) || this._adminSvcs.test(e6);
  }
  _isServerRsrc(e6) {
    return this._isRESTService(e6) || this._isAdminResource(e6);
  }
  _isIdenticalService(e6, t5) {
    let r3 = false;
    if (this._isRESTService(e6) && this._isRESTService(t5)) {
      const s6 = this._getSuffix(e6).toLowerCase(), i3 = this._getSuffix(t5).toLowerCase();
      if (r3 = s6 === i3, !r3) {
        const e7 = /(.*)\/(MapServer|FeatureServer|UtilityNetworkServer).*/gi;
        r3 = s6.replaceAll(e7, "$1") === i3.replaceAll(e7, "$1");
      }
    } else
      this._isAdminResource(e6) && this._isAdminResource(t5) ? r3 = true : this._isServerRsrc(e6) || this._isServerRsrc(t5) || !this._isPortalDomain(e6) || (r3 = true);
    return r3;
  }
  _isPortalDomain(e6) {
    const r3 = new x(e6.toLowerCase()), s6 = this._portalConfig;
    let i3 = this._gwDomains.some((e7) => e7.regex.test(r3.uri));
    return !i3 && s6 && (i3 = this._hasSameServerInstance(this._getServerInstanceRoot(s6.restBaseUrl), r3.uri)), i3 || s.portalUrl && (i3 = F(r3, s.portalUrl, true)), i3 || (i3 = this._portals.some((e7) => this._hasSameServerInstance(e7, r3.uri))), i3 = i3 || this._agsPortal.test(r3.path), i3;
  }
  _isIdProvider(e6, t5) {
    let r3 = -1, s6 = -1;
    this._gwDomains.forEach((i4, o2) => {
      -1 === r3 && i4.regex.test(e6) && (r3 = o2), -1 === s6 && i4.regex.test(t5) && (s6 = o2);
    });
    let i3 = false;
    if (r3 > -1 && s6 > -1 && (0 === r3 || 4 === r3 ? 0 !== s6 && 4 !== s6 || (i3 = true) : 1 === r3 ? 1 !== s6 && 2 !== s6 || (i3 = true) : 2 === r3 ? 2 === s6 && (i3 = true) : 3 === r3 && 3 === s6 && (i3 = true)), !i3) {
      const r4 = this.findServerInfo(t5), s7 = r4 == null ? void 0 : r4.owningSystemUrl;
      s7 && b2(r4) && this._isPortalDomain(s7) && this._isIdProvider(e6, s7) && (i3 = true);
    }
    return i3;
  }
  _getIdenticalSvcIdx(e6, t5) {
    let r3 = -1;
    for (let s6 = 0; s6 < t5.resources.length; s6++) {
      const i3 = t5.resources[s6];
      if (this._isIdenticalService(e6, i3)) {
        r3 = s6;
        break;
      }
    }
    return r3;
  }
  _getSuffix(e6) {
    return e6.replace(this._regexSDirUrl, "").replace(this._regexServerType, "$1");
  }
  _getTokenSvcUrl(e6) {
    let t5, r3, i3;
    if (this._isRESTService(e6) || this._isAdminResource(e6)) {
      const i4 = this._getServerInstanceRoot(e6);
      return t5 = i4 + "/admin/generateToken", r3 = j(e6 = i4 + "/rest/info", { query: { f: "json" } }).then((e7) => e7.data), { adminUrl: t5, promise: r3 };
    }
    if (this._isPortalDomain(e6)) {
      let t6 = "";
      if (this._gwDomains.some((r4) => (r4.regex.test(e6) && (t6 = r4.tokenServiceUrl), !!t6)), t6 || this._portals.some((r4) => (this._hasSameServerInstance(r4, e6) && (t6 = r4 + this._gwTokenUrl), !!t6)), t6 || (i3 = e6.toLowerCase().indexOf("/sharing"), -1 !== i3 && (t6 = e6.substring(0, i3) + this._gwTokenUrl)), t6 || (t6 = this._getOrigin(e6) + this._gwTokenUrl), t6) {
        const r4 = new x(e6).port;
        /^http:\/\//i.test(e6) && "7080" === r4 && (t6 = t6.replace(/:7080/i, ":7443")), t6 = t6.replace(/http:/i, "https:");
      }
      return t6;
    }
    if (e6.toLowerCase().includes("premium.arcgisonline.com"))
      return "https://premium.arcgisonline.com/server/tokens";
  }
  _processOAuthResponseParams(e6, t5, r3) {
    const s6 = t5._oAuthCred;
    if (e6.code) {
      const i4 = s6.codeVerifier;
      return s6.codeVerifier = null, s6.stateUID = null, s6.save(), this._getOAuthToken(r3.server, e6.code, t5.appId, this._getRedirectURI(t5, true), i4).then((i5) => {
        const o2 = new L({ userId: i5.username, server: r3.server, token: i5.access_token, expires: Date.now() + 1e3 * i5.expires_in, ssl: i5.ssl, oAuthState: e6.state, _oAuthCred: s6 });
        return t5.userId = o2.userId, s6.storage = i5.persist ? q : j2, s6.refreshToken = i5.refresh_token, s6.token = null, s6.expires = i5.refresh_token_expires_in ? Date.now() + 1e3 * i5.refresh_token_expires_in : null, s6.userId = o2.userId, s6.ssl = o2.ssl, s6.save(), o2;
      });
    }
    const i3 = new L({ userId: e6.username, server: r3.server, token: e6.access_token, expires: Date.now() + 1e3 * Number(e6.expires_in), ssl: "true" === e6.ssl, oAuthState: e6.state, _oAuthCred: s6 });
    return t5.userId = i3.userId, s6.storage = e6.persist ? q : j2, s6.refreshToken = null, s6.token = i3.token, s6.expires = i3.expires, s6.userId = i3.userId, s6.ssl = i3.ssl, s6.save(), Promise.resolve(i3);
  }
  _processOAuthPopupParams(e6) {
    var _a;
    const t5 = this._oAuthDfd;
    if (this._oAuthDfd = null, t5)
      if (clearInterval(this._oAuthIntervalId), (_a = this._oAuthOnPopupHandle) == null ? void 0 : _a.remove(), e6.error) {
        const r3 = "access_denied" === e6.error, s6 = new s2(r3 ? "identity-manager:user-aborted" : "identity-manager:authentication-failed", r3 ? "ABORTED" : "OAuth: " + e6.error + " - " + e6.error_description);
        t5.reject(s6);
      } else
        this._processOAuthResponseParams(e6, t5.oinfo_, t5.sinfo_).then((e7) => {
          t5.resolve(e7);
        }).catch((e7) => {
          t5.reject(e7);
        });
  }
  _setOAuthResponseQueryString(e6) {
    e6 && ("?" === e6.charAt(0) && (e6 = e6.substring(1)), this._processOAuthPopupParams(A(e6)));
  }
  _exchangeToken(e6, t5, r3) {
    return j(`${e6}/sharing/rest/oauth2/exchangeToken`, { authMode: "anonymous", method: "post", query: { f: "json", client_id: t5, token: r3 } }).then((e7) => e7.data.token);
  }
  _getPlatformSelf(e6, t5) {
    return e6 = e6.replace(/^http:/i, "https:"), j(`${e6}/sharing/rest/oauth2/platformSelf`, { authMode: "anonymous", headers: { "X-Esri-Auth-Client-Id": t5, "X-Esri-Auth-Redirect-Uri": window.location.href.replace(/#.*$/, "") }, method: "post", query: { f: "json", expiration: 30 }, withCredentials: true }).then((e7) => e7.data);
  }
  _getPortalSelf(e6, t5) {
    let r3;
    if (this._gwDomains.some((t6) => (t6.regex.test(e6) && (r3 = t6.customBaseUrl), !!r3)), r3)
      return Promise.resolve({ allSSL: true, currentVersion: "8.4", customBaseUrl: r3, portalMode: "multitenant", supportsOAuth: true });
    this._appOrigin.startsWith("https:") ? e6 = e6.replace(/^http:/i, "https:").replace(/:7080/i, ":7443") : /^http:/i.test(t5) && (e6 = e6.replace(/^https:/i, "http:").replace(/:7443/i, ":7080"));
    return j(e6, { query: { f: "json" }, authMode: "anonymous", withCredentials: true }).then((e7) => e7.data);
  }
  _doPortalSignIn(e6) {
    const t5 = this._portalConfig, r3 = window.location.href, s6 = this.findServerInfo(e6);
    return !(!t5 && !this._isPortalDomain(r3) || !(s6 ? s6.hasPortal || s6.owningSystemUrl && this._isPortalDomain(s6.owningSystemUrl) : this._isPortalDomain(e6)) || !(this._isIdProvider(r3, e6) || t5 && (this._hasSameServerInstance(this._getServerInstanceRoot(t5.restBaseUrl), e6) || this._isIdProvider(t5.restBaseUrl, e6)) || F(r3, e6, true)));
  }
  _checkProtocol(e6, t5, r3, s6) {
    let o2 = true;
    const n3 = s6 ? t5.adminTokenServiceUrl : t5.tokenServiceUrl;
    if (n3.trim().toLowerCase().startsWith("https:") && !this._appOrigin.startsWith("https:") && T(n3) && (o2 = !!this._protocolFunc && !!this._protocolFunc({ resourceUrl: e6, serverInfo: t5 }), !o2)) {
      r3(new s2("identity-manager:aborted", "Aborted the Sign-In process to avoid sending password over insecure connection."));
    }
    return o2;
  }
  _enqueue(e6, t5, r3, s6, i3, o2) {
    return s6 || (s6 = C()), s6.resUrl_ = e6, s6.sinfo_ = t5, s6.options_ = r3, s6.admin_ = i3, s6.refresh_ = o2, this._busy ? this._hasSameServerInstance(this._getServerInstanceRoot(e6), this._busy.resUrl_) ? (this._oAuthDfd && this._oAuthDfd.oAuthWin_ && this._oAuthDfd.oAuthWin_.focus(), this._soReqs.push(s6)) : this._xoReqs.push(s6) : this._doSignIn(s6), s6.promise;
  }
  _doSignIn(e6) {
    this._busy = e6, this._rejectOnPersistedPageShow = false;
    const t5 = (t6) => {
      var _a;
      const r4 = (_a = e6.options_) == null ? void 0 : _a.resource, s7 = e6.resUrl_, i3 = e6.refresh_;
      let o3 = false;
      this.credentials.includes(t6) || (i3 && this.credentials.includes(i3) ? (i3.userId = t6.userId, i3.token = t6.token, i3.expires = t6.expires, i3.validity = t6.validity, i3.ssl = t6.ssl, i3.creationTime = t6.creationTime, o3 = true, t6 = i3) : this.credentials.push(t6)), t6.resources || (t6.resources = []), t6.resources.includes(r4 || s7) || t6.resources.push(r4 || s7), t6.scope = this._isServerRsrc(s7) ? "server" : "portal", t6.emitTokenChange();
      const n3 = this._soReqs, a3 = {};
      this._soReqs = [], n3.forEach((e7) => {
        if (!this._isIdenticalService(s7, e7.resUrl_)) {
          const r5 = this._getSuffix(e7.resUrl_);
          a3[r5] || (a3[r5] = true, t6.resources.push(e7.resUrl_));
        }
      }), e6.resolve(t6), n3.forEach((e7) => {
        this._hasSameServerInstance(this._getServerInstanceRoot(s7), e7.resUrl_) ? e7.resolve(t6) : this._soReqs.push(e7);
      }), this._busy = e6.resUrl_ = e6.sinfo_ = e6.refresh_ = null, o3 || this.emit("credential-create", { credential: t6 }), this._soReqs.length ? this._doSignIn(this._soReqs.shift()) : this._xoReqs.length && this._doSignIn(this._xoReqs.shift());
    }, r3 = (t6) => {
      e6.reject(t6), this._busy = e6.resUrl_ = e6.sinfo_ = e6.refresh_ = null, this._soReqs.length ? this._doSignIn(this._soReqs.shift()) : this._xoReqs.length && this._doSignIn(this._xoReqs.shift());
    }, s6 = (o3, a3, h2, l4) => {
      var _a, _b, _c;
      const d5 = e6.sinfo_, u2 = !e6.options_ || false !== e6.options_.prompt, p3 = d5.hasPortal && this._findOAuthInfo(e6.resUrl_);
      let g, f2;
      if (o3)
        t5(new L({ userId: o3, server: d5.server, token: h2 || null, expires: null != l4 ? Number(l4) : null, ssl: !!a3 }));
      else if (window !== window.parent && ((_a = this._appUrlObj.query) == null ? void 0 : _a["arcgis-auth-origin"]) && ((_b = this._appUrlObj.query) == null ? void 0 : _b["arcgis-auth-portal"]) && this._hasSameServerInstance(this._getServerInstanceRoot(this._appUrlObj.query["arcgis-auth-portal"]), e6.resUrl_)) {
        window.parent.postMessage({ type: "arcgis:auth:requestCredential" }, this._appUrlObj.query["arcgis-auth-origin"]);
        const s7 = r(window, "message", (e7) => {
          e7.source === window.parent && e7.data && ("arcgis:auth:credential" === e7.data.type ? (s7.remove(), e7.data.credential.expires < Date.now() ? r3(new s2("identity-manager:credential-request-failed", "Parent application's token has expired.")) : t5(new L(e7.data.credential))) : "arcgis:auth:error" === e7.data.type && (s7.remove(), "tokenExpiredError" === e7.data.error.name ? r3(new s2("identity-manager:credential-request-failed", "Parent application's token has expired.")) : r3(s2.fromJSON(e7.data.error))));
        });
        m((_c = e6.options_) == null ? void 0 : _c.signal, () => {
          s7.remove();
        });
      } else if (p3) {
        let o4 = p3._oAuthCred;
        if (!o4) {
          const e7 = new e5(p3, q), t6 = new e5(p3, j2);
          e7.isValid() && t6.isValid() ? e7.expires > t6.expires ? (o4 = e7, t6.destroy()) : (o4 = t6, e7.destroy()) : o4 = e7.isValid() ? e7 : t6, p3._oAuthCred = o4;
        }
        if (o4.isValid()) {
          g = new L({ userId: o4.userId, server: d5.server, token: o4.token, expires: o4.expires, ssl: o4.ssl, _oAuthCred: o4 });
          const r4 = p3.appId !== o4.appId && this._doPortalSignIn(e6.resUrl_);
          r4 || o4.refreshToken ? (e6._pendingDfd = o4.refreshToken ? this._getOAuthToken(d5.server, o4.refreshToken, o4.appId).then((e7) => (g.expires = Date.now() + 1e3 * e7.expires_in, g.token = e7.access_token, g)) : Promise.resolve(g), e6._pendingDfd.then((e7) => r4 ? this._exchangeToken(e7.server, p3.appId, e7.token).then((t6) => (e7.token = t6, e7)).catch(() => e7) : e7).then((e7) => {
            t5(e7);
          }).catch(() => {
            o4 == null ? void 0 : o4.destroy(), s6();
          })) : t5(g);
        } else if (this._oAuthLocationParams && this._hasSameServerInstance(p3.portalUrl, this._oAuthLocationParams.state.portalUrl) && (this._oAuthLocationParams.access_token || this._oAuthLocationParams.code && this._oAuthLocationParams.state.uid === o4.stateUID && o4.codeVerifier)) {
          const s7 = this._oAuthLocationParams;
          this._oAuthLocationParams = null, e6._pendingDfd = this._processOAuthResponseParams(s7, p3, d5).then((e7) => {
            t5(e7);
          }).catch(r3);
        } else {
          const s7 = () => {
            u2 ? e6._pendingDfd = this.oAuthSignIn(e6.resUrl_, d5, p3, e6.options_).then(t5, r3) : (f2 = new s2("identity-manager:not-authenticated", "User is not signed in."), r3(f2));
          };
          this._doPortalSignIn(e6.resUrl_) ? e6._pendingDfd = this._getPlatformSelf(d5.server, p3.appId).then((e7) => {
            F(e7.portalUrl, this._appOrigin, true) ? (g = new L({ userId: e7.username, server: d5.server, expires: Date.now() + 1e3 * e7.expires_in, token: e7.token }), t5(g)) : s7();
          }).catch(s7) : s7();
        }
      } else if (u2) {
        if (this._checkProtocol(e6.resUrl_, d5, r3, e6.admin_)) {
          let s7 = e6.options_;
          e6.admin_ && (s7 = s7 || {}, s7.isAdmin = true), e6._pendingDfd = this.signIn(e6.resUrl_, d5, s7).then(t5, r3);
        }
      } else
        f2 = new s2("identity-manager:not-authenticated", "User is not signed in."), r3(f2);
    }, o2 = () => {
      const s7 = e6.sinfo_, i3 = s7.owningSystemUrl, o3 = e6.options_;
      let n3, a3, h2, l4;
      if (o3 && (n3 = o3.token, a3 = o3.error, h2 = o3.prompt), l4 = this._findCredential(i3, { token: n3, resource: e6.resUrl_ }), !l4) {
        for (const e7 of this.credentials)
          if (this._isIdProvider(i3, e7.server)) {
            l4 = e7;
            break;
          }
      }
      if (l4) {
        const i4 = this.findCredential(e6.resUrl_, l4.userId);
        if (i4)
          t5(i4);
        else if (D(s7, this._legacyFed)) {
          const e7 = l4.toJSON();
          e7.server = s7.server, e7.resources = null, t5(new L(e7));
        } else {
          (e6._pendingDfd = this.generateToken(this.findServerInfo(l4.server), null, { serverUrl: e6.resUrl_, token: l4.token, signal: e6.options_.signal, ssl: l4.ssl })).then((r4) => {
            t5(new L({ userId: l4 == null ? void 0 : l4.userId, server: s7.server, token: r4.token, expires: null != r4.expires ? Number(r4.expires) : null, ssl: !!r4.ssl, isAdmin: e6.admin_, validity: r4.validity }));
          }, r3);
        }
      } else {
        this._busy = null, n3 && (e6.options_.token = null);
        (e6._pendingDfd = this.getCredential(i3.replace(/\/?$/, "/sharing"), { resource: e6.resUrl_, owningTenant: s7.owningTenant, signal: e6.options_.signal, token: n3, error: a3, prompt: h2 })).then(() => {
          this._enqueue(e6.resUrl_, e6.sinfo_, e6.options_, e6, e6.admin_);
        }, (t6) => {
          e6.resUrl_ = e6.sinfo_ = e6.refresh_ = null, e6.reject(t6);
        });
      }
    };
    this._errbackFunc = r3;
    const a2 = e6.sinfo_.owningSystemUrl, l3 = this._isServerRsrc(e6.resUrl_), d4 = e6.sinfo_._restInfoPms;
    d4 ? d4.promise.then((t6) => {
      const r4 = e6.sinfo_;
      if (r4._restInfoPms) {
        r4.adminTokenServiceUrl = r4._restInfoPms.adminUrl, r4._restInfoPms = null, r4.tokenServiceUrl = (t("authInfo.tokenServicesUrl", t6) || t("authInfo.tokenServiceUrl", t6) || t("tokenServiceUrl", t6)) ?? null, r4.shortLivedTokenValidity = t("authInfo.shortLivedTokenValidity", t6) ?? null, r4.currentVersion = t6.currentVersion, r4.owningTenant = t6.owningTenant;
        const e7 = r4.owningSystemUrl = t6.owningSystemUrl;
        e7 && this._portals.push(e7);
      }
      l3 && r4.owningSystemUrl ? o2() : s6();
    }, () => {
      e6.sinfo_._restInfoPms = null;
      const t6 = new s2("identity-manager:server-identification-failed", "Unknown resource - could not find token service endpoint.");
      r3(t6);
    }) : l3 && a2 ? o2() : e6.sinfo_._selfReq ? e6.sinfo_._selfReq.selfDfd.then((t6) => {
      var _a;
      const r4 = {};
      let s7, i3, o3, n3;
      return t6 && (s7 = (_a = t6.user) == null ? void 0 : _a.username, r4.username = s7, r4.allSSL = t6.allSSL, i3 = t6.supportsOAuth, n3 = parseFloat(t6.currentVersion), "multitenant" === t6.portalMode && (o3 = t6.customBaseUrl), e6.sinfo_.currentVersion = n3), e6.sinfo_.webTierAuth = !!s7, s7 && this.normalizeWebTierAuth ? this.generateToken(e6.sinfo_, null, { ssl: r4.allSSL }).catch(() => null).then((e7) => (r4.portalToken = e7 && e7.token, r4.tokenExpiration = e7 && e7.expires, r4)) : !s7 && i3 && n3 >= 4.4 && !this._findOAuthInfo(e6.resUrl_) ? this._generateOAuthInfo({ portalUrl: e6.sinfo_.server, customBaseUrl: o3, owningTenant: e6.sinfo_._selfReq.owningTenant }).catch(() => null).then(() => r4) : r4;
    }).catch(() => null).then((t6) => {
      e6.sinfo_._selfReq = null, t6 ? s6(t6.username, t6.allSSL, t6.portalToken, t6.tokenExpiration) : s6();
    }) : s6();
  }
  _generateOAuthInfo(e6) {
    let t5, r3 = null, i3 = e6.portalUrl;
    const o2 = e6.customBaseUrl, n3 = e6.owningTenant, a2 = !this._defaultOAuthInfo && this._createDefaultOAuthInfo && !this._hasTestedIfAppIsOnPortal;
    if (a2) {
      r3 = window.location.href;
      let e7 = r3.indexOf("?");
      e7 > -1 && (r3 = r3.slice(0, e7)), e7 = r3.search(/\/(apps|home)\//), r3 = e7 > -1 ? r3.slice(0, e7) : null;
    }
    return a2 && r3 ? (this._hasTestedIfAppIsOnPortal = true, t5 = j(r3 + "/sharing/rest", { query: { f: "json" } }).then(() => {
      this._defaultOAuthInfo = new i({ appId: "arcgisonline", popupCallbackUrl: r3 + "/home/oauth-callback.html" });
    })) : t5 = Promise.resolve(), t5.then(() => {
      if (this._defaultOAuthInfo)
        return i3 = i3.replace(/^http:/i, "https:"), j(i3 + "/sharing/rest/oauth2/validateRedirectUri", { query: { accountId: n3, client_id: this._defaultOAuthInfo.appId, redirect_uri: _(this._defaultOAuthInfo.popupCallbackUrl), f: "json" } }).then((e7) => {
          if (e7.data.valid) {
            const t6 = this._defaultOAuthInfo.clone();
            e7.data.urlKey && o2 ? t6.portalUrl = "https://" + e7.data.urlKey.toLowerCase() + "." + o2 : t6.portalUrl = i3, t6.popup = window !== window.top || !(F(i3, this._appOrigin) || this._gwDomains.some((e8) => e8.regex.test(i3) && e8.regex.test(this._appOrigin))), this.oAuthInfos.push(t6);
          }
        });
    });
  }
  _doOAuthSignIn(e6, t5, r3, s6) {
    const o2 = r3._oAuthCred, a2 = { portalUrl: r3.portalUrl };
    !r3.popup && r3.preserveUrlHash && window.location.hash && (a2.hash = window.location.hash), o2.stateUID && (a2.uid = o2.stateUID);
    const h2 = { client_id: r3.appId, response_type: o2.codeVerifier ? "code" : "token", state: JSON.stringify(a2), expiration: r3.expiration, locale: r3.locale, redirect_uri: this._getRedirectURI(r3, !!o2.codeVerifier) };
    r3.forceLogin && (h2.force_login = true), r3.forceUserId && r3.userId && (h2.prepopulatedusername = r3.userId), !r3.popup && this._doPortalSignIn(e6) && (h2.redirectToUserOrgUrl = true), o2.codeVerifier && (h2.code_challenge = s6 || o2.codeVerifier, h2.code_challenge_method = s6 ? "S256" : "plain");
    const l3 = r3.portalUrl.replace(/^http:/i, "https:") + "/sharing/oauth2/authorize", c4 = l3 + "?" + v(h2);
    if (r3.popup) {
      const e7 = window.open(c4, "esriJSAPIOAuth", r3.popupWindowFeatures);
      if (e7)
        e7.focus(), this._oAuthDfd.oAuthWin_ = e7, this._oAuthIntervalId = setInterval(() => {
          if (e7.closed) {
            clearInterval(this._oAuthIntervalId), this._oAuthOnPopupHandle.remove();
            const e8 = this._oAuthDfd;
            if (e8) {
              const t6 = new s2("identity-manager:user-aborted", "ABORTED");
              e8.reject(t6);
            }
          }
        }, 500), this._oAuthOnPopupHandle = r(window, ["arcgis:auth:hash", "arcgis:auth:location:search"], (e8) => {
          "arcgis:auth:hash" === e8.type ? this.setOAuthResponseHash(e8.detail) : this._setOAuthResponseQueryString(e8.detail);
        });
      else {
        const e8 = new s2("identity-manager:popup-blocked", "ABORTED");
        this._oAuthDfd.reject(e8);
      }
    } else
      this._rejectOnPersistedPageShow = true, this._oAuthRedirectFunc ? this._oAuthRedirectFunc({ authorizeParams: h2, authorizeUrl: l3, resourceUrl: e6, serverInfo: t5, oAuthInfo: r3 }) : window.location.href = c4;
  }
  _getRedirectURI(e6, t5) {
    const r3 = window.location.href.replace(/#.*$/, "");
    if (e6.popup)
      return _(e6.popupCallbackUrl);
    if (t5) {
      const e7 = I(r3);
      return e7.query && ["code", "error", "error_description", "message_code", "persist", "state"].forEach((t6) => {
        delete e7.query[t6];
      }), Et(e7.path, e7.query);
    }
    return r3;
  }
};
E.prototype.declaredClass = "esri.identity.IdentityManagerBase";
var L = class extends o.EventedAccessor {
  constructor(e6) {
    super(e6), this._oAuthCred = null, this.tokenRefreshBuffer = 2, (e6 == null ? void 0 : e6._oAuthCred) && (this._oAuthCred = e6._oAuthCred);
  }
  initialize() {
    this.resources = this.resources || [], null == this.creationTime && (this.creationTime = Date.now());
  }
  refreshToken() {
    const e6 = t3.findServerInfo(this.server), t5 = e6 == null ? void 0 : e6.owningSystemUrl, s6 = !!t5 && "server" === this.scope, i3 = s6 && D(e6, t3._legacyFed), o2 = e6.webTierAuth, n3 = o2 && t3.normalizeWebTierAuth, a2 = C2[this.server], h2 = a2 == null ? void 0 : a2[this.userId];
    let l3, c4 = this.resources && this.resources[0], d4 = s6 ? t3.findServerInfo(t5) : null, u2 = { username: this.userId, password: h2 };
    if (o2 && !n3)
      return;
    s6 && !d4 && t3.serverInfos.some((e7) => (t3._isIdProvider(t5, e7.server) && (d4 = e7), !!d4));
    const p3 = d4 ? t3.findCredential(d4.server, this.userId) : null;
    if (!s6 || p3) {
      if (!i3) {
        if (s6)
          l3 = { serverUrl: c4, token: p3 == null ? void 0 : p3.token, ssl: p3 && p3.ssl };
        else if (n3)
          u2 = null, l3 = { ssl: this.ssl };
        else {
          if (!h2) {
            let t6;
            return c4 && (c4 = t3._sanitizeUrl(c4), this._enqueued = 1, t6 = t3._enqueue(c4, e6, null, null, this.isAdmin, this), t6.then(() => {
              this._enqueued = 0, this.refreshServerTokens();
            }).catch(() => {
              this._enqueued = 0;
            })), t6;
          }
          this.isAdmin && (l3 = { isAdmin: true });
        }
        return t3.generateToken(s6 ? d4 : e6, s6 ? null : u2, l3).then((e7) => {
          this.token = e7.token, this.expires = null != e7.expires ? Number(e7.expires) : null, this.creationTime = Date.now(), this.validity = e7.validity, this.emitTokenChange(), this.refreshServerTokens();
        }).catch(() => {
        });
      }
      p3 == null ? void 0 : p3.refreshToken();
    }
  }
  refreshServerTokens() {
    "portal" === this.scope && t3.credentials.forEach((e6) => {
      const t5 = t3.findServerInfo(e6.server), s6 = t5 == null ? void 0 : t5.owningSystemUrl;
      e6 !== this && e6.userId === this.userId && s6 && "server" === e6.scope && (t3._hasSameServerInstance(this.server, s6) || t3._isIdProvider(s6, this.server)) && (D(t5, t3._legacyFed) ? (e6.token = this.token, e6.expires = this.expires, e6.creationTime = this.creationTime, e6.validity = this.validity, e6.emitTokenChange()) : e6.refreshToken());
    });
  }
  emitTokenChange(e6) {
    clearTimeout(this._refreshTimer);
    const t5 = this.server ? t3.findServerInfo(this.server) : null, s6 = t5 == null ? void 0 : t5.owningSystemUrl, i3 = s6 ? t3.findServerInfo(s6) : null;
    false === e6 || s6 && "portal" !== this.scope && (!(i3 == null ? void 0 : i3.webTierAuth) || t3.normalizeWebTierAuth) || null == this.expires && null == this.validity || this._startRefreshTimer(), this.emit("token-change");
  }
  destroy() {
    this.userId = this.server = this.token = this.expires = this.validity = this.resources = this.creationTime = null, this._oAuthCred && (this._oAuthCred.destroy(), this._oAuthCred = null);
    const e6 = t3.credentials.indexOf(this);
    e6 > -1 && t3.credentials.splice(e6, 1), this.emitTokenChange(), this.emit("destroy");
  }
  toJSON() {
    const e6 = l({ userId: this.userId, server: this.server, token: this.token, expires: this.expires, validity: this.validity, ssl: this.ssl, isAdmin: this.isAdmin, creationTime: this.creationTime, scope: this.scope }), t5 = this.resources;
    return t5 && t5.length > 0 && (e6.resources = t5.slice()), e6;
  }
  _startRefreshTimer() {
    clearTimeout(this._refreshTimer);
    const e6 = 6e4 * this.tokenRefreshBuffer, t5 = 2 ** 31 - 1;
    let r3 = (this.validity ? this.creationTime + 6e4 * this.validity : this.expires) - Date.now();
    r3 < 0 ? r3 = 0 : r3 > t5 && (r3 = t5), this._refreshTimer = setTimeout(this.refreshToken.bind(this), r3 > e6 ? r3 - e6 : r3);
  }
};
e([y()], L.prototype, "creationTime", void 0), e([y()], L.prototype, "expires", void 0), e([y()], L.prototype, "isAdmin", void 0), e([y()], L.prototype, "oAuthState", void 0), e([y()], L.prototype, "resources", void 0), e([y()], L.prototype, "scope", void 0), e([y()], L.prototype, "server", void 0), e([y()], L.prototype, "ssl", void 0), e([y()], L.prototype, "token", void 0), e([y()], L.prototype, "tokenRefreshBuffer", void 0), e([y()], L.prototype, "userId", void 0), e([y()], L.prototype, "validity", void 0), L = e([c2("esri.identity.Credential")], L);

// node_modules/@arcgis/core/identity/IdentityManager.js
var r2 = class extends E {
};
r2.prototype.declaredClass = "esri.identity.IdentityManager";
var s5 = new r2();
n(s5);
export {
  s5 as default
};
/*! Bundled license information:

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.2.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 7.5.4
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)
*/
//# sourceMappingURL=@arcgis_core_identity_IdentityManager.js.map
