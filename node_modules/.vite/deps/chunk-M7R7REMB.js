import {
  f
} from "./chunk-QWPLZ3QH.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";

// node_modules/@arcgis/core/support/arcadeOnDemand.js
var a = s.getLogger("esri.support.arcadeOnDemand");
var s3;
function i() {
  return s3 || (s3 = (async () => {
    const e = await import("./arcadeUtils-XGMWCG7P.js");
    return { arcade: e.arcade, arcadeUtils: e, Dictionary: e.Dictionary, Feature: e.arcadeFeature };
  })()), s3;
}
var c = (e, r, t) => u.create(e, r, t, null, ["$feature", "$view"], []);
var n = (e, r, t) => u.create(e, r, t, null, ["$feature", "$view"], []);
var l = (e, r, t, a2) => u.create(e, r, t, a2, ["$feature", "$view"], []);
var u = class _u {
  constructor(e, r, t, a2, s4, i2, c2) {
    this.services = null, this.script = e, this.evaluate = a2;
    const n2 = Array.isArray(i2) ? i2 : i2.fields;
    this.fields = n2, this._syntaxTree = t, this._arcade = r, this._arcadeFeature = s4, this._spatialReference = c2, this._referencesGeometry = r.scriptTouchesGeometry(this._syntaxTree), this._referencesScale = this._arcade.referencesMember(this._syntaxTree, "scale");
  }
  static async create(r, s4, c2, n2, o, l2) {
    const { arcade: p, Feature: m, Dictionary: f2 } = await i(), d = f.fromJSON(s4);
    let y;
    try {
      y = p.parseScript(r, l2);
    } catch (x) {
      return a.error(new s2("arcade-bad-expression", "Failed to parse arcade script", { script: r, error: x })), null;
    }
    const h = o.reduce((e, r2) => ({ ...e, [r2]: null }), {});
    let w = null;
    null != n2 && (w = new f2(n2), w.immutable = true, h.$config = null);
    const v = p.scriptUsesGeometryEngine(y), $ = v && p.enableGeometrySupport(), g = p.scriptUsesFeatureSet(y) && p.enableFeatureSetSupport(), _ = p.scriptIsAsync(y), F = _ && p.enableAsyncSupport(), S = { vars: h, spatialReference: d, useAsync: !!F };
    await Promise.all([$, g, F]);
    const b = /* @__PURE__ */ new Set();
    await p.loadDependentModules(b, y, null, _, v);
    const j = new f2();
    j.immutable = false, j.setField("scale", 0);
    const G = p.compileScript(y, S), R = (e, r2) => {
      var _a;
      const t = (_a = e.$view) == null ? void 0 : _a.timeZone;
      return "$view" in e && e.$view && (j.setField("scale", "object" == typeof e.$view && "scale" in e.$view ? e.$view.scale : void 0), e.$view = j), w && (e.$config = w), G({ vars: e, spatialReference: d, services: r2, timeZone: t });
    };
    return new _u(r, p, y, R, new m(), c2, d);
  }
  repurposeFeature(e) {
    return e.geometry && !e.geometry.spatialReference && (e.geometry.spatialReference = this._spatialReference), this._arcadeFeature.repurposeFromGraphicLikeObject(e.geometry, e.attributes, { fields: this.fields }), this._arcadeFeature;
  }
  referencesGeometry() {
    return this._referencesGeometry;
  }
  referencesScale() {
    return this._referencesScale;
  }
};

export {
  i,
  c,
  n,
  l,
  u
};
//# sourceMappingURL=chunk-M7R7REMB.js.map
