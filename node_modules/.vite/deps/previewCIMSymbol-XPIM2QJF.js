import {
  i
} from "./chunk-O2FQJXDX.js";
import {
  c as c2
} from "./chunk-TKUQYK2U.js";
import "./chunk-R72HXU5Y.js";
import {
  l
} from "./chunk-GKZKNWGZ.js";
import {
  t as t2
} from "./chunk-QS4IQWBR.js";
import {
  m
} from "./chunk-6JCSK7BN.js";
import "./chunk-XZLDDXLF.js";
import {
  V,
  j as j2
} from "./chunk-BRF3NTLN.js";
import "./chunk-OG2GBCUQ.js";
import {
  Q,
  et,
  le,
  ne,
  r
} from "./chunk-WR3GXMXV.js";
import "./chunk-NS7I2ZSY.js";
import "./chunk-3S7E6CPQ.js";
import {
  O,
  c,
  r as r2,
  t
} from "./chunk-XI27PUTI.js";
import "./chunk-7REGXRO2.js";
import "./chunk-L2VCMOKZ.js";
import "./chunk-PHDOV32N.js";
import "./chunk-Z26DT4RT.js";
import "./chunk-BUMLJETN.js";
import "./chunk-OPV4AZKI.js";
import "./chunk-XFC7DZXI.js";
import "./chunk-5WG7GACT.js";
import "./chunk-7Y57Y6IH.js";
import "./chunk-SBUFDP7O.js";
import "./chunk-B7TIRUHV.js";
import "./chunk-EY7PGBJG.js";
import "./chunk-6M5DUIJQ.js";
import "./chunk-NDKHIQMD.js";
import "./chunk-L7F73IMH.js";
import "./chunk-SA3C7GIT.js";
import "./chunk-P3R45ANF.js";
import "./chunk-CSWPLQ7Q.js";
import "./chunk-KWSMYM7P.js";
import "./chunk-AMSVADDY.js";
import {
  p2 as p
} from "./chunk-HITXLR5N.js";
import "./chunk-WYZCKLOR.js";
import "./chunk-S6NERLXF.js";
import "./chunk-4TSAC52K.js";
import "./chunk-H4ZZ5S37.js";
import {
  u as u2
} from "./chunk-G557TGXY.js";
import "./chunk-IRNKV32L.js";
import "./chunk-IATM3RCE.js";
import "./chunk-GRHSIT57.js";
import "./chunk-PJQIAD5D.js";
import "./chunk-Z6KIMOUA.js";
import "./chunk-SZAJDZCO.js";
import "./chunk-M7R7REMB.js";
import "./chunk-ZZYUEH57.js";
import "./chunk-VTWXDFFD.js";
import "./chunk-IPCIO3PX.js";
import {
  e,
  u
} from "./chunk-EIY2DYTV.js";
import "./chunk-WJ4LS3YG.js";
import "./chunk-F6MD5VOH.js";
import "./chunk-V2RPSCV3.js";
import "./chunk-LMT5JII2.js";
import "./chunk-OIIDE5GZ.js";
import "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import "./chunk-TBSVVR6M.js";
import "./chunk-6TJWLWLO.js";
import "./chunk-H7BKONNV.js";
import "./chunk-K6C6RVSV.js";
import "./chunk-KBJ5Z4R2.js";
import "./chunk-JUZJCTW2.js";
import "./chunk-423VNHLR.js";
import "./chunk-FN47E7YK.js";
import "./chunk-XZS3Q5K4.js";
import "./chunk-XXFXRXFH.js";
import "./chunk-CCXEAKIM.js";
import "./chunk-Y5D433JZ.js";
import "./chunk-QNOCEWCR.js";
import "./chunk-WURET5CW.js";
import "./chunk-QWPLZ3QH.js";
import "./chunk-HLGIRLYQ.js";
import "./chunk-N2K4VRZH.js";
import "./chunk-WL4VPODY.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import {
  j
} from "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import "./chunk-LXXF7K7W.js";
import "./chunk-SBW6NNVI.js";
import "./chunk-62CXLI6S.js";
import {
  s
} from "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import "./chunk-WJ3HJKNC.js";
import "./chunk-4V6374PV.js";
import "./chunk-A34O4XB5.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/symbols/cim/CIMSymbolRasterizer.js
var C = (e2) => (e2 == null ? void 0 : e2.scaleFactor) ? e2.scaleFactor : 1;
var _ = 96 / 72;
var M = class {
  constructor(e2, t3) {
    this._spatialReference = e2, this._avoidSDF = t3, this._resourceCache = /* @__PURE__ */ new Map(), this._lazyImageDataCanvas = null, this._pictureMarkerCache = /* @__PURE__ */ new Map(), this._textRasterizer = new r(), this._cimResourceManager = new i(), this._rasterizer = new c2(this._cimResourceManager);
  }
  get _imageDataCanvas() {
    return this._lazyImageDataCanvas ?? (this._lazyImageDataCanvas = document.createElement("canvas")), this._lazyImageDataCanvas;
  }
  get _imageDataContext() {
    return this._imageDataCanvas.getContext("2d", { willReadFrequently: true });
  }
  get resourceManager() {
    return this._cimResourceManager;
  }
  async rasterizeCIMSymbolAsync(e2, t3, a, i2, r3, o, s3, m3, g) {
    if (!e2)
      return null;
    const { data: f2 } = e2;
    if (!f2 || "CIMSymbolReference" !== f2.type || !f2.symbol)
      return null;
    const { symbol: d } = f2;
    o || (o = O(d));
    const y2 = await le.resolveSymbolOverrides(f2, t3, this._spatialReference, r3, o, s3, m3), p3 = this._imageDataCanvas, w = this._cimResourceManager, C2 = [];
    ne.fetchResources(y2, w, C2), ne.fetchFonts(y2, w, C2), C2.length > 0 && await Promise.all(C2);
    const { width: M2, height: b2 } = a, I = z(o, M2, b2, i2), x = ne.getEnvelope(y2, I, w);
    if (!x)
      return null;
    const R = (window.devicePixelRatio || 1) * _;
    let v = 1, D = 0, P = 0;
    switch (d.type) {
      case "CIMPointSymbol":
      case "CIMTextSymbol":
        {
          let e3 = 1;
          x.width > M2 && (e3 = M2 / x.width);
          let t4 = 1;
          x.height > b2 && (t4 = b2 / x.height), "preview" === i2 && (x.width < M2 && (e3 = M2 / x.width), x.height < b2 && (t4 = b2 / x.height)), v = Math.min(e3, t4), D = x.x + x.width / 2, P = x.y + x.height / 2;
        }
        break;
      case "CIMLineSymbol":
        {
          (g || x.height > b2) && (v = b2 / x.height), P = x.y + x.height / 2;
          const e3 = x.x * v + M2 / 2, t4 = (x.x + x.width) * v + M2 / 2, { paths: a2 } = I;
          a2[0][0][0] -= e3 / v, a2[0][2][0] -= (t4 - M2) / v;
        }
        break;
      case "CIMPolygonSymbol": {
        D = x.x + x.width / 2, P = x.y + x.height / 2;
        const e3 = x.x * v + M2 / 2, t4 = (x.x + x.width) * v + M2 / 2, a2 = x.y * v + b2 / 2, i3 = (x.y + x.height) * v + b2 / 2, { rings: r4 } = I;
        e3 < 0 && (r4[0][0][0] -= e3, r4[0][3][0] -= e3, r4[0][4][0] -= e3), a2 < 0 && (r4[0][0][1] += a2, r4[0][1][1] += a2, r4[0][4][1] += a2), t4 > M2 && (r4[0][1][0] -= t4 - M2, r4[0][2][0] -= t4 - M2), i3 > b2 && (r4[0][2][1] += i3 - b2, r4[0][3][1] += i3 - b2);
      }
    }
    p3.width = M2 * R, p3.height = b2 * R;
    const S = 1;
    p3.width += 2 * S, p3.height += 2 * S;
    const k = this._imageDataContext, A = Q.createIdentity();
    A.translate(-D, -P), A.scale(v * R, -v * R), A.translate(M2 * R / 2 + S, b2 * R / 2 + S), k.clearRect(0, 0, p3.width, p3.height);
    return new et(k, w, A, true).drawSymbol(y2, I), k.getImageData(0, 0, p3.width, p3.height);
  }
  async analyzeCIMSymbol3D(e2, t3, i2, o, s3) {
    const n = [], l2 = t3 ? { geometryType: o, spatialReference: this._spatialReference, fields: t3 } : null, c4 = [];
    ne.fetchFonts(e2.data.symbol, this._cimResourceManager, c4), await Promise.all(c4);
    const m3 = new j2(this._cimResourceManager, l2);
    let g;
    await m3.analyzeSymbolReference(e2.data, this._avoidSDF, n), s(s3);
    for (const a of n)
      "CIMPictureMarker" !== a.cim.type && "CIMPictureFill" !== a.cim.type && "CIMPictureStroke" !== a.cim.type || (g || (g = []), g.push(this._fetchPictureMarkerResource(a, s3))), i2 && "text" === a.type && "string" == typeof a.text && a.text.includes("[") && (a.text = c(i2, a.text, a.cim.textCase));
    return g && await Promise.all(g), n;
  }
  rasterizeCIMSymbol3D(e2, t3, a, i2, r3, o) {
    const s3 = [];
    for (const n of e2) {
      i2 && "function" == typeof i2.scaleFactor && (i2.scaleFactor = i2.scaleFactor(t3, r3, o));
      const e3 = this._getRasterizedResource(n, t3, a, i2, r3, o);
      if (!e3)
        continue;
      let l2 = 0, c4 = e3.anchorX || 0, h2 = e3.anchorY || 0, m3 = false, g = 0, u4 = 0;
      if ("esriGeometryPoint" === a) {
        const e4 = C(i2);
        if (g = t(n.offsetX, t3, r3, o) * e4 || 0, u4 = t(n.offsetY, t3, r3, o) * e4 || 0, "marker" === n.type)
          l2 = t(n.rotation, t3, r3, o) || 0, m3 = n.rotateClockwise ?? false;
        else if ("text" === n.type) {
          if (l2 = t(n.angle, t3, r3, o) || 0, void 0 !== n.horizontalAlignment)
            switch (n.horizontalAlignment) {
              case "left":
                c4 = -0.5;
                break;
              case "right":
                c4 = 0.5;
                break;
              default:
                c4 = 0;
            }
          if (void 0 !== n.verticalAlignment)
            switch (n.verticalAlignment) {
              case "top":
                h2 = 0.5;
                break;
              case "bottom":
                h2 = -0.5;
                break;
              case "baseline":
                h2 = -0.25;
                break;
              default:
                h2 = 0;
            }
        }
      }
      null != e3 && s3.push({ angle: l2, rotateClockWise: m3, anchorX: c4, anchorY: h2, offsetX: g, offsetY: u4, rasterizedResource: e3 });
    }
    return this.getSymbolImage(s3);
  }
  getSymbolImage(e2) {
    const t3 = document.createElement("canvas"), a = t3.getContext("2d");
    let r3 = 0, o = 0, s3 = 0, n = 0;
    const l2 = [];
    for (let g = 0; g < e2.length; g++) {
      const t4 = e2[g], c5 = t4.rasterizedResource;
      if (!c5)
        continue;
      const h3 = c5.size, m4 = t4.offsetX, u4 = t4.offsetY, f2 = t4.anchorX, d = t4.anchorY, y2 = t4.rotateClockWise || false;
      let p3 = t4.angle, w = u(m4) - h3[0] * (0.5 + f2), C2 = u(u4) - h3[1] * (0.5 + d), _2 = w + h3[0], M2 = C2 + h3[1];
      if (p3) {
        y2 && (p3 = -p3);
        const e3 = Math.sin(p3 * Math.PI / 180), t5 = Math.cos(p3 * Math.PI / 180), a2 = w * t5 - C2 * e3, i2 = w * e3 + C2 * t5, r4 = w * t5 - M2 * e3, o2 = w * e3 + M2 * t5, s4 = _2 * t5 - M2 * e3, n2 = _2 * e3 + M2 * t5, l3 = _2 * t5 - C2 * e3, c6 = _2 * e3 + C2 * t5;
        w = Math.min(a2, r4, s4, l3), C2 = Math.min(i2, o2, n2, c6), _2 = Math.max(a2, r4, s4, l3), M2 = Math.max(i2, o2, n2, c6);
      }
      r3 = w < r3 ? w : r3, o = C2 < o ? C2 : o, s3 = _2 > s3 ? _2 : s3, n = M2 > n ? M2 : n;
      const z2 = a.createImageData(c5.size[0], c5.size[1]);
      z2.data.set(new Uint8ClampedArray(c5.image.buffer));
      const b2 = { offsetX: m4, offsetY: u4, rotateClockwise: y2, angle: p3, rasterizedImage: z2, anchorX: f2, anchorY: d };
      l2.push(b2);
    }
    t3.width = s3 - r3, t3.height = n - o;
    const c4 = -r3, h2 = n;
    for (let g = 0; g < l2.length; g++) {
      const e3 = l2[g], t4 = this._imageDataToCanvas(e3.rasterizedImage), r4 = e3.rasterizedImage.width, o2 = e3.rasterizedImage.height, s4 = c4 - r4 * (0.5 + e3.anchorX), n2 = h2 - o2 * (0.5 - e3.anchorY);
      if (e3.angle) {
        const r5 = (360 - e3.angle) * Math.PI / 180;
        a.save(), a.translate(u(e3.offsetX), -u(e3.offsetY)), a.translate(c4, h2), a.rotate(r5), a.translate(-c4, -h2), a.drawImage(t4, s4, n2), a.restore();
      } else
        a.drawImage(t4, s4 + u(e3.offsetX), n2 - u(e3.offsetY));
    }
    const m3 = new p({ x: c4 / t3.width - 0.5, y: h2 / t3.height - 0.5 });
    return { imageData: 0 !== t3.width && 0 !== t3.height ? a.getImageData(0, 0, t3.width, t3.height) : a.createImageData(1, 1), anchorPosition: m3 };
  }
  async _fetchPictureMarkerResource(e2, a) {
    const i2 = e2.materialHash;
    if (!this._pictureMarkerCache.get(i2)) {
      const r3 = (await j(e2.cim.url, { responseType: "image", signal: a == null ? void 0 : a.signal })).data;
      this._pictureMarkerCache.set(i2, r3);
    }
  }
  _imageDataToCanvas(e2) {
    const t3 = this._imageDataCanvas, a = this._imageDataContext;
    return t3.width = e2.width, t3.height = e2.height, a.putImageData(e2, 0, 0), t3;
  }
  _imageTo32Array(t3, a, i2, r3) {
    const o = this._imageDataCanvas, s3 = this._imageDataContext;
    if (o.width = a, o.height = i2, s3.drawImage(t3, 0, 0, a, i2), r3) {
      s3.save();
      const o2 = new u2(r3);
      s3.fillStyle = o2.toHex(), s3.globalCompositeOperation = "multiply", s3.fillRect(0, 0, a, i2), s3.globalCompositeOperation = "destination-atop", s3.drawImage(t3, 0, 0, a, i2), s3.restore();
    }
    return new Uint32Array(s3.getImageData(0, 0, a, i2).data.buffer);
  }
  _getRasterizedResource(e2, t3, a, i2, r3, o) {
    let s3, n, l2;
    const c4 = null, h2 = null;
    if ("text" === e2.type)
      return this._rasterizeTextResource(e2, t3, i2, r3, o);
    ({ analyzedCIM: s3, hash: n } = b(e2, t3, r3, o));
    const m3 = C(i2);
    if ("CIMPictureMarker" === e2.cim.type) {
      const a2 = t(e2.size, t3, r3, o) * m3, { image: i3, width: s4, height: n2 } = this._getPictureResource(e2, a2, t(e2.color, t3, r3, o));
      return l2 = { image: i3, size: [s4, n2], sdf: false, simplePattern: false, anchorX: e2.anchorPoint ? e2.anchorPoint.x : 0, anchorY: e2.anchorPoint ? e2.anchorPoint.y : 0 }, l2;
    }
    m(s3, m3, { preserveOutlineWidth: false });
    const g = s3;
    n += a, i2 && (n += JSON.stringify(i2));
    const u4 = this._resourceCache;
    return u4.has(n) ? u4.get(n) : (l2 = this._rasterizer.rasterizeJSONResource({ cim: g, type: e2.type, url: e2.url, mosaicHash: n, size: c4, path: h2 }, window.devicePixelRatio || 1, this._avoidSDF), u4.set(n, l2), l2);
  }
  _rasterizeTextResource(e2, t3, a, i2, r3) {
    var _a, _b, _c;
    const o = C(a), s3 = t(e2.text, t3, i2, r3);
    if (!s3 || 0 === s3.length)
      return null;
    const n = e2.cim, l2 = t((n == null ? void 0 : n.fontFamilyName) || e2.fontName, t3, i2, r3), c4 = t(((_a = n == null ? void 0 : n.font) == null ? void 0 : _a.style) || e2.style, t3, i2, r3), h2 = t(((_b = n == null ? void 0 : n.font) == null ? void 0 : _b.weight) || e2.weight, t3, i2, r3), m3 = t(((_c = n == null ? void 0 : n.font) == null ? void 0 : _c.decoration) || e2.decoration, t3, i2, r3), g = t(e2.size, t3, i2, r3) * o, u4 = t(e2.horizontalAlignment, t3, i2, r3), f2 = t(e2.verticalAlignment, t3, i2, r3), p3 = r2(t(e2.color, t3, i2, r3)), w = r2(t(e2.outlineColor, t3, i2, r3)), _2 = t(e2.outlineSize, t3, i2, r3), M2 = null != e2.backgroundColor ? r2(e2.backgroundColor) : null, z2 = null != e2.borderLineColor ? r2(e2.borderLineColor) : null, b2 = null != e2.borderLineWidth ? e2.borderLineWidth : null, I = { color: p3, size: g, horizontalAlignment: u4, verticalAlignment: f2, font: { family: l2, style: c4, weight: h2, decoration: m3 }, halo: { size: _2 || 0, color: w, style: c4 }, backgroundColor: M2, borderLine: null != z2 && null != b2 ? { color: z2, size: b2 } : null, pixelRatio: 1, premultiplyColors: !this._avoidSDF };
    return this._textRasterizer.rasterizeText(s3, I);
  }
  _getPictureResource(e2, t3, a) {
    const r3 = this._pictureMarkerCache.get(e2.materialHash);
    if (!r3)
      return null;
    const o = r3.height / r3.width, s3 = t3 ? o > 1 ? u(t3) : u(t3) / o : r3.width, n = t3 ? o > 1 ? u(t3) * o : u(t3) : r3.height;
    return { image: this._imageTo32Array(r3, s3, n, a), width: s3, height: n };
  }
};
function z(e2, t3, a, i2) {
  const r3 = 1, o = -t3 / 2 + r3, s3 = t3 / 2 - r3, n = a / 2 - r3, l2 = -a / 2 + r3;
  switch (e2) {
    case "esriGeometryPoint":
      return { x: 0, y: 0 };
    case "esriGeometryPolyline":
      return { paths: [[[o, 0], [0, 0], [s3, 0]]] };
    default:
      return "legend" === i2 ? { rings: [[[o, n], [s3, 0], [s3, l2], [o, l2], [o, n]]] } : { rings: [[[o, n], [s3, n], [s3, l2], [o, l2], [o, n]]] };
  }
}
function b(e2, t3, a, i2) {
  let r3, s3;
  if ("function" == typeof e2.materialHash) {
    r3 = (0, e2.materialHash)(t3, a, i2), s3 = V(e2.cim, e2.materialOverrides);
  } else
    r3 = e2.materialHash, s3 = e2.cim;
  return { analyzedCIM: s3, hash: r3 };
}

// node_modules/@arcgis/core/symbols/support/previewCIMSymbol.js
var s2 = new M(null, true);
var c3 = e(t2.size);
var m2 = e(t2.maxSize);
var u3 = e(t2.lineWidth);
var f = 1;
async function h(e2, t3, i2) {
  const l2 = t3 == null ? void 0 : t3.size;
  let n = null != l2 && "object" == typeof l2 && "width" in l2 ? l2.width : l2, a = null != l2 && "object" == typeof l2 && "height" in l2 ? l2.height : l2;
  if (null == n || null == a)
    if ("esriGeometryPolygon" === i2)
      n = c3, a = c3;
    else {
      const l3 = await y(e2, t3, i2);
      l3 && (n = l3.width, a = l3.height), "esriGeometryPolyline" === i2 && (n = u3), n = null != n && isFinite(n) ? Math.min(n, m2) : c3, a = null != a && isFinite(a) ? Math.max(Math.min(a, m2), f) : c3;
    }
  return "legend" === t3.style && "esriGeometryPolyline" === i2 && (n = u3), { width: n, height: a };
}
async function y(e2, t3, n) {
  const { feature: a, fieldMap: r3, viewParams: o } = t3.cimOptions || t3, c4 = await le.resolveSymbolOverrides(e2.data, a, null, r3, n, null, o);
  if (!c4)
    return null;
  (e2 = e2.clone()).data = { type: "CIMSymbolReference", symbol: c4 }, e2.data.primitiveOverrides = void 0;
  const m3 = [];
  return ne.fetchResources(c4, s2.resourceManager, m3), ne.fetchFonts(c4, s2.resourceManager, m3), m3.length > 0 && await Promise.all(m3), ne.getEnvelope(c4, null, s2.resourceManager);
}
async function p2(e2, i2 = {}) {
  var _a;
  const { node: l2, opacity: n, symbolConfig: r3 } = i2, c4 = null != r3 && "object" == typeof r3 && "isSquareFill" in r3 && r3.isSquareFill, m3 = i2.cimOptions || i2, u4 = m3.geometryType || O((_a = e2 == null ? void 0 : e2.data) == null ? void 0 : _a.symbol), f2 = await h(e2, i2, u4), { feature: y2, fieldMap: p3 } = m3, d = c4 || "esriGeometryPolygon" !== u4 ? "preview" : "legend", g = await s2.rasterizeCIMSymbolAsync(e2, y2, f2, d, p3, u4, null, m3.viewParams, m3.allowScalingUp);
  if (!g)
    return null;
  const { width: w, height: b2 } = g, M2 = document.createElement("canvas");
  M2.width = w, M2.height = b2;
  M2.getContext("2d").putImageData(g, 0, 0);
  const v = u(f2.width), j3 = u(f2.height), S = new Image(v, j3);
  S.src = M2.toDataURL(), S.ariaLabel = i2.ariaLabel ?? null, S.alt = i2.ariaLabel ?? "", null != n && (S.style.opacity = `${n}`);
  let C2 = S;
  if (null != i2.effectView) {
    const e3 = { shape: { type: "image", x: 0, y: 0, width: v, height: j3, src: S.src }, fill: null, stroke: null, offset: [0, 0] };
    C2 = l([[e3]], [v, j3], { effectView: i2.effectView, ariaLabel: i2.ariaLabel });
  }
  return l2 && C2 && l2.appendChild(C2), C2;
}
export {
  p2 as previewCIMSymbol
};
//# sourceMappingURL=previewCIMSymbol-XPIM2QJF.js.map
