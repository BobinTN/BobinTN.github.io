import {
  h as h4,
  k as k2,
  r as r3
} from "./chunk-JWWTIFGY.js";
import "./chunk-DMXA3RSU.js";
import {
  X,
  Y,
  b as b4
} from "./chunk-IIRYA6V3.js";
import {
  v
} from "./chunk-WSCMFOAM.js";
import {
  o as o2
} from "./chunk-C4Z4KYO2.js";
import {
  I,
  a as a2,
  r as r2,
  u as u2
} from "./chunk-3BAHO36Z.js";
import {
  S
} from "./chunk-NI23WAWZ.js";
import {
  t as t5
} from "./chunk-ODGAHKYT.js";
import {
  n as n2,
  s as s6
} from "./chunk-TJGMKUCX.js";
import "./chunk-UMP4LYVN.js";
import "./chunk-TREPTI6V.js";
import "./chunk-Z26DT4RT.js";
import "./chunk-BUMLJETN.js";
import "./chunk-OPV4AZKI.js";
import "./chunk-CU4AT6XH.js";
import {
  c as c4
} from "./chunk-XFC7DZXI.js";
import "./chunk-7SYCRLSC.js";
import "./chunk-UIBKJIZ5.js";
import "./chunk-PPQAHSM4.js";
import "./chunk-RCLKRKWR.js";
import {
  c as c3,
  d as d4
} from "./chunk-MKRPXDII.js";
import "./chunk-S6CVQWN7.js";
import {
  b as b3,
  h as h2
} from "./chunk-JWPJ4Y6I.js";
import {
  r
} from "./chunk-OYPRFNII.js";
import {
  W
} from "./chunk-7KUR2TMU.js";
import "./chunk-3ON6HO7Q.js";
import "./chunk-KMTPMPRR.js";
import "./chunk-K4NVR6KM.js";
import {
  j as j4,
  x
} from "./chunk-57KRYRCY.js";
import {
  It,
  K,
  L,
  M as M2,
  N,
  at,
  ht,
  it,
  st,
  tt,
  yt
} from "./chunk-747B2TEO.js";
import "./chunk-4NEWABLH.js";
import {
  e as e2,
  t as t3
} from "./chunk-FW2Y26A2.js";
import {
  t as t4
} from "./chunk-5WG7GACT.js";
import "./chunk-AZHRWST4.js";
import "./chunk-PFFV4MXI.js";
import "./chunk-NYTJIWNN.js";
import {
  m
} from "./chunk-7Y57Y6IH.js";
import "./chunk-WND35VNG.js";
import "./chunk-GXVWD6F2.js";
import "./chunk-W4QVNWBV.js";
import {
  d as d5
} from "./chunk-ZEQ5M7ZZ.js";
import {
  i as i4
} from "./chunk-ZBT4RUU7.js";
import {
  _
} from "./chunk-2FFBPEOX.js";
import {
  h as h3
} from "./chunk-XHP7ONEC.js";
import "./chunk-X2Y3P2BF.js";
import "./chunk-GJ4KNHRS.js";
import {
  h
} from "./chunk-XUD6H4VO.js";
import {
  j as j5
} from "./chunk-CQMEHG4P.js";
import "./chunk-GZTU5O23.js";
import "./chunk-LOGPPZUD.js";
import "./chunk-HYU6N3H3.js";
import "./chunk-EC5POYCL.js";
import "./chunk-X5VYGREB.js";
import {
  a,
  p as p2,
  s as s5
} from "./chunk-SEKLTVY5.js";
import "./chunk-S6MJEC4A.js";
import {
  b as b2
} from "./chunk-45OAWGCA.js";
import "./chunk-R4LYFMZX.js";
import "./chunk-X2TA76Q5.js";
import "./chunk-XN6LAULS.js";
import {
  Z
} from "./chunk-M7OEQQRX.js";
import "./chunk-CSWPLQ7Q.js";
import "./chunk-KWSMYM7P.js";
import "./chunk-RP5SAUAF.js";
import "./chunk-6BFXMZEZ.js";
import "./chunk-AMSVADDY.js";
import "./chunk-GAJBN4TM.js";
import {
  c as c5
} from "./chunk-6ABSX3YY.js";
import "./chunk-24NOAXOQ.js";
import "./chunk-2AXFVQBN.js";
import {
  c as c2
} from "./chunk-WOGT6UK2.js";
import "./chunk-RHT6WWRD.js";
import "./chunk-EUGXS5RE.js";
import {
  i as i3
} from "./chunk-IRNKV32L.js";
import "./chunk-HLM2UN42.js";
import "./chunk-5WWPLX36.js";
import "./chunk-UNONG753.js";
import "./chunk-OFRZSMZB.js";
import "./chunk-IATM3RCE.js";
import "./chunk-BEALJUHO.js";
import "./chunk-GRHSIT57.js";
import "./chunk-PJQIAD5D.js";
import "./chunk-Z6KIMOUA.js";
import "./chunk-SZAJDZCO.js";
import "./chunk-M7R7REMB.js";
import "./chunk-ZZYUEH57.js";
import "./chunk-VTWXDFFD.js";
import "./chunk-IPCIO3PX.js";
import "./chunk-EIY2DYTV.js";
import "./chunk-WJ4LS3YG.js";
import "./chunk-F6MD5VOH.js";
import "./chunk-V2RPSCV3.js";
import {
  w as w2
} from "./chunk-AOJ6OCPK.js";
import "./chunk-LMT5JII2.js";
import "./chunk-A43TI6AT.js";
import "./chunk-BHJVWW2P.js";
import "./chunk-4HKQSEUR.js";
import "./chunk-V3U4F2NL.js";
import "./chunk-ZB6PGKG5.js";
import {
  j as j3
} from "./chunk-OIIDE5GZ.js";
import "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import {
  i as i2
} from "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import {
  d as d2,
  p,
  w
} from "./chunk-TBSVVR6M.js";
import "./chunk-6TJWLWLO.js";
import "./chunk-H7BKONNV.js";
import "./chunk-K6C6RVSV.js";
import {
  i
} from "./chunk-KBJ5Z4R2.js";
import "./chunk-JUZJCTW2.js";
import {
  o
} from "./chunk-423VNHLR.js";
import "./chunk-FN47E7YK.js";
import "./chunk-XZS3Q5K4.js";
import "./chunk-XXFXRXFH.js";
import "./chunk-CCXEAKIM.js";
import {
  M
} from "./chunk-Y5D433JZ.js";
import "./chunk-QNOCEWCR.js";
import "./chunk-WURET5CW.js";
import {
  f as f2
} from "./chunk-QWPLZ3QH.js";
import {
  G,
  d2 as d3,
  s as s4
} from "./chunk-HLGIRLYQ.js";
import "./chunk-N2K4VRZH.js";
import "./chunk-WL4VPODY.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import {
  j as j2
} from "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import {
  g,
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  A,
  C,
  b,
  d,
  f,
  j,
  s as s3,
  t as t2,
  u
} from "./chunk-RFPH3ZTZ.js";
import {
  n
} from "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import {
  has,
  k,
  t
} from "./chunk-4V6374PV.js";
import "./chunk-A34O4XB5.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/2d/layers/features/processors.js
function o3(o7) {
  return "heatmap" === o7 ? import("./HeatmapProcessor-L45BVAK4.js") : import("./SymbolProcessor-Q7KAUIEI.js");
}

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBFHeader.js
var n3 = 268435455;
var o4 = class {
  constructor() {
    this.hasFeatures = false, this.exceededTransferLimit = false, this.fieldCount = 0, this.featureCount = 0, this.objectIdFieldIndex = 0, this.vertexCount = 0, this.offsets = { attributes: new Array(), geometry: new Array() }, this.centroid = new Array();
  }
};
function a3(a6, i7, c10 = false) {
  var _a;
  const f6 = 1, d8 = 3, u6 = 9, g4 = 12, l4 = 13, p7 = 15, h8 = a6.asUnsafe(), b5 = h8.pos(), w5 = new o4();
  let m6 = 0, y5 = 0;
  const k4 = 1, x4 = 2, I4 = 4, L4 = 3;
  let A4 = null, F3 = null, C3 = null, S6 = false;
  const j7 = [];
  for (; h8.next(); )
    switch (h8.tag()) {
      case f6:
        A4 = h8.getString();
        break;
      case d8:
        F3 = h8.getString();
        break;
      case g4:
        C3 = h8.processMessage(h2);
        break;
      case u6:
        if (w5.exceededTransferLimit = h8.getBool(), w5.exceededTransferLimit) {
          w5.offsets.geometry = c10 ? new Float64Array(8e3) : new Int32Array(8e3), w5.centroid = c10 ? new Float64Array(16e3) : new Int32Array(16e3);
          for (let e3 = 0; e3 < w5.centroid.length; e3++)
            w5.centroid[e3] = n3;
        }
        break;
      case l4: {
        const e3 = h8.processMessage(b3);
        e3.index = m6++, j7.push(e3);
        break;
      }
      case p7: {
        const e3 = h8.getLength(), t7 = h8.pos() + e3;
        if (!w5.exceededTransferLimit) {
          const e4 = w5.offsets.geometry, t8 = w5.centroid;
          e4.push(0), t8.push(n3), t8.push(n3);
        }
        !S6 && w5.exceededTransferLimit && (S6 = true, w5.offsets.attributes = c10 ? new Float64Array(8e3 * m6) : new Uint32Array(8e3 * m6));
        let s11 = y5 * m6;
        for (; h8.pos() < t7 && h8.next(); )
          switch (h8.tag()) {
            case k4: {
              if (S6)
                w5.offsets.attributes[s11++] = h8.pos();
              else {
                w5.offsets.attributes.push(h8.pos());
              }
              const e4 = h8.getLength();
              h8.skipLen(e4);
              break;
            }
            case x4:
              if (i7) {
                const e4 = h8.getLength(), t8 = h8.pos() + e4;
                for (; h8.pos() < t8 && h8.next(); )
                  switch (h8.tag()) {
                    case L4: {
                      h8.getUInt32();
                      const e5 = h8.getSInt64(), t9 = h8.getSInt64();
                      w5.centroid[2 * y5] = e5, w5.centroid[2 * y5 + 1] = t9;
                      break;
                    }
                    default:
                      h8.skip();
                  }
              } else {
                w5.offsets.geometry[y5] = h8.pos();
                const e4 = h8.getLength();
                w5.vertexCount += e4, h8.skipLen(e4);
              }
              break;
            case I4: {
              const e4 = h8.getLength(), t8 = h8.pos() + e4;
              for (; h8.pos() < t8 && h8.next(); )
                switch (h8.tag()) {
                  case L4: {
                    h8.getUInt32();
                    const e5 = h8.getSInt64(), t9 = h8.getSInt64();
                    w5.centroid[2 * y5] = e5, w5.centroid[2 * y5 + 1] = t9;
                    break;
                  }
                  default:
                    h8.skip();
                }
              break;
            }
            default:
              h8.skip();
          }
        y5++, w5.hasFeatures = true;
        break;
      }
      default:
        h8.skip();
    }
  const U2 = A4 || F3;
  if (!U2)
    throw new s2("FeatureSet has no objectId or globalId field name");
  return w5.fields = new Z(j7), w5.featureCount = y5, w5.fieldCount = m6, w5.objectIdFieldIndex = (_a = w5.fields.get(U2)) == null ? void 0 : _a.index, w5.transform = C3, w5.displayIds = new Uint32Array(w5.featureCount), w5.groupIds = new Uint16Array(w5.featureCount), h8.move(b5), w5;
}

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBF.js
var u3 = true;
var c6 = 268435455;
var g2 = 128;
var l = 128e3;
var _2 = { small: { delta: new Int32Array(g2), decoded: new Int32Array(g2) }, large: { delta: new Int32Array(l), decoded: new Int32Array(l) } };
function f3(e3) {
  return e3 <= _2.small.delta.length ? _2.small : (e3 <= _2.large.delta.length || (_2.large.delta = new Int32Array(Math.round(1.25 * e3)), _2.large.decoded = new Int32Array(Math.round(1.25 * e3))), _2.large);
}
function y2(r5) {
  try {
    const e3 = 2, t7 = new r(new Uint8Array(r5), new DataView(r5));
    for (; t7.next(); ) {
      if (t7.tag() === e3)
        return I2(t7.getMessage());
      t7.skip();
    }
  } catch (i7) {
    const r6 = new s2("query:parsing-pbf", "Error while parsing FeatureSet PBF payload", { error: i7 });
    s.getLogger("esri.view.2d.layers.features.support.FeatureSetReaderPBF").error(r6);
  }
  return null;
}
function I2(e3) {
  const t7 = 1;
  for (; e3.next(); ) {
    if (e3.tag() === t7)
      return e3.getMessage();
    e3.skip();
  }
  return null;
}
function p3(e3) {
  const t7 = 1, r5 = 2, s11 = 3, i7 = 4, n5 = 5, a6 = 6, h8 = 7, o7 = 8, d8 = 9, u6 = e3.getLength(), c10 = e3.pos() + u6;
  for (; e3.pos() < c10 && e3.next(); )
    switch (e3.tag()) {
      case t7:
        return e3.getString();
      case r5:
        return e3.getFloat();
      case s11:
        return e3.getDouble();
      case i7:
        return e3.getSInt32();
      case n5:
        return e3.getUInt32();
      case a6:
        return e3.getInt64();
      case h8:
        return e3.getUInt64();
      case o7:
        return e3.getSInt64();
      case d8:
        return e3.getBool();
      default:
        return e3.skip(), null;
    }
  return null;
}
function m2(e3, t7, r5, s11, i7, n5) {
  return 0.5 * Math.abs(e3 * s11 + r5 * n5 + i7 * t7 - e3 * n5 - r5 * t7 - i7 * s11);
}
function x2(e3, t7, r5, s11) {
  return 0 === e3 * s11 - r5 * t7 && e3 * r5 + t7 * s11 > 0;
}
var S2 = class _S extends S {
  static fromBuffer(e3, t7, r5 = false) {
    const s11 = t7.geometryType, i7 = y2(e3), n5 = a3(i7, "esriGeometryPoint" === s11, r5), a6 = S.createInstance();
    return new _S(a6, i7, n5, t7);
  }
  constructor(e3, t7, r5, s11) {
    super(e3, s11), this._hasNext = false, this._isPoints = false, this._featureIndex = -1, this._featureOffset = 0, this._cache = { area: 0, unquantGeometry: void 0, geometry: void 0, centroid: void 0, legacyFeature: void 0, optFeature: void 0 }, this._geometryType = s11.geometryType, this._reader = t7, this._header = r5, this._hasNext = r5.hasFeatures, this._isPoints = "esriGeometryPoint" === s11.geometryType;
  }
  get fields() {
    return this._header.fields;
  }
  get geometryType() {
    return this._geometryType;
  }
  get _size() {
    return this._header.featureCount;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  get stride() {
    return 2 + (this.hasZ ? 1 : 0) + (this.hasM ? 1 : 0);
  }
  get hasFeatures() {
    return this._header.hasFeatures;
  }
  get hasNext() {
    return this._hasNext;
  }
  get exceededTransferLimit() {
    return this._header.exceededTransferLimit;
  }
  getSize() {
    return this._size;
  }
  getQuantizationTransform() {
    return this._header.transform;
  }
  getCursor() {
    return this.copy();
  }
  getIndex() {
    return this._featureIndex;
  }
  setIndex(e3) {
    this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0, this._cache.centroid = void 0, this._cache.legacyFeature = void 0, this._cache.optFeature = void 0, this._featureIndex = e3;
  }
  getAttributeHash() {
    let e3 = "";
    for (const t7 of this._header.fields.fields)
      e3 += this._readAttributeAtIndex(t7.index) + ".";
    return e3;
  }
  getObjectId() {
    return this._readAttributeAtIndex(this._header.objectIdFieldIndex);
  }
  getDisplayId() {
    return this._header.displayIds[this._featureIndex];
  }
  setDisplayId(e3) {
    this._header.displayIds[this._featureIndex] = e3;
  }
  getGroupId() {
    return this._header.groupIds[this._featureIndex];
  }
  setGroupId(e3) {
    this._header.groupIds[this._featureIndex] = e3;
  }
  readLegacyFeature() {
    if (void 0 === this._cache.legacyFeature) {
      const e3 = this.readCentroid(), t7 = { attributes: this.readAttributes(), geometry: this._isPoints ? this.readLegacyPointGeometry() : this.readLegacyGeometry(), centroid: (e3 && { x: e3.coords[0], y: e3.coords[1] }) ?? null };
      return this._cache.legacyFeature = t7, t7;
    }
    return this._cache.legacyFeature;
  }
  readOptimizedFeature() {
    if (void 0 === this._cache.optFeature) {
      const e3 = new t3(this.readGeometry(), this.readAttributes(), this.readCentroid());
      return e3.objectId = this.getObjectId(), e3.displayId = this.getDisplayId(), this._cache.optFeature = e3, e3;
    }
    return this._cache.optFeature;
  }
  getXHydrated() {
    const e3 = this._header.centroid[2 * this._featureIndex], t7 = this.getQuantizationTransform();
    return null == t7 ? e3 : e3 * t7.scale[0] + t7.translate[0];
  }
  getYHydrated() {
    const e3 = this._header.centroid[2 * this._featureIndex + 1], t7 = this.getQuantizationTransform();
    return null == t7 ? e3 : t7.translate[1] - e3 * t7.scale[1];
  }
  getX() {
    return this._header.centroid[2 * this._featureIndex] * this._sx + this._tx;
  }
  getY() {
    return this._header.centroid[2 * this._featureIndex + 1] * this._sy + this._ty;
  }
  readLegacyPointGeometry() {
    return { x: this.getX(), y: this.getY() };
  }
  readLegacyGeometry(e3) {
    const t7 = this.readUnquantizedGeometry(e3);
    return st(t7, this.geometryType, false, false);
  }
  readLegacyCentroid() {
    const e3 = this.readCentroid();
    if (!e3)
      return null;
    const [t7, r5] = e3.coords;
    return { x: t7, y: r5 };
  }
  readGeometryArea() {
    return this._cache.area || this.readGeometry(true), this._cache.area;
  }
  readUnquantizedGeometry(e3 = false) {
    if (void 0 === this._cache.unquantGeometry) {
      const t7 = this.readGeometry(e3);
      if (!t7)
        return this._cache.unquantGeometry = void 0, null;
      const r5 = f3(t7.coords.length).decoded, s11 = t7.clone(r5), i7 = s11.coords;
      let n5 = 0;
      for (const e4 of s11.lengths) {
        for (let t8 = 1; t8 < e4; t8++) {
          const e5 = 2 * (n5 + t8), r6 = 2 * (n5 + t8 - 1);
          i7[e5] += i7[r6], i7[e5 + 1] += i7[r6 + 1];
        }
        n5 += e4;
      }
      return this._cache.unquantGeometry = s11, s11;
    }
    return this._cache.unquantGeometry;
  }
  readHydratedGeometry() {
    if (this._isPoints) {
      if (this._header.centroid[2 * this._featureIndex] === c6)
        return null;
      const e4 = this.getXHydrated(), t8 = this.getYHydrated();
      return new t4([], [e4, t8]);
    }
    const e3 = this.readGeometry();
    if (!e3)
      return null;
    const t7 = e3.clone(), r5 = this.getQuantizationTransform();
    return null != r5 && It(t7, t7, this.hasZ, this.hasM, r5), t7;
  }
  readGeometry(e3 = false) {
    if (void 0 === this._cache.geometry) {
      let r5 = null;
      if (this._isPoints) {
        if (this._header.centroid[2 * this._featureIndex] === c6)
          return null;
        const e4 = this.getX(), t7 = this.getY();
        r5 = new t4([], [e4, t7]);
      } else {
        const s11 = this._header.offsets.geometry[this._featureIndex], i7 = this._reader;
        if (0 === s11) {
          const e4 = this._readServerCentroid();
          if (!e4)
            return null;
          const [t7, r6] = e4.coords;
          return this.createQuantizedExtrudedGeometry(t7, r6);
        }
        i7.move(s11);
        try {
          if (r5 = e3 ? this._parseGeometryForDisplay(i7) : this._parseGeometry(i7), !r5) {
            const e4 = this._readServerCentroid();
            if (!e4)
              return null;
            const [t7, r6] = e4.coords;
            return this.createQuantizedExtrudedGeometry(t7, r6);
          }
        } catch (t7) {
          return console.error("Failed to parse geometry!", t7), null;
        }
      }
      return this._cache.geometry = r5, r5;
    }
    return this._cache.geometry;
  }
  readCentroid() {
    if (void 0 === this._cache.centroid) {
      let e3;
      return e3 = this._computeCentroid(), e3 || (e3 = this._readServerCentroid()), this._cache.centroid = e3 ?? void 0, e3 ?? null;
    }
    return this._cache.centroid;
  }
  copy() {
    const e3 = this._reader.clone(), t7 = new _S(this.instance, e3, this._header, this.fullSchema());
    return this.copyInto(t7), t7;
  }
  next() {
    for (this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0, this._cache.centroid = void 0, this._cache.legacyFeature = void 0, this._cache.optFeature = void 0; ++this._featureIndex < this._size && !this._getExists(); )
      ;
    return this._featureIndex < this._size;
  }
  _readAttribute(e3, t7) {
    var _a;
    const r5 = this._header.fields.get(e3);
    if (null == r5)
      return;
    let s11 = this._readAttributeAtIndex(r5.index);
    "esriFieldTypeTimestampOffset" === ((_a = this.fields.get(e3)) == null ? void 0 : _a.type) && (s11 = this.parseTimestampOffset(s11));
    const i7 = this._header.fields.isDateField(r5.name);
    return t7 ? null == s11 ? s11 : i7 ? new Date(s11) : s11 : s11;
  }
  _readAttributes() {
    const e3 = {};
    for (const t7 of this._header.fields.fields)
      e3[t7.name] = this._readAttributeAtIndex(t7.index);
    return e3;
  }
  copyInto(e3) {
    super.copyInto(e3), e3._featureIndex = this._featureIndex, e3._featureOffset = this._featureOffset, e3._hasNext = this._hasNext;
  }
  _readAttributeAtIndex(e3) {
    const t7 = this._header.offsets.attributes[this._featureIndex * this._header.fieldCount + e3], r5 = this._reader;
    return r5.move(t7), p3(r5);
  }
  _readServerCentroid() {
    const e3 = this._header.centroid[2 * this._featureIndex] + this._tx, t7 = this._header.centroid[2 * this._featureIndex + 1] + this._ty;
    return e3 === c6 ? null : new t4([], [e3, t7]);
  }
  _parseGeometry(e3) {
    const t7 = 2, r5 = 3, s11 = e3.asUnsafe(), i7 = s11.getLength(), n5 = s11.pos() + i7, a6 = [], o7 = [];
    for (; s11.pos() < n5 && s11.next(); )
      switch (s11.tag()) {
        case t7: {
          const e4 = s11.getUInt32(), t8 = s11.pos() + e4;
          for (; s11.pos() < t8; )
            o7.push(s11.getUInt32());
          break;
        }
        case r5: {
          const e4 = s11.getUInt32(), t8 = s11.pos() + e4;
          for (a6.push(s11.getSInt32() + this._tx), a6.push(s11.getSInt32() + this._ty), this.hasZ && s11.getSInt32(), this.hasM && s11.getSInt32(); s11.pos() < t8; )
            a6.push(s11.getSInt32()), a6.push(s11.getSInt32()), this.hasZ && s11.getSInt32(), this.hasM && s11.getSInt32();
          break;
        }
        default:
          s11.skip();
      }
    return a6.length ? new t4(o7, a6) : null;
  }
  _parseGeometryForDisplay(e3) {
    const t7 = 2, s11 = 3, i7 = e3.asUnsafe(), n5 = i7.getLength(), a6 = i7.pos() + n5, o7 = [], d8 = [];
    let c10 = 0, g4 = 0, l4 = null, _4 = 0;
    const y5 = "esriGeometryPolygon" === this.geometryType;
    for (; i7.pos() < a6 && i7.next(); )
      switch (i7.tag()) {
        case t7: {
          const e4 = i7.getUInt32(), t8 = i7.pos() + e4;
          for (; i7.pos() < t8; ) {
            const e5 = i7.getUInt32();
            o7.push(e5), c10 += e5;
          }
          l4 = f3(2 * c10).delta;
          break;
        }
        case s11: {
          i7.getUInt32();
          const e4 = 2 + (this.hasZ ? 1 : 0) + (this.hasM ? 1 : 0);
          n(l4);
          for (const t8 of o7)
            if (g4 + e4 * t8 > l4.length)
              for (let e5 = 0; e5 < t8; e5++)
                i7.getSInt32(), i7.getSInt32(), this.hasZ && i7.getSInt32(), this.hasM && i7.getSInt32();
            else if (y5 && u3) {
              const e5 = this.getAreaSimplificationThreshold(t8, this._header.vertexCount);
              let r5 = 2, s12 = 1;
              const n6 = false;
              let a7 = i7.getSInt32(), h8 = i7.getSInt32();
              l4[g4++] = a7, l4[g4++] = h8, this.hasZ && i7.getSInt32(), this.hasM && i7.getSInt32();
              let o8 = i7.getSInt32(), u6 = i7.getSInt32();
              for (this.hasZ && i7.getSInt32(), this.hasM && i7.getSInt32(); r5 < t8; ) {
                let t9 = i7.getSInt32(), n7 = i7.getSInt32();
                this.hasZ && i7.getSInt32(), this.hasM && i7.getSInt32();
                const d9 = a7 + o8, c11 = h8 + u6;
                m2(a7, h8, d9, c11, d9 + t9, c11 + n7) >= e5 ? (_4 += -0.5 * (d9 - a7) * (c11 + h8), s12 > 1 && x2(l4[g4 - 2], l4[g4 - 1], o8, u6) ? (l4[g4 - 2] += o8, l4[g4 - 1] += u6) : (l4[g4++] = o8, l4[g4++] = u6, s12++), a7 = d9, h8 = c11) : (t9 += o8, n7 += u6), o8 = t9, u6 = n7, r5++;
              }
              s12 < 3 || n6 ? g4 -= 2 * s12 : (_4 += -0.5 * (a7 + o8 - a7) * (h8 + u6 + h8), x2(l4[g4 - 2], l4[g4 - 1], o8, u6) ? (l4[g4 - 2] += o8, l4[g4 - 1] += u6, d8.push(s12)) : (l4[g4++] = o8, l4[g4++] = u6, d8.push(++s12)));
            } else {
              let e5 = 0, r5 = i7.getSInt32(), s12 = i7.getSInt32();
              this.hasZ && i7.getSInt32(), this.hasM && i7.getSInt32(), l4[g4++] = r5, l4[g4++] = s12, e5 += 1;
              for (let n6 = 1; n6 < t8; n6++) {
                const t9 = i7.getSInt32(), a7 = i7.getSInt32(), h8 = r5 + t9, o8 = s12 + a7;
                _4 += -0.5 * (h8 - r5) * (o8 + s12), this.hasZ && i7.getSInt32(), this.hasM && i7.getSInt32(), n6 > 2 && x2(l4[g4 - 2], l4[g4 - 1], t9, a7) ? (l4[g4 - 2] += t9, l4[g4 - 1] += a7) : (l4[g4++] = t9, l4[g4++] = a7, e5 += 1), r5 = h8, s12 = o8;
              }
              d8.push(e5);
            }
          break;
        }
        default:
          i7.skip();
      }
    if (this._cache.area = _4, !d8.length)
      return null;
    if (this._tx || this._ty) {
      let e4 = 0;
      n(l4);
      for (const t8 of d8)
        l4[2 * e4] += this._tx, l4[2 * e4 + 1] += this._ty, e4 += t8;
    }
    return new t4(d8, l4);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/controllers/support/sourceAdapters.js
var m3 = class {
  constructor(e3) {
    this.service = e3, this._arcadeLayerSchema = { ...e3, fieldsIndex: Z.fromJSON(e3.fieldsIndex) };
  }
  destroy() {
  }
};
function p4(e3) {
  return Array.isArray(e3.source);
}
function l2(e3) {
  return "ogc-source" === (e3 == null ? void 0 : e3.type);
}
function y3(e3) {
  const { capabilities: t7 } = e3;
  return l2(e3.source) ? new F(e3) : p4(e3) ? new h5(e3) : t7.query.supportsFormatPBF && has("featurelayer-pbf") ? new d6(e3) : new S3(e3);
}
async function f4(t7) {
  const r5 = new c5();
  return await r5.open(t7, {}), r5;
}
var h5 = class extends m3 {
  constructor(e3) {
    super(e3), this._portsOpen = f4(e3.source).then((e4) => this.client = e4);
  }
  destroy() {
    this.client.close(), this.client = null;
  }
  async executeQuery(e3, t7) {
    await this._portsOpen;
    const r5 = await this.client.invoke("queryFeatures", e3.toJSON(), t7);
    return h4.fromFeatureSet(r5, this._arcadeLayerSchema);
  }
};
var d6 = class extends m3 {
  async executeQuery(e3, t7) {
    const { data: r5 } = await d4(this.service.source, e3, t7), a6 = !e3.quantizationParameters;
    return S2.fromBuffer(r5, this._arcadeLayerSchema, a6);
  }
};
var S3 = class extends m3 {
  async executeQuery(e3, s11) {
    var _a;
    const { source: i7, capabilities: o7, spatialReference: u6, objectIdField: m6, geometryType: p7 } = this.service;
    if (null != e3.quantizationParameters && !o7.query.supportsQuantization) {
      const o8 = e3.clone(), p8 = m(o8.quantizationParameters);
      o8.quantizationParameters = null;
      const { data: l5 } = await c3(i7, o8, u6, s11), y5 = it(l5, m6);
      return at(p8, y5), h4.fromOptimizedFeatureSet(y5, this._arcadeLayerSchema);
    }
    const { data: l4 } = await c3(i7, e3, this.service.spatialReference, s11);
    return "esriGeometryPoint" === p7 && (l4.features = (_a = l4.features) == null ? void 0 : _a.filter((e4) => {
      if (null != e4.geometry) {
        const t7 = e4.geometry;
        return Number.isFinite(t7.x) && Number.isFinite(t7.y);
      }
      return true;
    })), h4.fromFeatureSet(l4, this._arcadeLayerSchema);
  }
};
var F = class extends m3 {
  async executeQuery(e3, r5) {
    const { capabilities: i7 } = this.service;
    if (e3.quantizationParameters && !i7.query.supportsQuantization) {
      const i8 = e3.clone(), o8 = m(i8.quantizationParameters);
      i8.quantizationParameters = null;
      const n5 = await v(this.service.source, e3, r5);
      return at(o8, n5), h4.fromOptimizedFeatureSet(n5, this._arcadeLayerSchema);
    }
    const o7 = await v(this.service.source, e3, r5);
    return h4.fromOptimizedFeatureSet(o7, this._arcadeLayerSchema);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/UpdateToken.js
var t6 = class _t {
  constructor() {
    this.version = 0, this.source = false, this.targets = { feature: false, aggregate: false }, this.storage = { filters: false, data: false }, this.mesh = false, this.queryFilter = false, this.why = { mesh: [], source: [] };
  }
  static create(e3) {
    const s11 = new _t();
    let r5;
    for (r5 in e3) {
      const t7 = e3[r5];
      if ("object" == typeof t7)
        for (const e4 in t7) {
          const a6 = e4, i7 = t7[a6];
          s11[r5][a6] = i7;
        }
      s11[r5] = t7;
    }
    return s11;
  }
  static empty() {
    return _t.create({});
  }
  static all() {
    return _t.create({ source: true, targets: { feature: true, aggregate: true }, storage: { filters: true, data: true }, mesh: true });
  }
  unset(t7) {
    this.version = t7.version, t7.source && (this.source = false), t7.targets.feature && (this.targets.feature = false), t7.targets.aggregate && (this.targets.aggregate = false), t7.storage.filters && (this.storage.filters = false), t7.storage.data && (this.storage.data = false), t7.mesh && (this.mesh = false), t7.queryFilter && (this.queryFilter = false);
  }
  any() {
    return this.source || this.mesh || this.storage.filters || this.storage.data || this.targets.feature || this.targets.aggregate || this.queryFilter;
  }
  describe() {
    let t7 = 0, e3 = "";
    if (this.mesh) {
      t7 += 20, e3 += "-> (20) Mesh needs update\n";
      for (const t8 of this.why.mesh)
        e3 += `    + ${t8}
`;
    }
    if (this.source) {
      t7 += 10, e3 += "-> (10) The source needs update\n";
      for (const t8 of this.why.source)
        e3 += `    + ${t8}
`;
    }
    this.targets.feature && (t7 += 5, e3 += "-> (5) Feature target parameters changed\n"), this.storage.filters && (t7 += 5, e3 += "-> (5) Feature filter parameters changed\n"), this.targets.aggregate && (t7 += 4, e3 += "-> (4) Aggregate target parameters changed\n"), this.storage.data && (t7 += 1, e3 += "-> (1) Texture storage parameters changed");
    const s11 = t7 < 5 ? "Fastest" : t7 < 10 ? "Fast" : t7 < 15 ? "Moderate" : t7 < 20 ? "Slow" : "Very Slow";
    console.debug(`Applying ${s11} update of cost ${t7}/45 `), console.debug(e3);
  }
  toJSON() {
    return { queryFilter: this.queryFilter, source: this.source, targets: this.targets, storage: this.storage, mesh: this.mesh };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/DataTileSubscription.js
var a4 = class {
  constructor(e3, i7) {
    this.requests = { done: new Array(), stream: new t5(10) }, this._edits = null, this._abortController = new AbortController(), this._version = 0, this._isDone = false, this.didSend = false, this.tile = e3, this._version = i7, this._resolver = C(), this._resolver.promise.catch((e4) => f(e4));
  }
  get signal() {
    return this._abortController.signal;
  }
  get options() {
    return { signal: this._abortController.signal };
  }
  get empty() {
    return !this.requests.done.length && null == this.edits;
  }
  get edits() {
    return this._edits;
  }
  get done() {
    return this._resolver.promise;
  }
  get isDone() {
    return this._isDone;
  }
  resolve() {
    this._isDone = true, this._resolver.resolve();
  }
  clear() {
    this.requests.done = [];
  }
  applyUpdate(e3) {
    this.requests.done.forEach((s11) => s11.message.status.unset(e3)), this._version = e3.version, null != this._edits && this._edits.status.unset(e3);
  }
  add(e3) {
    e3.message.status = e3.message.status ?? t6.empty(), e3.message.status.version = this._version, has("esri-2d-update-debug") && console.debug(this.tile.id, "DataTileSubscription:add", this._version), e3.message.end && (this.requests.done.forEach((e4) => {
      null != e4.message && e4.message.end && (e4.message.end = false);
    }), this._resolver.resolve(), this._isDone = true), this.requests.done.push(e3);
  }
  edit(s11, t7) {
    const r5 = s11.getQuantizationTransform(), i7 = s11.fullSchema(), a6 = Array.from(s11.features()).filter(k), n5 = [...t7, ...a6.map((e3) => e3.objectId)];
    if (this.removeIds(n5), this._invalidate(), null == this._edits)
      return void (this._edits = { type: "append", addOrUpdate: h4.fromOptimizedFeatures(a6, i7, r5), id: this.tile.id, status: t6.empty(), end: true });
    this.requests.done.forEach((e3) => e3.message.end = false);
    this._edits.addOrUpdate.append(s11.features());
  }
  *readers() {
    var _a2;
    for (const { message: e3 } of this.requests.done)
      null != e3.addOrUpdate && (yield e3.addOrUpdate);
    null != ((_a2 = this._edits) == null ? void 0 : _a2.addOrUpdate) && (yield this._edits.addOrUpdate);
  }
  _invalidate() {
    for (const e3 of this.requests.done)
      e3.message.status = t6.empty();
    null != this._edits && (this._edits.status = t6.empty());
  }
  removeIds(e3) {
    var _a2;
    this._invalidate();
    for (const { message: s11 } of this.requests.done) {
      const t7 = s11.addOrUpdate;
      null != t7 && (t7.removeIds(e3), t7.isEmpty && (has("esri-2d-update-debug") && console.debug("Removing FeatureSetReader"), s11.addOrUpdate = null));
    }
    null != ((_a2 = this._edits) == null ? void 0 : _a2.addOrUpdate) && this._edits.addOrUpdate.removeIds(e3), this.requests.done = this.requests.done.filter((e4) => e4.message.addOrUpdate || e4.message.end);
  }
  abort() {
    this._abortController.abort(), this._resolver.reject(u());
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/DataTileSource.js
function p5(e3, s11) {
  const t7 = /* @__PURE__ */ new Set();
  return e3 && e3.forEach((e4) => t7.add(e4)), s11 && s11.forEach((e4) => t7.add(e4)), t7.has("*") ? ["*"] : Array.from(t7);
}
var m4 = class {
  constructor(e3) {
    this.updatingHandles = new h(), this.events = new o(), this._resolver = C(), this._didEdit = false, this._subscriptions = /* @__PURE__ */ new Map(), this._outSR = e3.outSR, this._serviceInfo = e3.serviceInfo, this._onTileUpdateMessage = e3.onMessage, this._arcadeLayerSchema = e3.arcadeLayerSchema;
  }
  destroy() {
    for (const e3 of this._subscriptions.values())
      e3.abort();
    this.updatingHandles.destroy();
  }
  get subscriptions() {
    return this._subscriptions.values();
  }
  async _onMessage(e3) {
    const s11 = this._subscriptions.get(e3.id);
    if (!s11)
      return;
    const t7 = { ...e3, remove: e3.remove ?? [], status: e3.status ?? t6.empty() };
    return d(this._onTileUpdateMessage(t7, s11.options));
  }
  update(s11, t7) {
    var _a;
    const i7 = t7.fields.length;
    t7.outFields = p5((_a = this._schema) == null ? void 0 : _a.outFields, t7.outFields), t7.outFields = t7.outFields.length >= 0.75 * i7 ? ["*"] : t7.outFields, t7.outFields.sort();
    const r5 = a(this._schema, t7);
    if (!r5)
      return;
    has("esri-2d-update-debug") && console.debug("Applying Update - Source:", r5);
    const a6 = "orderByFields" in this._serviceInfo && this._serviceInfo.orderByFields ? this._serviceInfo.orderByFields : this._serviceInfo.objectIdField + " ASC", d8 = this._serviceInfo.source, h8 = { returnCentroid: !(null !== d8 && "object" == typeof d8 && "path" in d8 && w2(d8.path)) && "esriGeometryPolygon" === this._serviceInfo.geometryType, returnGeometry: true, timeReferenceUnknownClient: "stream" !== this._serviceInfo.type && this._serviceInfo.timeReferenceUnknownClient, outFields: t7.outFields, outSpatialReference: this._outSR, orderByFields: [a6], where: t7.definitionExpression || "1=1", gdbVersion: t7.gdbVersion, historicMoment: t7.historicMoment, timeExtent: t7.timeExtent ? c2.fromJSON(t7.timeExtent) : null }, l4 = this._schema && s5(r5, "outFields");
    this._schema && p2(r5, ["timeExtent", "definitionExpression", "gdbVersion", "historicMoment", "customParameters"]) && (s11.why.mesh.push("Layer filter and/or custom parameters changed"), s11.why.source.push("Layer filter and/or custom parameters changed"), s11.mesh = true, s11.source = true, s11.queryFilter = true), l4 && (s11.why.source.push("Layer required fields changed"), s11.source = true), a(h8, this._queryInfo) && (this._queryInfo = h8), this._schema = t7, this._resolver.resolve();
  }
  whenInitialized() {
    return this._resolver.promise;
  }
  async applyUpdate(e3) {
    if (e3.queryFilter || e3.source && this._didEdit)
      return this.refresh(e3.version), void (this._didEdit = false);
    this._subscriptions.forEach((s11) => s11.applyUpdate(e3)), await this.resend();
  }
  refresh(e3, s11) {
    for (const t7 of this._tiles())
      this.unsubscribe(t7), this.subscribe(t7, e3);
  }
  subscribe(e3, s11) {
    const t7 = new a4(e3, s11);
    return this._subscriptions.set(e3.id, t7), t7;
  }
  unsubscribe(e3) {
    const s11 = this.getSubscription(e3.id);
    null != s11 && s11.abort(), this._subscriptions.delete(e3.id);
  }
  createQuery(e3 = {}) {
    const s11 = this._queryInfo.historicMoment ? new Date(this._queryInfo.historicMoment) : null;
    return new b2({ ...this._queryInfo, historicMoment: s11, ...e3 });
  }
  getSubscription(e3) {
    return this._subscriptions.has(e3) ? this._subscriptions.get(e3) : null;
  }
  async queryLastEditDate() {
    throw new Error("Service does not support query type");
  }
  async query(e3, s11) {
    throw new Error("Service does not support query");
  }
  *_tiles() {
    const e3 = Array.from(this._subscriptions.values());
    for (const s11 of e3)
      yield s11.tile;
  }
  async edit(e3, s11) {
    return this.updatingHandles.addPromise(this._edit(e3, s11));
  }
  async _edit(e3, s11) {
    const t7 = Array.from(this._subscriptions.values()), i7 = t7.map(({ tile: e4 }) => e4);
    for (const r5 of t7)
      r5.removeIds(s11);
    if (e3.length) {
      const t8 = i7.map((s12) => {
        const t9 = this.createTileQuery(s12);
        return t9.objectIds = e3, { tile: s12, query: t9 };
      }).map(async ({ tile: e4, query: s12 }) => ({ tile: e4, result: await this.query(s12, { query: { tile: has("esri-tiles-debug") ? e4.id.replaceAll("/", ".") : void 0 } }), query: s12 })), o7 = (await j(t8)).map(async ({ tile: t9, result: i8 }) => {
        if (!i8.hasFeatures && !s11.length && !e3.length)
          return;
        const r5 = this._subscriptions.get(t9.key.id);
        r5 && r5.edit(i8, e3);
      });
      await Promise.allSettled(o7);
    }
    this._didEdit = true;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/BaseFeatureSource.js
var u4 = 4;
var c7 = class extends m4 {
  constructor(e3) {
    super(e3), this.type = "feature", this.mode = "on-demand", this._adapter = y3(e3.serviceInfo), this._queue = new _({ concurrency: 8, process: async (e4) => {
      var _a, _b;
      if (s3(e4), null != e4.tile) {
        const t7 = e4.tile.key.id, { signal: r5 } = e4, s11 = has("esri-tiles-debug") ? { tile: t7.replaceAll("/", "."), depth: e4.depth } : void 0, i7 = await this._adapter.executeQuery(e4.query, { signal: r5, query: { ...s11, ...(_a = this._schema) == null ? void 0 : _a.customParameters } });
        return i7.level = e4.tile.key.level, i7;
      }
      return this._adapter.executeQuery(e4.query, { ...e4, query: (_b = this._schema) == null ? void 0 : _b.customParameters });
    } }), this._patchQueue = new _({ concurrency: 8, process: async (e4) => {
      var _a, _b;
      if (s3(e4), null != e4.tile) {
        const t7 = e4.tile.key.id, { signal: r5 } = e4, s11 = has("esri-tiles-debug") ? { tile: t7.replaceAll("/", "."), depth: e4.depth } : void 0, i7 = await this._adapter.executeQuery(e4.query, { signal: r5, query: { ...s11, ...(_a = this._schema) == null ? void 0 : _a.customParameters } });
        return i7.level = e4.tile.key.level, i7;
      }
      return this._adapter.executeQuery(e4.query, { ...e4, query: (_b = this._schema) == null ? void 0 : _b.customParameters });
    } });
  }
  destroy() {
    super.destroy(), this._adapter.destroy(), this._queue.destroy(), this._patchQueue.destroy();
  }
  enqueueQuery(e3, t7) {
    return this.updatingHandles.addPromise(this._queue.push(e3, t7));
  }
  enqueuePatchQuery(e3, t7) {
    return this.updatingHandles.addPromise(this._patchQueue.push(e3, t7));
  }
  get maxRecordCountFactor() {
    const { query: e3 } = this._serviceInfo.capabilities;
    return e3.supportsMaxRecordCountFactor ? u4 : null;
  }
  get maxPageSize() {
    const { query: e3 } = this._serviceInfo.capabilities;
    return (e3.maxRecordCount ?? 8e3) * (this.maxRecordCountFactor ?? 1);
  }
  get pageSize() {
    return Math.min(8e3, this.maxPageSize);
  }
  enableEvent(e3, t7) {
  }
  subscribe(e3, s11) {
    const a6 = super.subscribe(e3, s11);
    return this._fetchDataTile(e3).catch((s12) => {
      b(s12) || s.getLogger("esri.views.2d.layers.features.sources.BaseFeatureSource").error(new s2("mapview-query-error", "Encountered error when fetching tile", { tile: e3, error: s12 }));
    }), a6;
  }
  unsubscribe(e3) {
    super.unsubscribe(e3);
  }
  readers(e3) {
    return this._subscriptions.get(e3).readers();
  }
  async query(e3, t7 = {}) {
    var _a;
    const r5 = t7.query ?? {};
    return this._adapter.executeQuery(e3, { ...t7, query: { ...r5, ...(_a = this._schema) == null ? void 0 : _a.customParameters } });
  }
  async queryLastEditDate() {
    const t7 = this._serviceInfo.source, r5 = { ...t7.query, f: "json" };
    return (await j2(t7.path, { query: r5, responseType: "json" })).data.editingInfo.lastEditDate;
  }
  createTileQuery(e3, t7 = {}) {
    const r5 = this._serviceInfo.geometryType, s11 = this.createQuery(t7);
    s11.quantizationParameters = t7.quantizationParameters ?? e3.getQuantizationParameters(), s11.resultType = "tile", s11.geometry = e3.extent, this._serviceInfo.capabilities.query.supportsQuantization ? "esriGeometryPolyline" === r5 && (s11.maxAllowableOffset = e3.resolution * has("feature-polyline-generalization-factor")) : "esriGeometryPolyline" !== r5 && "esriGeometryPolygon" !== r5 || (s11.maxAllowableOffset = e3.resolution, "esriGeometryPolyline" === r5 && (s11.maxAllowableOffset *= has("feature-polyline-generalization-factor")));
    const i7 = this._serviceInfo.capabilities.query;
    return s11.defaultSpatialReferenceEnabled = i7.supportsDefaultSpatialReference, s11.compactGeometryEnabled = i7.supportsCompactGeometry, s11;
  }
  async _executePatchQuery(e3, t7, r5, s11) {
    const i7 = t7.clone();
    i7.outFields = [this._serviceInfo.objectIdField, ...r5], i7.returnCentroid = false, i7.returnGeometry = false;
    const a6 = null != i7.start ? i7.start / 8e3 : 0, o7 = s11.signal;
    return await this.enqueuePatchQuery({ tile: e3, query: i7, signal: o7, depth: a6 });
  }
  async _resend(e3, t7) {
    const { query: r5, message: i7 } = e3, a6 = null != r5.outFields ? r5.outFields : [], o7 = this._queryInfo.outFields, n5 = o7.filter((e4) => !a6.includes(e4));
    if (null != i7.addOrUpdate)
      if (n5.length)
        try {
          const e4 = this._subscriptions.get(i7.id).tile, a7 = await this._executePatchQuery(e4, r5, n5, t7);
          s3(t7), r5.outFields = o7, i7.addOrUpdate.joinAttributes(a7), this._onMessage({ ...i7, end: i7.end, type: "append" });
        } catch (u6) {
        }
      else
        this._onMessage({ ...i7, type: "append" });
    else
      this._onMessage({ ...i7, type: "append" });
  }
  async _resendSubscription(e3) {
    if (has("esri-2d-update-debug") && console.debug(e3.tile.id, "Resend Subscription"), e3.empty)
      return this._onMessage({ id: e3.tile.id, addOrUpdate: null, end: false, type: "append" });
    const t7 = e3.signal;
    for (const r5 of e3.requests.done)
      await this._resend(r5, { signal: t7 });
    return null != e3.edits ? this._onMessage(e3.edits) : void 0;
  }
  async resend() {
    const e3 = Array.from(this._subscriptions.values());
    await Promise.all(e3.map((e4) => this._resendSubscription(e4)));
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/DrillDownFeatureSource.js
var s7 = has("esri-mobile");
var i5 = { maxDrillLevel: s7 ? 1 : 4, maxRecordCountFactor: s7 ? 1 : 3 };
var a5 = class extends c7 {
  constructor(e3) {
    super(e3);
  }
  async _fetchDataTile(r5) {
    const s11 = this._serviceInfo.capabilities.query.supportsMaxRecordCountFactor, a6 = this._subscriptions.get(r5.key.id), o7 = a6.signal, n5 = r5.getQuantizationParameters();
    let c10 = 0;
    const d8 = async (u6, l4) => {
      const m6 = this._queryInfo, p7 = this.createTileQuery(u6, { maxRecordCountFactor: s11 ? i5.maxRecordCountFactor : void 0, returnExceededLimitFeatures: false, quantizationParameters: n5 });
      c10++;
      try {
        const t7 = await this.enqueueQuery({ tile: r5, query: p7, signal: o7, depth: l4 });
        if (c10--, s3(o7), !t7)
          return;
        if (m6 !== this._queryInfo)
          return void d8(u6, l4);
        if (t7.exceededTransferLimit && l4 < i5.maxDrillLevel) {
          for (const e3 of u6.createChildTiles())
            d8(e3, l4 + 1);
          return;
        }
        const s12 = { id: r5.id, addOrUpdate: t7, end: 0 === c10, type: "append" };
        a6.add({ query: p7, message: s12 }), this._onMessage(s12);
      } catch (f6) {
        if (!b(f6)) {
          const e3 = { id: r5.id, addOrUpdate: null, end: true, type: "append" };
          a6.add({ query: p7, message: e3 }), this._onMessage(e3);
        }
      }
    };
    d8(r5, 0);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/PagedFeatureSource.js
var o5 = class extends c7 {
  constructor(e3) {
    super(e3);
  }
  async _fetchDataTile(s11) {
    const i7 = 6, o7 = 20, n5 = this._subscriptions.get(s11.key.id);
    let d8 = false, c10 = 0, u6 = 0;
    const h8 = (e3, t7) => {
      u6--, s3(n5);
      const r5 = s11.id, i8 = e3.reader, o8 = e3.query;
      if (!i8.exceededTransferLimit) {
        if (d8 = true, 0 !== t7 && !i8.hasFeatures) {
          const e5 = { id: r5, addOrUpdate: i8, end: 0 === u6, type: "append" };
          return n5.add({ message: e5, query: o8 }), void this._onMessage(e5);
        }
        const e4 = { id: r5, addOrUpdate: i8, end: 0 === u6, type: "append" };
        return n5.add({ message: e4, query: o8 }), void this._onMessage(e4);
      }
      const c11 = { id: r5, addOrUpdate: i8, end: d8 && 0 === u6, type: "append" };
      n5.add({ message: c11, query: o8 }), this._onMessage(c11);
    };
    let m6 = 0, p7 = 0;
    for (; !d8 && p7++ < o7; ) {
      let o8;
      for (let a6 = 0; a6 < m6 + 1; a6++) {
        const a7 = c10++;
        u6++, o8 = this._fetchDataTilePage(s11, a7, n5).then((e3) => e3 && h8(e3, a7)).catch((a8) => {
          if (d8 = true, !b(a8)) {
            s.getLogger("esri.views.2d.layers.features.sources.PagedFeatureSource").error(new s2("mapview-query-error", "Encountered error when fetching tile", { tile: s11, error: a8 }));
            const r5 = { id: s11.id, addOrUpdate: null, end: d8, type: "append" }, i8 = { start: this.pageSize * c10, num: this.pageSize, returnExceededLimitFeatures: true, quantizationParameters: s11.getQuantizationParameters() };
            null != this.maxRecordCountFactor && (i8.maxRecordCountFactor = this.maxRecordCountFactor);
            const o9 = this.createTileQuery(s11, i8);
            n5.add({ message: r5, query: o9 }), this._onMessage(r5);
          }
        });
      }
      await o8, s3(n5), m6 = Math.min(m6 + 2, i7);
    }
  }
  async _fetchDataTilePage(e3, t7, r5) {
    s3(r5);
    const i7 = this._queryInfo, o7 = { start: this.pageSize * t7, num: this.pageSize, returnExceededLimitFeatures: true, quantizationParameters: e3.getQuantizationParameters() };
    null != this.maxRecordCountFactor && (o7.maxRecordCountFactor = this.maxRecordCountFactor);
    const n5 = this.createTileQuery(e3, o7);
    try {
      const s11 = r5.signal, o8 = await this.enqueueQuery({ tile: e3, query: n5, signal: s11, depth: t7 });
      return s3(r5), o8 ? i7 !== this._queryInfo ? this._fetchDataTilePage(e3, t7, r5) : { reader: o8, query: n5 } : null;
    } catch (d8) {
      return f(d8), null;
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/SnapshotFeatureSource.js
function l3(e3, t7, s11) {
  const r5 = e3.getXHydrated(), o7 = e3.getYHydrated(), a6 = t7.getColumnForX(r5), n5 = Math.floor(t7.normalizeCol(a6));
  return `${s11}/${Math.floor(t7.getRowForY(o7))}/${n5}`;
}
function h6(e3, t7) {
  if (null == e3)
    return null;
  const s11 = t7.transform, r5 = e3.getQuantizationTransform();
  if (null == r5) {
    const [t8, r6] = s11.scale, [o8, a7] = s11.translate, n6 = -o8 / t8, i8 = 1 / t8, d9 = a7 / r6, u7 = 1 / -r6;
    return e3.transform(n6, d9, i8, u7);
  }
  const [o7, a6] = r5.scale, [n5, i7] = r5.translate, [d8, u6] = s11.scale, [l4, h8] = s11.translate, c10 = o7 / d8, g4 = (n5 - l4) / d8, p7 = a6 / u6, _4 = (-i7 + h8) / u6;
  return e3.transform(g4, _4, c10, p7);
}
var c8 = class extends c7 {
  constructor(e3) {
    super(e3), this.mode = "snapshot", this._loading = true, this._controller = new AbortController(), this._downloadPromise = null, this._didSendEnd = false, this._queries = new Array(), this._invalidated = false, this._hasAggregates = false, this._random = new t(1e3), this._store = e3.store, this._markedIdsBufId = this._store.storage.createBitset();
  }
  destroy() {
    super.destroy(), this._controller.abort();
  }
  get loading() {
    return this._loading;
  }
  get _signal() {
    return this._controller.signal;
  }
  update(e3, t7) {
    var _a;
    super.update(e3, t7), this._featureCount ?? (this._featureCount = t7.initialFeatureCount), null != t7.changedFeatureCount && (this._featureCount = t7.changedFeatureCount), this._hasAggregates = !!((_a = e3.targets) == null ? void 0 : _a.aggregate);
  }
  async resend(e3 = false) {
    if (await this._downloadPromise, this._invalidated || e3) {
      const e4 = this._featureCount;
      return n(e4, "Expected featureCount to be defined"), this._invalidated = false, this._subscriptions.forEach((e5) => e5.clear()), this._downloadPromise = this._download(e4), void await this._downloadPromise;
    }
    const t7 = this._queries.map(({ query: e4, reader: t8 }) => this._sendPatchQuery(e4, t8));
    await Promise.all(t7), this._subscriptions.forEach((e4) => {
      e4.requests.done.forEach((e5) => this._onMessage(e5.message));
    });
  }
  async refresh(e3, t7) {
    t7 && (this._featureCount = t7.featureCount), await this.resend(true);
  }
  async _sendPatchQuery(e3, t7) {
    const s11 = null != e3.outFields ? e3.outFields : [], o7 = this._queryInfo.outFields, a6 = o7.filter((e4) => !s11.includes(e4));
    if (!a6.length)
      return;
    const n5 = e3.clone(), i7 = this._signal;
    n5.returnGeometry = false, n5.returnCentroid = false, n5.outFields = a6, e3.outFields = o7;
    const d8 = await this.enqueueQuery({ query: n5, depth: 0, signal: i7 });
    s3({ signal: i7 }), t7.joinAttributes(d8);
  }
  async _fetchDataTile(e3) {
    this._downloadPromise ?? (this._downloadPromise = this._download(this._featureCount));
    const t7 = this._store.search(e3), s11 = this._subscriptions.get(e3.key.id), r5 = t7.length - 1;
    for (let d8 = 0; d8 < r5; d8++) {
      const r6 = h6(t7[d8], e3), a7 = { type: "append", id: e3.id, addOrUpdate: r6, end: false, status: t6.empty() };
      s11.add({ query: null, message: a7 }), this._hasAggregates || await A(1), this._onMessage(a7);
    }
    const a6 = h6(r5 >= 0 ? t7[r5] : null, e3), n5 = this._didSendEnd, i7 = { type: "append", id: e3.id, addOrUpdate: a6, end: n5, status: t6.empty() };
    s11.add({ query: null, message: i7 }), this._onMessage(i7);
  }
  async _download(e3) {
    try {
      await this.whenInitialized();
      const t7 = this._store.storage.getBitset(this._markedIdsBufId), s11 = /* @__PURE__ */ new Set();
      t7.clear();
      const r5 = Math.ceil(e3 / this.pageSize), o7 = Array.from({ length: r5 }, (e4, t8) => t8).sort((e4, t8) => this._random.getInt() - this._random.getInt()).map((e4) => this._downloadPage(e4, t7, s11));
      await Promise.all(o7), this._store.sweepFeatures(t7, this._store.storage), this._store.sweepFeatureSets(s11);
    } catch (s11) {
      s.getLogger("esri.views.2d.layers.features.sources.SnapshotFeatureSource").error("mapview-snapshot-source", "Encountered and error when downloading feature snapshot", s11);
    }
    this._sendEnd(), this._loading = false;
  }
  async _downloadPage(e3, t7, s11) {
    const o7 = this.pageSize, a6 = { start: e3 * o7, num: o7, cacheHint: true };
    null != this.maxRecordCountFactor && (a6.maxRecordCountFactor = this.maxRecordCountFactor);
    const n5 = this.createQuery(a6), i7 = this._signal, d8 = await this.enqueueQuery({ query: n5, depth: e3, signal: i7 });
    s3({ signal: i7 }), this._queries.push({ query: n5, reader: d8 }), this._store.insert(d8), s11.add(d8.instance);
    const u6 = d8.getCursor();
    for (; u6.next(); )
      t7.set(u6.getDisplayId());
    this._send(d8);
  }
  _send(e3) {
    if (!this._subscriptions.size)
      return;
    let t7 = null;
    const s11 = /* @__PURE__ */ new Map(), r5 = /* @__PURE__ */ new Set(), o7 = /* @__PURE__ */ new Map();
    this._subscriptions.forEach((e4) => {
      const a6 = e4.tile;
      s11.set(a6.key.id, null), t7 = a6.tileInfoView, r5.add(a6.level);
      const { row: n5, col: i7 } = a6.key, d8 = `${a6.level}/${n5}/${i7}`, u6 = o7.get(d8) ?? [];
      u6.push(e4), o7.set(d8, u6);
    });
    for (const a6 of r5) {
      const r6 = t7.getLODInfoAt(a6), n5 = e3.getCursor();
      for (; n5.next(); ) {
        const e4 = l3(n5, r6, a6), t8 = n5.getIndex();
        if (o7.has(e4))
          for (const r7 of o7.get(e4)) {
            const e5 = r7.tile.id;
            let o8 = s11.get(e5);
            null == o8 && (o8 = [], s11.set(e5, o8)), o8.push(t8);
          }
      }
    }
    s11.forEach((t8, s12) => {
      if (null != t8) {
        const r6 = this._subscriptions.get(s12), o8 = { type: "append", id: s12, addOrUpdate: h6(r2.from(e3, t8), r6.tile), end: false, status: t6.empty() };
        r6.add({ query: null, message: o8 }), this._onMessage(o8);
      }
    });
  }
  _sendEnd() {
    this._subscriptions.forEach((e3) => {
      const t7 = { type: "append", id: e3.tile.id, addOrUpdate: null, end: true, status: t6.empty() };
      e3.add({ query: null, message: t7 }), this._onMessage(t7);
    }), this._didSendEnd = true;
  }
};
c8 = e([c("esri.view.2d.layers.features.sources.SnapshotFeatureSource")], c8);

// node_modules/@arcgis/core/layers/graphics/data/StreamFeatureManager.js
var s8 = "__esri_stream_id__";
var i6 = "__esri_timestamp__";
var r4 = 1e3;
var o6 = class {
  constructor(t7, e3, i7, r5, o7 = 128) {
    this._trackIdToObservations = /* @__PURE__ */ new Map(), this._idCounter = 0, this._lastPurge = performance.now(), this._addOrUpdated = /* @__PURE__ */ new Map(), this._removed = [], this._maxAge = 0, this._timeInfo = i7, this._purgeOptions = r5, this.store = t7, this.objectIdField = e3, this.purgeInterval = o7, this._useGeneratedIds = this.objectIdField === s8;
  }
  removeById(t7) {
    this._removed.push(t7);
  }
  removeByTrackId(t7) {
    const e3 = this._trackIdToObservations.get(t7);
    if (e3)
      for (const s11 of e3.entries)
        this._removed.push(s11);
  }
  add(s11) {
    var _a;
    if (this._useGeneratedIds) {
      const t7 = this._nextId();
      s11.attributes[this.objectIdField] = t7, s11.objectId = t7;
    } else
      s11.objectId = s11.attributes[this.objectIdField];
    const i7 = s11.objectId;
    if (this._addOrUpdated.set(i7, s11), this._maxAge = Math.max(this._maxAge, s11.attributes[this._timeInfo.startTimeField]), !this._timeInfo.trackIdField)
      return null == this._trackIdLessObservations && (this._trackIdLessObservations = new t5(1e5)), void this._trackIdLessObservations.enqueue(i7);
    const o7 = s11.attributes[this._timeInfo.trackIdField];
    if (!this._trackIdToObservations.has(o7)) {
      const s12 = null != ((_a = this._purgeOptions) == null ? void 0 : _a.maxObservations) ? this._purgeOptions.maxObservations : r4, i8 = i2(s12, 0, r4);
      this._trackIdToObservations.set(o7, new t5(i8));
    }
    const d8 = this._trackIdToObservations.get(o7), a6 = d8 == null ? void 0 : d8.enqueue(i7);
    null != a6 && (this._addOrUpdated.has(a6) ? this._addOrUpdated.delete(a6) : this._removed.push(a6));
  }
  checkForUpdates() {
    const t7 = this._getToAdd(), e3 = this._getToRemove(), s11 = performance.now();
    s11 - this._lastPurge >= this.purgeInterval && (this._purge(s11), this._lastPurge = s11);
    const r5 = [];
    if (null != e3)
      for (const i7 of e3) {
        const t8 = this.store.removeById(i7);
        null != t8 && r5.push(t8);
      }
    const o7 = [];
    if (null != t7) {
      const r6 = new Set(e3 ?? []);
      for (const e4 of t7)
        r6.has(e4.objectId) || (e4.attributes[i6] = s11, this.store.add(e4), o7.push(e4));
    }
    (o7.length || (r5 == null ? void 0 : r5.length)) && this.store.update(o7, r5);
  }
  _getToAdd() {
    if (!this._addOrUpdated.size)
      return null;
    const t7 = new Array(this._addOrUpdated.size);
    let e3 = 0;
    return this._addOrUpdated.forEach((s11) => t7[e3++] = s11), this._addOrUpdated.clear(), t7;
  }
  _getToRemove() {
    const t7 = this._removed;
    return this._removed.length ? (this._removed = [], t7) : null;
  }
  _nextId() {
    const t7 = this._idCounter;
    return this._idCounter = (this._idCounter + 1) % 4294967294 + 1, t7;
  }
  _purge(t7) {
    const e3 = this._purgeOptions;
    null != e3 && (this._purgeSomeByDisplayCount(e3), this._purgeByAge(e3), this._purgeByAgeReceived(t7, e3), this._purgeTracks());
  }
  _purgeSomeByDisplayCount(t7) {
    if (!t7.displayCount)
      return;
    let e3 = this.store.size;
    if (e3 > t7.displayCount) {
      if (this._timeInfo.trackIdField) {
        for (const s11 of this._trackIdToObservations.values())
          if (e3 > t7.displayCount && s11.size) {
            const t8 = s11.dequeue();
            this._removed.push(t8), e3--;
          }
      }
      if (null != this._trackIdLessObservations) {
        let s11 = e3 - t7.displayCount;
        for (; s11-- > 0; ) {
          const t8 = this._trackIdLessObservations.dequeue();
          null != t8 && this._removed.push(t8);
        }
      }
    }
  }
  _purgeByAge(t7) {
    var _a;
    const e3 = (_a = this._timeInfo) == null ? void 0 : _a.startTimeField;
    if (!t7.age || !e3)
      return;
    const s11 = 60 * t7.age * 1e3, i7 = this._maxAge - s11;
    this.store.forEach((t8) => {
      t8.attributes[e3] < i7 && this._removed.push(t8.objectId);
    });
  }
  _purgeByAgeReceived(t7, e3) {
    if (!e3.ageReceived)
      return;
    const s11 = t7 - 60 * e3.ageReceived * 1e3;
    this.store.forEach((t8) => {
      t8.attributes[i6] < s11 && this._removed.push(t8.objectId);
    });
  }
  _purgeTracks() {
    this._trackIdToObservations.forEach((t7, e3) => {
      0 === t7.size && this._trackIdToObservations.delete(e3);
    });
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/StreamConnectionState.js
var s9 = class extends g {
  constructor(r5) {
    super(r5);
  }
  get connectionStatus() {
    var _a;
    return (_a = this.connection) == null ? void 0 : _a.connectionStatus;
  }
  get errorString() {
    var _a;
    return (_a = this.connection) == null ? void 0 : _a.errorString;
  }
};
e([y()], s9.prototype, "connection", void 0), e([y()], s9.prototype, "connectionStatus", null), e([y()], s9.prototype, "errorString", null), s9 = e([c("esri.views.2d.layers.features.sources.StreamConnectionState")], s9);

// node_modules/@arcgis/core/views/2d/layers/features/sources/StreamSource.js
var p6 = 2500;
function _3(e3, t7) {
  const s11 = e3.weakClone();
  if (null != e3.geometry) {
    const i7 = M2(t7, e3.geometry.coords[0]), o7 = N(t7, e3.geometry.coords[1]);
    s11.geometry = new t4([], [i7, o7]);
  }
  return s11;
}
function m5(e3) {
  return "esriGeometryPoint" === e3 ? _3 : (t7, s11) => {
    const n5 = t7.weakClone(), r5 = new t4(), o7 = false, d8 = false, c10 = ht(r5, t7.geometry, o7, d8, e3, s11, false, false);
    return n5.geometry = c10, n5;
  };
}
function y4(e3) {
  return "esriGeometryPoint" === e3 ? (e4) => null != e4.geometry ? { minX: e4.geometry.coords[0], minY: e4.geometry.coords[1], maxX: e4.geometry.coords[0], maxY: e4.geometry.coords[1] } : { minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 } : (e4) => {
    let t7 = 1 / 0, s11 = 1 / 0, i7 = -1 / 0, n5 = -1 / 0;
    return null != e4.geometry && e4.geometry.forEachVertex((e5, r5) => {
      t7 = Math.min(t7, e5), s11 = Math.min(s11, r5), i7 = Math.max(i7, e5), n5 = Math.max(n5, r5);
    }), { minX: t7, minY: s11, maxX: i7, maxY: n5 };
  };
}
function g3(e3, s11) {
  const i7 = i4(9, y4(s11));
  return i7.load(e3), i7;
}
function f5(e3, t7) {
  return e3.search({ minX: t7.bounds[0], minY: t7.bounds[1], maxX: t7.bounds[2], maxY: t7.bounds[3] });
}
var v2 = class {
  constructor(e3, t7) {
    this.onUpdate = e3, this._geometryType = t7, this._objectIdToFeature = /* @__PURE__ */ new Map(), this._index = null;
  }
  get _features() {
    const e3 = [];
    return this._objectIdToFeature.forEach((t7) => e3.push(t7)), e3;
  }
  add(e3) {
    this._objectIdToFeature.set(e3.objectId, e3), this._index = null;
  }
  get(e3) {
    return this._objectIdToFeature.has(e3) ? this._objectIdToFeature.get(e3) : null;
  }
  forEach(e3) {
    this._objectIdToFeature.forEach(e3);
  }
  search(e3) {
    return this._index || (this._index = g3(this._features, this._geometryType)), f5(this._index, e3);
  }
  clear() {
    this._index = null, this._objectIdToFeature.clear();
  }
  removeById(e3) {
    const t7 = this._objectIdToFeature.get(e3);
    return t7 ? (this._objectIdToFeature.delete(e3), this._index = null, t7) : null;
  }
  update(e3, t7) {
    this.onUpdate(e3, t7);
  }
  get size() {
    return this._objectIdToFeature.size;
  }
};
var I3 = class extends m4 {
  constructor(t7) {
    super(t7), this.type = "stream", this._updateIntervalId = 0, this._level = 0, this._isPaused = false, this._updateInfo = { websocket: 0, client: 0 }, this._inUpdate = false;
    const { outSR: s11 } = t7, { geometryType: i7, objectIdField: n5, timeInfo: r5, purgeOptions: a6, source: c10, spatialReference: u6, serviceFilter: l4, maxReconnectionAttempts: _4, maxReconnectionInterval: y5, updateInterval: g4, customParameters: f6, enabledEventTypes: I4 } = t7.serviceInfo, b5 = new v2(this._onUpdate.bind(this), i7), T4 = new o6(b5, n5, r5, a6), S6 = o2(c10, u6, s11, i7, l4, _4, y5, f6 ?? {});
    this._connectionState = new s9({ connection: S6 }), this._store = b5, this._manager = T4, this._connection = S6, this._quantize = m5(i7), this._enabledEventTypes = new Set(I4), this._handlesGroup = t2([this._connection.on("data-received", (e3) => this._onFeature(e3)), this._connection.on("message-received", (e3) => this._onWebSocketMessage(e3))]), this._initUpdateInterval = () => {
      let e3 = performance.now();
      this._updateIntervalId = setInterval(() => {
        const s12 = performance.now(), i8 = s12 - e3;
        if (i8 > p6) {
          e3 = s12;
          const t8 = Math.round(this._updateInfo.client / (i8 / 1e3)), n6 = Math.round(this._updateInfo.websocket / (i8 / 1e3));
          this._updateInfo.client = 0, this._updateInfo.websocket = 0, this.events.emit("updateRate", { client: t8, websocket: n6 });
        }
        t7.canAcceptRequest() && !this._inUpdate && this._manager.checkForUpdates();
      }, g4);
    }, this._isPaused = t7.serviceInfo.isPaused, this._isPaused || this._initUpdateInterval();
  }
  destroy() {
    var _a;
    super.destroy(), this._clearUpdateInterval(), this._connection.destroy(), (_a = this._handlesGroup) == null ? void 0 : _a.remove();
  }
  _fetchDataTile() {
  }
  get connectionStatus() {
    return this._connectionState.connectionStatus;
  }
  get errorString() {
    return this._connectionState.errorString;
  }
  updateCustomParameters(e3) {
    this._connection.updateCustomParameters(e3);
  }
  pauseStream() {
    this._isPaused || (this._isPaused = true, this._clearUpdateInterval());
  }
  resumeStream() {
    this._isPaused && (this._isPaused = false, this._initUpdateInterval());
  }
  sendMessageToSocket(e3) {
    this._connection.sendMessageToSocket(e3);
  }
  sendMessageToClient(e3) {
    this._isPaused && "type" in e3 && "clear" === e3.type ? (this._store.clear(), this._subscriptions.forEach((e4, t7) => {
      e4.didSend && e4.tile.level === this._level && this._onMessage({ type: "append", id: t7, addOrUpdate: null, clear: true, end: true });
    })) : this._connection.sendMessageToClient(e3);
  }
  enableEvent(e3, t7) {
    t7 ? this._enabledEventTypes.add(e3) : this._enabledEventTypes.delete(e3);
  }
  subscribe(e3, t7) {
    const s11 = super.subscribe(e3, t7);
    this._level = e3.level;
    const i7 = this._getTileFeatures(e3);
    return this._onMessage({ type: "append", id: e3.key.id, addOrUpdate: i7, end: true }), s11.didSend = true, s11;
  }
  unsubscribe(e3) {
    super.unsubscribe(e3);
  }
  *readers(e3) {
    const t7 = this._subscriptions.get(e3), { tile: s11 } = t7;
    yield this._getTileFeatures(s11);
  }
  createTileQuery(e3) {
    throw new Error("Service does not support tile  queries");
  }
  async resend() {
    this._subscriptions.forEach((e3) => {
      const { tile: t7 } = e3, s11 = { type: "append", id: t7.id, addOrUpdate: this._getTileFeatures(t7), end: true };
      this._onMessage(s11);
    });
  }
  _getTileFeatures(e3) {
    const t7 = this._store.search(e3).map((t8) => this._quantize(t8, e3.transform));
    return h4.fromOptimizedFeatures(t7, this._arcadeLayerSchema, e3.transform);
  }
  _onWebSocketMessage(e3) {
    if (this._enabledEventTypes.has("message-received") && this.events.emit("message-received", e3), "type" in e3)
      switch (e3.type) {
        case "delete":
          if (e3.objectIds)
            for (const t7 of e3.objectIds)
              this._manager.removeById(t7);
          if (e3.trackIds)
            for (const t7 of e3.trackIds)
              this._manager.removeByTrackId(t7);
          break;
        case "clear":
          this._store.forEach((e4) => this._manager.removeById(e4.objectId));
      }
  }
  _onFeature(e3) {
    this._updateInfo.websocket++;
    try {
      this._enabledEventTypes.has("data-received") && this.events.emit("data-received", e3);
      const t7 = tt(e3, this._serviceInfo.geometryType, false, false, this._serviceInfo.objectIdField);
      this._manager.add(t7);
    } catch (t7) {
    }
  }
  _clearUpdateInterval() {
    clearInterval(this._updateIntervalId), this._updateIntervalId = 0;
  }
  async _onUpdate(e3, t7) {
    this._inUpdate = true;
    try {
      null != e3 && (this._updateInfo.client += e3.length), this._subscriptions.forEach((e4, t9) => {
        e4.didSend && e4.tile.level === this._level && this._onMessage({ type: "append", id: t9, addOrUpdate: null, clear: true, end: false });
      });
      const t8 = [];
      this._subscriptions.forEach((e4, s11) => {
        if (!e4.didSend || e4.tile.level !== this._level)
          return;
        const i7 = e4.tile, n5 = { type: "append", id: s11, addOrUpdate: this._getTileFeatures(i7), remove: [], end: false, status: t6.empty() };
        e4.requests.stream.enqueue(n5), t8.push(this._onMessage(n5));
      }), await Promise.all(t8), this._subscriptions.forEach((e4, t9) => {
        e4.didSend && e4.tile.level === this._level && this._onMessage({ type: "append", id: t9, addOrUpdate: null, end: true });
      });
    } catch {
    }
    this._inUpdate = false;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/createSource.js
function s10(e3, s11, c10, u6, i7, p7, m6) {
  const f6 = n4(e3, s11, c10, u6, i7, p7, m6);
  switch (f6.type) {
    case "feature":
      switch (f6.origin) {
        case "hosted":
        case "local":
          return new o5(f6);
        case "snapshot":
          return new c8(f6);
        default:
          return new a5(f6);
      }
    case "stream":
      return new I3(f6);
  }
}
function n4(r5, t7, a6, o7, s11, n5, c10) {
  switch (r5.type) {
    case "snapshot":
      return { type: "feature", origin: "snapshot", featureCount: r5.featureCount ?? 0, serviceInfo: r5, onMessage: s11, outSR: a6, tileInfoView: o7, canAcceptRequest: n5, store: c10, arcadeLayerSchema: t7 };
    case "stream":
      return { type: "stream", serviceInfo: r5, onMessage: s11, outSR: a6, canAcceptRequest: n5, arcadeLayerSchema: t7 };
    case "memory":
    case "on-demand":
      return { type: "feature", serviceInfo: r5, onMessage: s11, outSR: a6, origin: u6(r5.source), tileInfoView: o7, canAcceptRequest: n5, arcadeLayerSchema: t7 };
  }
  function u6(r6) {
    return Array.isArray(r6) ? "local" : "path" in r6 && w2(r6.path) ? "hosted" : "unknown";
  }
}

// node_modules/@arcgis/core/geohash/GeohashTree.js
var h7 = class {
  constructor(e3 = [], s11, i7 = 8096) {
    this.onRelease = (t7) => {
    }, this._nodes = 0, this._root = new c9(this, 0, 0, 0), this._statisticFields = e3, this._pool = i7 ? new t5(8096) : null, this._serviceInfo = s11;
  }
  destroy() {
    this.clear();
  }
  _acquire(t7, e3, s11) {
    this._nodes++;
    let i7 = null;
    return null != this._pool && (i7 = this._pool.dequeue()), null != i7 ? i7.realloc(t7, e3, s11) : i7 = new c9(this, t7, e3, s11), i7;
  }
  _release(t7) {
    this.onRelease(t7), this._nodes--, null != this._pool && this._pool.enqueue(t7);
  }
  get count() {
    return this._root.count;
  }
  get size() {
    return this._nodes;
  }
  get poolSize() {
    var _a;
    return ((_a = this._pool) == null ? void 0 : _a.size) ?? 0;
  }
  get depth() {
    let t7 = 0;
    return this.forEach((e3) => t7 = Math.max(t7, e3.depth)), t7;
  }
  dropLevels(t7) {
    this.forEach((e3) => {
      if (e3.depth >= t7)
        for (let t8 = 0; t8 < e3.children.length; t8++) {
          const s11 = e3.children[t8];
          s11 && this._release(s11);
        }
    }), this.forEach((e3) => {
      if (e3.depth >= t7)
        for (let t8 = 0; t8 < e3.children.length; t8++)
          e3.children[t8] = null;
    });
  }
  clear() {
    this.forEach((t7) => this._release(t7)), this._root = new c9(this, 0, 0, 0);
  }
  insert(t7, e3, s11 = 0) {
    const i7 = h4.fromOptimizedFeatures([t7], this._serviceInfo).getCursor();
    i7.next();
    const n5 = i7.readGeometry();
    if (!n5)
      return;
    const [o7, a6] = n5.coords, r5 = t7.geohashX, h8 = t7.geohashY;
    this.insertCursor(i7, t7.displayId, o7, a6, r5, h8, e3, s11);
  }
  insertCursor(t7, e3, s11, i7, n5, o7, a6, r5 = 0) {
    let l4 = this._root, h8 = 0, c10 = 0, u6 = 0;
    for (; null !== l4; ) {
      if (l4.depth >= r5 && (l4.count += 1, l4.xTotal += s11, l4.yTotal += i7, l4.xGeohashTotal += n5, l4.yGeohashTotal += o7, l4.referenceId = e3, this._updateStatisticsCursor(t7, l4, 1)), h8 >= a6)
        return void l4.add(e3);
      const d8 = Math.ceil((h8 + 1) / 2), f6 = Math.floor((h8 + 1) / 2), x4 = 1 - h8 % 2, m6 = 30 - (3 * d8 + 2 * f6), g4 = 30 - (2 * d8 + 3 * f6), y5 = (n5 & 7 * x4 + 3 * (1 - x4) << m6) >> m6, p7 = (o7 & 3 * x4 + 7 * (1 - x4) << g4) >> g4, _4 = y5 + p7 * (8 * x4 + 4 * (1 - x4));
      c10 = c10 << 3 * x4 + 2 * (1 - x4) | y5, u6 = u6 << 2 * x4 + 3 * (1 - x4) | p7, null == l4.children[_4] && (l4.children[_4] = this._acquire(c10, u6, h8 + 1)), h8 += 1, l4 = l4.children[_4];
    }
  }
  remove(t7, e3) {
    const s11 = h4.fromOptimizedFeatures([t7], this._serviceInfo).getCursor();
    s11.next();
    const i7 = s11.readGeometry();
    if (!i7)
      return;
    const [n5, o7] = i7.coords, a6 = t7.geohashX, r5 = t7.geohashY;
    this.removeCursor(s11, n5, o7, a6, r5, e3);
  }
  removeCursor(t7, e3, s11, i7, n5, o7) {
    let a6 = this._root, r5 = 0;
    for (; null !== a6; ) {
      if (a6.count -= 1, a6.xTotal -= e3, a6.yTotal -= s11, a6.xGeohashTotal -= i7, a6.yGeohashTotal -= n5, this._updateStatisticsCursor(t7, a6, -1), r5 >= o7)
        return void a6.remove(t7.getDisplayId());
      const l4 = Math.ceil((r5 + 1) / 2), h8 = Math.floor((r5 + 1) / 2), c10 = 1 - r5 % 2, u6 = 30 - (3 * l4 + 2 * h8), d8 = 30 - (2 * l4 + 3 * h8), f6 = ((i7 & 7 * c10 + 3 * (1 - c10) << u6) >> u6) + ((n5 & 3 * c10 + 7 * (1 - c10) << d8) >> d8) * (8 * c10 + 4 * (1 - c10)), x4 = a6.children[f6];
      1 === (x4 == null ? void 0 : x4.count) && (this._release(x4), a6.children[f6] = null), r5 += 1, a6 = x4;
    }
  }
  forEach(t7) {
    let e3 = this._root;
    for (; null !== e3; ) {
      const s11 = this._linkChildren(e3) || e3.next;
      t7(e3), e3 = s11;
    }
  }
  find(t7, e3, s11) {
    return this._root.find(t7, e3, s11, 0, 0, 0);
  }
  findIf(t7) {
    let e3 = null;
    return this.forEach((s11) => {
      t7(s11) && (e3 = s11);
    }), e3;
  }
  findAllIf(t7) {
    const e3 = [];
    return this.forEach((s11) => {
      t7(s11) && e3.push(s11);
    }), e3;
  }
  findSingleOccupancyNode(t7, e3, s11, i7, n5) {
    let o7 = this._root;
    for (; null !== o7; ) {
      const a6 = o7.depth, r5 = o7.xNode, l4 = o7.yNode, h8 = 1 - a6 % 2, c10 = o7.xGeohashTotal / o7.count, u6 = o7.yGeohashTotal / o7.count;
      if (1 === o7.count && t7 < c10 && c10 <= s11 && e3 < u6 && u6 <= i7)
        return o7;
      if (a6 >= n5) {
        o7 = o7.next;
        continue;
      }
      const d8 = Math.ceil((a6 + 1) / 2), f6 = Math.floor((a6 + 1) / 2), x4 = 30 - (3 * d8 + 2 * f6), m6 = 30 - (2 * d8 + 3 * f6), g4 = ~((1 << x4) - 1), y5 = ~((1 << m6) - 1), p7 = (t7 & g4) >> x4, _4 = (e3 & y5) >> m6, v3 = (s11 & g4) >> x4, M3 = (i7 & y5) >> m6, T4 = r5 << 3 * h8 + 2 * (1 - h8), b5 = l4 << 2 * h8 + 3 * (1 - h8), k4 = T4 + 8 * h8 + 4 * (1 - h8), N2 = b5 + 4 * h8 + 8 * (1 - h8), I4 = Math.max(T4, p7), C3 = Math.max(b5, _4), G3 = Math.min(k4, v3), L4 = Math.min(N2, M3);
      let S6 = null, w5 = null;
      for (let t8 = C3; t8 <= L4; t8++)
        for (let e4 = I4; e4 <= G3; e4++) {
          const s12 = e4 - T4 + (t8 - b5) * (8 * h8 + 4 * (1 - h8)), i8 = o7.children[s12];
          i8 && (S6 || (S6 = i8, S6.next = o7.next), w5 && (w5.next = i8), w5 = i8, i8.next = o7.next);
        }
      o7 = S6 || o7.next;
    }
    return null;
  }
  getRegionDisplayIds(t7) {
    let e3 = this._root;
    const { bounds: s11, geohashBounds: i7, level: n5 } = t7, [o7, a6, r5, l4] = s11, h8 = [];
    for (; null !== e3; ) {
      const t8 = e3.depth, s12 = e3.xNode, c10 = e3.yNode;
      if (t8 >= n5) {
        const t9 = e3.xTotal / e3.count, s13 = e3.yTotal / e3.count;
        t9 >= o7 && t9 <= r5 && s13 >= a6 && s13 <= l4 && e3.displayIds.forEach((t10) => h8.push(t10)), e3 = e3.next;
        continue;
      }
      const u6 = Math.ceil((t8 + 1) / 2), d8 = Math.floor((t8 + 1) / 2), f6 = 1 - t8 % 2, x4 = 30 - (3 * u6 + 2 * d8), m6 = 30 - (2 * u6 + 3 * d8), g4 = ~((1 << x4) - 1), y5 = ~((1 << m6) - 1), p7 = (i7.xLL & g4) >> x4, _4 = (i7.yLL & y5) >> m6, v3 = (i7.xTR & g4) >> x4, M3 = (i7.yTR & y5) >> m6, T4 = s12 << 3 * f6 + 2 * (1 - f6), b5 = c10 << 2 * f6 + 3 * (1 - f6), k4 = T4 + 8 * f6 + 4 * (1 - f6), N2 = b5 + 4 * f6 + 8 * (1 - f6), I4 = Math.max(T4, p7), C3 = Math.max(b5, _4), G3 = Math.min(k4, v3), L4 = Math.min(N2, M3);
      let S6 = null, w5 = null;
      for (let i8 = C3; i8 <= L4; i8++)
        for (let t9 = I4; t9 <= G3; t9++) {
          const s13 = t9 - T4 + (i8 - b5) * (8 * f6 + 4 * (1 - f6)), n6 = e3.children[s13];
          n6 && (S6 || (S6 = n6, S6.next = e3.next), w5 && (w5.next = n6), w5 = n6, n6.next = e3.next);
        }
      e3 = S6 || e3.next;
    }
    return h8;
  }
  getRegionStatistics(t7) {
    let e3 = this._root, s11 = 0, i7 = 0, n5 = 0;
    const o7 = {}, { bounds: a6, geohashBounds: r5, level: l4 } = t7, [h8, c10, u6, d8] = a6;
    let f6 = 0;
    for (; null !== e3; ) {
      const t8 = e3.depth, a7 = e3.xNode, x4 = e3.yNode;
      if (t8 >= l4) {
        const t9 = e3.xTotal / e3.count, a8 = e3.yTotal / e3.count;
        t9 > h8 && t9 <= u6 && a8 > c10 && a8 <= d8 && (s11 += e3.count, i7 += e3.xTotal, n5 += e3.yTotal, 1 === e3.count && (f6 = e3.referenceId), this._aggregateStatistics(o7, e3.statistics)), e3 = e3.next;
        continue;
      }
      const m6 = Math.ceil((t8 + 1) / 2), g4 = Math.floor((t8 + 1) / 2), y5 = 1 - t8 % 2, p7 = 30 - (3 * m6 + 2 * g4), _4 = 30 - (2 * m6 + 3 * g4), v3 = ~((1 << p7) - 1), M3 = ~((1 << _4) - 1), T4 = (r5.xLL & v3) >> p7, b5 = (r5.yLL & M3) >> _4, k4 = (r5.xTR & v3) >> p7, N2 = (r5.yTR & M3) >> _4, I4 = a7 << 3 * y5 + 2 * (1 - y5), C3 = x4 << 2 * y5 + 3 * (1 - y5), G3 = I4 + 8 * y5 + 4 * (1 - y5), L4 = C3 + 4 * y5 + 8 * (1 - y5), S6 = Math.max(I4, T4), w5 = Math.max(C3, b5), R3 = Math.min(G3, k4), F3 = Math.min(L4, N2);
      let z = null, j7 = null;
      for (let r6 = w5; r6 <= F3; r6++)
        for (let t9 = S6; t9 <= R3; t9++) {
          const a8 = t9 - I4 + (r6 - C3) * (8 * y5 + 4 * (1 - y5)), l5 = e3.children[a8];
          if (l5) {
            if (r6 !== w5 && r6 !== F3 && t9 !== S6 && t9 !== R3) {
              const t10 = l5.xTotal / l5.count, e4 = l5.yTotal / l5.count;
              t10 > h8 && t10 <= u6 && e4 > c10 && e4 <= d8 && (s11 += l5.count, i7 += l5.xTotal, n5 += l5.yTotal, 1 === l5.count && (f6 = l5.referenceId), this._aggregateStatistics(o7, l5.statistics));
              continue;
            }
            z || (z = l5, z.next = e3.next), j7 && (j7.next = l5), j7 = l5, l5.next = e3.next;
          }
        }
      e3 = z || e3.next;
    }
    return { count: s11, attributes: this.normalizeStatistics(o7, s11), xTotal: i7, yTotal: n5, referenceId: f6 };
  }
  getBins(t7) {
    const e3 = [], { geohashBounds: s11, level: i7 } = t7;
    let n5 = this._root;
    for (; null !== n5; ) {
      const t8 = n5.depth, o7 = n5.xNode, a6 = n5.yNode;
      if (t8 >= i7) {
        e3.push(n5), n5 = n5.next;
        continue;
      }
      const r5 = Math.ceil((t8 + 1) / 2), l4 = Math.floor((t8 + 1) / 2), h8 = 1 - t8 % 2, c10 = 30 - (3 * r5 + 2 * l4), u6 = 30 - (2 * r5 + 3 * l4), d8 = ~((1 << c10) - 1), f6 = ~((1 << u6) - 1), x4 = (s11.xLL & d8) >> c10, m6 = (s11.yLL & f6) >> u6, g4 = (s11.xTR & d8) >> c10, y5 = (s11.yTR & f6) >> u6, p7 = o7 << 3 * h8 + 2 * (1 - h8), _4 = a6 << 2 * h8 + 3 * (1 - h8), v3 = p7 + 8 * h8 + 4 * (1 - h8), M3 = _4 + 4 * h8 + 8 * (1 - h8), T4 = Math.max(p7, x4), b5 = Math.max(_4, m6), k4 = Math.min(v3, g4), N2 = Math.min(M3, y5);
      let I4 = null, C3 = null;
      for (let e4 = b5; e4 <= N2; e4++)
        for (let t9 = T4; t9 <= k4; t9++) {
          const s12 = t9 - p7 + (e4 - _4) * (8 * h8 + 4 * (1 - h8)), i8 = n5.children[s12];
          i8 && (I4 || (I4 = i8, I4.next = n5.next), C3 && (C3.next = i8), C3 = i8, i8.next = n5.next);
        }
      n5 = I4 || n5.next;
    }
    return e3;
  }
  _linkChildren(t7) {
    let e3 = null, s11 = null;
    for (let i7 = 0; i7 <= t7.children.length; i7++) {
      const n5 = t7.children[i7];
      n5 && (e3 || (e3 = n5, e3.next = t7.next), s11 && (s11.next = n5), s11 = n5, n5.next = t7.next);
    }
    return e3;
  }
  _updateStatisticsCursor(t7, e3, s11) {
    for (const i7 of this._statisticFields) {
      const n5 = i7.name, o7 = i7.inField ? t7.readAttribute(i7.inField) : t7.getComputedNumericAtIndex(i7.inFieldIndex);
      switch (i7.statisticType) {
        case "min": {
          if (isNaN(o7))
            break;
          if (!e3.statistics[n5]) {
            e3.statistics[n5] = { value: o7 };
            break;
          }
          const t8 = e3.statistics[n5].value;
          e3.statistics[n5].value = Math.min(t8, o7);
          break;
        }
        case "max": {
          if (isNaN(o7))
            break;
          if (!e3.statistics[n5]) {
            e3.statistics[n5] = { value: o7 };
            break;
          }
          const t8 = e3.statistics[n5].value;
          e3.statistics[n5].value = Math.max(t8, o7);
          break;
        }
        case "count":
          break;
        case "sum":
        case "avg": {
          e3.statistics[n5] || (e3.statistics[n5] = { value: 0, nanCount: 0 });
          const t8 = e3.statistics[n5].value, i8 = e3.statistics[n5].nanCount ?? 0;
          null == o7 || isNaN(o7) ? e3.statistics[n5].nanCount = i8 + s11 : e3.statistics[n5].value = t8 + s11 * o7;
          break;
        }
        case "avg_angle": {
          e3.statistics[n5] || (e3.statistics[n5] = { x: 0, y: 0, nanCount: 0 });
          const t8 = e3.statistics[n5].x, i8 = e3.statistics[n5].y, a6 = e3.statistics[n5].nanCount ?? 0, r5 = Math.PI / 180;
          null == o7 || isNaN(o7) ? e3.statistics[n5].nanCount = a6 + s11 : (e3.statistics[n5].x = t8 + s11 * Math.cos(o7 * r5), e3.statistics[n5].y = i8 + s11 * Math.sin(o7 * r5));
          break;
        }
        case "mode": {
          e3.statistics[n5] || (e3.statistics[n5] = {});
          const t8 = e3.statistics[n5][o7] || 0;
          e3.statistics[n5][o7] = t8 + s11;
          break;
        }
      }
    }
  }
  _aggregateStatistics(t7, e3) {
    for (const s11 of this._statisticFields) {
      const i7 = s11.name;
      switch (s11.statisticType) {
        case "min": {
          if (!t7[i7]) {
            t7[i7] = { value: e3[i7].value };
            break;
          }
          const s12 = t7[i7].value;
          t7[i7].value = Math.min(s12, e3[i7].value);
          break;
        }
        case "max": {
          if (!t7[i7]) {
            t7[i7] = { value: e3[i7].value };
            break;
          }
          const s12 = t7[i7].value;
          t7[i7].value = Math.max(s12, e3[i7].value);
          break;
        }
        case "count":
          break;
        case "sum":
        case "avg":
        case "avg_angle":
        case "mode":
          t7[i7] || (t7[i7] = {});
          for (const s12 in e3[i7]) {
            const n5 = t7[i7][s12] || 0;
            t7[i7][s12] = n5 + e3[i7][s12];
          }
      }
    }
  }
  normalizeStatistics(t7, e3) {
    const s11 = {};
    for (const i7 of this._statisticFields) {
      const n5 = i7.name;
      switch (i7.statisticType) {
        case "min":
        case "max": {
          const i8 = t7[n5];
          if (!e3 || !i8)
            break;
          s11[n5] = i8.value;
          break;
        }
        case "count":
          if (!e3)
            break;
          s11[n5] = e3;
          break;
        case "sum": {
          if (!e3)
            break;
          const { value: i8, nanCount: o7 } = t7[n5];
          if (!(e3 - o7))
            break;
          s11[n5] = i8;
          break;
        }
        case "avg": {
          if (!e3)
            break;
          const { value: i8, nanCount: o7 } = t7[n5];
          if (!(e3 - o7))
            break;
          s11[n5] = i8 / (e3 - o7);
          break;
        }
        case "avg_angle": {
          if (!e3)
            break;
          const { x: i8, y: o7, nanCount: a6 } = t7[n5];
          if (!(e3 - a6))
            break;
          const r5 = i8 / (e3 - a6), l4 = o7 / (e3 - a6), h8 = 180 / Math.PI, c10 = Math.atan2(l4, r5) * h8;
          s11[n5] = c10;
          break;
        }
        case "mode": {
          const e4 = t7[n5];
          let i8 = 0, o7 = 0, a6 = null;
          for (const t8 in e4) {
            const s12 = e4[t8];
            s12 === i8 ? o7 += 1 : s12 > i8 && (i8 = s12, o7 = 1, a6 = t8);
          }
          s11[n5] = "null" === a6 || o7 > 1 ? null : a6;
          break;
        }
      }
    }
    return s11;
  }
};
var c9 = class {
  constructor(t7, e3, s11, i7) {
    this.count = 0, this.xTotal = 0, this.yTotal = 0, this.statistics = {}, this.displayId = 0, this.referenceId = 0, this.displayIds = /* @__PURE__ */ new Set(), this.next = null, this.depth = 0, this.xNode = 0, this.yNode = 0, this.xGeohashTotal = 0, this.yGeohashTotal = 0, this._tree = t7, this.children = new Array(32);
    for (let n5 = 0; n5 < this.children.length; n5++)
      this.children[n5] = null;
    this.xNode = e3, this.yNode = s11, this.depth = i7;
  }
  realloc(t7, e3, s11) {
    for (let i7 = 0; i7 < this.children.length; i7++)
      this.children[i7] = null;
    return this.xNode = t7, this.yNode = e3, this.depth = s11, this.next = null, this.xGeohashTotal = 0, this.yGeohashTotal = 0, this.displayId = 0, this.referenceId = 0, this.xTotal = 0, this.yTotal = 0, this.count = 0, this.statistics = {}, this.displayIds.clear(), this;
  }
  get id() {
    return `${this.xNode}.${this.yNode}`;
  }
  add(t7) {
    this.displayIds.add(t7);
  }
  remove(t7) {
    this.displayIds.delete(t7);
  }
  getAttributes() {
    const t7 = this._tree.normalizeStatistics(this.statistics, this.count);
    return t7.referenceId = null, t7.aggregateId = this.id, t7.aggregateCount = this.count, t7;
  }
  getGeometry(t7, e3) {
    const o7 = this.getLngLatBounds(), [l4, h8, c10, u6] = o7, d8 = j4({ rings: [[[l4, h8], [l4, u6], [c10, u6], [c10, h8], [l4, h8]]] }, f2.WGS84, t7), f6 = K(new t4(), d8, false, false);
    if (null != e3) {
      return ht(new t4(), f6, false, false, "esriGeometryPolygon", e3, false, false);
    }
    return f6;
  }
  getGeometryCentroid(t7, e3) {
    const i7 = this.getLngLatBounds(), [l4, h8, c10, u6] = i7, d8 = j4({ x: (l4 + c10) / 2, y: (h8 + u6) / 2 }, f2.WGS84, t7), f6 = L(new t4(), d8);
    if (null != e3) {
      return ht(new t4(), f6, false, false, "esriGeometryPoint", e3, false, false);
    }
    return f6;
  }
  getLngLatBounds() {
    const t7 = this.depth, s11 = Math.ceil(t7 / 2), i7 = Math.floor(t7 / 2), n5 = 30 - (3 * s11 + 2 * i7), o7 = 30 - (2 * s11 + 3 * i7), a6 = this.xNode << n5, r5 = this.yNode << o7;
    return X({ geohashX: a6, geohashY: r5 }, this.depth);
  }
  find(t7, e3, s11, i7, n5, o7) {
    if (i7 >= s11)
      return this;
    const a6 = 1 - i7 % 2, r5 = 3 * a6 + 2 * (1 - a6), l4 = 2 * a6 + 3 * (1 - a6), h8 = 30 - n5 - r5, c10 = 30 - o7 - l4, u6 = ((t7 & 7 * a6 + 3 * (1 - a6) << h8) >> h8) + ((e3 & 3 * a6 + 7 * (1 - a6) << c10) >> c10) * (8 * a6 + 4 * (1 - a6)), d8 = this.children[u6];
    return null == d8 ? null : d8.find(t7, e3, s11, i7 + 1, n5 + r5, o7 + l4);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/BinStore.js
var F2 = s.getLogger("esri.view.2d.layers.features.support.BinStore");
var S4 = 12;
var G2 = 64;
var R = i3();
var L2 = 5;
function T(e3) {
  return 57.29577951308232 * e3;
}
var A2 = class extends a2 {
  constructor(t7, s11, r5, i7) {
    super(t7, r5), this.type = "bin", this.events = new o(), this.objectIdField = "aggregateId", this.featureAdapter = I, this._geohashLevel = L2, this._geohashBuf = [], this._serviceInfo = i7, this.geometryInfo = t7.geometryInfo, this._spatialReference = s11, this._projectionSupportCheck = x(s11, f2.WGS84), this._bitsets.geohash = r5.getBitset(r5.createBitset()), this._bitsets.inserted = r5.getBitset(r5.createBitset());
  }
  destroy() {
    this._tree && this._tree.destroy();
  }
  get featureSpatialReference() {
    return this._spatialReference;
  }
  get fields() {
    return this._fields;
  }
  async updateSchema(e3, t7) {
    const o7 = this._schema;
    try {
      await super.updateSchema(e3, t7), await this._projectionSupportCheck;
    } catch (h8) {
    }
    this._fields = this._schema.params.fields, this._fieldsIndex = new Z(this._fields);
    const a6 = a(o7, t7);
    t7 && (null != a6 || e3.source || e3.storage.filters) ? ((s5(a6, "params.fields") || s5(a6, "params") || !this._tree || e3.source) && (this._tree && this._tree.destroy(), this._tree = new h7(this._statisticFields, this._serviceInfo), this._tree.onRelease = (e4) => e4.displayId && this._storage.releaseDisplayId(e4.displayId), this._geohashLevel = this._schema.params.fixedBinLevel, this._rebuildTree(), has("esri-2d-update-debug") && F2.info("Aggregate mesh needs update due to tree changing")), has("esri-2d-update-debug") && F2.info("Aggregate mesh needs update due to tree changing"), e3.targets[t7.name] = true, e3.mesh = false) : o7 && (e3.mesh = true);
  }
  clear() {
    this._rebuildTree();
  }
  sweepFeatures(e3, t7) {
    this._bitsets.inserted.forEachSet((s11) => {
      if (!e3.has(s11)) {
        const e4 = t7.lookupByDisplayIdUnsafe(s11);
        this._remove(e4);
      }
    });
  }
  sweepAggregates(e3, t7, s11) {
  }
  onTileData(e3, t7, s11, r5, i7, o7 = true) {
    if (!this._schema || null == t7.addOrUpdate)
      return t7;
    this.events.emit("changed");
    const a6 = this._getTransforms(e3, this._spatialReference);
    {
      const e4 = t7.addOrUpdate.getCursor();
      for (; e4.next(); )
        this._update(e4, r5);
    }
    if (t7.status.mesh || !o7)
      return t7;
    const h8 = new Array();
    this._getBinsForTile(h8, e3, a6, s11), t7.addOrUpdate = h4.fromOptimizedFeatures(h8, { fields: this.fields, fieldsIndex: this._fieldsIndex, geometryType: "esriGeometryPolygon", objectIdField: this.objectIdField }), t7.addOrUpdate.attachStorage(s11), t7.end = true, t7.isRepush || (t7.clear = true);
    {
      const r6 = t7.addOrUpdate.getCursor();
      for (; r6.next(); ) {
        const t8 = r6.getDisplayId();
        this._bitsets.computed.unset(t8), this.setComputedAttributes(s11, r6, t8, e3.scale, i7);
      }
    }
    return t7;
  }
  forEachBin(e3) {
    this._tree.forEach(e3);
  }
  forEach(e3) {
    this._tree.forEach((t7) => {
      if (t7.depth !== this._geohashLevel)
        return;
      const s11 = this._toFeatureJSON(t7), r5 = h4.fromFeatures([s11], { objectIdField: this.objectIdField, globalIdField: null, geometryType: this.geometryInfo.geometryType, fields: this.fields, fieldsIndex: this._fieldsIndex }).getCursor();
      r5.next(), e3(r5);
    });
  }
  forEachInBounds(e3, t7) {
  }
  forEachBounds(e3, t7) {
    const { hasM: s11, hasZ: r5 } = this.geometryInfo;
    for (const i7 of e3) {
      const e4 = yt(R, i7.readGeometry(), r5, s11);
      null != e4 && t7(e4);
    }
  }
  onTileUpdate(e3) {
  }
  getAggregate(e3) {
    const t7 = s6(e3, true), s11 = this._tree.findIf((e4) => e4.displayId === t7);
    return s11 ? this._toFeatureJSON(s11) : null;
  }
  getAggregates() {
    return this._tree.findAllIf((e3) => e3.depth === this._geohashLevel).map(this._toFeatureJSON.bind(this));
  }
  getDisplayId(e3) {
    var _a;
    return (_a = this._tree.findIf((t7) => t7.id === e3)) == null ? void 0 : _a.displayId;
  }
  getFeatureDisplayIdsForAggregate(e3) {
    const t7 = this._tree.findIf((t8) => t8.id === e3);
    return null != t7 ? Array.from(t7.displayIds) : [];
  }
  getDisplayIdForReferenceId(e3) {
    var _a;
    return (_a = this._tree.findIf((t7) => 1 === t7.displayIds.size && t7.displayIds.has(e3))) == null ? void 0 : _a.displayId;
  }
  _toFeatureJSON(e3) {
    const t7 = this._spatialReference;
    return { displayId: e3.displayId, attributes: e3.getAttributes(), geometry: st(e3.getGeometry(t7), "esriGeometryPolygon", false, false), centroid: null };
  }
  _rebuildTree() {
    this._bitsets.computed.clear(), this._bitsets.inserted.clear(), this._tree && this._tree.clear();
  }
  _remove(e3) {
    const t7 = e3.getDisplayId(), s11 = e3.getXHydrated(), r5 = e3.getYHydrated(), i7 = this._geohashBuf[2 * t7], o7 = this._geohashBuf[2 * t7 + 1];
    this._bitsets.inserted.has(t7) && (this._bitsets.inserted.unset(t7), this._tree.removeCursor(e3, s11, r5, i7, o7, this._geohashLevel));
  }
  _update(e3, t7) {
    const s11 = e3.getDisplayId(), r5 = this._bitsets.inserted, i7 = t7.isVisible(s11);
    if (i7 === r5.has(s11))
      return;
    if (!i7)
      return void this._remove(e3);
    const o7 = e3.getXHydrated(), a6 = e3.getYHydrated();
    if (!this._setGeohash(s11, o7, a6))
      return;
    const h8 = this._geohashBuf[2 * s11], n5 = this._geohashBuf[2 * s11 + 1];
    this._tree.insertCursor(e3, s11, o7, a6, h8, n5, this._geohashLevel), r5.set(s11);
  }
  _setGeohash(e3, t7, s11) {
    if (this._bitsets.geohash.has(e3))
      return true;
    const r5 = this._geohashBuf;
    if (this._spatialReference.isWebMercator) {
      const i7 = T(t7 / s4.radius), a6 = i7 - 360 * Math.floor((i7 + 180) / 360), h8 = T(Math.PI / 2 - 2 * Math.atan(Math.exp(-s11 / s4.radius)));
      b4(r5, e3, h8, a6, S4);
    } else {
      const i7 = j4({ x: t7, y: s11 }, this._spatialReference, f2.WGS84);
      if (!i7)
        return false;
      b4(r5, e3, i7.y, i7.x, S4);
    }
    return this._bitsets.geohash.set(e3), true;
  }
  _getBinsForTile(e3, t7, s11, r5) {
    try {
      const i7 = this._getGeohashBounds(t7), o7 = this._tree.getBins(i7);
      for (const t8 of o7) {
        t8.displayId || (t8.displayId = r5.createDisplayId(true));
        let i8 = null;
        const o8 = t8.getGeometry(this._spatialReference, s11.tile);
        o8 || (i8 = t8.getGeometryCentroid(this._spatialReference, s11.tile));
        const a6 = new t3(o8, t8.getAttributes(), i8);
        a6.objectId = t8.id, a6.displayId = t8.displayId, e3.push(a6);
      }
    } catch (i7) {
      return void F2.error("Unable to get bins for tile", t7.key.id);
    }
  }
  _getGeohash(e3, t7, s11) {
    const r5 = { geohashX: 0, geohashY: 0 };
    return Y(r5, t7, e3, s11), r5;
  }
  _getGeohashBounds(e3) {
    const t7 = this._getGeohashLevel(e3.key.level), s11 = [e3.extent.xmin, e3.extent.ymin, e3.extent.xmax, e3.extent.ymax], r5 = j3.fromExtent(M.fromBounds(s11, this._spatialReference)), i7 = j4(r5, this._spatialReference, f2.WGS84, { densificationStep: e3.resolution * G2 }), o7 = K(new t4(), i7, false, false), a6 = o7.coords.filter((e4, t8) => !(t8 % 2)), h8 = o7.coords.filter((e4, t8) => t8 % 2), n5 = Math.min(...a6), d8 = Math.min(...h8), l4 = Math.max(...a6), p7 = Math.max(...h8), f6 = this._getGeohash(n5, d8, t7), c10 = this._getGeohash(l4, p7, t7);
    return { bounds: s11, geohashBounds: { xLL: f6.geohashX, yLL: f6.geohashY, xTR: c10.geohashX, yTR: c10.geohashY }, level: t7 };
  }
  _getGeohashLevel(e3) {
    return this._schema.params.fixedBinLevel;
  }
  _getTransforms(e3, t7) {
    const s11 = { originPosition: "upperLeft", scale: [e3.resolution, e3.resolution], translate: [e3.bounds[0], e3.bounds[3]] }, r5 = G(t7);
    if (!r5)
      return { tile: s11, left: null, right: null };
    const [i7, o7] = r5.valid;
    return { tile: s11, left: { ...s11, translate: [o7, e3.bounds[3]] }, right: { ...s11, translate: [i7 - o7 + e3.bounds[0], e3.bounds[3]] } };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/ClusterStore.js
var C2 = 12;
var L3 = 64;
var w3 = 1;
var B = i3();
var S5 = class _S extends e2 {
  constructor(e3, t7, s11, r5, i7) {
    super(new t4([], [t7, s11]), r5, null, e3), this.geohashBoundsInfo = i7;
  }
  get count() {
    return this.attributes.cluster_count;
  }
  static create(e3, t7, s11, r5, i7, o7, a6, h8) {
    const l4 = new _S(t7, s11, r5, o7, a6);
    return l4.displayId = e3.createDisplayId(true), l4.referenceId = h8, l4.tileLevel = i7, l4;
  }
  update(e3, t7, s11, r5, i7, o7) {
    return this.geometry.coords[0] = e3, this.geometry.coords[1] = t7, this.tileLevel = s11, this.attributes = r5, this.geohashBoundsInfo = i7, this.referenceId = null, this.referenceId = o7, this;
  }
  toJSON() {
    return { attributes: { ...this.attributes, aggregateId: this.objectId, referenceId: 1 === this.attributes.cluster_count ? this.referenceId : null }, geometry: { x: this.geometry.coords[0], y: this.geometry.coords[1] } };
  }
};
function T2(e3) {
  return 57.29577951308232 * e3;
}
var V = class extends a2 {
  constructor(t7, s11, r5, i7) {
    super(t7, r5), this.type = "cluster", this.events = new o(), this.objectIdField = "aggregateId", this.featureAdapter = I, this._geohashLevel = 0, this._tileLevel = 0, this._aggregateValueRanges = {}, this._aggregateValueRangesChanged = false, this._geohashBuf = [], this._clusters = /* @__PURE__ */ new Map(), this._tiles = /* @__PURE__ */ new Map(), this._serviceInfo = i7, this.geometryInfo = t7.geometryInfo, this._spatialReference = s11, this._projectionSupportCheck = x(s11, f2.WGS84), this._bitsets.geohash = r5.getBitset(r5.createBitset()), this._bitsets.inserted = r5.getBitset(r5.createBitset());
  }
  destroy() {
    this._tree.destroy();
  }
  get featureSpatialReference() {
    return this._spatialReference;
  }
  get fields() {
    return this._fields;
  }
  async updateSchema(e3, i7) {
    const o7 = this._schema;
    try {
      await super.updateSchema(e3, i7), await this._projectionSupportCheck;
    } catch (h8) {
    }
    this._fields = [...this._schema.params.fields, { name: "referenceId", alias: "referenceId", type: "esriFieldTypeInteger" }];
    !!this._fields.some((e4) => "cluster_count" === e4.name) || this._fields.push({ name: "cluster_count", alias: "cluster_count", type: "esriFieldTypeInteger" }), this._fieldsIndex = new Z(this._fields);
    const a6 = a(o7, i7);
    i7 && (null != a6 || e3.source || e3.storage.filters) ? ((s5(a6, "params.fields") || !this._tree || e3.source) && (this._tree && this._tree.destroy(), this._tree = new h7(this._statisticFields, this._serviceInfo), this._rebuildTree(), has("esri-2d-update-debug") && console.debug("Aggregate mesh needs update due to tree changing")), has("esri-2d-update-debug") && console.debug("Applying Update - ClusterStore:", a6), e3.targets[i7.name] = true, e3.mesh = false, this._aggregateValueRanges = {}) : o7 && (e3.mesh = true);
  }
  clear() {
    this._rebuildTree();
  }
  sweepFeatures(e3, t7) {
    this._bitsets.inserted.forEachSet((s11) => {
      if (!e3.has(s11)) {
        const e4 = t7.lookupByDisplayIdUnsafe(s11);
        this._remove(e4);
      }
    });
  }
  sweepAggregates(e3, t7, s11) {
    this._clusters.forEach((r5, i7) => {
      r5 && r5.tileLevel !== s11 && (e3.releaseDisplayId(r5.displayId), t7.unsetAttributeData(r5.displayId), this._clusters.delete(i7));
    });
  }
  onTileData(e3, t7, s11, r5, i7, o7 = true) {
    if (!this._schema || null == t7.addOrUpdate)
      return t7;
    this.events.emit("changed");
    const a6 = this._getTransforms(e3, this._spatialReference);
    {
      const e4 = t7.addOrUpdate.getCursor();
      for (; e4.next(); )
        this._update(e4, r5);
    }
    if (t7.status.mesh || !o7)
      return t7;
    const h8 = new Array(), l4 = this._schema.params.clusterRadius;
    this._getClustersForTile(h8, e3, l4, s11, a6), t7.addOrUpdate = h4.fromOptimizedFeatures(h8, { fields: this.fields, fieldsIndex: this._fieldsIndex, geometryType: "esriGeometryPoint", objectIdField: this.objectIdField }), t7.addOrUpdate.attachStorage(s11), t7.clear = true, t7.end = true;
    {
      const r6 = t7.addOrUpdate.getCursor();
      for (; r6.next(); ) {
        const t8 = r6.getDisplayId();
        this._bitsets.computed.unset(t8), this.setComputedAttributes(s11, r6, t8, e3.scale, i7);
      }
    }
    return this._aggregateValueRangesChanged && t7.end && (this.events.emit("valueRangesChanged", { valueRanges: this._aggregateValueRanges }), this._aggregateValueRangesChanged = false), t7;
  }
  onTileUpdate({ added: e3, removed: t7 }) {
    if (e3.length) {
      const t8 = e3[0].level;
      this._tileLevel = t8, this._setGeohashLevel(t8);
    }
    if (!this._schema)
      return;
    const s11 = this._schema.params.clusterRadius;
    t7.forEach((e4) => {
      this._tiles.delete(e4.key.id), this._markTileClustersForDeletion(e4, s11);
    });
  }
  getAggregate(e3) {
    for (const t7 of this._clusters.values())
      if (((t7 == null ? void 0 : t7.displayId) & n2) == (e3 & n2))
        return t7.toJSON();
    return null;
  }
  getAggregates() {
    const e3 = [];
    for (const t7 of this._clusters.values())
      (t7 == null ? void 0 : t7.tileLevel) === this._tileLevel && e3.push(t7.toJSON());
    return e3;
  }
  getDisplayId(e3) {
    const t7 = this._clusters.get(e3);
    return t7 ? t7.displayId : null;
  }
  getFeatureDisplayIdsForAggregate(e3) {
    const t7 = this._clusters.get(e3);
    return t7 ? this._tree.getRegionDisplayIds(t7.geohashBoundsInfo) : [];
  }
  getDisplayIdForReferenceId(e3) {
    for (const t7 of this._clusters.values())
      if ((t7 == null ? void 0 : t7.referenceId) === e3)
        return t7.displayId;
    return null;
  }
  getAggregateValueRanges() {
    return this._aggregateValueRanges;
  }
  forEach(e3) {
    this._clusters.forEach((t7) => {
      if (!t7)
        return;
      const s11 = t7.toJSON(), r5 = h4.fromFeatures([s11], { objectIdField: this.objectIdField, globalIdField: null, geometryType: this.geometryInfo.geometryType, fields: this.fields, fieldsIndex: this._fieldsIndex }).getCursor();
      r5.next(), e3(r5);
    });
  }
  forEachInBounds(e3, t7) {
  }
  forEachBounds(e3, t7) {
    const { hasM: s11, hasZ: r5 } = this.geometryInfo;
    for (const i7 of e3) {
      const e4 = yt(B, i7.readGeometry(), r5, s11);
      null != e4 && t7(e4);
    }
  }
  size() {
    let e3 = 0;
    return this.forEach((t7) => e3++), e3;
  }
  _rebuildTree() {
    this._bitsets.computed.clear(), this._bitsets.inserted.clear(), this._tree && this._tree.clear();
  }
  _remove(e3) {
    const t7 = e3.getDisplayId(), s11 = e3.getXHydrated(), r5 = e3.getYHydrated(), i7 = this._geohashBuf[2 * t7], o7 = this._geohashBuf[2 * t7 + 1];
    this._bitsets.inserted.has(t7) && (this._bitsets.inserted.unset(t7), this._tree.removeCursor(e3, s11, r5, i7, o7, this._geohashLevel));
  }
  _update(e3, t7) {
    const s11 = e3.getDisplayId(), r5 = this._bitsets.inserted, i7 = t7.isVisible(s11);
    if (i7 === r5.has(s11))
      return;
    if (!i7)
      return void this._remove(e3);
    const o7 = e3.getXHydrated(), a6 = e3.getYHydrated();
    if (!this._setGeohash(s11, o7, a6))
      return;
    const h8 = this._geohashBuf[2 * s11], l4 = this._geohashBuf[2 * s11 + 1];
    this._tree.insertCursor(e3, s11, o7, a6, h8, l4, this._geohashLevel), r5.set(s11);
  }
  _setGeohash(e3, t7, s11) {
    if (this._bitsets.geohash.has(e3))
      return true;
    const r5 = this._geohashBuf;
    if (this._spatialReference.isWebMercator) {
      const o7 = T2(t7 / s4.radius), a6 = o7 - 360 * Math.floor((o7 + 180) / 360), l4 = T2(Math.PI / 2 - 2 * Math.atan(Math.exp(-s11 / s4.radius)));
      b4(r5, e3, l4, a6, C2);
    } else {
      const o7 = j4({ x: t7, y: s11 }, this._spatialReference, f2.WGS84);
      if (!o7)
        return false;
      b4(r5, e3, o7.y, o7.x, C2);
    }
    return this._bitsets.geohash.set(e3), true;
  }
  _getClustersForTile(e3, t7, s11, r5, i7, o7 = true) {
    const a6 = this._schema.params.clusterPixelBuffer, h8 = 2 * s11, l4 = Math.ceil(2 ** t7.key.level * c4 / h8) + 1, n5 = Math.ceil(a6 / h8) + 0, g4 = Math.ceil(c4 / h8), { row: c10, col: p7 } = t7.key, _4 = p7 * c4, m6 = c10 * c4, y5 = Math.floor(_4 / h8) - n5, b5 = Math.floor(m6 / h8) - n5, v3 = y5 + g4 + 2 * n5, R3 = b5 + g4 + 2 * n5, x4 = t7.tileInfoView.getLODInfoAt(t7.key.level);
    for (let I4 = y5; I4 <= v3; I4++)
      for (let s12 = b5; s12 <= R3; s12++) {
        let a7 = I4;
        x4.wrap && (a7 = I4 < 0 ? I4 + l4 : I4 % l4);
        const h9 = x4.wrap && I4 < 0, n6 = x4.wrap && I4 % l4 !== I4, g5 = this._lookupCluster(r5, x4, t7.key.level, a7, s12, t7);
        if (null != g5) {
          let t8 = null;
          if (i7 && (t8 = h9 ? i7.left : n6 ? i7.right : i7.tile), o7 && null == t8)
            continue;
          if (!g5.count)
            continue;
          if (null != t8 && o7) {
            const s13 = g5.geometry.clone();
            let r6 = g5.attributes;
            s13.coords[0] = M2(t8, s13.coords[0]), s13.coords[1] = N(t8, s13.coords[1]), 1 === g5.count && null != g5.referenceId && (r6 = { ...g5.attributes, referenceId: g5.referenceId });
            const i8 = new t3(s13, r6);
            i8.displayId = g5.displayId, e3.push(i8);
          }
        }
      }
  }
  _getGeohashLevel(e3) {
    return Math.min(Math.ceil(e3 / 2 + 2), C2);
  }
  _setGeohashLevel(e3) {
    const t7 = this._getGeohashLevel(e3), s11 = (Math.floor(t7 / w3) + 1) * w3 - 1;
    if (this._geohashLevel !== s11)
      return this._geohashLevel = s11, this._rebuildTree(), void this._bitsets.geohash.clear();
  }
  _getTransforms(e3, t7) {
    const s11 = { originPosition: "upperLeft", scale: [e3.resolution, e3.resolution], translate: [e3.bounds[0], e3.bounds[3]] }, r5 = G(t7);
    if (!r5)
      return { tile: s11, left: null, right: null };
    const [i7, o7] = r5.valid;
    return { tile: s11, left: { ...s11, translate: [o7, e3.bounds[3]] }, right: { ...s11, translate: [i7 - o7 + e3.bounds[0], e3.bounds[3]] } };
  }
  _getClusterId(e3, t7, s11) {
    return (15 & e3) << 28 | (16383 & t7) << 14 | 16383 & s11;
  }
  _markForDeletion(e3, t7, s11) {
    const r5 = this._getClusterId(e3, t7, s11);
    this._clusters.delete(r5);
  }
  _getClusterBounds(e3, t7, s11) {
    const r5 = this._schema.params.clusterRadius, i7 = 2 * r5;
    let o7 = s11 % 2 ? t7 * i7 : t7 * i7 - r5;
    const a6 = s11 * i7;
    let h8 = o7 + i7;
    const l4 = a6 - i7, n5 = 2 ** e3.level * c4;
    e3.wrap && o7 < 0 && (o7 = 0), e3.wrap && h8 > n5 && (h8 = n5);
    const u6 = o7 / c4, d8 = a6 / c4, g4 = h8 / c4, c10 = l4 / c4;
    return [e3.getXForColumn(u6), e3.getYForRow(d8), e3.getXForColumn(g4), e3.getYForRow(c10)];
  }
  _getGeohash(e3, t7, s11) {
    const r5 = { geohashX: 0, geohashY: 0 };
    return Y(r5, t7, e3, s11), r5;
  }
  _getGeohashBounds(e3, t7) {
    const s11 = this._getGeohashLevel(e3.key.level);
    if (this._spatialReference.isWebMercator) {
      const [e4, r6, i8, a7] = t7, l5 = { x: e4, y: r6 }, n6 = { x: i8, y: a7 };
      let u7 = 0, d9 = 0, g4 = 0, c11 = 0;
      {
        const e5 = T2(l5.x / s4.radius);
        u7 = e5 - 360 * Math.floor((e5 + 180) / 360), d9 = T2(Math.PI / 2 - 2 * Math.atan(Math.exp(-l5.y / s4.radius)));
      }
      {
        const e5 = T2(n6.x / s4.radius);
        g4 = e5 - 360 * Math.floor((e5 + 180) / 360), c11 = T2(Math.PI / 2 - 2 * Math.atan(Math.exp(-n6.y / s4.radius)));
      }
      const f7 = { geohashX: 0, geohashY: 0 }, p7 = { geohashX: 0, geohashY: 0 };
      Y(f7, d9, u7, s11), Y(p7, c11, g4, s11);
      return { bounds: [e4, r6, i8, a7], geohashBounds: { xLL: f7.geohashX, yLL: f7.geohashY, xTR: p7.geohashX, yTR: p7.geohashY }, level: s11 };
    }
    const r5 = j3.fromExtent(M.fromBounds(t7, this._spatialReference)), i7 = j4(r5, this._spatialReference, f2.WGS84, { densificationStep: e3.resolution * L3 });
    if (!i7)
      return null;
    const a6 = K(new t4(), i7, false, false), l4 = a6.coords.filter((e4, t8) => !(t8 % 2)), n5 = a6.coords.filter((e4, t8) => t8 % 2), u6 = Math.min(...l4), d8 = Math.min(...n5), c10 = Math.max(...l4), f6 = Math.max(...n5), _4 = this._getGeohash(u6, d8, s11), y5 = this._getGeohash(c10, f6, s11);
    return { bounds: t7, geohashBounds: { xLL: _4.geohashX, yLL: _4.geohashY, xTR: y5.geohashX, yTR: y5.geohashY }, level: s11 };
  }
  _lookupCluster(e3, t7, s11, r5, i7, o7) {
    const a6 = this._getClusterId(s11, r5, i7), h8 = this._clusters.get(a6), l4 = this._getClusterBounds(t7, r5, i7), n5 = this._getGeohashBounds(o7, l4);
    if (null == n5)
      return null;
    const u6 = this._tree.getRegionStatistics(n5), { count: d8, xTotal: g4, yTotal: c10, referenceId: f6 } = u6, p7 = d8 ? g4 / d8 : 0, _4 = d8 ? c10 / d8 : 0;
    if (0 === d8)
      return this._clusters.set(a6, null), null;
    const m6 = { cluster_count: d8, ...u6.attributes }, y5 = null != h8 ? h8.update(p7, _4, s11, m6, n5, f6) : S5.create(e3, a6, p7, _4, s11, m6, n5, f6);
    if (0 === d8) {
      const [e4, t8, s12, r6] = l4;
      y5.geometry.coords[0] = (e4 + s12) / 2, y5.geometry.coords[1] = (t8 + r6) / 2;
    }
    return this._clusters.set(a6, y5), this._updateAggregateValueRangeForCluster(y5, y5.tileLevel), y5;
  }
  _updateAggregateValueRangeForCluster(e3, t7) {
    const s11 = this._aggregateValueRanges[t7] || { minValue: 1 / 0, maxValue: 0 }, r5 = s11.minValue, i7 = s11.maxValue;
    s11.minValue = Math.min(r5, e3.count), s11.maxValue = Math.max(i7, e3.count), this._aggregateValueRanges[t7] = s11, r5 === s11.minValue && i7 === s11.maxValue || (this._aggregateValueRangesChanged = true);
  }
  _markTileClustersForDeletion(e3, t7) {
    const s11 = 2 * t7, r5 = Math.ceil(c4 / s11), { row: i7, col: o7 } = e3.key, a6 = o7 * c4, h8 = i7 * c4, l4 = Math.floor(a6 / s11), n5 = Math.floor(h8 / s11);
    for (let u6 = l4; u6 < l4 + r5; u6++)
      for (let t8 = n5; t8 < n5 + r5; t8++)
        this._markForDeletion(e3.key.level, u6, t8);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/controllers/FeatureController2D.js
var w4 = 5e3;
var x3 = "tileRenderer.featuresView.attributeView.initialize";
var T3 = "tileRenderer.featuresView.attributeView.requestUpdate";
var A3 = "tileRenderer.featuresView.requestRender";
function j6(e3) {
  return "worker:port-closed" === e3.name;
}
function k3(e3) {
  if (!b(e3) && !j6(e3))
    throw e3;
}
function U(e3) {
  return "feature" === e3.type && "snapshot" === e3.mode;
}
var R2 = class extends g {
  constructor() {
    super(...arguments), this._storage = new r3(), this._markedIdsBufId = this._storage.createBitset(), this._lastCleanup = performance.now(), this._cleanupNeeded = false, this._invalidated = false, this._tileToResolver = /* @__PURE__ */ new Map(), this._didEdit = false, this._updateVersion = 1, this._updatingHandles = new h(), this.tileStore = null, this.config = null, this.processor = null, this.remoteClient = null, this.service = null;
  }
  initialize() {
    this._initStores(), this._initSource(), this._updateQueue = new _({ concurrency: "stream" === this._source.type ? 1 : 4, process: (e3, t7) => this._onTileMessage(e3, { signal: t7 }) }), this.addHandles([this.tileStore.on("update", this.onTileUpdate.bind(this)), p(() => !this.updating, () => this.onIdle())]);
  }
  _initSource() {
    const e3 = this.tileStore.tileScheme, t7 = () => this._updateQueue && this._updateQueue.length < 50, r5 = (e4, t8) => (this._invalidated = true, this._patchTile(e4, t8));
    this._source = s10(this.service, { ...this.service, fieldsIndex: this.fieldsIndex }, this.spatialReference, e3, r5, t7, this.featureStore), this._proxyEvents();
  }
  _setStreamClientProperty(e3, t7) {
    this.remoteClient.invoke("setProperty", { propertyName: e3, value: t7 }).catch(k3);
  }
  _proxyEvents() {
    if ("stream" === this._source.type) {
      const e3 = this._source.events, t7 = this._source;
      this.addHandles([d2(() => t7.connectionStatus, (e4) => this._setStreamClientProperty("pipelineConnectionStatus", e4), { initial: true }), d2(() => t7.errorString, (e4) => this._setStreamClientProperty("pipelineErrorString", e4), { initial: true }), e3.on("data-received", (e4) => this.remoteClient.invoke("emitEvent", { name: "data-received", event: { attributes: e4.attributes, centroid: e4.centroid, geometry: e4.geometry } }).catch(k3)), e3.on("message-received", (e4) => this.remoteClient.invoke("emitEvent", { name: "message-received", event: e4 }).catch(k3)), e3.on("updateRate", (e4) => this.remoteClient.invoke("emitEvent", { name: "update-rate", event: { ...e4 } }).catch(k3))]);
    }
  }
  _initAttributeStore(e3) {
    this.attributeStore || (this.attributeStore = new k2({ type: "remote", initialize: (e4, t7) => d(this.remoteClient.invoke(x3, e4, { signal: t7 }).catch(k3)), update: (e4, t7) => d(this.remoteClient.invoke(T3, e4, { signal: t7 }).catch(k3)), render: (e4) => d(this.remoteClient.invoke(A3, void 0, { signal: e4 }).catch(k3)) }, e3));
  }
  _initStores() {
    const e3 = "snapshot" === this.service.type ? "snapshot" : "on-demand", t7 = { geometryInfo: { geometryType: this.service.geometryType, hasM: false, hasZ: false }, spatialReference: this.spatialReference, fieldsIndex: this.fieldsIndex };
    this.featureStore = new u2(t7, this._storage, e3);
  }
  _initQueryEngine(e3) {
    var _a;
    const t7 = this;
    (_a = this.featureQueryEngine) == null ? void 0 : _a.destroy(), this.featureQueryEngine = new W({ availableFields: e3.availableFields, definitionExpression: e3.schema.source.definitionExpression ?? void 0, fieldsIndex: Z.fromJSON(this.service.fieldsIndex), geometryType: this.service.geometryType, objectIdField: this.service.objectIdField, hasM: false, hasZ: false, spatialReference: this.spatialReference.toJSON(), cacheSpatialQueries: true, featureStore: this.featureStore, aggregateAdapter: { getFeatureObjectIds(e4) {
      if (null == t7.aggregateStore)
        return [];
      return t7.aggregateStore.getFeatureDisplayIdsForAggregate(e4).map((e5) => t7.getObjectId(e5));
    } }, timeInfo: this.service.timeInfo });
  }
  _initAggregateQueryEngine(e3, t7) {
    var _a;
    if ((_a = this.aggregateQueryEngine) == null ? void 0 : _a.destroy(), null == e3)
      return;
    const r5 = t7.targets.aggregate.params.fields.slice();
    this.aggregateQueryEngine = new W({ definitionExpression: void 0, fieldsIndex: Z.fromLayerJSON({ fields: r5, dateFieldsTimeReference: { timeZoneIANA: i } }), geometryType: e3.geometryInfo.geometryType, objectIdField: e3.objectIdField, hasM: e3.geometryInfo.hasM, hasZ: e3.geometryInfo.hasZ, spatialReference: this.spatialReference.toJSON(), cacheSpatialQueries: false, featureStore: e3, aggregateAdapter: { getFeatureObjectIds: (e4) => [] } });
  }
  destroy() {
    var _a, _b, _c;
    this._updateQueue.destroy(), this._source.destroy(), (_a = this.featureQueryEngine) == null ? void 0 : _a.destroy(), (_b = this.aggregateQueryEngine) == null ? void 0 : _b.destroy(), (_c = this.attributeStore) == null ? void 0 : _c.destroy();
    for (const e3 of this.tileStore.tiles)
      this._source.unsubscribe(e3);
    clearInterval(this._checkUpdating), this._updatingHandles.destroy();
  }
  get fieldsIndex() {
    return Z.fromJSON(this.service.fieldsIndex);
  }
  get spatialReference() {
    return this.tileStore.tileScheme.spatialReference;
  }
  get dataUpdating() {
    return this._source.updatingHandles.updating;
  }
  get updating() {
    return this.isUpdating();
  }
  isUpdating() {
    const e3 = this._source.updatingHandles.updating, t7 = !this.attributeStore || this.attributeStore.updatingHandles.updating, r5 = e3 || t7 || this._updatingHandles.updating;
    if (has("esri-2d-log-updating")) {
      let s11 = `Updating FeatureController2D: ${r5}
`;
      s11 += `  -> updatingSource ${e3}
`;
      for (const e4 of this._source.subscriptions)
        s11 += `     ${e4.tile.id} ${e4.isDone}
`;
      s11 += `  -> updatingAttributeStore ${t7}
`, s11 += `  -> updatingHandles ${this._updatingHandles.updating} (queue: ${this._updateQueue.length})
`, console.log(s11);
    }
    return r5;
  }
  updateCustomParameters(e3) {
    "stream" === this._source.type && this._source.updateCustomParameters(e3);
  }
  enableEvent(e3) {
    this._source.enableEvent(e3.name, e3.value);
  }
  pause() {
    this._updateQueue.pause(), this._updateQueue.clear();
  }
  resume() {
    this._updateQueue.resume();
  }
  pauseStream() {
    "stream" === this._source.type && this._source.pauseStream();
  }
  resumeStream() {
    "stream" === this._source.type && this._source.resumeStream();
  }
  sendMessageToSocket(e3) {
    "stream" === this._source.type && this._source.sendMessageToSocket(e3);
  }
  sendMessageToClient(e3) {
    "stream" === this._source.type && this._source.sendMessageToClient(e3);
  }
  _initAggregateStore(e3) {
    var _a, _b, _c, _d, _e;
    const t7 = ((_b = (_a = e3.schema.targets) == null ? void 0 : _a.aggregate) == null ? void 0 : _b.type) ?? null;
    if ((((_e = (_d = (_c = this.config) == null ? void 0 : _c.schema.targets) == null ? void 0 : _d.aggregate) == null ? void 0 : _e.type) ?? null) !== t7 && (null != this.aggregateStore && (this.removeHandles("valueRangesChanged"), this.aggregateStore.destroy(), this.aggregateStore = null), t7)) {
      switch (t7) {
        case "cluster": {
          const e4 = { geometryInfo: { geometryType: "esriGeometryPoint", hasM: false, hasZ: false }, spatialReference: this.spatialReference, fieldsIndex: this.fieldsIndex, fields: this.service.fields };
          this.aggregateStore = new V(e4, this.spatialReference, this._storage, { ...this.service, fieldsIndex: this.fieldsIndex }), this.addHandles(this.aggregateStore.events.on("valueRangesChanged", (e5) => {
            this.remoteClient.invoke("emitEvent", { name: "valueRangesChanged", event: { valueRanges: e5.valueRanges } }).catch(k3);
          }), "valueRangesChanged");
          break;
        }
        case "bin": {
          const e4 = { geometryInfo: { geometryType: "esriGeometryPolygon", hasM: false, hasZ: false }, spatialReference: this.spatialReference, fieldsIndex: this.fieldsIndex, fields: this.service.fields };
          this.aggregateStore = new A2(e4, this.spatialReference, this._storage, { ...this.service, fieldsIndex: this.fieldsIndex });
          break;
        }
      }
      this.aggregateStore.onTileUpdate({ added: this.tileStore.tiles, removed: [] });
    }
  }
  async update(e3, t7) {
    var _a;
    this._updateVersion++, has("esri-2d-update-debug") && console.debug(`FeatureController2D::update: Token version ${this._updateVersion}`), this._initQueryEngine(t7), this._initAttributeStore(t7), this.pause(), ((_a = this.config) == null ? void 0 : _a.timeZone) !== t7.timeZone && (e3.mesh = true, e3.storage.data = true, e3.storage.filters = true, e3.targets.aggregate = true, e3.targets.feature = true, this.featureStore.invalidate()), await Promise.all([this._source.update(e3, t7.schema.source), this.featureStore.updateSchema(e3, t7.schema.targets.feature), this.attributeStore.update(e3, t7), this.attributeStore.updateFilters(e3, t7, this)]), this._initAggregateStore(t7), null != this.aggregateStore && await this.aggregateStore.updateSchema(e3, t7.schema.targets.aggregate), this._initAggregateQueryEngine(this.aggregateStore, t7.schema), has("esri-2d-update-debug") && e3.describe(), this._set("config", t7);
  }
  async applyUpdate(e3) {
    e3.version = this._updateVersion, has("esri-2d-update-debug") && console.debug(`FeatureController2D::applyUpdate: Token version ${e3.version}`), e3.mesh && this.clearTiles(), this._updateQueue.resume(), await this._source.applyUpdate(e3), has("esri-2d-update-debug") && console.debug("FeatureController2D::applyUpdate Waiting for source update to finish"), this.notifyChange("updating"), await w(() => !this.updating), has("esri-2d-update-debug") && console.debug("FeatureController2D::applyUpdate Source update finsihed"), null != this.aggregateStore && (await A(10), has("esri-2d-update-debug") && console.debug("FeatureController2D::applyUpdate Waiting for aggregate idle call"), await w(() => !this.updating), has("esri-2d-update-debug") && console.debug("FeatureController2D::applyUpdate Aggregate idle called")), has("esri-2d-update-debug") && console.debug("FeatureController2D::applyUpdate Update finished");
  }
  async onEdits({ edits: e3 }) {
    has("esri-2d-update-debug") && console.debug("Applying Edit:", e3), this._didEdit = true;
    try {
      const t7 = e3.removed.map((e4) => e4.objectId && -1 !== e4.objectId ? e4.objectId : this._lookupObjectIdByGlobalId(e4.globalId)), r5 = e3.addOrModified.map(({ objectId: e4 }) => e4);
      this.featureStore.invalidate(), await this._source.edit(r5, t7), this.clearTiles(), this.notifyChange("updating"), null != this.aggregateStore && this.aggregateStore.clear(), await this._source.resend(), await w(() => !this.updating);
    } catch (t7) {
    }
  }
  async refresh(e3) {
    if (!e3.dataChanged) {
      const e4 = t6.empty();
      return e4.storage.filters = true, this.applyUpdate(e4);
    }
    this.featureStore.invalidate(), this.clearTiles(), this._source.refresh(this._updateVersion, e3), this._cleanupNeeded = true, this.notifyChange("updating"), await w(() => !this.updating);
  }
  clearTiles() {
    for (const e3 of this.tileStore.tiles)
      this.processor.onTileClear(e3, false);
  }
  onTileUpdate(e3) {
    null != this.aggregateStore && this.aggregateStore.onTileUpdate(e3);
    for (const t7 of e3.added) {
      const e4 = this._source.subscribe(t7, this._updateVersion);
      "stream" !== this._source.type && this._updatingHandles.addPromise(e4.done), this._level = t7.level;
    }
    for (const t7 of e3.removed)
      this._source.unsubscribe(t7), this._cleanupNeeded = true, this._tileToResolver.has(t7.id) && (this._tileToResolver.get(t7.id).resolve(), this._tileToResolver.delete(t7.id));
    this.notifyChange("updating");
  }
  async onIdle() {
    this._invalidated && (this._invalidated = false, null == this.aggregateStore && "heatmap" !== this.processor.type || await this._repushCurrentLevelTiles()), this._markAndSweep();
  }
  async querySummaryStatistics({ query: e3, params: t7 }) {
    return this.featureQueryEngine.executeQueryForSummaryStatistics(e3, t7);
  }
  async queryAggregateSummaryStatistics({ query: e3, params: t7 }) {
    return this.aggregateQueryEngine.executeQueryForSummaryStatistics(this._normalizeAggregateQuery(e3), t7);
  }
  async queryUniqueValues({ query: e3, params: t7 }) {
    return this.featureQueryEngine.executeQueryForUniqueValues(e3, t7);
  }
  async queryAggregateUniqueValues({ query: e3, params: t7 }) {
    return this.aggregateQueryEngine.executeQueryForUniqueValues(this._normalizeAggregateQuery(e3), t7);
  }
  async queryClassBreaks({ query: e3, params: t7 }) {
    return this.featureQueryEngine.executeQueryForClassBreaks(e3, t7);
  }
  async queryAggregateClassBreaks({ query: e3, params: t7 }) {
    return this.aggregateQueryEngine.executeQueryForClassBreaks(this._normalizeAggregateQuery(e3), t7);
  }
  async queryHistogram({ query: e3, params: t7 }) {
    return this.featureQueryEngine.executeQueryForHistogram(e3, t7);
  }
  async queryAggregateHistogram({ query: e3, params: t7 }) {
    return this.aggregateQueryEngine.executeQueryForHistogram(this._normalizeAggregateQuery(e3), t7);
  }
  queryExtent(e3) {
    return this.featureQueryEngine.executeQueryForExtent(e3);
  }
  queryAggregates(e3) {
    return this.aggregateQueryEngine.executeQuery(this._normalizeAggregateQuery(e3));
  }
  queryAggregateCount(e3) {
    return this.aggregateQueryEngine.executeQueryForCount(this._normalizeAggregateQuery(e3));
  }
  queryAggregateIds(e3) {
    return this.aggregateQueryEngine.executeQueryForIds(this._normalizeAggregateQuery(e3));
  }
  queryFeatures(e3) {
    return this.featureQueryEngine.executeQuery(e3);
  }
  async queryVisibleFeatures(e3) {
    const t7 = await this.featureQueryEngine.executeQuery(e3), r5 = t7.objectIdFieldName;
    return t7.features = t7.features.filter((e4) => {
      const t8 = e4.attributes[r5], s11 = this.getDisplayId(t8);
      return null != s11 && this.attributeStore.isVisible(s11);
    }), t7;
  }
  queryFeatureCount(e3) {
    return this.featureQueryEngine.executeQueryForCount(e3);
  }
  queryLatestObservations(e3) {
    return this.featureQueryEngine.executeQueryForLatestObservations(e3);
  }
  queryObjectIds(e3) {
    return this.featureQueryEngine.executeQueryForIds(e3);
  }
  async queryStatistics() {
    return this.featureStore.storeStatistics;
  }
  getObjectId(e3) {
    return this.featureStore.lookupObjectId(e3, this._storage);
  }
  getDisplayId(e3) {
    if (null != this.aggregateStore) {
      const t7 = this.aggregateStore.getDisplayId(e3);
      if (null == t7) {
        const t8 = this.featureStore.lookupDisplayId(e3);
        return this.aggregateStore.getDisplayIdForReferenceId(t8);
      }
      return t7;
    }
    return this.featureStore.lookupDisplayId(e3);
  }
  getFeatures(e3) {
    const t7 = [], r5 = [];
    for (const s11 of e3) {
      const e4 = null != this.aggregateStore ? this.getAggregate(s11) : null;
      if (null != e4)
        if (null != e4.attributes.referenceId) {
          const r6 = this.getFeature(e4.attributes.referenceId);
          null != r6 && t7.push(r6);
        } else
          r5.push(e4);
      else {
        const e5 = this.getFeature(s11);
        null != e5 && t7.push(e5);
      }
    }
    return { features: t7, aggregates: r5 };
  }
  getFeature(e3) {
    const t7 = this.featureStore.lookupFeatureByDisplayId(e3, this._storage);
    if (null == t7)
      return null;
    const r5 = t7.readHydratedGeometry(), s11 = st(r5, t7.geometryType, t7.hasZ, t7.hasM);
    return { attributes: t7.readAttributes(), geometry: s11 };
  }
  getAggregate(e3) {
    return null == this.aggregateStore ? null : this.aggregateStore.getAggregate(e3);
  }
  getAggregates() {
    return null == this.aggregateStore ? [] : this.aggregateStore.getAggregates();
  }
  async setHighlight(e3) {
    const t7 = e3.map((e4) => this.getDisplayId(e4)).filter(k);
    return this.attributeStore.setHighlight(e3, t7);
  }
  _normalizeAggregateQuery(e3) {
    const t7 = e3.objectIds ?? [];
    for (const r5 of e3.aggregateIds ?? [])
      t7.push(r5);
    return e3.objectIds = t7, e3.aggregateIds = [], e3;
  }
  _lookupObjectIdByGlobalId(e3) {
    const t7 = this.service.globalIdField;
    if (null == t7)
      throw new Error("Expected globalIdField to be defined");
    let r5 = null;
    if (this.featureStore.forEach((s11) => {
      e3 === s11.readAttribute(t7) && (r5 = s11.getObjectId());
    }), null == r5)
      throw new Error(`Expected to find a feature with globalId ${e3}`);
    return r5;
  }
  async _repushCurrentLevelTiles() {
    const e3 = this.tileStore.tiles.filter((e4) => e4.level === this._level);
    e3.map(async (e4) => this._patchTile({ type: "append", id: e4.key.id, clear: true, addOrUpdate: null, end: false }));
    const t7 = e3.map(async (e4) => this._patchTile({ type: "append", id: e4.key.id, addOrUpdate: h4.fromOptimizedFeatures([], { ...this.service, fieldsIndex: this.fieldsIndex }), remove: [], end: true, isRepush: true, status: t6.empty() }));
    await Promise.all(t7);
  }
  _maybeForceCleanup() {
    performance.now() - this._lastCleanup > w4 && this._markAndSweep();
  }
  _patchTile(e3, t7) {
    const r5 = this._updateQueue.push(e3, t7).catch((e4) => {
    });
    return this._updatingHandles.addPromise(r5);
  }
  async _onTileMessage(e3, t7) {
    var _a, _b, _c;
    if (s3(t7), has("esri-2d-update-debug")) {
      const t8 = (_a = e3.addOrUpdate) == null ? void 0 : _a.hasFeatures;
      console.debug(e3.id, `FeatureController:onTileMessage: [clear:${e3.clear}, end:${e3.end}, features: ${t8}]`);
    }
    const r5 = this.tileStore.get(e3.id);
    if (!r5)
      return;
    if (e3.clear)
      return this.processor.onTileClear(r5, e3.end);
    const s11 = e3.status;
    this._cleanupNeeded = true;
    const i7 = [];
    for (const a6 of e3.remove ?? []) {
      const e4 = this.featureStore.lookupDisplayId(a6);
      e4 && i7.push(e4);
    }
    e3.remove = i7;
    try {
      if (null == e3.addOrUpdate)
        return void this.processor.onTileMessage(r5, { ...e3, addOrUpdate: null }, null != this.aggregateStore, t7).catch(f);
      if (e3.addOrUpdate.setArcadeSpatialReference(this.spatialReference), this.featureStore.hasInstance(e3.addOrUpdate.instance) && s11.targets.feature || (s11.targets.feature = true, this.featureStore.onTileData(r5, e3, (_b = this.config) == null ? void 0 : _b.timeZone)), !s11.storage.data || !s11.storage.filters) {
        s11.storage.data = true, s11.storage.filters = true, this.attributeStore.onTileData(r5, e3);
        "stream" === this._source.type || this._didEdit ? (await this.attributeStore.sendUpdates(), s3(t7)) : this.attributeStore.sendUpdates();
      }
      if (null != this.aggregateStore && !s11.targets.aggregate) {
        s11.targets.aggregate = true;
        const t8 = U(this._source) && this._source.loading, i8 = !U(this._source) || t8 || e3.end;
        if (this.aggregateStore.onTileData(r5, e3, this._storage, this.attributeStore, (_c = this.config) == null ? void 0 : _c.timeZone, i8), !i8)
          return;
        s11.mesh || (this.attributeStore.onTileData(r5, e3), await this.attributeStore.sendUpdates());
      }
      if (!s11.mesh) {
        s11.mesh = true;
        const i8 = null != this.aggregateStore && "cluster" === this.aggregateStore.type;
        await this.processor.onTileMessage(r5, e3, i8, t7), s3(t7);
      }
      this._maybeForceCleanup();
    } catch (n5) {
      f(n5);
    }
  }
  _mark(e3, t7, r5) {
    const s11 = (4294901760 & this._storage.getInstanceId(e3)) >>> 16;
    e3 && (t7.add(s11), r5.set(e3));
  }
  _markAndSweep() {
    this._lastCleanup = performance.now();
    if (!(!("feature" === this._source.type && "snapshot" === this._source.mode) && ("stream" === this._source.type || this._cleanupNeeded)))
      return;
    this._cleanupNeeded = false;
    const e3 = this._storage.getBitset(this._markedIdsBufId), t7 = /* @__PURE__ */ new Set();
    e3.clear();
    for (const r5 of this.tileStore.tiles)
      for (const s11 of this._source.readers(r5.id)) {
        const r6 = s11.getCursor();
        for (; r6.next(); ) {
          let s12 = r6.getDisplayId();
          if (!s12) {
            const e4 = r6.getObjectId();
            s12 = this.featureStore.lookupDisplayId(e4);
          }
          this._mark(s12, t7, e3);
        }
      }
    "symbol" === this.processor.type && this.processor.forEachBufferId((r5) => {
      this._mark(r5, t7, e3);
    }), this._updateQueue.forEach((r5) => {
      for (const s11 of r5.remove ?? []) {
        const r6 = this.featureStore.lookupDisplayId(s11);
        this._mark(r6, t7, e3);
      }
    }), null != this.aggregateStore && (this.aggregateStore.sweepFeatures(e3, this.featureStore), "sweepAggregates" in this.aggregateStore && this.aggregateStore.sweepAggregates(this._storage, this.attributeStore, this._level)), this.featureStore.sweepFeatures(e3, this._storage, this.attributeStore), this.featureStore.sweepFeatureSets(t7);
  }
};
e([y({ constructOnly: true })], R2.prototype, "tileStore", void 0), e([y()], R2.prototype, "config", void 0), e([y({ readOnly: true })], R2.prototype, "fieldsIndex", null), e([y()], R2.prototype, "processor", void 0), e([y({ constructOnly: true })], R2.prototype, "remoteClient", void 0), e([y({ constructOnly: true })], R2.prototype, "service", void 0), e([y()], R2.prototype, "spatialReference", null), e([y()], R2.prototype, "dataUpdating", null), e([y()], R2.prototype, "updating", null), R2 = e([c("esri.views.2d.layers.features.controllers.FeatureController2D")], R2);
var q = R2;

// node_modules/@arcgis/core/views/2d/layers/features/Pipeline.js
var d7 = class extends g {
  constructor() {
    super(...arguments), this.controller = null, this.processor = null, this.remoteClient = null, this.tileStore = null, this.service = null, this.viewState = null, this._paused = false, this._pendingTileUpdates = [];
  }
  initialize() {
    this.addHandles([d2(() => this.updating, (e3) => {
      this.remoteClient.invoke("setUpdating", e3).catch((e4) => {
      });
    })]);
  }
  destroy() {
    var _a, _b;
    this.stop(), (_a = this.controller) == null ? void 0 : _a.destroy(), (_b = this.processor) == null ? void 0 : _b.destroy(), this.controller = this.processor = this.tileStore = this.remoteClient = null;
  }
  get updating() {
    return !this.controller || this.controller.updating;
  }
  stop() {
    var _a, _b, _c;
    this._paused = true, Array.isArray((_a = this.service) == null ? void 0 : _a.source) && (this.service.source.forEach((e3) => e3.close()), this.service.source.length = 0), (_b = this.tileStore) == null ? void 0 : _b.updateTiles({ added: [], removed: this.tileStore.tiles.map((e3) => e3.id) }), (_c = this.tileStore) == null ? void 0 : _c.destroy(), this.tileStore = null, this._pendingTileUpdates.length = 0;
  }
  async startup({ service: e3, config: t7, tileInfo: r5, tiles: s11 }) {
    var _a, _b, _c;
    if (this._paused = true, Array.isArray((_a = this.service) == null ? void 0 : _a.source) && (this.service.source.forEach((e4) => e4.close()), this.service.source.length = 0), this.service = e3, !this.tileStore || !d3(this.tileStore.tileScheme.spatialReference, r5.spatialReference)) {
      const e4 = new h3(j5.fromJSON(r5));
      s11.added.length = s11.removed.length = 0, (_b = this.tileStore) == null ? void 0 : _b.updateTiles({ added: [], removed: this.tileStore.tiles.map((e5) => e5.id) }), (_c = this.tileStore) == null ? void 0 : _c.destroy(), this.tileStore = new d5(e4), this._pendingTileUpdates.length = 0;
    }
    for (await this._createProcessorAndController(t7), await this.update({ config: t7 }), this.controller.resume(), this.tileStore.clear(), this.tileStore.updateTiles(s11), this._paused = false; this._pendingTileUpdates.length; )
      this.tileStore.updateTiles(this._pendingTileUpdates.pop());
  }
  async updateTiles(e3) {
    var _a;
    this._paused ? this._pendingTileUpdates.push(e3) : (_a = this.tileStore) == null ? void 0 : _a.updateTiles(e3);
  }
  async update({ config: e3 }) {
    const t7 = t6.empty();
    return await Promise.all([this.processor.update(t7, e3), this.controller.update(t7, e3)]), t7.toJSON();
  }
  async applyUpdate(e3) {
    return this.controller.applyUpdate(t6.create(e3));
  }
  async _createProcessorAndController(e3) {
    await Promise.all([this._handleControllerConfig(e3), this._handleProcessorConfig(e3)]), this.controller.processor = this.processor;
  }
  async _handleControllerConfig(e3) {
    return this._createController(this.service, e3);
  }
  async _handleProcessorConfig(e3) {
    return this._createProcessor(this.service, e3);
  }
  async _createController(e3, t7) {
    this.controller && (this.controller.destroy(), this.removeHandles("controller"));
    const { tileStore: s11, remoteClient: o7 } = this, i7 = new q({ service: e3, tileStore: s11, remoteClient: o7 }), l4 = d2(() => i7.dataUpdating, (e4) => {
      this.remoteClient.invoke("setDataUpdating", e4).catch((e5) => {
      });
    });
    return this.addHandles(l4, "controller"), this.controller = i7, i7;
  }
  async _createProcessor(e3, t7) {
    const r5 = t7.schema.processors[0].type, s11 = (await o3(r5)).default, { remoteClient: o7, tileStore: i7 } = this, l4 = new s11({ service: e3, config: t7, tileStore: i7, remoteClient: o7 });
    return this.processor && this.processor.destroy(), this.processor = l4, l4;
  }
};
e([y()], d7.prototype, "controller", void 0), e([y()], d7.prototype, "processor", void 0), e([y()], d7.prototype, "updating", null), e([y()], d7.prototype, "viewState", void 0), d7 = e([c("esri.views.2d.layers.features.Pipeline")], d7);
var u5 = d7;
export {
  u5 as default
};
//# sourceMappingURL=Pipeline-OAIVFN5H.js.map
