import {
  e
} from "./chunk-SZAJDZCO.js";
import {
  i
} from "./chunk-M7R7REMB.js";
import {
  DateTime
} from "./chunk-XZS3Q5K4.js";
import {
  t5 as t2
} from "./chunk-LXXF7K7W.js";
import {
  o,
  s3 as s,
  t
} from "./chunk-WJ3HJKNC.js";

// node_modules/@arcgis/core/widgets/support/dataUtils.js
function t3(n2) {
  return "string" == typeof n2 || n2 instanceof String;
}

// node_modules/@arcgis/core/widgets/support/dateUtils.js
var v = "yyyy-MM-dd";
var S = "TT";
var M;
!function(t5) {
  t5.HM = "HH:mm", t5.HMS = "HH:mm:ss", t5.HMS_MS = "HH:mm:ss.SSS";
}(M || (M = {}));
var O = [M.HMS_MS, M.HMS, M.HM, S];
function k2(t5) {
  return DateTime.fromFormat(t5, v);
}
function E2(t5) {
  let e2 = null;
  return O.find((n2) => (e2 = DateTime.fromFormat(t5, n2), e2.isValid)), e2;
}
function R(t5) {
  return DateTime.fromISO(t5);
}

// node_modules/@arcgis/core/layers/support/domainUtils.js
var t4;
!function(n2) {
  n2.VALUE_OUT_OF_RANGE = "domain-validation-error::value-out-of-range", n2.INVALID_CODED_VALUE = "domain-validation-error::invalid-coded-value";
}(t4 || (t4 = {}));
var r = /* @__PURE__ */ new Set(["integer", "small-integer", "big-integer", "esriFieldTypeInteger", "esriFieldTypeSmallInteger", "esriFieldTypeBigInteger"]);
function u(n2) {
  return null != n2 && r.has(n2.type);
}
function a(n2) {
  return null != n2 && ("date-only" === n2.type || "esriFieldTypeDateOnly" === n2.type);
}
function o2(n2) {
  return null != n2 && ("timestamp-offset" === n2.type || "esriFieldTypeTimestampOffset" === n2.type);
}
function s2(n2) {
  return null != n2 && ("time-only" === n2.type || "esriFieldTypeTimeOnly" === n2.type);
}
function m(n2, e2) {
  const l = n2 == null ? void 0 : n2.domain;
  if (!l)
    return null;
  switch (l.type) {
    case "range": {
      const { min: l2, max: i4 } = d(n2);
      if (null != l2 && +e2 < l2 || null != i4 && +e2 > i4)
        return t4.VALUE_OUT_OF_RANGE;
      break;
    }
    case "coded-value":
    case "codedValue":
      if (null == l.codedValues || l.codedValues.every((n3) => null == n3 || n3.code !== e2))
        return t4.INVALID_CODED_VALUE;
  }
  return null;
}
function d(n2, e2) {
  const l = e2 ?? (n2 == null ? void 0 : n2.domain);
  if (!l || "range" !== l.type)
    return;
  const i4 = "range" in l ? l.range[0] : l.minValue, t5 = "range" in l ? l.range[1] : l.maxValue, r2 = u(n2);
  return a(n2) || s2(n2) || o2(n2) ? { ...p(n2, t5, i4), isInteger: r2 } : { min: null != i4 && "number" == typeof i4 ? i4 : null, max: null != t5 && "number" == typeof t5 ? t5 : null, rawMin: i4, rawMax: t5, isInteger: r2 };
}
function p(t5, r2, u3) {
  if (a(t5)) {
    return { min: null != u3 && t3(u3) ? k2(u3).toMillis() : null, max: null != r2 && t3(r2) ? k2(r2).toMillis() : null, rawMin: u3, rawMax: r2 };
  }
  if (s2(t5)) {
    return { min: null != u3 && t3(u3) ? E2(u3).toMillis() : null, max: null != r2 && t3(r2) ? E2(r2).toMillis() : null, rawMin: u3, rawMax: r2 };
  }
  if (o2(t5)) {
    return { min: null != u3 && t3(u3) ? R(u3).toMillis() : null, max: null != r2 && t3(r2) ? R(r2).toMillis() : null, rawMin: u3, rawMax: r2 };
  }
  return { max: null, min: null };
}

// node_modules/@arcgis/core/layers/support/fieldUtils.js
var u2 = /^([0-9_])/;
var f = /[^a-z0-9_\u0080-\uffff]+/gi;
function d2(e2) {
  if (null == e2)
    return null;
  return e2.trim().replaceAll(f, "_").replace(u2, "F$1") || null;
}
var c2 = ["field", "field2", "field3", "normalizationField", "rotationInfo.field", "proportionalSymbolInfo.field", "proportionalSymbolInfo.normalizationField", "colorInfo.field", "colorInfo.normalizationField"];
var m2 = ["field", "normalizationField"];
function p2(e2, n2) {
  if (null != e2 && null != n2) {
    for (const i4 of Array.isArray(e2) ? e2 : [e2])
      if (y(c2, i4, n2), "visualVariables" in i4 && i4.visualVariables)
        for (const e3 of i4.visualVariables)
          y(m2, e3, n2);
  }
}
function y(e2, t5, r2) {
  if (e2)
    for (const l of e2) {
      const e3 = t(l, t5), o3 = e3 && "function" != typeof e3 && r2.get(e3);
      o3 && o(l, o3.name, t5);
    }
}
function g(e2, n2) {
  var _a;
  if (null != e2 && ((_a = n2 == null ? void 0 : n2.fields) == null ? void 0 : _a.length))
    if ("startField" in e2) {
      const i4 = n2.get(e2.startField), t5 = n2.get(e2.endField);
      e2.startField = (i4 == null ? void 0 : i4.name) ?? null, e2.endField = (t5 == null ? void 0 : t5.name) ?? null;
    } else {
      const i4 = n2.get(e2.startTimeField), t5 = n2.get(e2.endTimeField);
      e2.startTimeField = (i4 == null ? void 0 : i4.name) ?? null, e2.endTimeField = (t5 == null ? void 0 : t5.name) ?? null;
    }
}
var F = /* @__PURE__ */ new Set();
function I2(e2, n2) {
  return e2 && n2 ? (F.clear(), b(F, e2, n2), Array.from(F).sort()) : [];
}
function b(e2, n2, i4) {
  var _a;
  if (i4)
    if ((_a = n2 == null ? void 0 : n2.fields) == null ? void 0 : _a.length)
      if (i4.includes("*"))
        for (const { name: t5 } of n2.fields)
          e2.add(t5);
      else
        for (const t5 of i4)
          w(e2, n2, t5);
    else {
      if (i4.includes("*"))
        return e2.clear(), void e2.add("*");
      for (const n3 of i4)
        null != n3 && e2.add(n3);
    }
}
function w(e2, n2, i4) {
  if ("string" == typeof i4)
    if (n2) {
      const t5 = n2.get(i4);
      t5 && e2.add(t5.name);
    } else
      e2.add(i4);
}
function x2(e2, n2) {
  return null == n2 || null == e2 ? [] : n2.includes("*") ? (e2.fields ?? []).map((e3) => e3.name) : n2;
}
async function h(e2, n2, i4) {
  var _a;
  if (!i4)
    return;
  const { arcadeUtils: t5 } = await i(), r2 = t5.extractFieldNames(i4, (_a = n2 == null ? void 0 : n2.fields) == null ? void 0 : _a.map((e3) => e3.name));
  for (const l of r2)
    w(e2, n2, l);
}
async function E3(n2, i4, t5) {
  if (t5 && "1=1" !== t5) {
    const l = await e(t5, i4);
    if (!l.isStandardized)
      throw new s("fieldUtils:collectFilterFields", "Where clause is not standardized", { where: t5 });
    b(n2, i4, l.fieldNames);
  }
}
function _({ displayField: e2, fields: n2 }) {
  return e2 || ((n2 == null ? void 0 : n2.length) ? N(n2, "name-or-title") || N(n2, "unique-identifier") || N(n2, "type-or-category") || A(n2) : null);
}
function A(e2) {
  for (const n2 of e2) {
    if (!(n2 == null ? void 0 : n2.name))
      continue;
    const e3 = n2.name.toLowerCase();
    if (e3.includes("name") || e3.includes("title"))
      return n2.name;
  }
  return null;
}
function N(e2, n2) {
  for (const i4 of e2)
    if ((i4 == null ? void 0 : i4.valueType) && i4.valueType === n2)
      return i4.name;
  return null;
}
async function v2(e2, n2) {
  var _a;
  if (!n2)
    return;
  const i4 = (_a = n2.elevationInfo) == null ? void 0 : _a.featureExpressionInfo;
  return i4 ? i4.collectRequiredFields(e2, n2.fieldsIndex) : void 0;
}
function $(e2, n2, i4) {
  i4.onStatisticExpression ? h(e2, n2, i4.onStatisticExpression.expression) : e2.add(i4.onStatisticField);
}
async function L(e2, n2, i4) {
  if (!n2 || !i4 || !("fields" in i4))
    return;
  const t5 = [], r2 = i4.popupTemplate;
  t5.push(D(e2, n2, r2)), i4.fields && t5.push(...i4.fields.map(async (i5) => $(e2, n2.fieldsIndex, i5))), await Promise.all(t5);
}
async function D(e2, n2, i4) {
  const t5 = [];
  (i4 == null ? void 0 : i4.expressionInfos) && t5.push(...i4.expressionInfos.map((i5) => h(e2, n2.fieldsIndex, i5.expression)));
  const r2 = i4 == null ? void 0 : i4.content;
  if (Array.isArray(r2))
    for (const l of r2)
      "expression" === l.type && l.expressionInfo && t5.push(h(e2, n2.fieldsIndex, l.expressionInfo.expression));
  await Promise.all(t5);
}
async function M2(e2, n2, i4) {
  n2 && (n2.timeInfo && (i4 == null ? void 0 : i4.timeExtent) && b(e2, n2.fieldsIndex, [n2.timeInfo.startField, n2.timeInfo.endField]), n2.floorInfo && b(e2, n2.fieldsIndex, [n2.floorInfo.floorField]), null != (i4 == null ? void 0 : i4.where) && await E3(e2, n2.fieldsIndex, i4.where));
}
async function O2(e2, n2, i4) {
  n2 && i4 && await Promise.all(i4.map((i5) => V(e2, n2, i5)));
}
async function V(e2, n2, i4) {
  n2 && i4 && (i4.valueExpression ? await h(e2, n2.fieldsIndex, i4.valueExpression) : i4.field && w(e2, n2.fieldsIndex, i4.field));
}
function j2(e2) {
  return e2 ? I2(e2.fieldsIndex, z(e2)) : [];
}
function C(e2) {
  if (!e2)
    return [];
  const n2 = e2.geometryFieldsInfo;
  return n2 ? I2(e2.fieldsIndex, [n2.shapeAreaField, n2.shapeLengthField]) : [];
}
var R2 = /* @__PURE__ */ new Set(["oid", "global-id", "guid"]);
var G = /* @__PURE__ */ new Set(["oid", "global-id"]);
var k3 = [/^fnode_$/i, /^tnode_$/i, /^lpoly_$/i, /^rpoly_$/i, /^poly_$/i, /^subclass$/i, /^subclass_$/i, /^rings_ok$/i, /^rings_nok$/i, /shape/i, /perimeter/i, /objectid/i, /_i$/i];
function X(e2) {
  const n2 = /* @__PURE__ */ new Set();
  P(e2).forEach((e3) => n2.add(e3)), C(e2).forEach((e3) => n2.add(e3.toLowerCase()));
  const i4 = e2 && "infoFor3D" in e2 ? e2.infoFor3D : void 0;
  return i4 && (Object.values(i4.assetMapFieldRoles).forEach((e3) => n2.add(e3.toLowerCase())), Object.values(i4.transformFieldRoles).forEach((e3) => n2.add(e3.toLowerCase()))), Array.from(n2);
}
function z(e2) {
  if (!e2)
    return [];
  const n2 = "editFieldsInfo" in e2 && e2.editFieldsInfo;
  if (!n2)
    return [];
  const { creationDateField: i4, creatorField: t5, editDateField: r2, editorField: l } = n2;
  return [i4, t5, r2, l].filter(Boolean);
}
function P(e2) {
  return z(e2).map((e3) => e3.toLowerCase());
}
function B(e2, n2) {
  var _a;
  return e2.editable && !R2.has(e2.type) && !P(n2).includes(((_a = e2.name) == null ? void 0 : _a.toLowerCase()) ?? "");
}
function q(e2, n2) {
  var _a;
  const i4 = ((_a = e2.name) == null ? void 0 : _a.toLowerCase()) ?? "";
  return !(null != (n2 == null ? void 0 : n2.objectIdField) && i4 === n2.objectIdField.toLowerCase() || null != (n2 == null ? void 0 : n2.globalIdField) && i4 === n2.globalIdField.toLowerCase() || X(n2).includes(i4) || G.has(e2.type) || k3.some((e3) => e3.test(i4)));
}
async function J(e2, n2) {
  const { labelingInfo: i4, fieldsIndex: t5 } = n2;
  (i4 == null ? void 0 : i4.length) && await Promise.all(i4.map((n3) => W(e2, t5, n3)));
}
async function W(e2, n2, i4) {
  if (!i4)
    return;
  const t5 = i4.getLabelExpression(), r2 = i4.where;
  if ("arcade" === t5.type)
    await h(e2, n2, t5.expression);
  else {
    const i5 = t5.expression.match(/{[^}]*}/g);
    i5 && i5.forEach((i6) => {
      w(e2, n2, i6.slice(1, -1));
    });
  }
  await E3(e2, n2, r2);
}
function H(e2) {
  const n2 = e2.defaultValue;
  return void 0 !== n2 && re(e2, n2) ? n2 : e2.nullable ? null : void 0;
}
function K(e2) {
  const n2 = "string" == typeof e2 ? { type: e2 } : e2;
  return ye(n2) ? 255 : "esriFieldTypeDate" === n2.type || "date" === n2.type ? 8 : void 0;
}
function Q(e2) {
  return "number" == typeof e2 && !isNaN(e2) && isFinite(e2);
}
function Z(e2) {
  return null === e2 || Q(e2);
}
function ee(e2) {
  return null === e2 || Number.isInteger(e2);
}
function ne(e2) {
  return null != e2 && "string" == typeof e2;
}
function ie(e2) {
  return null === e2 || ne(e2);
}
function te() {
  return true;
}
function re(e2, n2) {
  let i4;
  switch (e2.type) {
    case "date":
    case "integer":
    case "long":
    case "small-integer":
    case "big-integer":
    case "esriFieldTypeDate":
    case "esriFieldTypeInteger":
    case "esriFieldTypeLong":
    case "esriFieldTypeSmallInteger":
    case "esriFieldTypeBigInteger":
      i4 = e2.nullable ? ee : Number.isInteger;
      break;
    case "double":
    case "single":
    case "esriFieldTypeSingle":
    case "esriFieldTypeDouble":
      i4 = e2.nullable ? Z : Q;
      break;
    case "string":
    case "esriFieldTypeString":
      i4 = e2.nullable ? ie : ne;
      break;
    default:
      i4 = te;
  }
  return 1 === arguments.length ? i4 : i4(n2);
}
var le = ["integer", "small-integer", "big-integer"];
var oe = ["single", "double"];
var se = [...le, ...oe];
var ae = ["esriFieldTypeInteger", "esriFieldTypeSmallInteger", "esriFieldTypeBigInteger"];
var ue = ["esriFieldTypeSingle", "esriFieldTypeDouble"];
var fe = /* @__PURE__ */ new Set([...le, ...ae]);
var de = /* @__PURE__ */ new Set([...oe, ...ue]);
var ce = t2(fe, de);
function pe(e2) {
  return null != e2 && ce.has(e2.type);
}
function ye(e2) {
  return null != e2 && ("string" === e2.type || "esriFieldTypeString" === e2.type);
}
function ge(e2) {
  return null != e2 && ("date" === e2.type || "esriFieldTypeDate" === e2.type);
}
function Fe(e2) {
  return null != e2 && ("date-only" === e2.type || "esriFieldTypeDateOnly" === e2.type);
}
function Ie(e2) {
  return null != e2 && ("timestamp-offset" === e2.type || "esriFieldTypeTimestampOffset" === e2.type);
}
function be(e2) {
  return null != e2 && ("time-only" === e2.type || "esriFieldTypeTimeOnly" === e2.type);
}
function we(e2) {
  return null != e2 && ("oid" === e2.type || "esriFieldTypeOID" === e2.type);
}
function xe(e2) {
  return null != e2 && ("global-id" === e2.type || "esriFieldTypeGlobalID" === e2.type);
}
function Te(e2, n2) {
  return null === Ae(e2, n2);
}
var he;
var Ee;
function _e(e2) {
  return null == e2 || "number" == typeof e2 && isNaN(e2) ? null : e2;
}
function Ae(e2, n2) {
  return null == e2 || e2.nullable && null === n2 ? null : pe(e2) && !Ne(e2.type, Number(n2)) ? he.OUT_OF_RANGE : re(e2, n2) ? e2.domain ? m(e2, n2) : null : Ee.INVALID_TYPE;
}
function Ne(e2, n2) {
  const i4 = "string" == typeof e2 ? ve(e2) : e2;
  if (!i4)
    return false;
  const t5 = i4.min, r2 = i4.max;
  return i4.isInteger ? Number.isInteger(n2) && n2 >= t5 && n2 <= r2 : n2 >= t5 && n2 <= r2;
}
function ve(e2) {
  switch (e2) {
    case "esriFieldTypeSmallInteger":
    case "small-integer":
      return Le;
    case "esriFieldTypeInteger":
    case "integer":
      return De;
    case "esriFieldTypeBigInteger":
    case "big-integer":
      return Me;
    case "esriFieldTypeSingle":
    case "single":
      return Oe;
    case "esriFieldTypeDouble":
    case "double":
      return Ve;
  }
}
!function(e2) {
  e2.OUT_OF_RANGE = "numeric-range-validation-error::out-of-range";
}(he || (he = {})), function(e2) {
  e2.INVALID_TYPE = "type-validation-error::invalid-type";
}(Ee || (Ee = {}));
var Le = { min: -32768, max: 32767, isInteger: true, rawMin: -32768, rawMax: 32767 };
var De = { min: -2147483648, max: 2147483647, isInteger: true, rawMin: -2147483648, rawMax: 2147483647 };
var Me = { min: -Number.MAX_SAFE_INTEGER, max: Number.MAX_SAFE_INTEGER, isInteger: true, rawMin: -Number.MAX_SAFE_INTEGER, rawMax: Number.MAX_SAFE_INTEGER };
var Oe = { min: -34e37, max: 12e37, isInteger: false, rawMin: -34e37, rawMax: 12e37 };
var Ve = { min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isInteger: false, rawMin: -Number.MAX_VALUE, rawMax: Number.MAX_VALUE };
function Ue(e2, n2, i4) {
  switch (e2) {
    case t4.INVALID_CODED_VALUE:
      return `Value ${i4} is not in the coded domain - field: ${n2.name}, domain: ${JSON.stringify(n2.domain)}`;
    case t4.VALUE_OUT_OF_RANGE:
      return `Value ${i4} is out of the range of valid values - field: ${n2.name}, domain: ${JSON.stringify(n2.domain)}`;
    case Ee.INVALID_TYPE:
      return `Value ${i4} is not a valid value for the field type - field: ${n2.name}, type: ${n2.type}, nullable: ${n2.nullable}`;
    case he.OUT_OF_RANGE: {
      const { min: e3, max: t5 } = ve(n2.type);
      return `Value ${i4} is out of range for the number type - field: ${n2.name}, type: ${n2.type}, value range is ${e3} to ${t5}`;
    }
  }
}
function je(e2, n2) {
  return !Ce(e2, n2, null);
}
function Ce(e2, n2, i4) {
  if (!(n2 == null ? void 0 : n2.attributes) || !e2) {
    if (null != i4)
      for (const n3 of e2 ?? [])
        i4.add(n3);
    return true;
  }
  const t5 = new Set(Object.keys(n2.attributes));
  let r2 = false;
  for (const l of e2)
    if (!t5.has(l)) {
      if (r2 = true, null == i4)
        break;
      i4.add(l);
    }
  return r2;
}
function Ge(e2) {
  return !!e2 && ["raster.itempixelvalue", "raster.servicepixelvalue"].some((n2) => e2.toLowerCase().startsWith(n2));
}

export {
  d,
  d2,
  p2 as p,
  g,
  I2 as I,
  b,
  w,
  x2 as x,
  h,
  _,
  v2 as v,
  L,
  M2 as M,
  O2 as O,
  j2 as j,
  B,
  q,
  J,
  H,
  K,
  pe,
  ye,
  ge,
  Fe,
  Ie,
  be,
  we,
  xe,
  Te,
  _e,
  Ae,
  Ue,
  je,
  Ge
};
//# sourceMappingURL=chunk-Z6KIMOUA.js.map
