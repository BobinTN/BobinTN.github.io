import {
  I
} from "./chunk-6JCSK7BN.js";
import {
  y,
  z
} from "./chunk-XZLDDXLF.js";
import {
  n as n4
} from "./chunk-B7TIRUHV.js";
import {
  c,
  e,
  i as i2,
  n as n3,
  o
} from "./chunk-EY7PGBJG.js";
import {
  i,
  n2
} from "./chunk-L7F73IMH.js";
import {
  u
} from "./chunk-G557TGXY.js";
import {
  j,
  t3 as t
} from "./chunk-R5DM4YAB.js";
import {
  n
} from "./chunk-WGO3VFQP.js";
import {
  s3 as s
} from "./chunk-WJ3HJKNC.js";
import {
  has
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/symbols/support/svgUtils.js
var h = "http://www.w3.org/2000/svg";
var f = 0;
var c2 = 0;
var d = has("android");
var u2 = has("chrome") || d && d >= 4 ? "auto" : "optimizeLegibility";
var y2 = { m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7, z: 0 };
var p = /([A-DF-Za-df-z])|([-+]?\d*[.]?\d+(?:[eE][-+]?\d+)?)/g;
var g = {};
var m = {};
var x = { solid: "none", shortdash: [4, 1], shortdot: [1, 1], shortdashdot: [4, 1, 1, 1], shortdashdotdot: [4, 1, 1, 1, 1, 1], dot: [1, 3], dash: [4, 3], longdash: [8, 3], dashdot: [4, 3, 1, 3], longdashdot: [8, 3, 1, 3], longdashdotdot: [8, 3, 1, 3, 1, 3] };
var w = Math.PI;
var k = 1;
function b(t2, e2) {
  const i3 = t2 * (w / 180);
  return Math.abs(e2 * Math.sin(i3)) + Math.abs(e2 * Math.cos(i3));
}
function j2(t2) {
  return t2.map((t3) => `${t3.command} ${t3.values.join(" ")}`).join(" ").trim();
}
function v(t2, i3, n5, r) {
  if (t2) {
    if ("circle" === t2.type)
      return n2("circle", { cx: t2.cx, cy: t2.cy, fill: i3, "fill-rule": "evenodd", r: t2.r, stroke: n5.color, "stroke-dasharray": n5.dashArray, "stroke-dashoffset": n5.dashOffset, "stroke-linecap": n5.cap, "stroke-linejoin": n5.join, "stroke-miterlimit": "4", "stroke-width": n5.width });
    if ("ellipse" === t2.type)
      return n2("ellipse", { cx: t2.cx, cy: t2.cy, fill: i3, "fill-rule": "evenodd", rx: t2.rx, ry: t2.ry, stroke: n5.color, "stroke-dasharray": n5.dashArray, "stroke-linecap": n5.cap, "stroke-linejoin": n5.join, "stroke-miterlimit": "4", "stroke-width": n5.width });
    if ("rect" === t2.type)
      return n2("rect", { fill: i3, "fill-rule": "evenodd", height: t2.height, stroke: n5.color, "stroke-dasharray": n5.dashArray, "stroke-linecap": n5.cap, "stroke-linejoin": n5.join, "stroke-miterlimit": "4", "stroke-width": n5.width, width: t2.width, x: t2.x, y: t2.y });
    if ("image" === t2.type)
      return n2("image", { height: t2.height, href: t2.src, preserveAspectRatio: "none", width: t2.width, x: t2.x, y: t2.y });
    if ("path" === t2.type) {
      const e2 = "string" != typeof t2.path ? j2(t2.path) : t2.path;
      return n2("path", { d: e2, fill: i3, "fill-rule": "evenodd", stroke: n5.color, "stroke-dasharray": n5.dashArray, "stroke-linecap": n5.cap, "stroke-linejoin": n5.join, "stroke-miterlimit": "4", "stroke-width": n5.width });
    }
    if ("text" === t2.type)
      return n(r), n2("text", { "dominant-baseline": r.dominantBaseline, fill: i3, "fill-rule": "evenodd", "font-family": r.font.family, "font-size": r.font.size, "font-style": r.font.style, "font-variant": r.font.variant, "font-weight": r.font.weight, kerning: r.kerning, rotate: r.rotate, stroke: n5.color, "stroke-dasharray": n5.dashArray, "stroke-linecap": n5.cap, "stroke-linejoin": n5.join, "stroke-miterlimit": "4", "stroke-width": n5.width, "text-anchor": r.align, "text-decoration": r.decoration, "text-rendering": u2, x: t2.x, y: t2.y }, t2.text);
  }
  return null;
}
function M(e2) {
  const i3 = { fill: "none", pattern: null, linearGradient: null };
  if (e2) {
    if ("type" in e2 && "pattern" === e2.type) {
      const t2 = "patternId-" + ++f;
      i3.fill = `url(#${t2})`, i3.pattern = { id: t2, x: e2.x, y: e2.y, width: e2.width, height: e2.height, image: { x: 0, y: 0, width: e2.width, height: e2.height, href: e2.src } };
    } else if ("type" in e2 && "linear" === e2.type) {
      const n5 = "linearGradientId-" + ++c2;
      i3.fill = `url(#${n5})`, i3.linearGradient = { id: n5, x1: e2.x1, y1: e2.y1, x2: e2.x2, y2: e2.y2, stops: e2.colors.map((e3) => ({ offset: e3.offset, color: e3.color && new u(e3.color).toString() })) };
    } else if (e2) {
      const n5 = new u(e2);
      i3.fill = n5.toString();
    }
  }
  return i3;
}
function A(e2) {
  const i3 = { color: "none", width: 1, cap: "butt", join: "4", dashArray: "none", dashOffset: "0" };
  if (e2 && (null != e2.width && (i3.width = e2.width), e2.cap && (i3.cap = e2.cap), e2.join && (i3.join = e2.join.toString()), e2.color && (i3.color = new u(e2.color).toString()), e2.dashArray && (i3.dashArray = e2.dashArray), e2.dashArray && (i3.dashOffset = e2.dashoffset), e2.style)) {
    let t2 = null;
    if (e2.style in x && (t2 = x[e2.style]), Array.isArray(t2)) {
      t2 = t2.slice(0);
      const i4 = e2.width ?? 0;
      for (let e3 = 0; e3 < t2.length; ++e3)
        t2[e3] *= i4;
      if ("butt" !== e2.cap) {
        for (let e3 = 0; e3 < t2.length; e3 += 2)
          t2[e3] -= i4, t2[e3] < 1 && (t2[e3] = 1);
        for (let e3 = 1; e3 < t2.length; e3 += 2)
          t2[e3] += i4;
      }
      t2 = t2.join(",");
    }
    i3.dashArray = t2;
  }
  return i3;
}
function S(t2, i3) {
  const n5 = { align: null, decoration: null, kerning: null, rotate: null, font: { style: null, variant: null, weight: null, size: null, family: null } };
  if (t2) {
    const r = t2.alignBaseline, o2 = "baseline" === r ? "auto" : "top" === r ? "text-top" : "bottom" === r ? "hanging" : r;
    n5.align = t2.align, n5.dominantBaseline = o2, n5.decoration = t2.decoration, n5.kerning = t2.kerning ? "auto" : "0", n5.rotate = t2.rotated ? "90" : "0", n(i3), n5.font.style = i3.style || "normal", n5.font.variant = i3.variant || "normal", n5.font.weight = i3.weight || "normal", n5.font.size = i3.size && i3.size.toString() || "10pt", n5.font.family = i3.family || "serif";
  }
  return n5;
}
function $(t2) {
  const { pattern: e2, linearGradient: i3 } = t2;
  if (e2)
    return n2("pattern", { height: e2.height, id: e2.id, patternUnits: "userSpaceOnUse", width: e2.width, x: e2.x, y: e2.y }, n2("image", { height: e2.image.height, href: e2.image.href, width: e2.image.width, x: e2.image.x, y: e2.image.y }));
  if (i3) {
    const t3 = i3.stops.map((t4, e3) => n2("stop", { key: `${e3}-stop`, offset: t4.offset, "stop-color": t4.color }));
    return n2("linearGradient", { gradientUnits: "userSpaceOnUse", id: i3.id, x1: i3.x1, x2: i3.x2, y1: i3.y1, y2: i3.y2 }, t3);
  }
  return null;
}
function N(t2, e2) {
  if (!t2 || 0 === t2.length)
    return null;
  const i3 = [];
  for (const n5 of t2) {
    const { shape: t3, fill: e3, stroke: r, font: o2 } = n5, s3 = M(e3), a = A(r), l2 = "text" === t3.type ? S(t3, o2) : null, h3 = v(t3, s3.fill, a, l2);
    h3 && i3.push(h3);
  }
  return n2("mask", { id: e2, maskUnits: "userSpaceOnUse" }, n2("g", null, i3));
}
function G(t2, e2, i3) {
  return i2(t2, n3(t2), [e2, i3]);
}
function I2(t2, e2, i3, n5, r) {
  return c(t2, n3(t2), [e2, i3]), t2[4] = t2[4] * e2 - n5 * e2 + n5, t2[5] = t2[5] * i3 - r * i3 + r, t2;
}
function z2(t2, e2, i3, n5) {
  const r = e2 % 360 * Math.PI / 180;
  e(t2, n3(t2), r);
  const s3 = Math.cos(r), l2 = Math.sin(r), h3 = t2[4], f3 = t2[5];
  return t2[4] = h3 * s3 - f3 * l2 + n5 * l2 - i3 * s3 + i3, t2[5] = f3 * s3 + h3 * l2 - i3 * l2 - n5 * s3 + n5, t2;
}
function B(t2, e2) {
  g && "left" in g ? (null != g.left && g.left > t2 && (g.left = t2), (null == g.right || g.right < t2) && (g.right = t2), (null == g.top || g.top > e2) && (g.top = e2), (null == g.bottom || g.bottom < e2) && (g.bottom = e2)) : g = { left: t2, bottom: e2, right: t2, top: e2 };
}
function U(t2) {
  const e2 = t2.args, i3 = e2.length;
  let n5;
  switch (t2.action) {
    case "M":
    case "L":
    case "C":
    case "S":
    case "Q":
    case "T":
      for (n5 = 0; n5 < i3; n5 += 2)
        B(e2[n5], e2[n5 + 1]);
      m.x = e2[i3 - 2], m.y = e2[i3 - 1];
      break;
    case "H":
      for (n5 = 0; n5 < i3; ++n5)
        B(e2[n5], m.y);
      m.x = e2[i3 - 1];
      break;
    case "V":
      for (n5 = 0; n5 < i3; ++n5)
        B(m.x, e2[n5]);
      m.y = e2[i3 - 1];
      break;
    case "m": {
      let t3 = 0;
      "x" in m || (B(m.x = e2[0], m.y = e2[1]), t3 = 2);
      for (n5 = t3; n5 < i3; n5 += 2)
        B(m.x += e2[n5], m.y += e2[n5 + 1]);
      break;
    }
    case "l":
    case "t":
      for (n5 = 0; n5 < i3; n5 += 2)
        B(m.x += e2[n5], m.y += e2[n5 + 1]);
      break;
    case "h":
      for (n5 = 0; n5 < i3; ++n5)
        B(m.x += e2[n5], m.y);
      break;
    case "v":
      for (n5 = 0; n5 < i3; ++n5)
        B(m.x, m.y += e2[n5]);
      break;
    case "c":
      for (n5 = 0; n5 < i3; n5 += 6)
        B(m.x + e2[n5], m.y + e2[n5 + 1]), B(m.x + e2[n5 + 2], m.y + e2[n5 + 3]), B(m.x += e2[n5 + 4], m.y += e2[n5 + 5]);
      break;
    case "s":
    case "q":
      for (n5 = 0; n5 < i3; n5 += 4)
        B(m.x + e2[n5], m.y + e2[n5 + 1]), B(m.x += e2[n5 + 2], m.y += e2[n5 + 3]);
      break;
    case "A":
      for (n5 = 0; n5 < i3; n5 += 7)
        B(e2[n5 + 5], e2[n5 + 6]);
      m.x = e2[i3 - 2], m.y = e2[i3 - 1];
      break;
    case "a":
      for (n5 = 0; n5 < i3; n5 += 7)
        B(m.x += e2[n5 + 5], m.y += e2[n5 + 6]);
  }
}
function F(t2, e2, i3) {
  const n5 = y2[t2.toLowerCase()];
  let r;
  "number" == typeof n5 && (n5 ? e2.length >= n5 && (r = { action: t2, args: e2.slice(0, e2.length - e2.length % n5) }, i3.push(r), U(r)) : (r = { action: t2, args: [] }, i3.push(r), U(r)));
}
function O(t2) {
  const e2 = ("string" != typeof t2.path ? j2(t2.path) : t2.path).match(p), i3 = [];
  if (g = {}, m = {}, !e2)
    return null;
  let n5 = "", r = [];
  const o2 = e2.length;
  for (let a = 0; a < o2; ++a) {
    const t3 = e2[a], o3 = parseFloat(t3);
    isNaN(o3) ? (n5 && F(n5, r, i3), r = [], n5 = t3) : r.push(o3);
  }
  F(n5, r, i3);
  const s3 = { x: 0, y: 0, width: 0, height: 0 };
  return g && "left" in g && (s3.x = g.left, s3.y = g.top, s3.width = g.right - g.left, s3.height = g.bottom - g.top), s3;
}
function T(t2) {
  const e2 = { x: 0, y: 0, width: 0, height: 0 };
  if ("circle" === t2.type)
    e2.x = t2.cx - t2.r, e2.y = t2.cy - t2.r, e2.width = 2 * t2.r, e2.height = 2 * t2.r;
  else if ("ellipse" === t2.type)
    e2.x = t2.cx - t2.rx, e2.y = t2.cy - t2.ry, e2.width = 2 * t2.rx, e2.height = 2 * t2.ry;
  else if ("image" === t2.type || "rect" === t2.type)
    e2.x = t2.x, e2.y = t2.y, e2.width = t2.width, e2.height = t2.height;
  else if ("path" === t2.type) {
    const i3 = O(t2);
    e2.x = i3.x, e2.y = i3.y, e2.width = i3.width, e2.height = i3.height;
  }
  return e2;
}
function E(t2) {
  const e2 = { x: 0, y: 0, width: 0, height: 0 };
  let i3 = null, n5 = Number.NEGATIVE_INFINITY, r = Number.NEGATIVE_INFINITY;
  for (const o2 of t2)
    i3 ? (i3.x = Math.min(i3.x, o2.x), i3.y = Math.min(i3.y, o2.y), n5 = Math.max(n5, o2.x + o2.width), r = Math.max(r, o2.y + o2.height)) : (i3 = e2, i3.x = o2.x, i3.y = o2.y, n5 = o2.x + o2.width, r = o2.y + o2.height);
  return i3 && (i3.width = n5 - i3.x, i3.height = r - i3.y), i3;
}
function V(t2, e2, r, o2, s3, a, l2, h3, f3) {
  let c3 = (l2 && a ? b(a, e2) : e2) / 2, d3 = (l2 && a ? b(a, r) : r) / 2;
  if (f3) {
    const t3 = f3[0], e3 = f3[1];
    c3 = (l2 && a ? b(a, t3) : t3) / 2, d3 = (l2 && a ? b(a, e3) : e3) / 2;
  }
  const u4 = t2.width + o2, y3 = t2.height + o2, p2 = n4(), g3 = n4();
  let m3 = false;
  if (s3 && 0 !== u4 && 0 !== y3) {
    const t3 = e2 !== r ? e2 / r : u4 / y3, i3 = e2 > r ? e2 : r;
    let o3 = 1, s4 = 1;
    isNaN(i3) || (t3 > 1 ? (o3 = i3 / u4, s4 = i3 / t3 / y3) : (s4 = i3 / y3, o3 = i3 * t3 / u4)), o(g3, g3, I2(p2, o3, s4, c3, d3)), m3 = true;
  }
  const x2 = t2.x + (u4 - o2) / 2, w2 = t2.y + (y3 - o2) / 2;
  if (o(g3, g3, G(p2, c3 - x2, d3 - w2)), !m3 && (u4 > e2 || y3 > r)) {
    const t3 = u4 / e2 > y3 / r, i3 = (t3 ? e2 : r) / (t3 ? u4 : y3);
    o(g3, g3, I2(p2, i3, i3, x2, w2));
  }
  return a && o(g3, g3, z2(p2, a, x2, w2)), h3 && o(g3, g3, G(p2, h3[0], h3[1])), `matrix(${g3[0]},${g3[1]},${g3[2]},${g3[3]},${g3[4]},${g3[5]})`;
}
function C(t2, e2, i3) {
  const n5 = t2 == null ? void 0 : t2.effects.find((t3) => "bloom" === t3.type);
  if (!n5)
    return null;
  const { strength: r, radius: o2 } = n5, s3 = r > 0 ? o2 : 0, a = (r + s3) * e2, h3 = 4 * r + 1;
  return n2("filter", { filterUnits: "userSpaceOnUse", height: "300%", id: `bloom${i3}`, width: "300%", x: "-100%", y: "-100%" }, n2("feMorphology", { in: "SourceGraphic", operator: "dilate", radius: (r + 0.5 * s3) * (5 ** (e2 / 100) * (0.4 + e2 / 100)), result: "dilate" }), n2("feGaussianBlur", { in: "dilate", result: "blur", stdDeviation: a / 25 }), n2("feGaussianBlur", { in: "blur", result: "intensityBlur", stdDeviation: a / 50 }), n2("feComponentTransfer", { in: "SourceGraphic", result: "intensityBrightness" }, n2("feFuncR", { slope: h3, type: "linear" }), n2("feFuncG", { slope: h3, type: "linear" }), n2("feFuncB", { slope: h3, type: "linear" })), n2("feMerge", null, n2("feMergeNode", { in: "intensityBlur" }), n2("feMergeNode", { in: "intensityBrightness" }), n2("feGaussianBlur", { stdDeviation: r / 10 })));
}
function D(t2, i3, n5, r = {}) {
  var _a;
  const o2 = [], s3 = [], a = ++k, f3 = C(r.effectView, i3, a);
  let c3 = null;
  if (f3) {
    const t3 = (_a = r.effectView) == null ? void 0 : _a.effects.find((t4) => "bloom" === t4.type), e2 = (t3.strength ? t3.strength + t3.radius / 2 : 0) / 3, o3 = i3 + i3 * e2, s4 = n5 + n5 * e2;
    c3 = [Math.max(o3, 10), Math.max(s4, 10)];
  }
  for (let e2 = 0; e2 < t2.length; e2++) {
    const a2 = t2[e2], h3 = [], f4 = [];
    let d4 = 0, u4 = 0, y3 = 0;
    for (const t3 of a2) {
      const { shape: e3, fill: i4, stroke: n6, font: s4, offset: a3 } = t3;
      r.ignoreStrokeWidth || "text" === e3.type || (d4 += (n6 == null ? void 0 : n6.width) || 0);
      const l2 = M(i4), c4 = A(n6), p3 = "text" === e3.type ? S(e3, s4) : null;
      o2.push($(l2)), h3.push(v(e3, l2.fill, c4, p3)), f4.push(T(e3)), a3 && (u4 += a3[0], y3 += a3[1]);
    }
    const p2 = V(E(f4), i3, n5, d4, r.scale ?? false, r.rotation, r.useRotationSize ?? false, [u4, y3], c3);
    let g3 = null;
    if (r.masking) {
      const t3 = `mask-${e2}`, i4 = r.masking[e2];
      o2.push(N(i4, t3)), g3 = `url(#${t3})`;
    }
    s3.push(g3 ? n2("g", { mask: g3 }, n2("g", { transform: p2 }, h3)) : n2("g", { transform: p2 }, h3));
  }
  r.useRotationSize && r.rotation && (i3 = b(r.rotation, i3), n5 = b(r.rotation, n5)), f3 && (n(c3), i3 = c3[0], n5 = c3[1]);
  const d3 = "display: block;";
  return n2("svg", { "aria-labelledby": r.ariaLabel, focusable: false, height: n5, role: "img", style: d3, width: i3, xmlns: h }, f3, n2("defs", null, o2), f3 ? n2("g", { filter: `url(#bloom${a})` }, s3) : s3);
}

// node_modules/@arcgis/core/symbols/support/renderUtils.js
var s2 = i();
function h2(t2, e2) {
  s2.append(t2, e2), s2.detach(e2);
}
function l(t2, e2, i3) {
  const r = Math.ceil(e2[0]), n5 = Math.ceil(e2[1]);
  if (!t2.some((t3) => !!t3.length))
    return null;
  const o2 = (i3 == null ? void 0 : i3.node) || document.createElement("div");
  null != i3.opacity && (o2.style.opacity = i3.opacity.toString()), null != i3.effectView && (o2.style.filter = I(i3.effectView));
  return h2(o2, () => D(t2, r, n5, i3)), o2;
}
function m2(t2, e2) {
  t2 = Math.ceil(t2), e2 = Math.ceil(e2);
  const i3 = document.createElement("canvas");
  i3.width = t2, i3.height = e2, i3.style.width = t2 + "px", i3.style.height = e2 + "px";
  const r = i3.getContext("2d");
  return r.clearRect(0, 0, t2, e2), r;
}
function g2(t2, i3, r) {
  return t2 ? j(t2, { responseType: "image" }).then((t3) => {
    const e2 = t3.data, n5 = e2.width, o2 = e2.height, a = n5 / o2;
    let c3 = i3;
    if (r) {
      const t4 = Math.max(n5, o2);
      c3 = Math.min(c3, t4);
    }
    return { image: e2, width: a <= 1 ? Math.ceil(c3 * a) : c3, height: a <= 1 ? c3 : Math.ceil(c3 / a) };
  }) : Promise.reject(new s("renderUtils: imageDataSize", "href not provided."));
}
function u3(t2, e2) {
  return !(!t2 || "ignore" === e2) && ("multiply" !== e2 || 255 !== t2.r || 255 !== t2.g || 255 !== t2.b || 1 !== t2.a);
}
function f2(t2, e2, n5, o2, a) {
  switch (a) {
    case "multiply":
      t2[e2] *= n5[0], t2[e2 + 1] *= n5[1], t2[e2 + 2] *= n5[2], t2[e2 + 3] *= n5[3];
      break;
    default: {
      const a2 = z({ r: t2[e2], g: t2[e2 + 1], b: t2[e2 + 2] });
      a2.h = o2.h, a2.s = o2.s, a2.v = a2.v / 100 * o2.v;
      const c3 = y(a2);
      t2[e2] = c3.r, t2[e2 + 1] = c3.g, t2[e2 + 2] = c3.b, t2[e2 + 3] *= n5[3];
      break;
    }
  }
}
function d2(e2, r, n5, o2, a) {
  return g2(e2, r, a).then((a2) => {
    var _a;
    const c3 = a2.width ?? r, s3 = a2.height ?? r;
    if (a2.image && u3(n5, o2)) {
      let t2 = a2.image.width, r2 = a2.image.height;
      has("edge") && /\.svg$/i.test(e2) && (t2 -= 1, r2 -= 1);
      const h3 = m2(c3, s3);
      h3.drawImage(a2.image, 0, 0, t2, r2, 0, 0, c3, s3);
      const l2 = h3.getImageData(0, 0, c3, s3), g3 = [n5.r / 255, n5.g / 255, n5.b / 255, n5.a], u4 = z(n5);
      for (let e3 = 0; e3 < l2.data.length; e3 += 4)
        f2(l2.data, e3, g3, u4, o2);
      h3.putImageData(l2, 0, 0), e2 = h3.canvas.toDataURL("image/png");
    } else {
      const i3 = (_a = t) == null ? void 0 : _a.findCredential(e2);
      if (i3 == null ? void 0 : i3.token) {
        const t2 = e2.includes("?") ? "&" : "?";
        e2 = `${e2}${t2}token=${i3.token}`;
      }
    }
    return { url: e2, width: c3, height: s3 };
  }).catch(() => ({ url: e2, width: r, height: r }));
}

export {
  l,
  d2 as d
};
//# sourceMappingURL=chunk-GKZKNWGZ.js.map
