import {
  n as n2
} from "./chunk-RXV6RUH7.js";
import {
  n,
  s as s2
} from "./chunk-JF5KFXQA.js";
import {
  a
} from "./chunk-SH5MUYBA.js";
import {
  x
} from "./chunk-MKRPXDII.js";
import {
  d
} from "./chunk-BYK6DXRK.js";
import {
  b
} from "./chunk-45OAWGCA.js";
import {
  K
} from "./chunk-X2TA76Q5.js";
import {
  i,
  u
} from "./chunk-OJ65P3EQ.js";
import {
  f
} from "./chunk-EUGXS5RE.js";
import {
  M
} from "./chunk-Y5D433JZ.js";
import {
  I
} from "./chunk-R5DM4YAB.js";
import {
  g,
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  h
} from "./chunk-RFPH3ZTZ.js";
import {
  s3 as s
} from "./chunk-WJ3HJKNC.js";
import {
  has
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/rest/query/executeForExtent.js
async function m(m2, n3, s3) {
  const p = f(m2);
  return x(p, b.from(n3), { ...s3 }).then((t) => ({ count: t.data.count, extent: M.fromJSON(t.data.extent) }));
}

// node_modules/@arcgis/core/layers/graphics/sources/support/QueryTask.js
var F = class extends g {
  constructor(e2) {
    super(e2), this.dynamicDataSource = null, this.fieldsIndex = null, this.gdbVersion = null, this.infoFor3D = null, this.pbfSupported = false, this.queryAttachmentsSupported = false, this.sourceSpatialReference = null, this.url = null;
  }
  get parsedUrl() {
    return I(this.url);
  }
  async execute(e2, t) {
    const r = await this.executeJSON(e2, t);
    return this.featureSetFromJSON(e2, r, t);
  }
  async executeJSON(e2, t) {
    var _a;
    const r = this._normalizeQuery(e2), o = null != ((_a = e2.outStatistics) == null ? void 0 : _a[0]), s3 = has("featurelayer-pbf-statistics"), i2 = !o || s3;
    let u2;
    if (this.pbfSupported && i2)
      try {
        u2 = await n2(this.url, r, t);
      } catch (a2) {
        if ("query:parsing-pbf" !== a2.name)
          throw a2;
        this.pbfSupported = false;
      }
    return this.pbfSupported && i2 || (u2 = await a(this.url, r, t)), this._normalizeFields(u2.fields), u2;
  }
  async featureSetFromJSON(e2, t, r) {
    if (!this._queryIs3DObjectFormat(e2) || null == this.infoFor3D || !t.features)
      return d.fromJSON(t);
    const { meshFeatureSetFromJSON: s3 } = await h(import("./meshFeatureSet-YL5BDCNS.js"), r);
    return s3(e2, this.infoFor3D, t);
  }
  executeForCount(e2, t) {
    return n(this.url, this._normalizeQuery(e2), t);
  }
  executeForExtent(e2, t) {
    return m(this.url, this._normalizeQuery(e2), t);
  }
  executeForIds(e2, t) {
    return s2(this.url, this._normalizeQuery(e2), t);
  }
  async executeRelationshipQuery(e2, t) {
    const [{ default: r }, { executeRelationshipQuery: s3 }] = await h(Promise.all([import("./RelationshipQuery-SXTJN3XF.js"), import("./executeRelationshipQuery-IRQB6W6P.js")]), t);
    return e2 = r.from(e2), (this.gdbVersion || this.dynamicDataSource) && ((e2 = e2.clone()).gdbVersion = e2.gdbVersion || this.gdbVersion, e2.dynamicDataSource = e2.dynamicDataSource || this.dynamicDataSource), s3(this.url, e2, t);
  }
  async executeRelationshipQueryForCount(e2, t) {
    const [{ default: r }, { executeRelationshipQueryForCount: s3 }] = await h(Promise.all([import("./RelationshipQuery-SXTJN3XF.js"), import("./executeRelationshipQuery-IRQB6W6P.js")]), t);
    return e2 = r.from(e2), (this.gdbVersion || this.dynamicDataSource) && ((e2 = e2.clone()).gdbVersion = e2.gdbVersion || this.gdbVersion, e2.dynamicDataSource = e2.dynamicDataSource || this.dynamicDataSource), s3(this.url, e2, t);
  }
  async executeAttachmentQuery(e2, t) {
    const { executeAttachmentQuery: r, fetchAttachments: s3, processAttachmentQueryResult: i2 } = await h(import("./queryAttachments-R2S6VWYV.js"), t), u2 = f(this.url);
    return i2(u2, await (this.queryAttachmentsSupported ? r(u2, e2, t) : s3(u2, e2, t)));
  }
  async executeTopFeaturesQuery(e2, t) {
    const { executeTopFeaturesQuery: r } = await h(import("./executeTopFeaturesQuery-FH5IJK2T.js"), t);
    return r(this.parsedUrl, e2, this.sourceSpatialReference, t);
  }
  async executeForTopIds(e2, t) {
    const { executeForTopIds: r } = await h(import("./executeForTopIds-AN2DTAJB.js"), t);
    return r(this.parsedUrl, e2, t);
  }
  async executeForTopExtents(e2, t) {
    const { executeForTopExtents: r } = await h(import("./executeForTopExtents-5IUYMVQM.js"), t);
    return r(this.parsedUrl, e2, t);
  }
  async executeForTopCount(e2, t) {
    const { executeForTopCount: r } = await h(import("./executeForTopCount-I23ARWOT.js"), t);
    return r(this.parsedUrl, e2, t);
  }
  _normalizeQuery(e2) {
    let t = b.from(e2);
    t.sourceSpatialReference = t.sourceSpatialReference || this.sourceSpatialReference, (this.gdbVersion || this.dynamicDataSource) && (t = t === e2 ? t.clone() : t, t.gdbVersion = e2.gdbVersion || this.gdbVersion, t.dynamicDataSource = e2.dynamicDataSource ? K.from(e2.dynamicDataSource) : this.dynamicDataSource);
    const { infoFor3D: o } = this;
    if (null != o && this._queryIs3DObjectFormat(e2)) {
      t = t === e2 ? t.clone() : t, t.formatOf3DObjects = null;
      const { supportedFormats: s3, queryFormats: i2 } = o, u2 = u("model/gltf-binary", s3) ?? i("glb", s3), c2 = u("model/gltf+json", s3) ?? i("gtlf", s3);
      for (const e3 of i2) {
        if (e3 === u2) {
          t.formatOf3DObjects = e3;
          break;
        }
        e3 !== c2 || t.formatOf3DObjects || (t.formatOf3DObjects = e3);
      }
      if (!t.formatOf3DObjects)
        throw new s("query:unsupported-3d-query-formats", "Could not find any supported 3D object query format. Only supported formats are 3D_glb and 3D_gltf");
      if (null == t.outFields || !t.outFields.includes("*")) {
        t = t === e2 ? t.clone() : t, null == t.outFields && (t.outFields = []);
        const { originX: r, originY: s4, originZ: i3, translationX: u3, translationY: a2, translationZ: n3, scaleX: c3, scaleY: p, scaleZ: l, rotationX: m2, rotationY: y2, rotationZ: d2, rotationDeg: f2 } = o.transformFieldRoles;
        t.outFields.push(r, s4, i3, u3, a2, n3, c3, p, l, m2, y2, d2, f2);
      }
    }
    return t;
  }
  _normalizeFields(e2) {
    if (null != this.fieldsIndex && null != e2)
      for (const t of e2) {
        const e3 = this.fieldsIndex.get(t.name);
        e3 && Object.assign(t, e3.toJSON());
      }
  }
  _queryIs3DObjectFormat(e2) {
    return null != this.infoFor3D && true === e2.returnGeometry && "xyFootprint" !== e2.multipatchOption && !e2.outStatistics;
  }
};
e([y({ type: K })], F.prototype, "dynamicDataSource", void 0), e([y()], F.prototype, "fieldsIndex", void 0), e([y()], F.prototype, "gdbVersion", void 0), e([y()], F.prototype, "infoFor3D", void 0), e([y({ readOnly: true })], F.prototype, "parsedUrl", null), e([y()], F.prototype, "pbfSupported", void 0), e([y()], F.prototype, "queryAttachmentsSupported", void 0), e([y()], F.prototype, "sourceSpatialReference", void 0), e([y({ type: String })], F.prototype, "url", void 0), F = e([c("esri.tasks.QueryTask")], F);
var x2 = F;

export {
  x2 as x
};
//# sourceMappingURL=chunk-DQ5CZJ7Y.js.map
