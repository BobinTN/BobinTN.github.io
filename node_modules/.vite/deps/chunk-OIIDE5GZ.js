import {
  u
} from "./chunk-3XSRVKBX.js";
import {
  n
} from "./chunk-WYBZLWIA.js";
import {
  M,
  f as f2,
  p as p2
} from "./chunk-Y5D433JZ.js";
import {
  g,
  p,
  x2 as x
} from "./chunk-QNOCEWCR.js";
import {
  f,
  r
} from "./chunk-QWPLZ3QH.js";
import {
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  a
} from "./chunk-WJ3HJKNC.js";
import {
  h
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/geometry/support/zmUtils.js
function h2(h7, a5, s5 = false) {
  let { hasM: t4, hasZ: e4 } = h7;
  Array.isArray(a5) ? 4 !== a5.length || t4 || e4 ? 3 === a5.length && s5 && !t4 ? (e4 = true, t4 = false) : 3 === a5.length && t4 && e4 && (t4 = false, e4 = false) : (t4 = true, e4 = true) : (e4 = !e4 && a5.hasZ && (!t4 || a5.hasM), t4 = !t4 && a5.hasM && (!e4 || a5.hasZ)), h7.hasZ = e4, h7.hasM = t4;
}

// node_modules/@arcgis/core/geometry/Multipoint.js
var h3;
function l(t4) {
  return (s5, e4) => null == s5 ? e4 : null == e4 ? s5 : t4(s5, e4);
}
function c2(t4) {
  return t4 && ("esri.geometry.SpatialReference" === t4.declaredClass || null != t4.wkid);
}
var m = h3 = class extends p {
  constructor(...t4) {
    super(...t4), this.points = [], this.type = "multipoint";
  }
  normalizeCtorArgs(t4, s5) {
    var _a;
    if (!t4 && !s5)
      return {};
    const e4 = {};
    Array.isArray(t4) ? (e4.points = t4, e4.spatialReference = s5) : c2(t4) ? e4.spatialReference = t4 : (t4.points && (e4.points = t4.points), t4.spatialReference && (e4.spatialReference = t4.spatialReference), t4.hasZ && (e4.hasZ = t4.hasZ), t4.hasM && (e4.hasM = t4.hasM));
    const i4 = (_a = e4.points) == null ? void 0 : _a[0];
    return i4 && (void 0 === e4.hasZ && void 0 === e4.hasM ? (e4.hasZ = i4.length > 2, e4.hasM = false) : void 0 === e4.hasZ ? e4.hasZ = i4.length > 3 : void 0 === e4.hasM && (e4.hasM = i4.length > 3)), e4;
  }
  get cache() {
    return this.commitProperty("points"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get extent() {
    const t4 = this.points;
    if (!t4.length)
      return null;
    const s5 = new M(), e4 = this.hasZ, i4 = this.hasM, r5 = e4 ? 3 : 2, n3 = t4[0], a5 = l(Math.min), p3 = l(Math.max);
    let h7, c8, m6, u7, [f8, y4] = n3, [d3, g4] = n3;
    for (let o5 = 0, l5 = t4.length; o5 < l5; o5++) {
      const s6 = t4[o5], [n4, l6] = s6;
      if (f8 = a5(f8, n4), y4 = a5(y4, l6), d3 = p3(d3, n4), g4 = p3(g4, l6), e4 && s6.length > 2) {
        const t5 = s6[2];
        h7 = a5(h7, t5), m6 = p3(m6, t5);
      }
      if (i4 && s6.length > r5) {
        const t5 = s6[r5];
        c8 = a5(c8, t5), u7 = p3(u7, t5);
      }
    }
    return s5.xmin = f8, s5.ymin = y4, s5.xmax = d3, s5.ymax = g4, s5.spatialReference = this.spatialReference, e4 ? (s5.zmin = h7, s5.zmax = m6) : (s5.zmin = void 0, s5.zmax = void 0), i4 ? (s5.mmin = c8, s5.mmax = u7) : (s5.mmin = void 0, s5.mmax = void 0), s5;
  }
  writePoints(t4, e4) {
    e4.points = a(this.points);
  }
  addPoint(t4) {
    return h2(this, t4), Array.isArray(t4) ? this.points.push(t4) : this.points.push(t4.toArray()), this.notifyChange("points"), this;
  }
  clone() {
    const t4 = { points: a(this.points), spatialReference: this.spatialReference };
    return this.hasZ && (t4.hasZ = true), this.hasM && (t4.hasM = true), new h3(t4);
  }
  getPoint(t4) {
    if (!this._validateInputs(t4))
      return null;
    const s5 = this.points[t4], e4 = { x: s5[0], y: s5[1], spatialReference: this.spatialReference };
    let i4 = 2;
    return this.hasZ && (e4.z = s5[2], i4 = 3), this.hasM && (e4.m = s5[i4]), new x(e4);
  }
  removePoint(t4) {
    if (!this._validateInputs(t4))
      return null;
    const s5 = new x(this.points.splice(t4, 1)[0], this.spatialReference);
    return this.notifyChange("points"), s5;
  }
  setPoint(t4, s5) {
    return this._validateInputs(t4) ? (h2(this, s5), Array.isArray(s5) || (s5 = s5.toArray()), this.points[t4] = s5, this.notifyChange("points"), this) : this;
  }
  toJSON(t4) {
    return this.write({}, t4);
  }
  _validateInputs(t4) {
    return null != t4 && t4 >= 0 && t4 < this.points.length;
  }
};
e([y({ readOnly: true })], m.prototype, "cache", null), e([y()], m.prototype, "extent", null), e([y({ type: [[Number]], json: { write: { isRequired: true } } })], m.prototype, "points", void 0), e([r("points")], m.prototype, "writePoints", null), m = h3 = e([c("esri.geometry.Multipoint")], m), m.prototype.toJSON.isDefaultToJSON = true;
var u2 = m;

// node_modules/@arcgis/core/geometry/support/boundsUtils.js
function t(n3) {
  return void 0 !== n3.xmin && void 0 !== n3.ymin && void 0 !== n3.xmax && void 0 !== n3.ymax;
}
function i(n3) {
  return void 0 !== n3.points;
}
function o(n3) {
  return void 0 !== n3.x && void 0 !== n3.y;
}
function e2(n3) {
  return void 0 !== n3.paths;
}
function r2(n3) {
  return void 0 !== n3.rings;
}
function u3(n3) {
  function t4(t5, i4) {
    return null == t5 ? i4 : null == i4 ? t5 : n3(t5, i4);
  }
  return t4;
}
var l2 = u3(Math.min);
var h4 = u3(Math.max);
function a2(n3, u7) {
  return e2(u7) ? x2(n3, u7.paths, false, false) : r2(u7) ? x2(n3, u7.rings, false, false) : i(u7) ? g2(n3, u7.points, false, false, false, false) : t(u7) ? s(n3, u7) : (o(u7) && (n3[0] = u7.x, n3[1] = u7.y, n3[2] = u7.x, n3[3] = u7.y), n3);
}
function c3(t4) {
  let i4, o5, e4, r5;
  for (t4.reset(), i4 = e4 = 1 / 0, o5 = r5 = -1 / 0; t4.nextPath(); ) {
    const n3 = f3(t4);
    i4 = Math.min(n3[0], i4), e4 = Math.min(n3[1], e4), o5 = Math.max(n3[2], o5), r5 = Math.max(n3[3], r5);
  }
  return u([i4, e4, o5, r5]);
}
function f3(t4) {
  let i4, o5, e4, r5;
  for (i4 = e4 = 1 / 0, o5 = r5 = -1 / 0; t4.nextPoint(); )
    i4 = Math.min(t4.x, i4), e4 = Math.min(t4.y, e4), o5 = Math.max(t4.x, o5), r5 = Math.max(t4.y, r5);
  return u([i4, e4, o5, r5]);
}
function m2(n3, u7) {
  return e2(u7) ? x2(n3, u7.paths, true, false) : r2(u7) ? x2(n3, u7.rings, true, false) : i(u7) ? g2(n3, u7.points, true, false, true, false) : t(u7) ? s(n3, u7, true, false, true, false) : (o(u7) && (n3[0] = u7.x, n3[1] = u7.y, n3[2] = u7.z, n3[3] = u7.x, n3[4] = u7.y, n3[5] = u7.z), n3);
}
function x2(n3, t4, i4, o5) {
  const e4 = i4 ? 3 : 2;
  if (!t4.length || !t4[0].length)
    return null;
  let r5, u7, a5, c8, [f8, m6] = t4[0][0], [x6, s5] = t4[0][0];
  for (let g4 = 0; g4 < t4.length; g4++) {
    const n4 = t4[g4];
    for (let t5 = 0; t5 < n4.length; t5++) {
      const g5 = n4[t5], [y4, d3] = g5;
      if (f8 = l2(f8, y4), m6 = l2(m6, d3), x6 = h4(x6, y4), s5 = h4(s5, d3), i4 && g5.length > 2) {
        const n5 = g5[2];
        r5 = l2(r5, n5), u7 = h4(u7, n5);
      }
      if (o5 && g5.length > e4) {
        const n5 = g5[e4];
        a5 = l2(r5, n5), c8 = h4(u7, n5);
      }
    }
  }
  return i4 ? o5 ? (n3[0] = f8, n3[1] = m6, n3[2] = r5, n3[3] = a5, n3[4] = x6, n3[5] = s5, n3[6] = u7, n3[7] = c8, n3.length = 8, n3) : (n3[0] = f8, n3[1] = m6, n3[2] = r5, n3[3] = x6, n3[4] = s5, n3[5] = u7, n3.length = 6, n3) : o5 ? (n3[0] = f8, n3[1] = m6, n3[2] = a5, n3[3] = x6, n3[4] = s5, n3[5] = c8, n3.length = 6, n3) : (n3[0] = f8, n3[1] = m6, n3[2] = x6, n3[3] = s5, n3.length = 4, n3);
}
function s(n3, t4, i4, o5, e4, r5) {
  const u7 = t4.xmin, l5 = t4.xmax, h7 = t4.ymin, a5 = t4.ymax;
  let c8 = t4.zmin, f8 = t4.zmax, m6 = t4.mmin, x6 = t4.mmax;
  return e4 ? (c8 = c8 || 0, f8 = f8 || 0, r5 ? (m6 = m6 || 0, x6 = x6 || 0, n3[0] = u7, n3[1] = h7, n3[2] = c8, n3[3] = m6, n3[4] = l5, n3[5] = a5, n3[6] = f8, n3[7] = x6, n3) : (n3[0] = u7, n3[1] = h7, n3[2] = c8, n3[3] = l5, n3[4] = a5, n3[5] = f8, n3)) : r5 ? (m6 = m6 || 0, x6 = x6 || 0, n3[0] = u7, n3[1] = h7, n3[2] = m6, n3[3] = l5, n3[4] = a5, n3[5] = x6, n3) : (n3[0] = u7, n3[1] = h7, n3[2] = l5, n3[3] = a5, n3);
}
function g2(n3, t4, i4, o5, e4, r5) {
  const u7 = i4 ? 3 : 2, a5 = o5 && r5, c8 = i4 && e4;
  if (!t4.length || !t4[0].length)
    return null;
  let f8, m6, x6, s5, [g4, y4] = t4[0], [d3, M2] = t4[0];
  for (let v2 = 0; v2 < t4.length; v2++) {
    const n4 = t4[v2], [i5, o6] = n4;
    if (g4 = l2(g4, i5), y4 = l2(y4, o6), d3 = h4(d3, i5), M2 = h4(M2, o6), c8 && n4.length > 2) {
      const t5 = n4[2];
      f8 = l2(f8, t5), m6 = h4(m6, t5);
    }
    if (a5 && n4.length > u7) {
      const t5 = n4[u7];
      x6 = l2(f8, t5), s5 = h4(m6, t5);
    }
  }
  return e4 ? (f8 = f8 || 0, m6 = m6 || 0, r5 ? (x6 = x6 || 0, s5 = s5 || 0, n3[0] = g4, n3[1] = y4, n3[2] = f8, n3[3] = x6, n3[4] = d3, n3[5] = M2, n3[6] = m6, n3[7] = s5, n3) : (n3[0] = g4, n3[1] = y4, n3[2] = f8, n3[3] = d3, n3[4] = M2, n3[5] = m6, n3)) : r5 ? (x6 = x6 || 0, s5 = s5 || 0, n3[0] = g4, n3[1] = y4, n3[2] = x6, n3[3] = d3, n3[4] = M2, n3[5] = s5, n3) : (n3[0] = g4, n3[1] = y4, n3[2] = d3, n3[3] = M2, n3);
}

// node_modules/@arcgis/core/geometry/geometryCursorCollectUtils.js
function t2(t4) {
  const n3 = [];
  for (t4.reset(); t4.nextPath(); ) {
    const e4 = [];
    for (; t4.nextPoint(); )
      e4.push([t4.x, t4.y]);
    n3.push(e4);
  }
  return t4.reset(), n3;
}
function n2(t4) {
  const n3 = [];
  for (; t4.nextPoint(); )
    n3.push([t4.x, t4.y]);
  return t4.seekPathStart(), n3;
}

// node_modules/@arcgis/core/geometry/support/coordsUtils.js
function i2(t4, n3) {
  const e4 = n3[0] - t4[0], r5 = n3[1] - t4[1];
  if (t4.length > 2 && n3.length > 2) {
    const i4 = t4[2] - n3[2];
    return Math.sqrt(e4 * e4 + r5 * r5 + i4 * i4);
  }
  return Math.sqrt(e4 * e4 + r5 * r5);
}
function o2(t4, n3, e4) {
  const r5 = t4[0] + e4 * (n3[0] - t4[0]), i4 = t4[1] + e4 * (n3[1] - t4[1]);
  return t4.length > 2 && n3.length > 2 ? [r5, i4, t4[2] + e4 * (n3[2] - t4[2])] : [r5, i4];
}
function s2(t4, n3, e4, r5) {
  return f4(t4, n3, e4[r5], e4[r5 + 1]);
}
function f4(t4, n3, e4, r5) {
  const [i4, o5] = n3, [s5, f8] = e4, [l5, u7] = r5, c8 = l5 - s5, h7 = u7 - f8, p3 = c8 * c8 + h7 * h7, a5 = (i4 - s5) * c8 + (o5 - f8) * h7, y4 = Math.min(1, Math.max(0, a5 / p3));
  return t4[0] = s5 + c8 * y4, t4[1] = f8 + h7 * y4, t4;
}
function c4(t4, n3) {
  return o2(t4, n3, 0.5);
}
function a3(t4, e4 = n.X, r5 = n.Y) {
  let i4 = 0;
  const o5 = t4.length;
  let s5 = t4[0];
  for (let n3 = 0; n3 < o5 - 1; n3++) {
    const o6 = t4[n3 + 1];
    i4 += (o6[e4] - s5[e4]) * (o6[r5] + s5[r5]), s5 = o6;
  }
  return i4 >= 0;
}
function y2(n3) {
  const e4 = n3.length;
  return e4 > 2 && h(n3[0], n3[e4 - 1]);
}
function m3(t4) {
  if ("rings" in t4 && (g3(t4), t4.rings.length > 0 && !a3(t4.rings[0])))
    for (const n3 of t4.rings)
      n3.reverse();
}
function g3(t4) {
  if ("rings" in t4)
    for (const n3 of t4.rings)
      y2(n3) || n3.push(n3[0].slice());
}

// node_modules/@arcgis/core/geometry/support/centroid.js
function r3(t4) {
  return t4 ? t4.hasZ ? [t4.xmax - t4.xmin / 2, t4.ymax - t4.ymin / 2, t4.zmax - t4.zmin / 2] : [t4.xmax - t4.xmin / 2, t4.ymax - t4.ymin / 2] : null;
}
function l3(t4) {
  return t4 ? o3(t4.rings, t4.hasZ ?? false) : null;
}
function o3(t4, n3) {
  if (!(t4 == null ? void 0 : t4.length))
    return null;
  const e4 = [], r5 = [], l5 = n3 ? [1 / 0, -1 / 0, 1 / 0, -1 / 0, 1 / 0, -1 / 0] : [1 / 0, -1 / 0, 1 / 0, -1 / 0];
  for (let o5 = 0, i4 = t4.length; o5 < i4; o5++) {
    const e5 = u4(t4[o5], n3, l5);
    e5 && r5.push(e5);
  }
  if (r5.sort((t5, e5) => {
    let r6 = t5[2] - e5[2];
    return 0 === r6 && n3 && (r6 = t5[4] - e5[4]), r6;
  }), r5.length && (e4[0] = r5[0][0], e4[1] = r5[0][1], n3 && (e4[2] = r5[0][3]), (e4[0] < l5[0] || e4[0] > l5[1] || e4[1] < l5[2] || e4[1] > l5[3] || n3 && (e4[2] < l5[4] || e4[2] > l5[5])) && (e4.length = 0)), !e4.length) {
    const r6 = t4[0] && t4[0].length ? s3(t4[0], n3) : null;
    if (!r6)
      return null;
    e4[0] = r6[0], e4[1] = r6[1], n3 && r6.length > 2 && (e4[2] = r6[2]);
  }
  return e4;
}
function u4(t4, n3, e4) {
  let r5 = 0, l5 = 0, o5 = 0, u7 = 0, i4 = 0;
  const s5 = t4.length ? t4[0][0] : 0, I2 = t4.length ? t4[0][1] : 0, h7 = t4.length && n3 ? t4[0][2] : 0;
  for (let f8 = 0; f8 < t4.length; f8++) {
    const c9 = t4[f8], N2 = t4[(f8 + 1) % t4.length], [x6, g4, a5] = c9, m6 = x6 - s5, P = g4 - I2, [T, y4, E] = N2, S = T - s5, p3 = y4 - I2, z = m6 * p3 - S * P;
    if (u7 += z, r5 += (m6 + S) * z, l5 += (P + p3) * z, n3 && c9.length > 2 && N2.length > 2) {
      const t5 = a5 - h7, n4 = E - h7, e5 = m6 * n4 - S * t5;
      o5 += (t5 + n4) * e5, i4 += e5;
    }
    x6 < e4[0] && (e4[0] = x6), x6 > e4[1] && (e4[1] = x6), g4 < e4[2] && (e4[2] = g4), g4 > e4[3] && (e4[3] = g4), n3 && (a5 < e4[4] && (e4[4] = a5), a5 > e4[5] && (e4[5] = a5));
  }
  if (u7 > 0 && (u7 *= -1), i4 > 0 && (i4 *= -1), !u7)
    return null;
  u7 *= 0.5, i4 *= 0.5;
  const c8 = [r5 / (6 * u7) + s5, l5 / (6 * u7) + I2, u7];
  return n3 && (e4[4] === e4[5] || 0 === i4 ? (c8[3] = (e4[4] + e4[5]) / 2, c8[4] = 0) : (c8[3] = o5 / (6 * i4) + h7, c8[4] = i4)), c8;
}
function i3(t4, n3) {
  let e4 = 0, r5 = 0, l5 = 0;
  t4.nextPoint();
  const o5 = t4.pathSize ? t4.x : 0, u7 = t4.pathSize ? t4.y : 0;
  for (let i4 = 0; i4 < t4.pathSize; i4++) {
    t4.seekInPath(i4);
    const s5 = [t4.x, t4.y];
    t4.seekInPath((i4 + 1) % t4.pathSize);
    const I2 = [t4.x, t4.y], [h7, c8] = s5, f8 = h7 - o5, N2 = c8 - u7, [x6, g4] = I2, a5 = x6 - o5, m6 = g4 - u7, P = f8 * m6 - a5 * N2;
    l5 += P, e4 += (f8 + a5) * P, r5 += (N2 + m6) * P, h7 < n3[0] && (n3[0] = h7), h7 > n3[1] && (n3[1] = h7), c8 < n3[2] && (n3[2] = c8), c8 > n3[3] && (n3[3] = c8);
  }
  if (l5 > 0 && (l5 *= -1), !l5)
    return null;
  l5 *= 0.5;
  return [e4 / (6 * l5) + o5, r5 / (6 * l5) + u7, l5];
}
function s3(t4, r5) {
  const l5 = r5 ? [0, 0, 0] : [0, 0], o5 = r5 ? [0, 0, 0] : [0, 0];
  let u7 = 0, i4 = 0, s5 = 0, I2 = 0;
  for (let h7 = 0, c8 = t4.length; h7 < c8 - 1; h7++) {
    const c9 = t4[h7], f8 = t4[h7 + 1];
    if (c9 && f8) {
      l5[0] = c9[0], l5[1] = c9[1], o5[0] = f8[0], o5[1] = f8[1], r5 && c9.length > 2 && f8.length > 2 && (l5[2] = c9[2], o5[2] = f8[2]);
      const t5 = i2(l5, o5);
      if (t5) {
        u7 += t5;
        const n3 = c4(c9, f8);
        i4 += t5 * n3[0], s5 += t5 * n3[1], r5 && n3.length > 2 && (I2 += t5 * n3[2]);
      }
    }
  }
  return u7 > 0 ? r5 ? [i4 / u7, s5 / u7, I2 / u7] : [i4 / u7, s5 / u7] : t4.length ? t4[0] : null;
}
function I(n3) {
  const { hasZ: e4, totalSize: r5 } = n3;
  if (0 === r5)
    return null;
  const l5 = [], o5 = [], i4 = e4 ? [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY] : [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
  for (n3.reset(); n3.nextPath(); ) {
    const e5 = u4(n2(n3), n3.hasZ, i4);
    e5 && o5.push(e5);
  }
  if (o5.sort((t4, n4) => {
    let r6 = t4[2] - n4[2];
    return 0 === r6 && e4 && (r6 = t4[4] - n4[4]), r6;
  }), o5.length && (l5[0] = o5[0][0], l5[1] = o5[0][1], e4 && (l5[2] = o5[0][3]), (l5[0] < i4[0] || l5[0] > i4[1] || l5[1] < i4[2] || l5[1] > i4[3] || e4 && (l5[2] < i4[4] || l5[2] > i4[5])) && (l5.length = 0)), !l5.length) {
    n3.reset(), n3.nextPath();
    const t4 = n3.pathSize ? h5(n3) : null;
    if (!t4)
      return null;
    l5[0] = t4[0], l5[1] = t4[1], e4 && t4.length > 2 && (l5[2] = t4[2]);
  }
  return l5;
}
function h5(t4) {
  const { hasZ: r5 } = t4, l5 = r5 ? [0, 0, 0] : [0, 0], o5 = r5 ? [0, 0, 0] : [0, 0];
  let u7 = 0, i4 = 0, s5 = 0, I2 = 0;
  if (t4.nextPoint()) {
    let h7 = t4.x, c8 = t4.y, f8 = t4.z;
    for (; t4.nextPoint(); ) {
      const N2 = t4.x, x6 = t4.y, g4 = t4.z;
      l5[0] = h7, l5[1] = c8, o5[0] = N2, o5[1] = x6, r5 && (l5[2] = f8, o5[2] = g4);
      const a5 = i2(l5, o5);
      if (a5) {
        u7 += a5;
        const t5 = c4(l5, o5);
        i4 += a5 * t5[0], s5 += a5 * t5[1], r5 && t5.length > 2 && (I2 += a5 * t5[2]);
      }
      h7 = N2, c8 = x6, f8 = g4;
    }
  }
  return u7 > 0 ? r5 ? [i4 / u7, s5 / u7, I2 / u7] : [i4 / u7, s5 / u7] : t4.pathSize ? (t4.seekPathStart(), t4.nextPoint(), [t4.x, t4.y]) : null;
}
var c5 = 1e-6;
function f5(t4) {
  let n3 = 0;
  for (t4.reset(); t4.nextPath(); )
    n3 += t4.getCurrentRingArea();
  if (n3 < c5) {
    const n4 = I(t4);
    return n4 ? [n4[0], n4[1]] : null;
  }
  const e4 = [0, 0];
  if (t4.reset(), !t4.nextPath() || !t4.nextPoint())
    return null;
  const r5 = [t4.x, t4.y];
  for (t4.reset(); t4.nextPath(); )
    x3(e4, r5, t4);
  return e4[0] *= 1 / n3, e4[1] *= 1 / n3, e4[0] += r5[0], e4[1] += r5[1], e4;
}
var N = 1 / 3;
function x3(t4, n3, e4) {
  if (!t4 || !e4 || e4.pathSize < 3)
    return null;
  e4.nextPoint();
  const r5 = e4.x, l5 = e4.y;
  e4.nextPoint();
  let o5, u7 = e4.x - r5, i4 = e4.y - l5, s5 = 0, I2 = 0;
  for (; e4.nextPoint(); )
    s5 = e4.x - r5, I2 = e4.y - l5, o5 = 0.5 * N * (s5 * i4 - I2 * u7), t4[0] += o5 * (u7 + s5), t4[1] += o5 * (i4 + I2), u7 = s5, i4 = I2;
  const h7 = e4.getCurrentRingArea(), c8 = [r5, l5];
  return c8[0] -= n3[0], c8[1] -= n3[1], c8[0] *= h7, c8[1] *= h7, t4[0] += c8[0], t4[1] += c8[1], t4;
}

// node_modules/@arcgis/core/geometry/support/extentUtils.js
function t3(n3) {
  return void 0 !== n3.xmin && void 0 !== n3.ymin && void 0 !== n3.xmax && void 0 !== n3.ymax;
}
function u5(n3) {
  return void 0 !== n3.points;
}
function m4(n3) {
  return void 0 !== n3.x && void 0 !== n3.y;
}
function o4(n3) {
  return void 0 !== n3.paths;
}
function r4(n3) {
  return void 0 !== n3.rings;
}
var x4 = [];
function a4(n3, i4, t4, u7) {
  return { xmin: n3, ymin: i4, xmax: t4, ymax: u7 };
}
function c6(n3, i4, t4, u7, m6, o5) {
  return { xmin: n3, ymin: i4, zmin: t4, xmax: u7, ymax: m6, zmax: o5 };
}
function s4(n3, i4, t4, u7, m6, o5) {
  return { xmin: n3, ymin: i4, mmin: t4, xmax: u7, ymax: m6, mmax: o5 };
}
function e3(n3, i4, t4, u7, m6, o5, r5, x6) {
  return { xmin: n3, ymin: i4, zmin: t4, mmin: u7, xmax: m6, ymax: o5, zmax: r5, mmax: x6 };
}
function f6(n3, i4 = false, t4 = false) {
  return i4 ? t4 ? e3(n3[0], n3[1], n3[2], n3[3], n3[4], n3[5], n3[6], n3[7]) : c6(n3[0], n3[1], n3[2], n3[3], n3[4], n3[5]) : t4 ? s4(n3[0], n3[1], n3[2], n3[3], n3[4], n3[5]) : a4(n3[0], n3[1], n3[2], n3[3]);
}
function l4(n3) {
  return n3 ? t3(n3) ? n3 : m4(n3) ? d(n3) : r4(n3) ? v(n3) : o4(n3) ? h6(n3) : u5(n3) ? y3(n3) : null : null;
}
function y3(i4) {
  const { hasZ: t4, hasM: u7, points: m6 } = i4;
  return f6(g2(x4, m6, t4 ?? false, u7 ?? false), t4, u7);
}
function d(n3) {
  const { x: i4, y: t4, z: u7, m: m6 } = n3, o5 = null != m6;
  return null != u7 ? o5 ? e3(i4, t4, u7, m6, i4, t4, u7, m6) : c6(i4, t4, u7, i4, t4, u7) : o5 ? s4(i4, t4, m6, i4, t4, m6) : a4(i4, t4, i4, t4);
}
function v(n3) {
  const { hasZ: t4, hasM: u7, rings: m6 } = n3, o5 = x2(x4, m6, t4 ?? false, u7 ?? false);
  return o5 ? f6(o5, t4, u7) : null;
}
function h6(n3) {
  const { hasZ: t4, hasM: u7, paths: m6 } = n3, o5 = x2(x4, m6, t4 ?? false, u7 ?? false);
  return o5 ? f6(o5, t4, u7) : null;
}

// node_modules/@arcgis/core/geometry/Polygon.js
var d2;
function R(t4) {
  return !Array.isArray(t4[0]);
}
var x5 = d2 = class extends p {
  static fromExtent(t4) {
    const e4 = t4.clone().normalize(), r5 = t4.spatialReference;
    let s5 = false, n3 = false;
    for (const o5 of e4)
      o5.hasZ && (s5 = true), o5.hasM && (n3 = true);
    const i4 = { rings: e4.map((t5) => {
      const e5 = [[t5.xmin, t5.ymin], [t5.xmin, t5.ymax], [t5.xmax, t5.ymax], [t5.xmax, t5.ymin], [t5.xmin, t5.ymin]];
      if (s5 && t5.hasZ) {
        const r6 = t5.zmin + 0.5 * (t5.zmax - t5.zmin);
        for (let t6 = 0; t6 < e5.length; t6++)
          e5[t6].push(r6);
      }
      if (n3 && t5.hasM) {
        const r6 = t5.mmin + 0.5 * (t5.mmax - t5.mmin);
        for (let t6 = 0; t6 < e5.length; t6++)
          e5[t6].push(r6);
      }
      return e5;
    }), spatialReference: r5 };
    return s5 && (i4.hasZ = true), n3 && (i4.hasM = true), new d2(i4);
  }
  constructor(...t4) {
    super(...t4), this.rings = [], this.type = "polygon";
  }
  normalizeCtorArgs(t4, e4) {
    var _a, _b;
    let r5, s5, n3 = null, i4 = null;
    return t4 && !Array.isArray(t4) ? (n3 = t4.rings ?? null, e4 || (t4.spatialReference ? e4 = t4.spatialReference : t4.rings || (e4 = t4)), r5 = t4.hasZ, s5 = t4.hasM) : n3 = t4, n3 = n3 || [], e4 = e4 || f.WGS84, n3.length && null != ((_a = n3[0]) == null ? void 0 : _a[0]) && "number" == typeof n3[0][0] && (n3 = [n3]), i4 = (_b = n3[0]) == null ? void 0 : _b[0], i4 && (void 0 === r5 && void 0 === s5 ? (r5 = i4.length > 2, s5 = i4.length > 3) : void 0 === r5 ? r5 = s5 ? i4.length > 3 : i4.length > 2 : void 0 === s5 && (s5 = r5 ? i4.length > 3 : i4.length > 2)), { rings: n3, spatialReference: e4, hasZ: r5, hasM: s5 };
  }
  get cache() {
    return this.commitProperty("rings"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get centroid() {
    const t4 = l3(this);
    if (!t4 || isNaN(t4[0]) || isNaN(t4[1]) || this.hasZ && isNaN(t4[2]))
      return null;
    const e4 = new x();
    return e4.x = t4[0], e4.y = t4[1], e4.spatialReference = this.spatialReference, this.hasZ && (e4.z = t4[2]), e4;
  }
  get extent() {
    const { spatialReference: t4 } = this, e4 = v(this);
    if (!e4)
      return null;
    const r5 = new M(e4);
    return r5.spatialReference = t4, r5;
  }
  get isSelfIntersecting() {
    return p2(this.rings);
  }
  writeRings(t4, e4) {
    e4.rings = a(this.rings);
  }
  addRing(t4) {
    if (!t4)
      return;
    const e4 = this.rings, r5 = e4.length;
    if (R(t4)) {
      const s5 = [];
      for (let e5 = 0, r6 = t4.length; e5 < r6; e5++)
        s5[e5] = t4[e5].toArray();
      e4[r5] = s5;
    } else
      e4[r5] = t4.concat();
    return this.notifyChange("rings"), this;
  }
  clone() {
    const t4 = new d2();
    return t4.spatialReference = this.spatialReference, t4.rings = a(this.rings), t4.hasZ = this.hasZ, t4.hasM = this.hasM, t4;
  }
  equals(t4) {
    if (this === t4)
      return true;
    if (null == t4)
      return false;
    const r5 = this.spatialReference, s5 = t4.spatialReference;
    if (null != r5 != (null != s5))
      return false;
    if (null != r5 && null != s5 && !r5.equals(s5))
      return false;
    if (this.rings.length !== t4.rings.length)
      return false;
    const n3 = ([t5, e4, r6, s6], [n4, i4, o5, a5]) => t5 === n4 && e4 === i4 && (null == r6 && null == o5 || r6 === o5) && (null == s6 && null == a5 || s6 === a5);
    for (let i4 = 0; i4 < this.rings.length; i4++) {
      const r6 = this.rings[i4], s6 = t4.rings[i4];
      if (!h(r6, s6, n3))
        return false;
    }
    return true;
  }
  contains(t4) {
    if (!t4)
      return false;
    const e4 = g(t4, this.spatialReference);
    return f2(this, null != e4 ? e4 : t4);
  }
  isClockwise(t4) {
    let e4;
    return e4 = R(t4) ? t4.map((t5) => this.hasZ ? this.hasM ? [t5.x, t5.y, t5.z, t5.m] : [t5.x, t5.y, t5.z] : [t5.x, t5.y]) : t4, a3(e4);
  }
  getPoint(t4, e4) {
    if (!this._validateInputs(t4, e4))
      return null;
    const r5 = this.rings[t4][e4], s5 = this.hasZ, n3 = this.hasM;
    return s5 && !n3 ? new x(r5[0], r5[1], r5[2], void 0, this.spatialReference) : n3 && !s5 ? new x(r5[0], r5[1], void 0, r5[2], this.spatialReference) : s5 && n3 ? new x(r5[0], r5[1], r5[2], r5[3], this.spatialReference) : new x(r5[0], r5[1], this.spatialReference);
  }
  insertPoint(t4, e4, r5) {
    return this._validateInputs(t4, e4, true) ? (h2(this, r5), Array.isArray(r5) || (r5 = r5.toArray()), this.rings[t4].splice(e4, 0, r5), this.notifyChange("rings"), this) : this;
  }
  removePoint(t4, e4) {
    if (!this._validateInputs(t4, e4))
      return null;
    const r5 = new x(this.rings[t4].splice(e4, 1)[0], this.spatialReference);
    return this.notifyChange("rings"), r5;
  }
  removeRing(t4) {
    if (!this._validateInputs(t4, null))
      return null;
    const e4 = this.rings.splice(t4, 1)[0], r5 = this.spatialReference, s5 = e4.map((t5) => new x(t5, r5));
    return this.notifyChange("rings"), s5;
  }
  setPoint(t4, e4, r5) {
    return this._validateInputs(t4, e4) ? (h2(this, r5), Array.isArray(r5) || (r5 = r5.toArray()), this.rings[t4][e4] = r5, this.notifyChange("rings"), this) : this;
  }
  _validateInputs(t4, e4, r5 = false) {
    if (null == t4 || t4 < 0 || t4 >= this.rings.length)
      return false;
    if (null != e4) {
      const s5 = this.rings[t4];
      if (r5 && (e4 < 0 || e4 > s5.length))
        return false;
      if (!r5 && (e4 < 0 || e4 >= s5.length))
        return false;
    }
    return true;
  }
  toJSON(t4) {
    return this.write({}, t4);
  }
};
e([y({ readOnly: true })], x5.prototype, "cache", null), e([y({ readOnly: true })], x5.prototype, "centroid", null), e([y({ readOnly: true })], x5.prototype, "extent", null), e([y({ readOnly: true })], x5.prototype, "isSelfIntersecting", null), e([y({ type: [[[Number]]], json: { write: { isRequired: true } } })], x5.prototype, "rings", void 0), e([r("rings")], x5.prototype, "writeRings", null), x5 = d2 = e([c("esri.geometry.Polygon")], x5), x5.prototype.toJSON.isDefaultToJSON = true;
var j = x5;

// node_modules/@arcgis/core/geometry/Polyline.js
var c7;
function u6(t4) {
  return !Array.isArray(t4[0]);
}
var f7 = c7 = class extends p {
  constructor(...t4) {
    super(...t4), this.paths = [], this.type = "polyline";
  }
  normalizeCtorArgs(t4, e4) {
    var _a, _b;
    let s5, r5, i4 = null, a5 = null;
    return t4 && !Array.isArray(t4) ? (i4 = t4.paths ?? null, e4 || (t4.spatialReference ? e4 = t4.spatialReference : t4.paths || (e4 = t4)), s5 = t4.hasZ, r5 = t4.hasM) : i4 = t4, i4 = i4 || [], e4 = e4 || f.WGS84, i4.length && null != ((_a = i4[0]) == null ? void 0 : _a[0]) && "number" == typeof i4[0][0] && (i4 = [i4]), a5 = (_b = i4[0]) == null ? void 0 : _b[0], a5 && (void 0 === s5 && void 0 === r5 ? (s5 = a5.length > 2, r5 = false) : void 0 === s5 ? s5 = !r5 && a5.length > 3 : void 0 === r5 && (r5 = !s5 && a5.length > 3)), { paths: i4, spatialReference: e4, hasZ: s5, hasM: r5 };
  }
  get cache() {
    return this.commitProperty("paths"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get extent() {
    const { spatialReference: t4 } = this, e4 = h6(this);
    if (!e4)
      return null;
    const s5 = new M(e4);
    return s5.spatialReference = t4, s5;
  }
  writePaths(t4, s5) {
    s5.paths = a(this.paths);
  }
  addPath(t4) {
    if (!t4)
      return;
    const e4 = this.paths, s5 = e4.length;
    if (u6(t4)) {
      const r5 = [];
      for (let e5 = 0, s6 = t4.length; e5 < s6; e5++)
        r5[e5] = t4[e5].toArray();
      e4[s5] = r5;
    } else
      e4[s5] = t4.concat();
    return this.notifyChange("paths"), this;
  }
  clone() {
    const t4 = new c7();
    return t4.spatialReference = this.spatialReference, t4.paths = a(this.paths), t4.hasZ = this.hasZ, t4.hasM = this.hasM, t4;
  }
  getPoint(t4, e4) {
    if (!this._validateInputs(t4, e4))
      return null;
    const s5 = this.paths[t4][e4], r5 = this.hasZ, i4 = this.hasM;
    return r5 && !i4 ? new x(s5[0], s5[1], s5[2], void 0, this.spatialReference) : i4 && !r5 ? new x(s5[0], s5[1], void 0, s5[2], this.spatialReference) : r5 && i4 ? new x(s5[0], s5[1], s5[2], s5[3], this.spatialReference) : new x(s5[0], s5[1], this.spatialReference);
  }
  insertPoint(t4, e4, s5) {
    return this._validateInputs(t4, e4, true) ? (h2(this, s5), Array.isArray(s5) || (s5 = s5.toArray()), this.paths[t4].splice(e4, 0, s5), this.notifyChange("paths"), this) : this;
  }
  removePath(t4) {
    if (!this._validateInputs(t4, null))
      return null;
    const e4 = this.paths.splice(t4, 1)[0], s5 = this.spatialReference, r5 = e4.map((t5) => new x(t5, s5));
    return this.notifyChange("paths"), r5;
  }
  removePoint(t4, e4) {
    if (!this._validateInputs(t4, e4))
      return null;
    const s5 = new x(this.paths[t4].splice(e4, 1)[0], this.spatialReference);
    return this.notifyChange("paths"), s5;
  }
  setPoint(t4, e4, s5) {
    return this._validateInputs(t4, e4) ? (h2(this, s5), Array.isArray(s5) || (s5 = s5.toArray()), this.paths[t4][e4] = s5, this.notifyChange("paths"), this) : this;
  }
  _validateInputs(t4, e4, s5 = false) {
    if (null == t4 || t4 < 0 || t4 >= this.paths.length)
      return false;
    if (null != e4) {
      const r5 = this.paths[t4];
      if (s5 && (e4 < 0 || e4 > r5.length))
        return false;
      if (!s5 && (e4 < 0 || e4 >= r5.length))
        return false;
    }
    return true;
  }
  toJSON(t4) {
    return this.write({}, t4);
  }
};
e([y({ readOnly: true })], f7.prototype, "cache", null), e([y({ readOnly: true })], f7.prototype, "extent", null), e([y({ type: [[[Number]]], json: { write: { isRequired: true } } })], f7.prototype, "paths", void 0), e([r("paths")], f7.prototype, "writePaths", null), f7 = c7 = e([c("esri.geometry.Polyline")], f7), f7.prototype.toJSON.isDefaultToJSON = true;
var m5 = f7;

export {
  u2 as u,
  t2 as t,
  n2 as n,
  s2 as s,
  f4 as f,
  a3 as a,
  m3 as m,
  g3 as g,
  r3 as r,
  l3 as l,
  i3 as i,
  f5 as f2,
  a2,
  c3 as c,
  f3,
  m2,
  l4 as l2,
  v,
  j,
  m5 as m3
};
//# sourceMappingURL=chunk-OIIDE5GZ.js.map
