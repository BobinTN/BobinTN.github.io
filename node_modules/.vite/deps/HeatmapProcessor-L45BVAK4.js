import {
  p
} from "./chunk-E4V5I23A.js";
import {
  o
} from "./chunk-46VITINB.js";
import {
  c as c2
} from "./chunk-XFC7DZXI.js";
import {
  a
} from "./chunk-SEKLTVY5.js";
import {
  s
} from "./chunk-6BFXMZEZ.js";
import "./chunk-AMSVADDY.js";
import "./chunk-EIY2DYTV.js";
import "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import "./chunk-JUZJCTW2.js";
import "./chunk-423VNHLR.js";
import "./chunk-FN47E7YK.js";
import "./chunk-LXXF7K7W.js";
import {
  c
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import "./chunk-WJ3HJKNC.js";
import "./chunk-4V6374PV.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/2d/layers/features/processors/HeatmapProcessor.js
var n = class {
  constructor(e2, t) {
    this.offset = e2, this.extent = t;
  }
};
function d(e2) {
  const t = e2.key, s2 = /* @__PURE__ */ new Map(), r = 256, o2 = c2, d2 = e2.tileInfoView.tileInfo.isWrappable;
  return s2.set(o(t, -1, -1, d2).id, new n([-o2, -o2], [o2 - r, o2 - r, o2, o2])), s2.set(o(t, 0, -1, d2).id, new n([0, -o2], [0, o2 - r, o2, o2])), s2.set(o(t, 1, -1, d2).id, new n([o2, -o2], [0, o2 - r, r, o2])), s2.set(o(t, -1, 0, d2).id, new n([-o2, 0], [o2 - r, 0, o2, o2])), s2.set(o(t, 1, 0, d2).id, new n([o2, 0], [0, 0, r, o2])), s2.set(o(t, -1, 1, d2).id, new n([-o2, o2], [o2 - r, 0, o2, r])), s2.set(o(t, 0, 1, d2).id, new n([0, o2], [0, 0, o2, r])), s2.set(o(t, 1, 1, d2).id, new n([o2, o2], [0, 0, r, r])), s2;
}
var l = class extends p {
  constructor() {
    super(...arguments), this.type = "heatmap", this._tileKeyToFeatureSets = /* @__PURE__ */ new Map();
  }
  initialize() {
    this.addHandles([this.tileStore.on("update", this.onTileUpdate.bind(this))]);
  }
  async update(e2, t) {
    const r = t.schema.processors[0];
    if ("heatmap" !== r.type)
      return;
    a(this._schema, r) && (e2.mesh = true, this._schema = r);
  }
  onTileUpdate(e2) {
    for (const t of e2.removed)
      this._tileKeyToFeatureSets.delete(t.key.id);
  }
  onTileClear(e2) {
    const t = { clear: true };
    return this._tileKeyToFeatureSets.delete(e2.key.id), this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: e2.id, data: t });
  }
  async onTileMessage(e2, t, s2) {
    this._tileKeyToFeatureSets.has(e2.key.id) || this._tileKeyToFeatureSets.set(e2.key.id, /* @__PURE__ */ new Map());
    const i = this._tileKeyToFeatureSets.get(e2.key.id);
    if (i && null != t.addOrUpdate && t.addOrUpdate.hasFeatures && i.set(t.addOrUpdate.instance, t), t.end) {
      const t2 = [], i2 = d(e2);
      this._tileKeyToFeatureSets.forEach((s3, r) => {
        if (r === e2.key.id)
          s3.forEach(({ addOrUpdate: e3 }) => {
            e3 && t2.push(e3);
          });
        else if (i2.has(r)) {
          const e3 = i2.get(r), [o3, a3] = e3.offset;
          s3.forEach(({ addOrUpdate: e4 }) => {
            if (e4) {
              const s4 = e4.transform(o3, a3, 1, 1);
              t2.push(s4);
            }
          });
        }
      });
      const o2 = s(t2, this._schema.mesh, 512, 512), a2 = { tileKey: e2.key.id, intensityInfo: o2 }, n2 = [o2.matrix];
      return this.remoteClient.invoke("tileRenderer.onTileData", a2, { ...s2, transferList: n2 });
    }
  }
  onTileError(e2, t, s2) {
    return this.remoteClient.invoke("tileRenderer.onTileError", { tileKey: e2.id, error: t }, s2);
  }
};
l = e([c("esri.views.2d.layers.features.processors.HeatmapProcessor")], l);
var p2 = l;
export {
  p2 as default
};
//# sourceMappingURL=HeatmapProcessor-L45BVAK4.js.map
