import {
  p as p2
} from "./chunk-CGHFVL5C.js";
import "./chunk-JDPYDQ7A.js";
import "./chunk-RURX4WVF.js";
import "./chunk-ED5W63C6.js";
import "./chunk-CQMEHG4P.js";
import "./chunk-GZTU5O23.js";
import {
  l
} from "./chunk-36R5EC6A.js";
import {
  j as j2
} from "./chunk-POSLR7O2.js";
import {
  u
} from "./chunk-YIAYIZOZ.js";
import {
  m
} from "./chunk-P5GW5DPX.js";
import {
  d
} from "./chunk-VIOPOI6P.js";
import "./chunk-HU7QYAVQ.js";
import "./chunk-T3Y5GTKO.js";
import "./chunk-CSWPLQ7Q.js";
import "./chunk-KWSMYM7P.js";
import "./chunk-6B7VJB6C.js";
import {
  v as v2
} from "./chunk-BADPOP5P.js";
import {
  b
} from "./chunk-YXRSJYLG.js";
import {
  p
} from "./chunk-KBKTS574.js";
import "./chunk-6ABSX3YY.js";
import "./chunk-24NOAXOQ.js";
import "./chunk-JHJVOI7Q.js";
import "./chunk-S6NERLXF.js";
import "./chunk-WOGT6UK2.js";
import "./chunk-BEALJUHO.js";
import "./chunk-Z6KIMOUA.js";
import "./chunk-SZAJDZCO.js";
import "./chunk-M7R7REMB.js";
import "./chunk-ZZYUEH57.js";
import "./chunk-VTWXDFFD.js";
import "./chunk-IPCIO3PX.js";
import "./chunk-AOJ6OCPK.js";
import "./chunk-LMT5JII2.js";
import "./chunk-A43TI6AT.js";
import "./chunk-BHJVWW2P.js";
import "./chunk-4HKQSEUR.js";
import "./chunk-V3U4F2NL.js";
import "./chunk-ZB6PGKG5.js";
import "./chunk-OIIDE5GZ.js";
import "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import "./chunk-TBSVVR6M.js";
import "./chunk-6TJWLWLO.js";
import "./chunk-H7BKONNV.js";
import "./chunk-K6C6RVSV.js";
import "./chunk-KBJ5Z4R2.js";
import "./chunk-JUZJCTW2.js";
import "./chunk-423VNHLR.js";
import "./chunk-FN47E7YK.js";
import "./chunk-XZS3Q5K4.js";
import "./chunk-XXFXRXFH.js";
import "./chunk-CCXEAKIM.js";
import "./chunk-Y5D433JZ.js";
import "./chunk-QNOCEWCR.js";
import {
  o
} from "./chunk-WURET5CW.js";
import "./chunk-QWPLZ3QH.js";
import "./chunk-HLGIRLYQ.js";
import "./chunk-N2K4VRZH.js";
import "./chunk-WL4VPODY.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import {
  j,
  v
} from "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import {
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  a,
  e as e2,
  s as s3
} from "./chunk-RFPH3ZTZ.js";
import {
  t
} from "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import {
  O
} from "./chunk-4V6374PV.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/support/ElevationTileData.js
var a2 = class {
  constructor(a3, t3, s5, e3) {
    this._hasNoDataValues = null, this._minValue = null, this._maxValue = null, "pixelData" in a3 ? (this.values = a3.pixelData, this.width = a3.width, this.height = a3.height, this.noDataValue = a3.noDataValue) : (this.values = a3, this.width = t3, this.height = s5, this.noDataValue = e3);
  }
  get hasNoDataValues() {
    if (null == this._hasNoDataValues) {
      const a3 = this.noDataValue;
      this._hasNoDataValues = this.values.includes(a3);
    }
    return this._hasNoDataValues;
  }
  get minValue() {
    return this._ensureBounds(), this._minValue;
  }
  get maxValue() {
    return this._ensureBounds(), this._maxValue;
  }
  _ensureBounds() {
    if (null != this._minValue)
      return;
    const { noDataValue: a3, values: t3 } = this;
    let s5 = 1 / 0, e3 = -1 / 0, i = true;
    for (const u2 of t3)
      u2 === a3 ? this._hasNoDataValues = true : (s5 = u2 < s5 ? u2 : s5, e3 = u2 > e3 ? u2 : e3, i = false);
    i ? (this._minValue = 0, this._maxValue = 0) : (this._minValue = s5, this._maxValue = e3 > -3e38 ? e3 : 0);
  }
};

// node_modules/@arcgis/core/core/workers/WorkerHandle.js
var h = class {
  constructor(e3, t3, r2, h2, o2 = {}) {
    this._mainMethod = t3, this._transferLists = r2, this._listeners = [], this._promise = p(e3, { ...o2, schedule: h2 }).then((e4) => {
      if (void 0 === this._thread) {
        this._thread = e4, this._promise = null, o2.hasInitialize && this.broadcast({}, "initialize");
        for (const e5 of this._listeners)
          this._connectListener(e5);
      } else
        e4.close();
    }), this._promise.catch((t4) => s.getLogger("esri.core.workers.WorkerHandle").error(`Failed to initialize ${e3} worker: ${t4}`));
  }
  on(s5, r2) {
    const i = { removed: false, eventName: s5, callback: r2, threadHandle: null };
    return this._listeners.push(i), this._connectListener(i), e2(() => {
      i.removed = true, O(this._listeners, i), this._thread && null != i.threadHandle && i.threadHandle.remove();
    });
  }
  destroy() {
    this._thread && (this._thread.close(), this._thread = null), this._promise = null, this._listeners.length = 0, this._transferLists = {};
  }
  invoke(e3, t3) {
    return this.invokeMethod(this._mainMethod, e3, t3);
  }
  invokeMethod(e3, t3, s5) {
    if (this._thread) {
      const r2 = this._transferLists[e3], i = r2 ? r2(t3) : [];
      return this._thread.invoke(e3, t3, { transferList: i, signal: s5 });
    }
    return this._promise ? this._promise.then(() => (s3(s5), this.invokeMethod(e3, t3, s5))) : Promise.reject(null);
  }
  broadcast(e3, t3) {
    return this._thread ? Promise.all(this._thread.broadcast(t3, e3)).then(() => {
    }) : this._promise ? this._promise.then(() => this.broadcast(e3, t3)) : Promise.reject();
  }
  get promise() {
    return this._promise;
  }
  _connectListener(e3) {
    this._thread && this._thread.on(e3.eventName, e3.callback).then((t3) => {
      e3.removed || (e3.threadHandle = t3);
    });
  }
};

// node_modules/@arcgis/core/layers/support/LercDecoder.js
var r = class extends h {
  constructor(e3 = null) {
    super("LercWorker", "_decode", { _decode: (e4) => [e4.buffer] }, e3, { strategy: "dedicated" }), this.schedule = e3, this.ref = 0;
  }
  decode(e3, r2, t3) {
    return e3 && 0 !== e3.byteLength ? this.invoke({ buffer: e3, options: r2 }, t3) : Promise.resolve(null);
  }
  release() {
    --this.ref <= 0 && (t2.forEach((e3, r2) => {
      e3 === this && t2.delete(r2);
    }), this.destroy());
  }
};
var t2 = /* @__PURE__ */ new Map();
function s4(e3 = null) {
  let s5 = t2.get(e3);
  return s5 || (null != e3 ? (s5 = new r((r2) => e3.immediate.schedule(r2)), t2.set(e3, s5)) : (s5 = new r(), t2.set(null, s5))), ++s5.ref, s5;
}

// node_modules/@arcgis/core/layers/ElevationLayer.js
var S = class extends p2(l(u(j2(m(b))))) {
  constructor(...e3) {
    super(...e3), this.capabilities = { operations: { supportsTileMap: false } }, this.copyright = null, this.heightModelInfo = null, this.path = null, this.minScale = void 0, this.maxScale = void 0, this.opacity = 1, this.operationalLayerType = "ArcGISTiledElevationServiceLayer", this.sourceJSON = null, this.type = "elevation", this.url = null, this.version = null, this._lercDecoder = s4();
  }
  normalizeCtorArgs(e3, r2) {
    return "string" == typeof e3 ? { url: e3, ...r2 } : e3;
  }
  destroy() {
    this._lercDecoder = t(this._lercDecoder);
  }
  readCapabilities(e3, r2) {
    const t3 = r2.capabilities && r2.capabilities.split(",").map((e4) => e4.toLowerCase().trim());
    if (!t3)
      return { operations: { supportsTileMap: false } };
    return { operations: { supportsTileMap: t3.includes("tilemap") } };
  }
  readVersion(e3, r2) {
    let t3 = r2.currentVersion;
    return t3 || (t3 = 9.3), t3;
  }
  load(e3) {
    const r2 = null != e3 ? e3.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"], supportsData: false, validateItem: (e4) => {
      for (let r3 = 0; r3 < e4.typeKeywords.length; r3++)
        if ("elevation 3d layer" === e4.typeKeywords[r3].toLowerCase())
          return true;
      throw new s2("portal:invalid-layer-item-type", "Invalid layer item type '${type}', expected '${expectedType}' ", { type: "Image Service", expectedType: "Image Service Elevation 3D Layer" });
    } }, e3).catch(a).then(() => this._fetchImageService(r2))), Promise.resolve(this);
  }
  fetchTile(e3, t3, i, o2) {
    const s5 = null != (o2 = o2 || { signal: null }).signal ? o2.signal : o2.signal = new AbortController().signal, a3 = { responseType: "array-buffer", signal: s5 }, p3 = { noDataValue: o2.noDataValue, returnFileInfo: true };
    return this.load().then(() => this._fetchTileAvailability(e3, t3, i, o2)).then(() => j(this.getTileUrl(e3, t3, i), a3)).then((e4) => this._lercDecoder.decode(e4.data, p3, s5)).then((e4) => new a2(e4));
  }
  getTileUrl(e3, r2, t3) {
    const i = !this.capabilities.operations.supportsTileMap && this.supportsBlankTile, o2 = v({ ...this.parsedUrl.query, blankTile: !i && null });
    return `${this.parsedUrl.path}/tile/${e3}/${r2}/${t3}${o2 ? "?" + o2 : ""}`;
  }
  async queryElevation(e3, r2) {
    const { ElevationQuery: t3 } = await import("./ElevationQuery-LZJLWGME.js");
    s3(r2);
    return new t3().query(this, e3, r2);
  }
  async createElevationSampler(e3, r2) {
    const { ElevationQuery: t3 } = await import("./ElevationQuery-LZJLWGME.js");
    s3(r2);
    return new t3().createSampler(this, e3, r2);
  }
  _fetchTileAvailability(e3, r2, t3, i) {
    return this.tilemapCache ? this.tilemapCache.fetchAvailability(e3, r2, t3, i) : Promise.resolve("unknown");
  }
  async _fetchImageService(e3) {
    var _a;
    if (this.sourceJSON)
      return this.sourceJSON;
    const t3 = { query: { f: "json", ...this.parsedUrl.query }, responseType: "json", signal: e3 }, i = await j(this.parsedUrl.path, t3);
    i.ssl && (this.url = (_a = this.url) == null ? void 0 : _a.replace(/^http:/i, "https:")), this.sourceJSON = i.data, this.read(i.data, { origin: "service", url: this.parsedUrl });
  }
  get hasOverriddenFetchTile() {
    return !this.fetchTile[w];
  }
};
e([y({ readOnly: true })], S.prototype, "capabilities", void 0), e([o("service", "capabilities", ["capabilities"])], S.prototype, "readCapabilities", null), e([y({ json: { read: { source: "copyrightText" } } })], S.prototype, "copyright", void 0), e([y({ readOnly: true, type: v2 })], S.prototype, "heightModelInfo", void 0), e([y({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], S.prototype, "path", void 0), e([y({ type: ["show", "hide"] })], S.prototype, "listMode", void 0), e([y({ json: { read: false, write: false, origins: { service: { read: false, write: false }, "portal-item": { read: false, write: false }, "web-document": { read: false, write: false } } }, readOnly: true })], S.prototype, "minScale", void 0), e([y({ json: { read: false, write: false, origins: { service: { read: false, write: false }, "portal-item": { read: false, write: false }, "web-document": { read: false, write: false } } }, readOnly: true })], S.prototype, "maxScale", void 0), e([y({ json: { read: false, write: false, origins: { "web-document": { read: false, write: false } } } })], S.prototype, "opacity", void 0), e([y({ type: ["ArcGISTiledElevationServiceLayer"] })], S.prototype, "operationalLayerType", void 0), e([y()], S.prototype, "sourceJSON", void 0), e([y({ json: { read: false }, value: "elevation", readOnly: true })], S.prototype, "type", void 0), e([y(d)], S.prototype, "url", void 0), e([y()], S.prototype, "version", void 0), e([o("version", ["currentVersion"])], S.prototype, "readVersion", null), S = e([c("esri.layers.ElevationLayer")], S);
var w = Symbol("default-fetch-tile");
S.prototype.fetchTile[w] = true;
var T = S;
export {
  T as default
};
//# sourceMappingURL=ElevationLayer-JVKQLVQ3.js.map
