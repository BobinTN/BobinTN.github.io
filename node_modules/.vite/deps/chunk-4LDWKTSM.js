import {
  m,
  n2 as n,
  p,
  v,
  y as y2
} from "./chunk-GDKL26HH.js";
import {
  p as p2
} from "./chunk-ICVVQFO6.js";
import {
  w2 as w
} from "./chunk-HITXLR5N.js";
import {
  h,
  w as w2
} from "./chunk-Z6KIMOUA.js";
import {
  i
} from "./chunk-M7R7REMB.js";
import {
  o as o2
} from "./chunk-V2RPSCV3.js";
import {
  o
} from "./chunk-WURET5CW.js";
import {
  r
} from "./chunk-QWPLZ3QH.js";
import {
  s as s3
} from "./chunk-OMPEZIP5.js";
import {
  s as s2
} from "./chunk-EUTNDAIV.js";
import {
  f
} from "./chunk-NSRXJNTS.js";
import {
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  a2,
  c,
  d,
  u2 as u
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  a,
  s2 as s
} from "./chunk-WJ3HJKNC.js";

// node_modules/@arcgis/core/renderers/support/ClassBreakInfo.js
var i2;
var l = i2 = class extends f {
  constructor(s4) {
    super(s4), this.description = null, this.label = null, this.minValue = null, this.maxValue = 0, this.symbol = null;
  }
  clone() {
    return new i2({ description: this.description, label: this.label, minValue: this.minValue, maxValue: this.maxValue, symbol: this.symbol ? this.symbol.clone() : null });
  }
  getMeshHash() {
    const s4 = JSON.stringify(this.symbol);
    return `${this.minValue}.${this.maxValue}.${s4}`;
  }
};
e([y({ type: String, json: { write: true } })], l.prototype, "description", void 0), e([y({ type: String, json: { write: true } })], l.prototype, "label", void 0), e([y({ type: Number, json: { read: { source: "classMinValue" }, write: { target: "classMinValue" } } })], l.prototype, "minValue", void 0), e([y({ type: Number, json: { read: { source: "classMaxValue" }, write: { target: "classMaxValue" } } })], l.prototype, "maxValue", void 0), e([y(n)], l.prototype, "symbol", void 0), l = i2 = e([c("esri.renderers.support.ClassBreakInfo")], l);
var a3 = l;

// node_modules/@arcgis/core/renderers/ClassBreaksRenderer.js
var B;
var V = "log";
var F = "percent-of-total";
var S = "field";
var E = new s2({ esriNormalizeByLog: V, esriNormalizeByPercentOfTotal: F, esriNormalizeByField: S });
var j = d(a3);
var z = B = class extends v(p) {
  constructor(e2) {
    super(e2), this._compiledValueExpression = { valueExpression: null, compiledFunction: null }, this.backgroundFillSymbol = null, this.classBreakInfos = null, this.defaultLabel = null, this.defaultSymbol = null, this.field = null, this.isMaxInclusive = true, this.legendOptions = null, this.normalizationField = null, this.normalizationTotal = null, this.type = "class-breaks", this.valueExpression = null, this.valueExpressionTitle = null, this._set("classBreakInfos", []);
  }
  readClassBreakInfos(e2, s4, t) {
    if (!Array.isArray(e2))
      return;
    let o3 = s4.minValue;
    return e2.map((e3) => {
      const s5 = new a3();
      return s5.read(e3, t), null == s5.minValue && (s5.minValue = o3), null == s5.maxValue && (s5.maxValue = s5.minValue), o3 = s5.maxValue, s5;
    });
  }
  writeClassBreakInfos(e2, s4, t, o3) {
    const i3 = e2.map((e3) => e3.write({}, o3));
    this._areClassBreaksConsecutive() && i3.forEach((e3) => delete e3.classMinValue), s4[t] = i3;
  }
  castField(e2) {
    return null == e2 ? e2 : "function" == typeof e2 ? (s.getLogger(this).error(".field: field must be a string value"), null) : u(e2);
  }
  get minValue() {
    return this.classBreakInfos && this.classBreakInfos[0] && this.classBreakInfos[0].minValue || 0;
  }
  get normalizationType() {
    let e2 = this._get("normalizationType");
    const s4 = !!this.normalizationField, t = null != this.normalizationTotal;
    return s4 || t ? (e2 = s4 && S || t && F || null, s4 && t && s.getLogger(this).warn("warning: both normalizationField and normalizationTotal are set!")) : e2 !== S && e2 !== F || (e2 = null), e2;
  }
  set normalizationType(e2) {
    this._set("normalizationType", e2);
  }
  addClassBreakInfo(e2, t, i3) {
    let r2 = null;
    r2 = "number" == typeof e2 ? new a3({ minValue: e2, maxValue: t, symbol: w(i3) }) : j(a(e2)), this.classBreakInfos.push(r2), 1 === this.classBreakInfos.length && this.notifyChange("minValue");
  }
  removeClassBreakInfo(e2, s4) {
    const t = this.classBreakInfos.length;
    for (let o3 = 0; o3 < t; o3++) {
      const t2 = [this.classBreakInfos[o3].minValue, this.classBreakInfos[o3].maxValue];
      if (t2[0] === e2 && t2[1] === s4) {
        this.classBreakInfos.splice(o3, 1);
        break;
      }
    }
  }
  getBreakIndex(e2, s4) {
    return this.valueExpression && null == (s4 == null ? void 0 : s4.arcade) && s.getLogger(this).warn(""), this.valueExpression ? this._getBreakIndexForExpression(e2, s4) : this._getBreakIndexForField(e2);
  }
  async getClassBreakInfo(e2, s4) {
    let t = s4;
    this.valueExpression && null == (s4 == null ? void 0 : s4.arcade) && (t = { ...t, arcade: await i() });
    const o3 = this.getBreakIndex(e2, t);
    return -1 !== o3 ? this.classBreakInfos[o3] : null;
  }
  getSymbol(e2, s4) {
    if (this.valueExpression && null == (s4 == null ? void 0 : s4.arcade))
      return void s.getLogger(this).error("#getSymbol()", "Please use getSymbolAsync if valueExpression is used");
    const t = this.getBreakIndex(e2, s4);
    return t > -1 ? this.classBreakInfos[t].symbol : this.defaultSymbol;
  }
  async getSymbolAsync(e2, s4) {
    let t = s4;
    if (this.valueExpression && null == (s4 == null ? void 0 : s4.arcade)) {
      const e3 = await i(), { arcadeUtils: s5 } = e3;
      s5.hasGeometryOperations(this.valueExpression) && await s5.enableGeometryOperations(), t = { ...t, arcade: e3 };
    }
    const o3 = this.getBreakIndex(e2, t);
    return o3 > -1 ? this.classBreakInfos[o3].symbol : this.defaultSymbol;
  }
  getSymbols() {
    const e2 = [];
    return this.classBreakInfos.forEach((s4) => {
      s4.symbol && e2.push(s4.symbol);
    }), this.defaultSymbol && e2.push(this.defaultSymbol), e2;
  }
  getAttributeHash() {
    return this.visualVariables && this.visualVariables.reduce((e2, s4) => e2 + s4.getAttributeHash(), "");
  }
  getMeshHash() {
    const e2 = JSON.stringify(this.backgroundFillSymbol), s4 = JSON.stringify(this.defaultSymbol), t = `${this.normalizationField}.${this.normalizationType}.${this.normalizationTotal}`;
    return `${e2}.${s4}.${this.classBreakInfos.reduce((e3, s5) => e3 + s5.getMeshHash(), "")}.${t}.${this.field}.${this.valueExpression}`;
  }
  get arcadeRequired() {
    return this.arcadeRequiredForVisualVariables || !!this.valueExpression;
  }
  clone() {
    var _a, _b;
    return new B({ field: this.field, backgroundFillSymbol: (_a = this.backgroundFillSymbol) == null ? void 0 : _a.clone(), defaultLabel: this.defaultLabel, defaultSymbol: (_b = this.defaultSymbol) == null ? void 0 : _b.clone(), valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, classBreakInfos: a(this.classBreakInfos), isMaxInclusive: this.isMaxInclusive, normalizationField: this.normalizationField, normalizationTotal: this.normalizationTotal, normalizationType: this.normalizationType, visualVariables: a(this.visualVariables), legendOptions: a(this.legendOptions), authoringInfo: this.authoringInfo && this.authoringInfo.clone() });
  }
  async collectRequiredFields(e2, s4) {
    const t = [this.collectVVRequiredFields(e2, s4), this.collectSymbolFields(e2, s4)];
    await Promise.all(t);
  }
  async collectSymbolFields(e2, s4) {
    const t = [...this.getSymbols().map((t2) => t2.collectRequiredFields(e2, s4)), h(e2, s4, this.valueExpression)];
    w2(e2, s4, this.field), w2(e2, s4, this.normalizationField), await Promise.all(t);
  }
  _getBreakIndexForExpression(e2, s4) {
    const { viewingMode: t, scale: o3, spatialReference: i3, arcade: r2, timeZone: a4 } = s4 ?? {}, { valueExpression: l2 } = this;
    let n2 = this._compiledValueExpression.valueExpression === l2 ? this._compiledValueExpression.compiledFunction : null;
    const u2 = r2.arcadeUtils;
    if (!n2) {
      const e3 = u2.createSyntaxTree(l2);
      n2 = u2.createFunction(e3), this._compiledValueExpression.compiledFunction = n2;
    }
    this._compiledValueExpression.valueExpression = l2;
    const c2 = u2.executeFunction(n2, u2.createExecContext(e2, u2.getViewInfo({ viewingMode: t, scale: o3, spatialReference: i3 }), a4));
    return this._getBreakIndexfromInfos(c2);
  }
  _getBreakIndexForField(e2) {
    const s4 = this.field, t = e2.attributes, o3 = this.normalizationType;
    let i3 = parseFloat(t[s4]);
    if (o3) {
      const e3 = this.normalizationTotal, s5 = parseFloat(this.normalizationField ? t[this.normalizationField] : void 0);
      if (o3 === V)
        i3 = Math.log(i3) * Math.LOG10E;
      else if (o3 !== F || null == e3 || isNaN(e3)) {
        if (o3 === S && !isNaN(s5)) {
          if (isNaN(i3) || isNaN(s5))
            return -1;
          i3 /= s5;
        }
      } else
        i3 = i3 / e3 * 100;
    }
    return this._getBreakIndexfromInfos(i3);
  }
  _getBreakIndexfromInfos(e2) {
    const s4 = this.isMaxInclusive;
    if (null != e2 && "number" == typeof e2 && !isNaN(e2))
      for (let t = 0; t < this.classBreakInfos.length; t++) {
        const o3 = [this.classBreakInfos[t].minValue, this.classBreakInfos[t].maxValue];
        if (o3[0] <= e2 && (s4 ? e2 <= o3[1] : e2 < o3[1]))
          return t;
      }
    return -1;
  }
  _areClassBreaksConsecutive() {
    const e2 = this.classBreakInfos, s4 = e2.length;
    for (let t = 1; t < s4; t++)
      if (e2[t - 1].maxValue !== e2[t].minValue)
        return false;
    return true;
  }
};
e([y(m)], z.prototype, "backgroundFillSymbol", void 0), e([y({ type: [a3] })], z.prototype, "classBreakInfos", void 0), e([o("classBreakInfos")], z.prototype, "readClassBreakInfos", null), e([r("classBreakInfos")], z.prototype, "writeClassBreakInfos", null), e([y({ type: String, json: { write: true } })], z.prototype, "defaultLabel", void 0), e([y(y2)], z.prototype, "defaultSymbol", void 0), e([y({ type: String, json: { write: true } })], z.prototype, "field", void 0), e([s3("field")], z.prototype, "castField", null), e([y({ type: Boolean })], z.prototype, "isMaxInclusive", void 0), e([y({ type: p2, json: { write: true } })], z.prototype, "legendOptions", void 0), e([y({ type: Number, readOnly: true, value: null, json: { read: false, write: { overridePolicy() {
  return 0 !== this.classBreakInfos.length && this._areClassBreaksConsecutive() ? { enabled: true } : { enabled: false };
} } } })], z.prototype, "minValue", null), e([y({ type: String, json: { write: true } })], z.prototype, "normalizationField", void 0), e([y({ type: Number, cast: (e2) => a2(e2), json: { write: true } })], z.prototype, "normalizationTotal", void 0), e([y({ type: E.apiValues, value: null, json: { type: E.jsonValues, read: E.read, write: E.write } })], z.prototype, "normalizationType", null), e([o2({ classBreaks: "class-breaks" })], z.prototype, "type", void 0), e([y({ type: String, json: { write: true } })], z.prototype, "valueExpression", void 0), e([y({ type: String, json: { write: true } })], z.prototype, "valueExpressionTitle", void 0), z = B = e([c("esri.renderers.ClassBreaksRenderer")], z);
var w3 = z;

export {
  a3 as a,
  w3 as w
};
//# sourceMappingURL=chunk-4LDWKTSM.js.map
