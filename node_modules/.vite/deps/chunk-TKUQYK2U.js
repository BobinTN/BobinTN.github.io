import {
  e,
  r
} from "./chunk-R72HXU5Y.js";
import {
  a as a2,
  l2 as l
} from "./chunk-BRF3NTLN.js";
import {
  de,
  ne,
  t
} from "./chunk-WR3GXMXV.js";
import {
  a
} from "./chunk-XI27PUTI.js";
import {
  c
} from "./chunk-MKW4ORPJ.js";

// node_modules/@arcgis/core/symbols/cim/Rasterizer.js
var m = 512;
var c2 = class {
  constructor(e2) {
    this._resourceManager = e2, this._lazyRasterizationCanvas = null;
  }
  dispose() {
    this._lazyRasterizationCanvas = null;
  }
  get _rasterizationCanvas() {
    return null == this._lazyRasterizationCanvas && (this._lazyRasterizationCanvas = document.createElement("canvas"), this._lazyRasterizationCanvas.getContext("2d", { willReadFrequently: true })), this._lazyRasterizationCanvas;
  }
  rasterizeJSONResource(l2, m2, c3) {
    if ("simple-fill" === l2.type || "esriSFS" === l2.type) {
      const [t2, a3, i] = r(this._rasterizationCanvas, l2.style, m2);
      return { size: [a3, i], image: new Uint32Array(t2.buffer), sdf: false, simplePattern: true, anchorX: 0, anchorY: 0, rasterizationScale: c(Math.ceil(m2)) };
    }
    if ("simple-line" === l2.type || "esriSLS" === l2.type || "line" === l2.type && l2.dashTemplate) {
      let e2, a3;
      if ("simple-line" === l2.type || "esriSLS" === l2.type)
        switch (e2 = de(l2.style, l2.cap), l2.cap) {
          case "butt":
            a3 = "Butt";
            break;
          case "square":
            a3 = "Square";
            break;
          default:
            a3 = "Round";
        }
      else
        e2 = l2.dashTemplate, a3 = l2.cim.capStyle;
      const [r2, n, s] = e(e2, a3);
      return { size: [n, s], image: new Uint32Array(r2.buffer), sdf: true, simplePattern: true, anchorX: 0, anchorY: 0 };
    }
    let f, h = null, p = null, u = 1;
    if ("simple-marker" === l2.type || "esriSMS" === l2.type || "line-marker" === l2.type ? (f = ne.fromSimpleMarker(l2), p = l(f)) : l2.cim && "CIMHatchFill" === l2.cim.type ? (f = ne.fromCIMHatchFill(l2.cim, m2), h = new t(f.frame.xmin, -f.frame.ymax, f.frame.xmax - f.frame.xmin, f.frame.ymax - f.frame.ymin), u = m2) : l2.cim.markerPlacement && "CIMMarkerPlacementInsidePolygon" === l2.cim.markerPlacement.type ? (f = ne.fromCIMInsidePolygon(l2.cim), h = new t(f.frame.xmin, -f.frame.ymax, f.frame.xmax - f.frame.xmin, f.frame.ymax - f.frame.ymin)) : (f = l2.cim, l2.avoidSDFRasterization || (p = l(f))), p && !c3) {
      const [e2, t2, a3] = a2(p);
      return e2 ? { size: [t2, a3], image: new Uint32Array(e2.buffer), sdf: true, simplePattern: true, anchorX: 0, anchorY: 0, rasterizationScale: u } : null;
    }
    const [y, z, d, C, g] = ne.rasterize(this._rasterizationCanvas, f, h, this._resourceManager, !c3);
    return y ? { size: [z, d], image: new Uint32Array(y.buffer), sdf: false, simplePattern: false, anchorX: C, anchorY: g } : null;
  }
  rasterizeImageResource(e2, t2, a3, r2) {
    this._rasterizationCanvas.width = e2, this._rasterizationCanvas.height = t2;
    const i = this._rasterizationCanvas.getContext("2d");
    a3 instanceof ImageData ? i.putImageData(a3, 0, 0) : (a3.setAttribute("width", `${e2}px`), a3.setAttribute("height", `${t2}px`), i.drawImage(a3, 0, 0, e2, t2));
    const n = i.getImageData(0, 0, e2, t2), s = new Uint8Array(n.data);
    if (r2) {
      for (const l2 of r2)
        if (l2 && l2.oldColor && 4 === l2.oldColor.length && l2.newColor && 4 === l2.newColor.length) {
          const [e3, t3, a4, r3] = l2.oldColor, [i2, n2, o2, m2] = l2.newColor;
          if (e3 === i2 && t3 === n2 && a4 === o2 && r3 === m2)
            continue;
          for (let l3 = 0; l3 < s.length; l3 += 4)
            e3 === s[l3] && t3 === s[l3 + 1] && a4 === s[l3 + 2] && r3 === s[l3 + 3] && (s[l3] = i2, s[l3 + 1] = n2, s[l3 + 2] = o2, s[l3 + 3] = m2);
        }
    }
    let o;
    for (let l2 = 0; l2 < s.length; l2 += 4)
      o = s[l2 + 3] / 255, s[l2] = s[l2] * o, s[l2 + 1] = s[l2 + 1] * o, s[l2 + 2] = s[l2 + 2] * o;
    let c3 = s, f = e2, h = t2;
    const p = m;
    if (f >= p || h >= p) {
      const a4 = f / h;
      a4 > 1 ? (f = p, h = Math.round(p / a4)) : (h = p, f = Math.round(p * a4)), c3 = new Uint8Array(4 * f * h);
      const r3 = new Uint8ClampedArray(c3.buffer);
      a(s, e2, t2, r3, f, h, false);
    }
    return { size: [f, h], image: new Uint32Array(c3.buffer), sdf: false, simplePattern: false, anchorX: 0, anchorY: 0 };
  }
};

export {
  c2 as c
};
//# sourceMappingURL=chunk-TKUQYK2U.js.map
