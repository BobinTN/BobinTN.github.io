import {
  c as c2,
  o as o3
} from "./chunk-BEALJUHO.js";
import {
  o
} from "./chunk-KBJ5Z4R2.js";
import {
  o as o2
} from "./chunk-WURET5CW.js";
import {
  r
} from "./chunk-QWPLZ3QH.js";
import {
  f
} from "./chunk-NSRXJNTS.js";
import {
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";

// node_modules/@arcgis/core/TimeExtent.js
var u;
var m = u = class extends f {
  static get allTime() {
    return p;
  }
  static get empty() {
    return d;
  }
  constructor(t) {
    super(t), this.end = null, this.start = null;
  }
  readEnd(t, e2) {
    return null != e2.end ? new Date(e2.end) : null;
  }
  writeEnd(t, e2) {
    e2.end = (t == null ? void 0 : t.getTime()) ?? null;
  }
  get isAllTime() {
    return this.equals(u.allTime);
  }
  get isEmpty() {
    return this.equals(u.empty);
  }
  readStart(t, e2) {
    return null != e2.start ? new Date(e2.start) : null;
  }
  writeStart(t, e2) {
    e2.start = (t == null ? void 0 : t.getTime()) ?? null;
  }
  clone() {
    return new u({ end: this.end, start: this.start });
  }
  equals(t) {
    var _a, _b, _c, _d;
    if (!t)
      return false;
    const e2 = ((_a = this.start) == null ? void 0 : _a.getTime()) ?? this.start, r2 = ((_b = this.end) == null ? void 0 : _b.getTime()) ?? this.end, s = ((_c = t.start) == null ? void 0 : _c.getTime()) ?? t.start, n = ((_d = t.end) == null ? void 0 : _d.getTime()) ?? t.end;
    return e2 === s && r2 === n;
  }
  expandTo(t, e2 = o) {
    if (this.isEmpty || this.isAllTime)
      return this.clone();
    let n = this.start;
    n && (n = c2(n, t, e2));
    let i = this.end;
    if (i) {
      const n2 = c2(i, t, e2);
      i = i.getTime() === n2.getTime() ? n2 : o3(n2, 1, t, e2);
    }
    return new u({ start: n, end: i });
  }
  intersection(t) {
    var _a, _b, _c, _d;
    if (!t)
      return this.clone();
    if (this.isEmpty || t.isEmpty)
      return u.empty;
    if (this.isAllTime)
      return t.clone();
    if (t.isAllTime)
      return this.clone();
    const e2 = ((_a = this.start) == null ? void 0 : _a.getTime()) ?? -1 / 0, r2 = ((_b = this.end) == null ? void 0 : _b.getTime()) ?? 1 / 0, s = ((_c = t.start) == null ? void 0 : _c.getTime()) ?? -1 / 0, n = ((_d = t.end) == null ? void 0 : _d.getTime()) ?? 1 / 0;
    let i, l;
    if (s >= e2 && s <= r2 ? i = s : e2 >= s && e2 <= n && (i = e2), r2 >= s && r2 <= n ? l = r2 : n >= e2 && n <= r2 && (l = n), null != i && null != l && !isNaN(i) && !isNaN(l)) {
      const t2 = new u();
      return t2.start = i === -1 / 0 ? null : new Date(i), t2.end = l === 1 / 0 ? null : new Date(l), t2;
    }
    return u.empty;
  }
  offset(t, e2, r2 = o) {
    if (this.isEmpty || this.isAllTime)
      return this.clone();
    const n = new u(), { start: i, end: l } = this;
    return null != i && (n.start = o3(i, t, e2, r2)), null != l && (n.end = o3(l, t, e2, r2)), n;
  }
  union(t) {
    if (!t || t.isEmpty)
      return this.clone();
    if (this.isEmpty)
      return t.clone();
    if (this.isAllTime || t.isAllTime)
      return p.clone();
    const e2 = null != this.start && null != t.start ? new Date(Math.min(this.start.getTime(), t.start.getTime())) : null, r2 = null != this.end && null != t.end ? new Date(Math.max(this.end.getTime(), t.end.getTime())) : null;
    return new u({ start: e2, end: r2 });
  }
};
e([y({ type: Date, json: { write: { allowNull: true } } })], m.prototype, "end", void 0), e([o2("end")], m.prototype, "readEnd", null), e([r("end")], m.prototype, "writeEnd", null), e([y({ readOnly: true, json: { read: false } })], m.prototype, "isAllTime", null), e([y({ readOnly: true, json: { read: false } })], m.prototype, "isEmpty", null), e([y({ type: Date, json: { write: { allowNull: true } } })], m.prototype, "start", void 0), e([o2("start")], m.prototype, "readStart", null), e([r("start")], m.prototype, "writeStart", null), m = u = e([c("esri.TimeExtent")], m);
var p = new m();
var d = new m({ start: void 0, end: void 0 });
var c3 = m;

export {
  c3 as c
};
//# sourceMappingURL=chunk-WOGT6UK2.js.map
