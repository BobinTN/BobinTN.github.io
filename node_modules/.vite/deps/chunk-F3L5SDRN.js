import {
  e as e3,
  n as n4
} from "./chunk-FUZOO24T.js";
import {
  T as T3,
  f as f3,
  t as t3
} from "./chunk-UQHFLGCY.js";
import {
  n2 as n5,
  n3 as n6
} from "./chunk-IF6ORLWU.js";
import {
  f as f2
} from "./chunk-BV5PCIP6.js";
import {
  s as s2
} from "./chunk-PTWYQEPE.js";
import {
  G as G2,
  S as S2
} from "./chunk-BNTQULGG.js";
import {
  E as E2,
  h
} from "./chunk-A6KO3R3G.js";
import {
  T as T2,
  a,
  a2,
  e2,
  u
} from "./chunk-T56C4ORZ.js";
import {
  o
} from "./chunk-RN5RTM2J.js";
import {
  t as t2
} from "./chunk-5JIGIHKI.js";
import {
  r as r4
} from "./chunk-OG2GBCUQ.js";
import {
  t
} from "./chunk-PPQAHSM4.js";
import {
  A as A2,
  C,
  D,
  E,
  F,
  G,
  I,
  L,
  M,
  N,
  O,
  P,
  R,
  S,
  T,
  U,
  V,
  X,
  Y,
  _,
  e,
  f,
  n as n2,
  r as r3
} from "./chunk-RCLKRKWR.js";
import {
  n as n3
} from "./chunk-MVXU4PVF.js";
import {
  r as r2
} from "./chunk-YTH6VA7N.js";
import {
  A
} from "./chunk-RFPH3ZTZ.js";
import {
  r
} from "./chunk-WGO3VFQP.js";
import {
  n
} from "./chunk-CQS47VN5.js";
import {
  s2 as s
} from "./chunk-WJ3HJKNC.js";
import {
  has
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/MaterialPrograms.js
var e4 = (r7) => {
  let t6 = "";
  t6 += r7[0].toUpperCase();
  for (let e8 = 1; e8 < r7.length; e8++) {
    const s4 = r7[e8];
    s4 === s4.toUpperCase() ? (t6 += "_", t6 += s4) : t6 += s4.toUpperCase();
  }
  return t6;
};
var s3 = (r7) => {
  const s4 = {};
  for (const t6 in r7) {
    s4[e4(t6)] = r7[t6];
  }
  return n4(s4);
};
var o2 = (t6, e8, o5, n10) => {
  const a3 = t6 + t6.substring(t6.lastIndexOf("/")), p = e8 + e8.substring(e8.lastIndexOf("/")), f4 = s3(n10);
  return { attributes: o5, shaders: { vertexShader: f4 + n5(`${a3}.vert`), fragmentShader: f4 + n5(`${p}.frag`) } };
};

// node_modules/@arcgis/core/views/webgl/ContextState.js
var h2 = class {
  constructor() {
    this.blend = false, this.blendColor = { r: 0, g: 0, b: 0, a: 0 }, this.blendFunction = { srcRGB: R.ONE, dstRGB: R.ZERO, srcAlpha: R.ONE, dstAlpha: R.ZERO }, this.blendEquation = { mode: T.ADD, modeAlpha: T.ADD }, this.colorMask = { r: true, g: true, b: true, a: true }, this.faceCulling = false, this.cullFace = N.BACK, this.frontFace = S.CCW, this.scissorTest = false, this.scissorRect = { x: 0, y: 0, width: 0, height: 0 }, this.depthTest = false, this.depthFunction = O.LESS, this.clearDepth = 1, this.depthWrite = true, this.depthRange = { zNear: 0, zFar: 1 }, this.viewport = null, this.stencilTest = false, this.polygonOffsetFill = false, this.polygonOffset = [0, 0], this.stencilFunction = { face: N.FRONT_AND_BACK, func: O.ALWAYS, ref: 0, mask: 1 }, this.clearStencil = 0, this.stencilWriteMask = 1, this.stencilOperation = { face: N.FRONT_AND_BACK, fail: I.KEEP, zFail: I.KEEP, zPass: I.KEEP }, this.clearColor = { r: 0, g: 0, b: 0, a: 0 }, this.program = null, this.vertexBuffer = null, this.indexBuffer = null, this.uniformBuffer = null, this.pixelPackBuffer = null, this.pixelUnpackBuffer = null, this.copyReadBuffer = null, this.copyWriteBuffer = null, this.uniformBufferBindingPoints = new Array(), this.readFramebuffer = null, this.drawFramebuffer = null, this.renderbuffer = null, this.activeTexture = 0, this.textureUnitMap = new Array(), this.vertexArrayObject = null;
  }
};

// node_modules/@arcgis/core/views/support/AllocationTracer.js
var t4 = class {
  constructor(t6) {
    this._allocations = /* @__PURE__ */ new Map(), t6 ? Error.stackTraceLimit = 1 / 0 : (this.add = () => {
    }, this.remove = () => {
    });
  }
  add(t6) {
    this._allocations.set(t6, new Error().stack);
  }
  remove(t6) {
    this._allocations.delete(t6);
  }
  get information() {
    let t6 = "";
    if (this._allocations.size > 0) {
      t6 += `${this._allocations.size} live object allocations:
`;
      const s4 = /* @__PURE__ */ new Map();
      this._allocations.forEach((t7) => {
        s4.set(t7, (s4.get(t7) ?? 0) + 1);
      }), s4.forEach((s5, o5) => {
        const i = o5.split("\n");
        i.shift(), i.shift(), t6 += `${s5}: ${i.shift()}
`, i.forEach((s6) => t6 += `   ${s6}
`);
      });
    }
    return t6;
  }
};

// node_modules/@arcgis/core/views/webgl/InstanceCounter.js
var e5 = { RECORD_ALLOCATIONS: false };
var n7 = class {
  constructor() {
    for (this._current = new Array(), this._allocations = new t4(e5.RECORD_ALLOCATIONS); this._current.length < V.COUNT; )
      this._current.push(0);
  }
  increment(t6, r7, e8 = 1) {
    this._current[t6] += e8, this._allocations.add(r7);
  }
  decrement(t6, r7, e8 = 1) {
    this._current[t6] -= e8, this._allocations.remove(r7);
  }
  get current() {
    return this._current;
  }
  get total() {
    return this.current.reduce((t6, e8, n10) => t6 + (n10 < V.UNCOUNTED ? e8 : 0), 0);
  }
  get resourceInformation() {
    let t6 = "";
    if (this.total > 0) {
      t6 += "Live objects:\n";
      for (let e8 = 0; e8 < V.COUNT; ++e8) {
        const n10 = this._current[e8];
        n10 > 0 && (t6 += `${V[e8]}: ${n10}
`);
      }
    }
    return t6 += this._allocations.information, t6;
  }
};

// node_modules/@arcgis/core/views/webgl/Parameters.js
var t5 = class {
  constructor(t6, r7, a3) {
    const i = r7.textureFilterAnisotropic, m = a3.maxAnisotropy ?? 1 / 0;
    this.versionString = t6.getParameter(t6.VERSION), this.maxVertexTextureImageUnits = t6.getParameter(t6.MAX_VERTEX_TEXTURE_IMAGE_UNITS), this.maxVertexAttributes = t6.getParameter(t6.MAX_VERTEX_ATTRIBS), this.maxMaxAnisotropy = i ? Math.min(t6.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY), m) : 1, this.maxTextureImageUnits = t6.getParameter(t6.MAX_TEXTURE_IMAGE_UNITS), this.maxTextureSize = t6.getParameter(t6.MAX_TEXTURE_SIZE), this.maxRenderbufferSize = t6.getParameter(t6.MAX_RENDERBUFFER_SIZE), this.maxViewportDims = t6.getParameter(t6.MAX_VIEWPORT_DIMS), n6(t6) ? (this.maxUniformBufferBindings = t6.getParameter(t6.MAX_UNIFORM_BUFFER_BINDINGS), this.maxVertexUniformBlocks = t6.getParameter(t6.MAX_VERTEX_UNIFORM_BLOCKS), this.maxFragmentUniformBlocks = t6.getParameter(t6.MAX_FRAGMENT_UNIFORM_BLOCKS), this.maxUniformBlockSize = t6.getParameter(t6.MAX_UNIFORM_BLOCK_SIZE), this.uniformBufferOffsetAlignment = t6.getParameter(t6.UNIFORM_BUFFER_OFFSET_ALIGNMENT), this.maxArrayTextureLayers = t6.getParameter(t6.MAX_ARRAY_TEXTURE_LAYERS), this.maxSamples = t6.getParameter(t6.MAX_SAMPLES)) : (this.maxUniformBufferBindings = 0, this.maxVertexUniformBlocks = 0, this.maxFragmentUniformBlocks = 0, this.maxUniformBlockSize = 0, this.uniformBufferOffsetAlignment = 1, this.maxArrayTextureLayers = 1, this.maxSamples = 1);
  }
};

// node_modules/@arcgis/core/views/webgl/AppleAmdDriverHelper.js
var n8 = class _n {
  constructor(e8) {
    this._rctx = e8, this._indexBuffer = this._createIndexbuffer(), this._program = this._createHelperProgram();
  }
  static getShaderSources() {
    return { vertex: "#version 300 es\n    precision highp float;\n\n    void main(void) {\n      gl_Position = vec4(0.0, 0.0, float(gl_VertexID)-2.0, 1.0);\n    }", fragment: "#version 300 es\n    precision highp float;\n\n    out vec4 fragColor;\n\n    void main(void) {\n      fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }" };
  }
  _createHelperProgram() {
    const e8 = _n.getShaderSources();
    return this._rctx.programCache.acquire(e8.vertex, e8.fragment, /* @__PURE__ */ new Map([]));
  }
  _createIndexbuffer() {
    return h.createIndex(this._rctx, F.STATIC_DRAW, new Uint32Array([0]));
  }
  run() {
    this._program.compiled && this._indexBuffer && (this._rctx.bindVAO(null), this._rctx.useProgram(this._program), this._rctx.bindBuffer(this._indexBuffer, A2.ELEMENT_ARRAY_BUFFER), this._rctx.drawElements(E.POINTS, 1, C.UNSIGNED_INT, 0));
  }
  dispose() {
    this._program.dispose(), this._indexBuffer.dispose();
  }
  get test() {
    var _a;
    return { cachedWebGLObjects: ((_a = this._indexBuffer) == null ? void 0 : _a.glName) ? 1 : 0 };
  }
};

// node_modules/@arcgis/core/views/webgl/testAppleAmdDrawArrays.js
var h3 = class extends t3 {
  constructor(e8) {
    super(), this._rctx = e8, this._helperProgram = null, this._rctx.type === n3.WEBGL2 && has("mac") && has("chrome") && (this._program = this._prepareProgram(), this._helperProgram = this._prepareHelperProgram());
  }
  dispose() {
    var _a;
    super.dispose(), (_a = this._helperProgram) == null ? void 0 : _a.dispose(), this._helperProgram = null;
  }
  _test(e8) {
    const r7 = this._rctx, o5 = r7.getBoundFramebufferObject(), { x: d3, y: h4, width: u2, height: _3 } = r7.getViewport();
    r7.resetState();
    const v = new e2(1);
    v.wrapMode = D.CLAMP_TO_EDGE, v.samplingMode = L.NEAREST;
    const x = new E2(r7, v), E4 = h.createIndex(this._rctx, F.STATIC_DRAW, new Uint8Array([0]));
    r7.bindFramebuffer(x), r7.setViewport(0, 0, 1, 1), r7.useProgram(this._helperProgram), r7.bindBuffer(E4, A2.ELEMENT_ARRAY_BUFFER), r7.drawElements(E.POINTS, 1, C.UNSIGNED_BYTE, 0), r7.useProgram(e8), r7.bindVAO(null), r7.drawArrays(E.TRIANGLES, 0, 258);
    const P2 = new Uint8Array(4);
    return x.readPixels(0, 0, 1, 1, G.RGBA, U.UNSIGNED_BYTE, P2), r7.setViewport(d3, h4, u2, _3), r7.bindFramebuffer(o5), x.dispose(), E4.dispose(), 255 === P2[0];
  }
  _prepareProgram() {
    const r7 = 85, t6 = `#version 300 es
    precision highp float;

    out float triangleId;

    const vec3 triangleVertices[3] = vec3[3](vec3(-0.5, -0.5, 0.0), vec3(0.5, -0.5, 0.0), vec3(0.0, 0.5, 0.0));

    void main(void) {
      triangleId = floor(float(gl_VertexID)/3.0);

      vec3 position = triangleVertices[gl_VertexID % 3];
      float offset = triangleId / ${o.float(r7)};
      position.z = 0.5 - offset;

      gl_Position = vec4(position, 1.0);
    }
    `, o5 = `#version 300 es
    precision highp float;

    in float triangleId;

    out vec4 fragColor;

    void main(void) {
      fragColor = triangleId == ${o.float(r7)} ? vec4(0.0, 1.0, 0.0, 1.0) : vec4(1.0, 0.0, 0.0, 1.0);
    }
    `;
    return this._rctx.programCache.acquire(t6, o5, /* @__PURE__ */ new Map([]));
  }
  _prepareHelperProgram() {
    const e8 = n8.getShaderSources();
    return this._rctx.programCache.acquire(e8.vertex, e8.fragment, /* @__PURE__ */ new Map([]));
  }
};

// node_modules/@arcgis/core/views/webgl/testDoublePrecisionArithmetic.js
var d = class extends t3 {
  constructor(e8) {
    super(), this._rctx = e8, this._program = A3(this._rctx, false), this._obfuscated = A3(this._rctx, true);
  }
  dispose() {
    super.dispose(), this._obfuscated = r(this._obfuscated);
  }
  _test(e8) {
    if (has("force-double-precision-obfuscation"))
      return true;
    if (null == this._obfuscated)
      return false;
    const n10 = this._runProgram(e8), o5 = this._runProgram(this._obfuscated);
    return 0 !== n10 && (0 === o5 || n10 / o5 > 5);
  }
  _runProgram(n10) {
    const _3 = this._rctx;
    _3.resetState();
    const d3 = new e2(1);
    d3.wrapMode = D.CLAMP_TO_EDGE, d3.samplingMode = L.NEAREST;
    const A5 = new E2(_3, d3), b = h.createVertex(_3, F.STATIC_DRAW, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])), g3 = new f2(_3, /* @__PURE__ */ new Map([["position", 0]]), { geometry: [new t("position", 2, C.UNSIGNED_SHORT, 0, 4)] }, { geometry: b }), B = r2(5633261287538229e-9, 2626832878767164e-9, 1.4349880495278358e6), F2 = r2(563327146742708e-8, 2.6268736381334523e6, 1434963231608387e-9), w = new Float32Array(6);
    t2(B, w, 3);
    const E4 = new Float32Array(6);
    t2(F2, E4, 3), _3.useProgram(n10), n10.setUniform3f("u_highA", w[0], w[2], w[4]), n10.setUniform3f("u_lowA", w[1], w[3], w[5]), n10.setUniform3f("u_highB", E4[0], E4[2], E4[4]), n10.setUniform3f("u_lowB", E4[1], E4[3], E4[5]), _3.bindFramebuffer(A5), _3.setViewport(0, 0, 1, 1), _3.bindVAO(g3), _3.drawArrays(E.TRIANGLE_STRIP, 0, 4);
    const O2 = new Uint8Array(4);
    A5.readPixels(0, 0, 1, 1, G.RGBA, U.UNSIGNED_BYTE, O2), g3.dispose(), A5.dispose();
    const I2 = (B[2] - F2[2]) / 25, U2 = r4(O2);
    return Math.abs(I2 - U2);
  }
};
function A3(e8, n10) {
  const o5 = `

  precision highp float;

  attribute vec2 position;

  uniform vec3 u_highA;
  uniform vec3 u_lowA;
  uniform vec3 u_highB;
  uniform vec3 u_lowB;

  varying vec4 v_color;

  ${n10 ? "#define DOUBLE_PRECISION_REQUIRES_OBFUSCATION" : ""}

  #ifdef DOUBLE_PRECISION_REQUIRES_OBFUSCATION

  vec3 dpPlusFrc(vec3 a, vec3 b) {
    return mix(a, a + b, vec3(notEqual(b, vec3(0))));
  }

  vec3 dpMinusFrc(vec3 a, vec3 b) {
    return mix(vec3(0), a - b, vec3(notEqual(a, b)));
  }

  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {
    vec3 t1 = dpPlusFrc(hiA, hiB);
    vec3 e = dpMinusFrc(t1, hiA);
    vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;
    return t1 + t2;
  }

  #else

  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {
    vec3 t1 = hiA + hiB;
    vec3 e = t1 - hiA;
    vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;
    return t1 + t2;
  }

  #endif

  const float MAX_RGBA_FLOAT =
    255.0 / 256.0 +
    255.0 / 256.0 / 256.0 +
    255.0 / 256.0 / 256.0 / 256.0 +
    255.0 / 256.0 / 256.0 / 256.0 / 256.0;

  const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);

  vec4 float2rgba(const float value) {
    // Make sure value is in the domain we can represent
    float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);

    // Decompose value in 32bit fixed point parts represented as
    // uint8 rgba components. Decomposition uses the fractional part after multiplying
    // by a power of 256 (this removes the bits that are represented in the previous
    // component) and then converts the fractional part to 8bits.
    vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);

    // Convert uint8 values (from 0 to 255) to floating point representation for
    // the shader
    const float toU8AsFloat = 1.0 / 255.0;

    return fixedPointU8 * toU8AsFloat;
  }

  void main() {
    vec3 val = dpAdd(u_highA, u_lowA, -u_highB, -u_lowB);

    v_color = float2rgba(val.z / 25.0);

    gl_Position = vec4(position * 2.0 - 1.0, 0.0, 1.0);
  }
  `, t6 = "\n  precision highp float;\n\n  varying vec4 v_color;\n\n  void main() {\n    gl_FragColor = v_color;\n  }\n  ";
  return e8.programCache.acquire(o5, t6, /* @__PURE__ */ new Map([["position", 0]]));
}

// node_modules/@arcgis/core/views/webgl/testFloatBufferBlend.js
var g = class extends t3 {
  constructor(e8) {
    var _a, _b, _c, _d, _e;
    if (super(), this._rctx = e8, !e8.gl)
      return;
    if (e8.type === n3.WEBGL1)
      return void (this._result = !(!((_a = e8.capabilities.textureFloat) == null ? void 0 : _a.textureFloat) || !((_b = e8.capabilities.colorBufferFloat) == null ? void 0 : _b.textureFloat)));
    if (!(((_c = e8.capabilities.textureFloat) == null ? void 0 : _c.textureFloat) && ((_d = e8.capabilities.colorBufferFloat) == null ? void 0 : _d.textureFloat) && ((_e = e8.capabilities.colorBufferFloat) == null ? void 0 : _e.floatBlend)))
      return;
    const t6 = "\n    precision highp float;\n    attribute vec2 a_pos;\n\n    void main() {\n      gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);\n    }\n    ", o5 = "\n     precision highp float;\n\n     void main() {\n      gl_FragColor = vec4(0.5, 0.5, 0.5, 0.5);\n     }\n    ";
    this._program = e8.programCache.acquire(t6, o5, /* @__PURE__ */ new Map([["a_pos", 0]]));
  }
  _test(r7) {
    const d3 = this._rctx, g3 = new e2(1);
    g3.wrapMode = D.CLAMP_TO_EDGE, g3.dataType = U.FLOAT, g3.internalFormat = P.RGBA32F, g3.samplingMode = L.NEAREST;
    const _3 = new E2(d3, g3), x = h.createVertex(d3, F.STATIC_DRAW, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])), F2 = new f2(d3, /* @__PURE__ */ new Map([["a_pos", 0]]), { geometry: [new t("a_pos", 2, C.UNSIGNED_SHORT, 0, 4)] }, { geometry: x });
    d3.useProgram(r7);
    const w = d3.getBoundFramebufferObject(), { x: j, y: T4, width: A5, height: h4 } = d3.getViewport();
    d3.bindFramebuffer(_3), d3.setViewport(0, 0, 1, 1), d3.bindVAO(F2), d3.drawArrays(E.TRIANGLE_STRIP, 0, 4);
    const y = S2({ blending: s2 });
    d3.setPipelineState(y), d3.drawArrays(E.TRIANGLE_STRIP, 0, 4);
    const E4 = d3.gl.getError();
    return d3.setViewport(j, T4, A5, h4), d3.bindFramebuffer(w), F2.dispose(), _3.dispose(), 1282 !== E4 || (console.warn("Device claims support for WebGL extension EXT_float_blend but does not support it. Using fall back."), false);
  }
};

// node_modules/@arcgis/core/views/webgl/testSamplerPrecision.js
var g2 = class extends t3 {
  constructor(e8) {
    super(), this._rctx = e8;
    const r7 = "\n      precision highp float;\n      attribute vec2 a_pos;\n      uniform highp sampler2D u_texture;\n      varying vec4 v_color;\n\n      float getBit(in float bitset, in int bitIndex) {\n        float offset = pow(2.0, float(bitIndex));\n        return mod(floor(bitset / offset), 2.0);\n      }\n\n      void main() {\n        vec4 value = texture2D(u_texture, vec2(0.0));\n        float bit = getBit(value.x * 255.0, 1);\n\n        v_color = bit * vec4(1.0);\n        gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);\n      }\n      ", t6 = "\n      precision highp float;\n      varying vec4 v_color;\n\n      void main() {\n        gl_FragColor = v_color;\n      }\n      ";
    this._program = e8.programCache.acquire(r7, t6, /* @__PURE__ */ new Map([["a_pos", 0]]));
  }
  _test(d3) {
    const g3 = this._rctx, b = new e2(1);
    b.wrapMode = D.CLAMP_TO_EDGE, b.samplingMode = L.NEAREST;
    const w = new E2(g3, b), v = new Uint8Array(4), _3 = h.createVertex(g3, F.STATIC_DRAW, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])), h4 = new f2(g3, /* @__PURE__ */ new Map([["a_position", 0]]), { geometry: [new t("a_position", 2, C.SHORT, 0, 4)] }, { geometry: _3 });
    g3.useProgram(d3);
    const x = new T2(g3, b, new Uint8Array([2, 255, 0, 0]));
    d3.setUniform1i("u_texture", 0), g3.bindTexture(x, 0);
    const y = g3.getBoundFramebufferObject();
    g3.bindFramebuffer(w), g3.useProgram(d3);
    const { x: A5, y: j, width: T4, height: D3 } = g3.getViewport();
    g3.setViewport(0, 0, 1, 1), g3.bindVAO(h4), g3.drawArrays(E.TRIANGLE_STRIP, 0, 4), g3.setViewport(A5, j, T4, D3), w.readPixels(0, 0, 1, 1, G.RGBA, U.UNSIGNED_BYTE, v), h4.dispose(), w.dispose();
    const E4 = 255 !== v[0] || 255 !== v[1] || 255 !== v[2] || 255 !== v[3];
    return E4 && s.getLogger("esri.views.webgl.testSamplerPrecision").warn(`A problem was detected with your graphics driver. Your driver does not appear to honor sampler precision specifiers, which may result in rendering issues due to numerical instability. We recommend ensuring that your drivers have been updated to the latest version. Applying lowp sampler workaround. [${v[0]}.${v[1]}.${v[2]}.${v[3]}]`), g3.bindFramebuffer(y), E4;
  }
};

// node_modules/@arcgis/core/views/webgl/WebGLDriverTest.js
var o3 = class {
  constructor(o5) {
    this.rctx = o5, this.floatBufferBlend = new g(o5), this.svgPremultipliesAlpha = new f3(o5), this.doublePrecisionRequiresObfuscation = new d(o5), this.ignoresSamplerPrecision = new g2(o5), this.drawArraysRequiresIndicesTypeReset = new h3(o5);
  }
  dispose() {
    this.ignoresSamplerPrecision.dispose(), this.doublePrecisionRequiresObfuscation.dispose(), this.svgPremultipliesAlpha.dispose(), this.floatBufferBlend.dispose(), this.drawArraysRequiresIndicesTypeReset.dispose();
  }
};

// node_modules/@arcgis/core/views/webgl/capabilities/DrawBuffers.js
function A4(A5, _3) {
  if (_3.disjointTimerQuery)
    return null;
  if (n6(A5))
    return { drawBuffers: A5.drawBuffers.bind(A5), MAX_DRAW_BUFFERS: A5.MAX_DRAW_BUFFERS, MAX_COLOR_ATTACHMENTS: A5.MAX_COLOR_ATTACHMENTS };
  if (_3.drawBuffers)
    return null;
  const e8 = A5.getExtension("WEBGL_draw_buffers");
  return e8 ? { drawBuffers: e8.drawBuffersWEBGL.bind(e8), MAX_DRAW_BUFFERS: e8.MAX_DRAW_BUFFERS_WEBGL, MAX_COLOR_ATTACHMENTS: e8.MAX_COLOR_ATTACHMENTS_WEBGL } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/load.js
function _2(t6, _3) {
  if (_3.compressedTextureETC)
    return null;
  const e8 = t6.getExtension("WEBGL_compressed_texture_etc");
  return e8 ? { COMPRESSED_R11_EAC: e8.COMPRESSED_R11_EAC, COMPRESSED_SIGNED_R11_EAC: e8.COMPRESSED_SIGNED_R11_EAC, COMPRESSED_RG11_EAC: e8.COMPRESSED_RG11_EAC, COMPRESSED_SIGNED_RG11_EAC: e8.COMPRESSED_SIGNED_RG11_EAC, COMPRESSED_RGB8_ETC2: e8.COMPRESSED_RGB8_ETC2, COMPRESSED_SRGB8_ETC2: e8.COMPRESSED_SRGB8_ETC2, COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: e8.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: e8.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, COMPRESSED_RGBA8_ETC2_EAC: e8.COMPRESSED_RGBA8_ETC2_EAC, COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: e8.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC } : null;
}
function e6(t6, _3) {
  if (_3.compressedTextureS3TC)
    return null;
  const e8 = t6.getExtension("WEBGL_compressed_texture_s3tc");
  return e8 ? { COMPRESSED_RGB_S3TC_DXT1: e8.COMPRESSED_RGB_S3TC_DXT1_EXT, COMPRESSED_RGBA_S3TC_DXT1: e8.COMPRESSED_RGBA_S3TC_DXT1_EXT, COMPRESSED_RGBA_S3TC_DXT3: e8.COMPRESSED_RGBA_S3TC_DXT3_EXT, COMPRESSED_RGBA_S3TC_DXT5: e8.COMPRESSED_RGBA_S3TC_DXT5_EXT } : null;
}
function E3(_3, e8) {
  if (n6(_3))
    return { MIN: _3.MIN, MAX: _3.MAX };
  if (e8.blendMinMax)
    return null;
  {
    const t6 = _3.getExtension("EXT_blend_minmax");
    return t6 ? { MIN: t6.MIN_EXT, MAX: t6.MAX_EXT } : null;
  }
}
function n9(t6, _3) {
  if (_3.textureFilterAnisotropic)
    return null;
  const e8 = t6.getExtension("EXT_texture_filter_anisotropic") || t6.getExtension("MOZ_EXT_texture_filter_anisotropic") || t6.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
  return e8 ? { MAX_TEXTURE_MAX_ANISOTROPY: e8.MAX_TEXTURE_MAX_ANISOTROPY_EXT, TEXTURE_MAX_ANISOTROPY: e8.TEXTURE_MAX_ANISOTROPY_EXT } : null;
}
function R2(_3, e8) {
  if (n6(_3))
    return { textureFloat: true, textureFloatLinear: !e8.textureFloatLinear && !!_3.getExtension("OES_texture_float_linear"), textureHalfFloat: true, textureHalfFloatLinear: true, HALF_FLOAT: _3.HALF_FLOAT, R16F: _3.R16F, RG16F: _3.RG16F, RGBA16F: _3.RGBA16F, R32F: _3.R32F, RG32F: _3.RG32F, RGBA32F: _3.RGBA32F, R11F_G11F_B10F: _3.R11F_G11F_B10F, RGB16F: _3.RGB16F };
  if (_3 instanceof WebGLRenderingContext) {
    const t6 = !e8.textureHalfFloat && _3.getExtension("OES_texture_half_float");
    return { textureFloat: !e8.textureFloat && !!_3.getExtension("OES_texture_float"), textureFloatLinear: !e8.textureFloatLinear && !!_3.getExtension("OES_texture_float_linear"), textureHalfFloat: !!t6, textureHalfFloatLinear: !e8.textureHalfFloatLinear && !!_3.getExtension("OES_texture_half_float_linear"), HALF_FLOAT: t6 ? t6.HALF_FLOAT_OES : void 0 };
  }
  return null;
}
function r5(_3, e8) {
  if (n6(_3)) {
    const t6 = !e8.colorBufferHalfFloat && _3.getExtension("EXT_color_buffer_half_float") || !e8.colorBufferFloat && _3.getExtension("EXT_color_buffer_float"), E4 = !e8.colorBufferFloat && _3.getExtension("EXT_color_buffer_float"), n10 = !e8.floatBlend && !e8.colorBufferFloat && _3.getExtension("EXT_float_blend");
    return t6 || E4 || n10 ? { textureFloat: !!E4, textureHalfFloat: !!t6, floatBlend: !!n10, R16F: _3.R16F, RG16F: _3.RG16F, RGBA16F: _3.RGBA16F, R32F: _3.R32F, RG32F: _3.RG32F, RGBA32F: _3.RGBA32F, R11F_G11F_B10F: _3.R11F_G11F_B10F, RGB16F: _3.RGB16F } : null;
  }
  if (_3 instanceof WebGLRenderingContext) {
    const t6 = !e8.colorBufferHalfFloat && _3.getExtension("EXT_color_buffer_half_float"), E4 = !e8.colorBufferFloat && _3.getExtension("WEBGL_color_buffer_float"), n10 = !e8.floatBlend && !e8.colorBufferFloat && _3.getExtension("EXT_float_blend");
    return t6 || E4 || n10 ? { textureFloat: !!E4, textureHalfFloat: !!t6, floatBlend: !!n10, RGBA16F: t6 ? t6.RGBA16F_EXT : void 0, RGB16F: t6 ? t6.RGB16F_EXT : void 0, RGBA32F: E4 ? E4.RGBA32F_EXT : void 0 } : null;
  }
  return null;
}
function o4(_3, e8, E4, n10, R3) {
  if (n10 && n6(_3))
    return true;
  if (e8[E4])
    return false;
  for (const t6 of R3)
    if (_3.getExtension(t6))
      return true;
  return false;
}
function l(_3, e8) {
  if (!n6(_3))
    return null;
  if (e8.textureNorm16)
    return null;
  const E4 = _3.getExtension("EXT_texture_norm16");
  return E4 ? { R16: E4.R16_EXT, RG16: E4.RG16_EXT, RGB16: E4.RGB16_EXT, RGBA16: E4.RGBA16_EXT, R16_SNORM: E4.R16_SNORM_EXT, RG16_SNORM: E4.RG16_SNORM_EXT, RGB16_SNORM: E4.RGB16_SNORM_EXT, RGBA16_SNORM: E4.RGBA16_SNORM_EXT } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/LoseContext.js
function e7(e8, t6) {
  const n10 = t6.loseContext && e8.getExtension("WEBGL_lose_context");
  return n10 ? { loseRenderingContext: () => n10.loseContext() } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/VertexArrayObjects.js
function r6(r7, t6) {
  if (n6(r7))
    return { createVertexArray: r7.createVertexArray.bind(r7), deleteVertexArray: r7.deleteVertexArray.bind(r7), bindVertexArray: r7.bindVertexArray.bind(r7) };
  if (t6.vao)
    return null;
  const n10 = r7.getExtension("OES_vertex_array_object") || r7.getExtension("MOZ_OES_vertex_array_object") || r7.getExtension("WEBKIT_OES_vertex_array_object");
  return n10 ? { createVertexArray: n10.createVertexArrayOES.bind(n10), deleteVertexArray: n10.deleteVertexArrayOES.bind(n10), bindVertexArray: n10.bindVertexArrayOES.bind(n10) } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/Capabilities.js
var d2 = class {
  constructor(t6, e8) {
    this._gl = t6, this._vertexArrayObject = null, this._compressedTextureETC = null, this._compressedTextureS3TC = null, this._textureFilterAnisotropic = null, this._textureFloat = null, this._colorBufferFloat = null, this._minMaxBlending = null, this._loseContext = null, this._drawBuffers = null, this._textureNorm16 = null, this._depthTexture = null, this._textureFloatLinear = null, this._disabledExtensions = e8.disabledExtensions || {}, this._debugWebGLExtensions = e8.debugWebGLExtensions || {};
  }
  get drawBuffers() {
    return this._drawBuffers || (this._drawBuffers = A4(this._gl, this._disabledExtensions)), this._drawBuffers;
  }
  get vao() {
    return this._vertexArrayObject || (this._vertexArrayObject = r6(this._gl, this._disabledExtensions)), this._vertexArrayObject;
  }
  get compressedTextureETC() {
    return this._compressedTextureETC || (this._compressedTextureETC = _2(this._gl, this._disabledExtensions)), this._compressedTextureETC;
  }
  get compressedTextureS3TC() {
    return this._compressedTextureS3TC || (this._compressedTextureS3TC = e6(this._gl, this._disabledExtensions)), this._compressedTextureS3TC;
  }
  get textureFilterAnisotropic() {
    return this._textureFilterAnisotropic || (this._textureFilterAnisotropic = n9(this._gl, this._disabledExtensions)), this._textureFilterAnisotropic;
  }
  get disjointTimerQuery() {
    return this._disjointTimerQuery || (this._disjointTimerQuery = T3(this._gl, this._disabledExtensions)), this._disjointTimerQuery;
  }
  get textureFloat() {
    return this._textureFloat || (this._textureFloat = R2(this._gl, this._disabledExtensions)), this._textureFloat;
  }
  get colorBufferFloat() {
    return this._colorBufferFloat || (this._colorBufferFloat = r5(this._gl, this._disabledExtensions)), this._colorBufferFloat;
  }
  get blendMinMax() {
    return this._minMaxBlending || (this._minMaxBlending = E3(this._gl, this._disabledExtensions)), this._minMaxBlending;
  }
  get depthTexture() {
    return null === this._depthTexture && (this._depthTexture = o4(this._gl, this._disabledExtensions, "depthTexture", true, ["WEBGL_depth_texture", "MOZ_WEBGL_depth_texture", "WEBKIT_WEBGL_depth_texture"])), this._depthTexture;
  }
  get loseContext() {
    return this._loseContext || (this._loseContext = e7(this._gl, this._debugWebGLExtensions)), this._loseContext;
  }
  get textureNorm16() {
    return this._textureNorm16 || (this._textureNorm16 = l(this._gl, this._disabledExtensions)), this._textureNorm16;
  }
  get textureFloatLinear() {
    return null === this._textureFloatLinear && (this._textureFloatLinear = o4(this._gl, this._disabledExtensions, "textureFloatLinear", false, ["OES_texture_float_linear"])), this._textureFloatLinear;
  }
  enable(t6) {
    return this[t6];
  }
};

// node_modules/@arcgis/core/views/webgl/RenderingContext.js
var N2 = class {
  constructor(t6, e8) {
    this.gl = t6, this.instanceCounter = new n7(), this.programCache = new e3(this), this._state = new h2(), this._numOfDrawCalls = 0, this._numOfTriangles = 0, this.type = n6(t6) ? n3.WEBGL2 : n3.WEBGL1, this._loadExtensions(), this.configure(e8);
  }
  get gl2() {
    return this.type === n3.WEBGL1 ? null : this.gl;
  }
  configure(e8) {
    this._capabilities = new d2(this.gl, e8), this._parameters = new t5(this.gl, this._capabilities, e8), T2.TEXTURE_UNIT_FOR_UPDATES = this._parameters.maxTextureImageUnits - 1;
    const s4 = this.gl.getParameter(this.gl.VIEWPORT);
    this._state = new h2(), this._state.viewport = { x: s4[0], y: s4[1], width: s4[2], height: s4[3] }, this._stateTracker = new G2({ setBlending: (t6) => {
      if (t6) {
        this.setBlendingEnabled(true), this.setBlendEquationSeparate(t6.opRgb, t6.opAlpha), this.setBlendFunctionSeparate(t6.srcRgb, t6.dstRgb, t6.srcAlpha, t6.dstAlpha);
        const e9 = t6.color;
        this.setBlendColor(e9.r, e9.g, e9.b, e9.a);
      } else
        this.setBlendingEnabled(false);
    }, setCulling: (t6) => {
      t6 ? (this.setFaceCullingEnabled(true), this.setCullFace(t6.face), this.setFrontFace(t6.mode)) : this.setFaceCullingEnabled(false);
    }, setPolygonOffset: (t6) => {
      t6 ? (this.setPolygonOffsetFillEnabled(true), this.setPolygonOffset(t6.factor, t6.units)) : this.setPolygonOffsetFillEnabled(false);
    }, setDepthTest: (t6) => {
      t6 ? (this.setDepthTestEnabled(true), this.setDepthFunction(t6.func)) : this.setDepthTestEnabled(false);
    }, setStencilTest: (t6) => {
      if (t6) {
        this.setStencilTestEnabled(true);
        const e9 = t6.function;
        this.setStencilFunction(e9.func, e9.ref, e9.mask);
        const s5 = t6.operation;
        this.setStencilOp(s5.fail, s5.zFail, s5.zPass);
      } else
        this.setStencilTestEnabled(false);
    }, setDepthWrite: (t6) => {
      t6 ? (this.setDepthWriteEnabled(true), this.setDepthRange(t6.zNear, t6.zFar)) : this.setDepthWriteEnabled(false);
    }, setColorWrite: (t6) => {
      t6 ? this.setColorMask(t6.r, t6.g, t6.b, t6.a) : this.setColorMask(false, false, false, false);
    }, setStencilWrite: (t6) => {
      t6 ? this.setStencilWriteMask(t6.mask) : this.setStencilWriteMask(0);
    }, setDrawBuffers: (t6) => {
      const { drawBuffers: e9 } = this._capabilities;
      if (t6)
        e9 == null ? void 0 : e9.drawBuffers(t6.buffers);
      else {
        const { drawFramebuffer: t7 } = this._state;
        null === t7 || 0 === t7.colorAttachments.length ? e9 == null ? void 0 : e9.drawBuffers([f.BACK]) : e9 == null ? void 0 : e9.drawBuffers([X.COLOR_ATTACHMENT0]);
      }
    } }), this.enforceState(), r(this._driverTest), this._driverTest = new o3(this);
  }
  dispose() {
    r(this._driverTest), this.programCache.dispose(), this.bindVAO(null), this.unbindBuffer(A2.ARRAY_BUFFER), this.unbindBuffer(A2.ELEMENT_ARRAY_BUFFER), this.type === n3.WEBGL2 && (this.unbindBuffer(A2.UNIFORM_BUFFER), this._state.uniformBufferBindingPoints.length = 0, this.unbindBuffer(A2.PIXEL_PACK_BUFFER), this.unbindBuffer(A2.PIXEL_UNPACK_BUFFER), this.unbindBuffer(A2.COPY_READ_BUFFER), this.unbindBuffer(A2.COPY_WRITE_BUFFER)), this._state.textureUnitMap.length = 0, a() && console.log(this.instanceCounter.resourceInformation);
  }
  get driverTest() {
    return this._driverTest;
  }
  get contextAttributes() {
    return this.gl.getContextAttributes();
  }
  get parameters() {
    return this._parameters;
  }
  setPipelineState(t6) {
    this._stateTracker.setPipeline(t6);
  }
  setBlendingEnabled(t6) {
    this._state.blend !== t6 && (true === t6 ? this.gl.enable(this.gl.BLEND) : this.gl.disable(this.gl.BLEND), this._state.blend = t6, this._stateTracker.invalidateBlending());
  }
  externalProgramUpdate() {
    var _a;
    (_a = this._state.program) == null ? void 0 : _a.stop(), this._state.program = null;
  }
  externalTextureUnitUpdate(t6, e8) {
    for (let s4 = 0; s4 < t6.length; ++s4)
      this._state.textureUnitMap[t6[s4]] = null;
    e8 >= 0 && (this._state.activeTexture = e8);
  }
  externalVertexArrayObjectUpdate() {
    const t6 = this.capabilities.vao;
    t6 && (t6.bindVertexArray(null), this._state.vertexArrayObject = null), this._state.vertexBuffer = null, this._state.indexBuffer = null;
  }
  externalVertexBufferUpdate() {
    this._state.vertexBuffer = null;
  }
  externalIndexBufferUpdate() {
    this._state.indexBuffer = null;
  }
  setBlendColor(t6, e8, s4, i) {
    t6 === this._state.blendColor.r && e8 === this._state.blendColor.g && s4 === this._state.blendColor.b && i === this._state.blendColor.a || (this.gl.blendColor(t6, e8, s4, i), this._state.blendColor.r = t6, this._state.blendColor.g = e8, this._state.blendColor.b = s4, this._state.blendColor.a = i, this._stateTracker.invalidateBlending());
  }
  setBlendFunction(t6, e8) {
    t6 === this._state.blendFunction.srcRGB && e8 === this._state.blendFunction.dstRGB || (this.gl.blendFunc(t6, e8), this._state.blendFunction.srcRGB = t6, this._state.blendFunction.srcAlpha = t6, this._state.blendFunction.dstRGB = e8, this._state.blendFunction.dstAlpha = e8, this._stateTracker.invalidateBlending());
  }
  setBlendFunctionSeparate(t6, e8, s4, i) {
    this._state.blendFunction.srcRGB === t6 && this._state.blendFunction.srcAlpha === s4 && this._state.blendFunction.dstRGB === e8 && this._state.blendFunction.dstAlpha === i || (this.gl.blendFuncSeparate(t6, e8, s4, i), this._state.blendFunction.srcRGB = t6, this._state.blendFunction.srcAlpha = s4, this._state.blendFunction.dstRGB = e8, this._state.blendFunction.dstAlpha = i, this._stateTracker.invalidateBlending());
  }
  setBlendEquation(t6) {
    this._state.blendEquation.mode !== t6 && (this.gl.blendEquation(t6), this._state.blendEquation.mode = t6, this._state.blendEquation.modeAlpha = t6, this._stateTracker.invalidateBlending());
  }
  setBlendEquationSeparate(t6, e8) {
    this._state.blendEquation.mode === t6 && this._state.blendEquation.modeAlpha === e8 || (this.gl.blendEquationSeparate(t6, e8), this._state.blendEquation.mode = t6, this._state.blendEquation.modeAlpha = e8, this._stateTracker.invalidateBlending());
  }
  setColorMask(t6, e8, s4, i) {
    this._state.colorMask.r === t6 && this._state.colorMask.g === e8 && this._state.colorMask.b === s4 && this._state.colorMask.a === i || (this.gl.colorMask(t6, e8, s4, i), this._state.colorMask.r = t6, this._state.colorMask.g = e8, this._state.colorMask.b = s4, this._state.colorMask.a = i, this._stateTracker.invalidateColorWrite());
  }
  setClearColor(t6, e8, s4, i) {
    this._state.clearColor.r === t6 && this._state.clearColor.g === e8 && this._state.clearColor.b === s4 && this._state.clearColor.a === i || (this.gl.clearColor(t6, e8, s4, i), this._state.clearColor.r = t6, this._state.clearColor.g = e8, this._state.clearColor.b = s4, this._state.clearColor.a = i);
  }
  setFaceCullingEnabled(t6) {
    this._state.faceCulling !== t6 && (true === t6 ? this.gl.enable(this.gl.CULL_FACE) : this.gl.disable(this.gl.CULL_FACE), this._state.faceCulling = t6, this._stateTracker.invalidateCulling());
  }
  setPolygonOffsetFillEnabled(t6) {
    this._state.polygonOffsetFill !== t6 && (true === t6 ? this.gl.enable(this.gl.POLYGON_OFFSET_FILL) : this.gl.disable(this.gl.POLYGON_OFFSET_FILL), this._state.polygonOffsetFill = t6, this._stateTracker.invalidatePolygonOffset());
  }
  setPolygonOffset(t6, e8) {
    this._state.polygonOffset[0] === t6 && this._state.polygonOffset[1] === e8 || (this._state.polygonOffset[0] = t6, this._state.polygonOffset[1] = e8, this.gl.polygonOffset(t6, e8), this._stateTracker.invalidatePolygonOffset());
  }
  setCullFace(t6) {
    this._state.cullFace !== t6 && (this.gl.cullFace(t6), this._state.cullFace = t6, this._stateTracker.invalidateCulling());
  }
  setFrontFace(t6) {
    this._state.frontFace !== t6 && (this.gl.frontFace(t6), this._state.frontFace = t6, this._stateTracker.invalidateCulling());
  }
  setScissorTestEnabled(t6) {
    this._state.scissorTest !== t6 && (true === t6 ? this.gl.enable(this.gl.SCISSOR_TEST) : this.gl.disable(this.gl.SCISSOR_TEST), this._state.scissorTest = t6);
  }
  setScissorRect(t6, e8, s4, i) {
    this._state.scissorRect.x === t6 && this._state.scissorRect.y === e8 && this._state.scissorRect.width === s4 && this._state.scissorRect.height === i || (this.gl.scissor(t6, e8, s4, i), this._state.scissorRect.x = t6, this._state.scissorRect.y = e8, this._state.scissorRect.width = s4, this._state.scissorRect.height = i);
  }
  setDepthTestEnabled(t6) {
    this._state.depthTest !== t6 && (true === t6 ? this.gl.enable(this.gl.DEPTH_TEST) : this.gl.disable(this.gl.DEPTH_TEST), this._state.depthTest = t6, this._stateTracker.invalidateDepthTest());
  }
  setClearDepth(t6) {
    this._state.clearDepth !== t6 && (this.gl.clearDepth(t6), this._state.clearDepth = t6);
  }
  setDepthFunction(t6) {
    this._state.depthFunction !== t6 && (this.gl.depthFunc(t6), this._state.depthFunction = t6, this._stateTracker.invalidateDepthTest());
  }
  setDepthWriteEnabled(t6) {
    this._state.depthWrite !== t6 && (this.gl.depthMask(t6), this._state.depthWrite = t6, this._stateTracker.invalidateDepthWrite());
  }
  setDepthRange(t6, e8) {
    this._state.depthRange.zNear === t6 && this._state.depthRange.zFar === e8 || (this.gl.depthRange(t6, e8), this._state.depthRange.zNear = t6, this._state.depthRange.zFar = e8, this._stateTracker.invalidateDepthWrite());
  }
  setStencilTestEnabled(t6) {
    this._state.stencilTest !== t6 && (true === t6 ? this.gl.enable(this.gl.STENCIL_TEST) : this.gl.disable(this.gl.STENCIL_TEST), this._state.stencilTest = t6, this._stateTracker.invalidateStencilTest());
  }
  setClearStencil(t6) {
    t6 !== this._state.clearStencil && (this.gl.clearStencil(t6), this._state.clearStencil = t6);
  }
  setStencilFunction(t6, e8, s4) {
    this._state.stencilFunction.func === t6 && this._state.stencilFunction.ref === e8 && this._state.stencilFunction.mask === s4 || (this.gl.stencilFunc(t6, e8, s4), this._state.stencilFunction.face = N.FRONT_AND_BACK, this._state.stencilFunction.func = t6, this._state.stencilFunction.ref = e8, this._state.stencilFunction.mask = s4, this._stateTracker.invalidateStencilTest());
  }
  setStencilFunctionSeparate(t6, e8, s4, i) {
    this._state.stencilFunction.face === t6 && this._state.stencilFunction.func === e8 && this._state.stencilFunction.ref === s4 && this._state.stencilFunction.mask === i || (this.gl.stencilFuncSeparate(t6, e8, s4, i), this._state.stencilFunction.face = t6, this._state.stencilFunction.func = e8, this._state.stencilFunction.ref = s4, this._state.stencilFunction.mask = i, this._stateTracker.invalidateStencilTest());
  }
  setStencilWriteMask(t6) {
    this._state.stencilWriteMask !== t6 && (this.gl.stencilMask(t6), this._state.stencilWriteMask = t6, this._stateTracker.invalidateStencilWrite());
  }
  setStencilOp(t6, e8, s4) {
    this._state.stencilOperation.face === N.FRONT_AND_BACK && this._state.stencilOperation.fail === t6 && this._state.stencilOperation.zFail === e8 && this._state.stencilOperation.zPass === s4 || (this.gl.stencilOp(t6, e8, s4), this._state.stencilOperation.face = N.FRONT_AND_BACK, this._state.stencilOperation.fail = t6, this._state.stencilOperation.zFail = e8, this._state.stencilOperation.zPass = s4, this._stateTracker.invalidateStencilTest());
  }
  setStencilOpSeparate(t6, e8, s4, i) {
    this._state.stencilOperation.face === t6 && this._state.stencilOperation.fail === e8 && this._state.stencilOperation.zFail === s4 && this._state.stencilOperation.zPass === i || (this.gl.stencilOpSeparate(t6, e8, s4, i), this._state.stencilOperation.face = t6, this._state.stencilOperation.fail = e8, this._state.stencilOperation.zFail = s4, this._state.stencilOperation.zPass = i, this._stateTracker.invalidateStencilTest());
  }
  setActiveTexture(t6, e8 = false) {
    const s4 = this._state.activeTexture;
    return t6 >= 0 && (e8 || t6 !== this._state.activeTexture) && (this.gl.activeTexture(Y + t6), this._state.activeTexture = t6), s4;
  }
  clear(t6) {
    t6 && this.gl.clear(t6);
  }
  clearSafe(t6, e8 = 255) {
    t6 && (t6 & _.COLOR_BUFFER_BIT && this.setColorMask(true, true, true, true), t6 & _.DEPTH_BUFFER_BIT && this.setDepthWriteEnabled(true), t6 & _.STENCIL_BUFFER_BIT && this.setStencilWriteMask(e8), this.gl.clear(t6));
  }
  drawArrays(t6, e8, s4) {
    a() && (this._numOfDrawCalls++, this._numOfTriangles += D2(t6, s4)), this.gl.drawArrays(t6, e8, s4), u(this.gl);
  }
  drawArraysInstanced(t6, e8, s4, i) {
    var _a;
    (_a = this.gl2) == null ? void 0 : _a.drawArraysInstanced(t6, e8, s4, i), u(this.gl);
  }
  drawElements(t6, e8, s4, a3) {
    if (a() && (this._numOfDrawCalls++, this._numOfTriangles += D2(t6, e8)), this.gl.drawElements(t6, e8, s4, a3), a()) {
      const i = a2(this);
      if (i) {
        const r7 = this.getBoundVAO(), n10 = r7 == null ? void 0 : r7.indexBuffer, l2 = r7 == null ? void 0 : r7.vertexBuffers, h4 = { indexBuffer: n10, vertexBuffers: l2 }, f4 = { mode: t6, count: e8, type: s4, offset: a3 }, o5 = (n10 == null ? void 0 : n10.size) ?? 0, u2 = a3 + e8, c = o5 < u2 ? `. Buffer is too small. Attempted to draw index ${u2} of ${o5}` : "";
        console.error(`drawElements: ${i}${c}`, { args: f4, vao: h4 });
      }
    }
  }
  logInfo() {
    a() && console.log(`DrawCalls: ${this._numOfDrawCalls}, Triangles: ${this._numOfTriangles}`);
  }
  resetInfo() {
    a() && (this._numOfDrawCalls = 0, this._numOfTriangles = 0);
  }
  get capabilities() {
    return this._capabilities;
  }
  setViewport(t6, e8, s4, i) {
    s4 = Math.max(Math.round(s4), 1), i = Math.max(Math.round(i), 1);
    const a3 = this._state.viewport;
    a3.x === t6 && a3.y === e8 && a3.width === s4 && a3.height === i || (a3.x = t6, a3.y = e8, a3.width = s4, a3.height = i, this.gl.viewport(t6, e8, s4, i));
  }
  setViewport4fv(t6) {
    this.setViewport(t6[0], t6[1], t6[2], t6[3]);
  }
  getViewport() {
    const t6 = this._state.viewport;
    return { x: t6.x, y: t6.y, width: t6.width, height: t6.height };
  }
  useProgram(t6) {
    var _a;
    this._state.program !== t6 && ((_a = this._state.program) == null ? void 0 : _a.stop(), this._state.program = t6, this.gl.useProgram((t6 == null ? void 0 : t6.glName) ?? null));
  }
  bindTexture(t6, e8, s4 = false) {
    (e8 >= this.parameters.maxTextureImageUnits || e8 < 0) && console.error("Input texture unit is out of range of available units!");
    const i = this._state.textureUnitMap[e8];
    return null == (t6 == null ? void 0 : t6.glName) ? (null != i && (this.setActiveTexture(e8, s4), this.gl.bindTexture(i.descriptor.target, null)), this._state.textureUnitMap[e8] = null, i) : s4 || i !== t6 ? (this.setActiveTexture(e8, s4), this.gl.bindTexture(t6.descriptor.target, t6.glName), t6.applyChanges(), this._state.textureUnitMap[e8] = t6, i) : (t6.isDirty && (this.setActiveTexture(e8, s4), t6.applyChanges()), i);
  }
  unbindTexture(t6) {
    if (null != t6)
      for (let e8 = 0; e8 < this.parameters.maxTextureImageUnits; e8++)
        this._state.textureUnitMap[e8] === t6 && (this.bindTexture(null, e8), this._state.textureUnitMap[e8] = null);
  }
  bindFramebuffer(t6, e8 = false) {
    if (e8 || this._state.readFramebuffer !== t6 || this._state.drawFramebuffer !== t6) {
      if (this._stateTracker.invalidateDrawBuffers(), null == t6)
        return this.gl.bindFramebuffer(n2.FRAMEBUFFER, null), this._state.readFramebuffer = null, void (this._state.drawFramebuffer = null);
      t6.initializeAndBind(n2.FRAMEBUFFER), this._state.readFramebuffer = t6, this._state.drawFramebuffer = t6;
    }
  }
  bindFramebufferSeparate(t6, e8, s4 = false) {
    const i = e8 === n2.READ_FRAMEBUFFER, a3 = i ? this._state.readFramebuffer : this._state.drawFramebuffer;
    (s4 || a3 !== t6) && (null == t6 ? this.gl.bindFramebuffer(e8, null) : t6.initializeAndBind(e8), i ? this._state.readFramebuffer = t6 ?? null : this._state.drawFramebuffer = t6 ?? null);
  }
  blitFramebuffer(t6, e8, s4 = 0, i = 0, a3 = t6.width, r7 = t6.height, n10 = 0, l2 = 0, h4 = e8.width, f4 = e8.height, o5 = _.COLOR_BUFFER_BIT, u2 = L.NEAREST) {
    this.bindFramebufferSeparate(t6, n2.READ_FRAMEBUFFER), this.bindFramebufferSeparate(e8, n2.DRAW_FRAMEBUFFER);
    this.gl.blitFramebuffer(s4, i, a3, r7, n10, l2, h4, f4, o5, u2);
  }
  bindBuffer(t6, e8) {
    if (t6)
      switch (e8 ?? (e8 = t6.bufferType), e8) {
        case A2.ARRAY_BUFFER:
          this._state.vertexBuffer = M2(this.gl, t6, e8, this._state.vertexBuffer);
          break;
        case A2.ELEMENT_ARRAY_BUFFER:
          this._state.indexBuffer = M2(this.gl, t6, e8, this._state.indexBuffer);
          break;
        case A2.UNIFORM_BUFFER:
          this._state.uniformBuffer = M2(this.gl, t6, e8, this._state.uniformBuffer);
          break;
        case A2.PIXEL_PACK_BUFFER:
          this._state.pixelPackBuffer = M2(this.gl, t6, e8, this._state.pixelPackBuffer);
          break;
        case A2.PIXEL_UNPACK_BUFFER:
          this._state.pixelUnpackBuffer = M2(this.gl, t6, e8, this._state.pixelUnpackBuffer);
          break;
        case A2.COPY_READ_BUFFER:
          this._state.copyReadBuffer = M2(this.gl, t6, e8, this._state.copyReadBuffer);
          break;
        case A2.COPY_WRITE_BUFFER:
          this._state.copyWriteBuffer = M2(this.gl, t6, e8, this._state.copyWriteBuffer);
      }
  }
  bindRenderbuffer(t6) {
    const e8 = this.gl;
    t6 || (e8.bindRenderbuffer(e8.RENDERBUFFER, null), this._state.renderbuffer = null), this._state.renderbuffer !== t6 && (e8.bindRenderbuffer(e8.RENDERBUFFER, t6.glName), this._state.renderbuffer = t6);
  }
  _getBufferBinding(t6, e8) {
    if (e8 >= this.parameters.maxUniformBufferBindings || e8 < 0)
      return console.error("Uniform buffer binding point is out of range!"), null;
    const s4 = this._state.uniformBufferBindingPoints;
    let i = s4[e8];
    return null == i && (i = { buffer: null, offset: 0, size: 0 }, s4[e8] = i), i;
  }
  bindBufferBase(t6, e8, s4) {
    const i = this._getBufferBinding(t6, e8);
    if (null == i)
      return;
    if (i.buffer === s4 && 0 === i.offset && 0 === i.size)
      return;
    this.gl.bindBufferBase(t6, e8, s4 ? s4.glName : null), i.buffer = s4, i.offset = 0, i.size = 0;
  }
  bindBufferRange(t6, e8, s4, i, a3) {
    const r7 = this._getBufferBinding(t6, e8);
    if (null == r7)
      return;
    if (r7.buffer === s4 && r7.offset === i && r7.size === a3)
      return;
    if (i % this._parameters.uniformBufferOffsetAlignment != 0)
      return void console.error("Uniform buffer binding offset is not a multiple of the context offset alignment");
    this.gl.bindBufferRange(t6, e8, s4.glName, i, a3), r7.buffer = s4, r7.offset = i, r7.size = a3;
  }
  bindUBO(t6, e8, s4, a3) {
    null != e8 ? (a() && (a3 ?? e8.byteLength) > this._parameters.maxUniformBlockSize && console.error("Attempting to bind more data than the maximum uniform block size"), e8.initialize(), void 0 !== s4 && void 0 !== a3 ? this.bindBufferRange(A2.UNIFORM_BUFFER, t6, e8.buffer, s4, a3) : this.bindBufferBase(A2.UNIFORM_BUFFER, t6, e8.buffer)) : this.bindBufferBase(A2.UNIFORM_BUFFER, t6, null);
  }
  unbindUBO(t6) {
    for (let e8 = 0, s4 = this._state.uniformBufferBindingPoints.length; e8 < s4; e8++) {
      const s5 = this._state.uniformBufferBindingPoints[e8];
      null != s5 && s5.buffer === t6.buffer && this.bindBufferBase(A2.UNIFORM_BUFFER, e8, null);
    }
  }
  unbindBuffer(t6) {
    switch (t6) {
      case A2.ARRAY_BUFFER:
        this._state.vertexBuffer = M2(this.gl, null, t6, this._state.vertexBuffer);
        break;
      case A2.ELEMENT_ARRAY_BUFFER:
        this._state.indexBuffer = M2(this.gl, null, t6, this._state.indexBuffer);
        break;
      case A2.UNIFORM_BUFFER:
        this._state.uniformBuffer = M2(this.gl, null, t6, this._state.uniformBuffer);
        break;
      case A2.PIXEL_PACK_BUFFER:
        this._state.pixelPackBuffer = M2(this.gl, null, t6, this._state.pixelPackBuffer);
        break;
      case A2.PIXEL_UNPACK_BUFFER:
        this._state.pixelUnpackBuffer = M2(this.gl, null, t6, this._state.pixelUnpackBuffer);
        break;
      case A2.COPY_READ_BUFFER:
        this._state.copyReadBuffer = M2(this.gl, null, t6, this._state.copyReadBuffer);
        break;
      case A2.COPY_WRITE_BUFFER:
        this._state.copyWriteBuffer = M2(this.gl, null, t6, this._state.copyWriteBuffer);
    }
  }
  bindVAO(t6 = null) {
    null != t6 ? this._state.vertexArrayObject !== t6 && (t6.bind(), this._state.vertexArrayObject = t6) : this._state.vertexArrayObject && (this._state.vertexArrayObject.unbind(), this._state.vertexArrayObject = null);
  }
  async clientWaitAsync(t6 = n(10)) {
    const i = this.gl, a3 = i.fenceSync(r3.SYNC_GPU_COMMANDS_COMPLETE, 0);
    if (!a3)
      throw new Error("Client wait failed, could not create sync object");
    let r7;
    this.instanceCounter.increment(V.Sync, a3), i.flush();
    do {
      await A(t6), r7 = i.clientWaitSync(a3, 0, 0);
    } while (r7 === e.TIMEOUT_EXPIRED);
    if (this.instanceCounter.decrement(V.Sync, a3), i.deleteSync(a3), r7 === e.WAIT_FAILED)
      throw new Error("Client wait failed");
  }
  getBoundFramebufferObject(t6 = n2.FRAMEBUFFER) {
    return t6 === n2.READ_FRAMEBUFFER ? this._state.readFramebuffer : this._state.drawFramebuffer;
  }
  getBoundVAO() {
    return this._state.vertexArrayObject;
  }
  resetState() {
    this.useProgram(null), this.bindVAO(null), this.bindFramebuffer(null, true), this.unbindBuffer(A2.ARRAY_BUFFER), this.unbindBuffer(A2.ELEMENT_ARRAY_BUFFER), this.type === n3.WEBGL2 && (this.unbindBuffer(A2.UNIFORM_BUFFER), this._state.uniformBufferBindingPoints.length = 0, this.unbindBuffer(A2.PIXEL_PACK_BUFFER), this.unbindBuffer(A2.PIXEL_UNPACK_BUFFER), this.unbindBuffer(A2.COPY_READ_BUFFER), this.unbindBuffer(A2.COPY_WRITE_BUFFER));
    for (let t6 = 0; t6 < this.parameters.maxTextureImageUnits; ++t6)
      this.bindTexture(null, t6);
    this.setBlendingEnabled(false), this.setBlendFunction(R.ONE, R.ZERO), this.setBlendEquation(T.ADD), this.setBlendColor(0, 0, 0, 0), this.setFaceCullingEnabled(false), this.setCullFace(N.BACK), this.setFrontFace(S.CCW), this.setPolygonOffsetFillEnabled(false), this.setPolygonOffset(0, 0), this.setScissorTestEnabled(false), this.setScissorRect(0, 0, this.gl.canvas.width, this.gl.canvas.height), this.setDepthTestEnabled(false), this.setDepthFunction(O.LESS), this.setDepthRange(0, 1), this.setStencilTestEnabled(false), this.setStencilFunction(O.ALWAYS, 0, 0), this.setStencilOp(I.KEEP, I.KEEP, I.KEEP), this.setClearColor(0, 0, 0, 0), this.setClearDepth(1), this.setClearStencil(0), this.setColorMask(true, true, true, true), this.setStencilWriteMask(4294967295), this.setDepthWriteEnabled(true), this.setViewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
  }
  enforceState() {
    var _a, _b, _c;
    const t6 = this.capabilities.vao;
    t6 && t6.bindVertexArray(null);
    const { gl: e8, gl2: s4 } = this;
    for (let a3 = 0; a3 < this.parameters.maxVertexAttributes; a3++)
      e8.disableVertexAttribArray(a3);
    if (this._state.vertexBuffer ? e8.bindBuffer(this._state.vertexBuffer.bufferType, this._state.vertexBuffer.glName) : e8.bindBuffer(A2.ARRAY_BUFFER, null), this._state.indexBuffer ? e8.bindBuffer(this._state.indexBuffer.bufferType, this._state.indexBuffer.glName) : e8.bindBuffer(A2.ELEMENT_ARRAY_BUFFER, null), null != s4) {
      this._state.uniformBuffer ? s4.bindBuffer(this._state.uniformBuffer.bufferType, this._state.uniformBuffer.glName) : s4.bindBuffer(A2.UNIFORM_BUFFER, null);
      for (let t7 = 0; t7 < this._parameters.maxUniformBufferBindings; t7++) {
        const e9 = this._state.uniformBufferBindingPoints[t7];
        if (null != e9) {
          const { buffer: i2, offset: a3, size: r7 } = e9;
          null !== i2 ? 0 === a3 && 0 === r7 ? s4.bindBufferBase(A2.UNIFORM_BUFFER, t7, i2.glName) : s4.bindBufferRange(A2.UNIFORM_BUFFER, t7, i2.glName, a3, r7) : s4.bindBufferBase(A2.UNIFORM_BUFFER, t7, null);
        }
      }
      this._state.pixelPackBuffer ? s4.bindBuffer(this._state.pixelPackBuffer.bufferType, this._state.pixelPackBuffer.glName) : s4.bindBuffer(A2.PIXEL_PACK_BUFFER, null), this._state.pixelUnpackBuffer ? s4.bindBuffer(this._state.pixelUnpackBuffer.bufferType, this._state.pixelUnpackBuffer.glName) : s4.bindBuffer(A2.PIXEL_UNPACK_BUFFER, null), this._state.copyReadBuffer ? s4.bindBuffer(this._state.copyReadBuffer.bufferType, this._state.copyReadBuffer.glName) : s4.bindBuffer(A2.COPY_READ_BUFFER, null), this._state.copyWriteBuffer ? s4.bindBuffer(this._state.copyWriteBuffer.bufferType, this._state.copyWriteBuffer.glName) : s4.bindBuffer(A2.COPY_WRITE_BUFFER, null), s4.bindFramebuffer(n2.READ_FRAMEBUFFER, null), s4.readBuffer(s4.BACK), this._state.readFramebuffer && (s4.bindFramebuffer(n2.READ_FRAMEBUFFER, this._state.readFramebuffer.glName), s4.readBuffer(X.COLOR_ATTACHMENT0)), s4.bindFramebuffer(n2.DRAW_FRAMEBUFFER, ((_a = this._state.drawFramebuffer) == null ? void 0 : _a.glName) ?? null);
    } else
      this._state.readFramebuffer = this._state.drawFramebuffer, e8.bindFramebuffer(n2.FRAMEBUFFER, ((_b = this._state.drawFramebuffer) == null ? void 0 : _b.glName) ?? null);
    if (t6 && this._state.vertexArrayObject) {
      const t7 = this._state.vertexArrayObject;
      this._state.vertexArrayObject && (this._state.vertexArrayObject.unbind(), this._state.vertexArrayObject = null), this.bindVAO(t7);
    }
    e8.useProgram(((_c = this._state.program) == null ? void 0 : _c.glName) ?? null), e8.blendColor(this._state.blendColor.r, this._state.blendColor.g, this._state.blendColor.b, this._state.blendColor.a), e8.bindRenderbuffer(e8.RENDERBUFFER, this._state.renderbuffer ? this._state.renderbuffer.glName : null), true === this._state.blend ? e8.enable(this.gl.BLEND) : e8.disable(this.gl.BLEND), e8.blendEquationSeparate(this._state.blendEquation.mode, this._state.blendEquation.modeAlpha), e8.blendFuncSeparate(this._state.blendFunction.srcRGB, this._state.blendFunction.dstRGB, this._state.blendFunction.srcAlpha, this._state.blendFunction.dstAlpha), e8.clearColor(this._state.clearColor.r, this._state.clearColor.g, this._state.clearColor.b, this._state.clearColor.a), e8.clearDepth(this._state.clearDepth), e8.clearStencil(this._state.clearStencil), e8.colorMask(this._state.colorMask.r, this._state.colorMask.g, this._state.colorMask.b, this._state.colorMask.a), e8.cullFace(this._state.cullFace), e8.depthFunc(this._state.depthFunction), e8.depthRange(this._state.depthRange.zNear, this._state.depthRange.zFar), true === this._state.depthTest ? e8.enable(e8.DEPTH_TEST) : e8.disable(e8.DEPTH_TEST), e8.depthMask(this._state.depthWrite), e8.frontFace(this._state.frontFace), e8.lineWidth(1), true === this._state.faceCulling ? e8.enable(e8.CULL_FACE) : e8.disable(e8.CULL_FACE), e8.polygonOffset(this._state.polygonOffset[0], this._state.polygonOffset[1]), true === this._state.polygonOffsetFill ? e8.enable(e8.POLYGON_OFFSET_FILL) : e8.disable(e8.POLYGON_OFFSET_FILL), e8.scissor(this._state.scissorRect.x, this._state.scissorRect.y, this._state.scissorRect.width, this._state.scissorRect.height), true === this._state.scissorTest ? e8.enable(e8.SCISSOR_TEST) : e8.disable(e8.SCISSOR_TEST), e8.stencilFunc(this._state.stencilFunction.func, this._state.stencilFunction.ref, this._state.stencilFunction.mask), e8.stencilOpSeparate(this._state.stencilOperation.face, this._state.stencilOperation.fail, this._state.stencilOperation.zFail, this._state.stencilOperation.zPass), true === this._state.stencilTest ? e8.enable(e8.STENCIL_TEST) : e8.disable(e8.STENCIL_TEST), e8.stencilMask(this._state.stencilWriteMask);
    for (let a3 = 0; a3 < this.parameters.maxTextureImageUnits; a3++) {
      e8.activeTexture(Y + a3), e8.bindTexture(M.TEXTURE_2D, null), e8.bindTexture(M.TEXTURE_CUBE_MAP, null), this.type === n3.WEBGL2 && (e8.bindTexture(M.TEXTURE_3D, null), e8.bindTexture(M.TEXTURE_2D_ARRAY, null));
      const t7 = this._state.textureUnitMap[a3];
      null != t7 && e8.bindTexture(t7.descriptor.target, t7.glName);
    }
    e8.activeTexture(Y + this._state.activeTexture);
    const i = this._state.viewport;
    e8.viewport(i.x, i.y, i.width, i.height), this.resetInfo();
  }
  _loadExtensions() {
    this.type === n3.WEBGL1 && this.gl.getExtension("OES_element_index_uint"), this.gl.getExtension("KHR_parallel_shader_compile");
  }
};
function M2(t6, e8, s4, i) {
  return e8 ? i !== e8 && t6.bindBuffer(s4, e8.glName) : t6.bindBuffer(s4, null), e8;
}
function D2(t6, e8) {
  switch (t6) {
    case E.POINTS:
      return 2 * e8;
    case E.TRIANGLES:
      return e8 / 3;
    case E.TRIANGLE_STRIP:
    case E.TRIANGLE_FAN:
      return e8 - 2;
    default:
      return 0;
  }
}

export {
  o2 as o,
  N2 as N
};
//# sourceMappingURL=chunk-F3L5SDRN.js.map
