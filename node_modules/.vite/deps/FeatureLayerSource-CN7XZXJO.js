import {
  x
} from "./chunk-DQ5CZJ7Y.js";
import "./chunk-RXV6RUH7.js";
import "./chunk-JF5KFXQA.js";
import {
  s as s5
} from "./chunk-SH5MUYBA.js";
import {
  v
} from "./chunk-EWVUTXQQ.js";
import {
  F as F3,
  b as b3
} from "./chunk-WCYCZR2L.js";
import {
  o as o2
} from "./chunk-UIBKJIZ5.js";
import {
  m as m2
} from "./chunk-SLEGPWAA.js";
import {
  r as r2
} from "./chunk-GLOKOXWD.js";
import {
  e as e2
} from "./chunk-4OLZTDWK.js";
import "./chunk-MKRPXDII.js";
import "./chunk-S6CVQWN7.js";
import "./chunk-JWPJ4Y6I.js";
import "./chunk-OYPRFNII.js";
import "./chunk-KMTPMPRR.js";
import "./chunk-747B2TEO.js";
import "./chunk-4NEWABLH.js";
import "./chunk-FW2Y26A2.js";
import "./chunk-5WG7GACT.js";
import "./chunk-LOGPPZUD.js";
import "./chunk-HYU6N3H3.js";
import {
  i
} from "./chunk-DMLVD5AS.js";
import {
  Q
} from "./chunk-DOALI2C2.js";
import "./chunk-E3I4MGUC.js";
import "./chunk-UHNBENSV.js";
import "./chunk-GDKL26HH.js";
import "./chunk-2CL4LRYG.js";
import "./chunk-64EQFPYJ.js";
import "./chunk-HKYMYCLL.js";
import "./chunk-ICVVQFO6.js";
import "./chunk-BYK6DXRK.js";
import "./chunk-UTCX6DGX.js";
import {
  a as a2,
  r as r3,
  s as s4
} from "./chunk-HBL2432S.js";
import "./chunk-OCLKX5SY.js";
import "./chunk-SEKLTVY5.js";
import "./chunk-HX5GOVNX.js";
import "./chunk-2Q2Q2Z4U.js";
import "./chunk-S6MJEC4A.js";
import {
  b as b2
} from "./chunk-45OAWGCA.js";
import "./chunk-R4LYFMZX.js";
import "./chunk-X2TA76Q5.js";
import "./chunk-T3Y5GTKO.js";
import "./chunk-XN6LAULS.js";
import "./chunk-RP5SAUAF.js";
import {
  F as F2
} from "./chunk-OJ65P3EQ.js";
import {
  c as c3
} from "./chunk-FWR4JURK.js";
import "./chunk-BELGAUAK.js";
import "./chunk-JHJVOI7Q.js";
import "./chunk-TWNBDJHC.js";
import "./chunk-HITXLR5N.js";
import "./chunk-WYZCKLOR.js";
import "./chunk-S6NERLXF.js";
import "./chunk-4TSAC52K.js";
import "./chunk-H4ZZ5S37.js";
import "./chunk-G557TGXY.js";
import "./chunk-2AXFVQBN.js";
import {
  c as c2
} from "./chunk-WOGT6UK2.js";
import "./chunk-RHT6WWRD.js";
import "./chunk-EUGXS5RE.js";
import "./chunk-IRNKV32L.js";
import "./chunk-BEALJUHO.js";
import "./chunk-GRHSIT57.js";
import "./chunk-PJQIAD5D.js";
import "./chunk-Z6KIMOUA.js";
import "./chunk-SZAJDZCO.js";
import "./chunk-M7R7REMB.js";
import "./chunk-ZZYUEH57.js";
import "./chunk-VTWXDFFD.js";
import {
  p
} from "./chunk-IPCIO3PX.js";
import "./chunk-EIY2DYTV.js";
import "./chunk-WJ4LS3YG.js";
import {
  q
} from "./chunk-F6MD5VOH.js";
import "./chunk-V2RPSCV3.js";
import {
  w
} from "./chunk-AOJ6OCPK.js";
import "./chunk-LMT5JII2.js";
import "./chunk-A43TI6AT.js";
import {
  F,
  b
} from "./chunk-4HKQSEUR.js";
import "./chunk-V3U4F2NL.js";
import "./chunk-ZB6PGKG5.js";
import "./chunk-OIIDE5GZ.js";
import "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import {
  r
} from "./chunk-APYNYYQC.js";
import "./chunk-TBSVVR6M.js";
import "./chunk-6TJWLWLO.js";
import "./chunk-H7BKONNV.js";
import "./chunk-K6C6RVSV.js";
import "./chunk-KBJ5Z4R2.js";
import "./chunk-JUZJCTW2.js";
import "./chunk-423VNHLR.js";
import "./chunk-FN47E7YK.js";
import "./chunk-XZS3Q5K4.js";
import "./chunk-XXFXRXFH.js";
import {
  m
} from "./chunk-CCXEAKIM.js";
import {
  M
} from "./chunk-Y5D433JZ.js";
import "./chunk-QNOCEWCR.js";
import "./chunk-WURET5CW.js";
import {
  f
} from "./chunk-QWPLZ3QH.js";
import {
  V as V2
} from "./chunk-HLGIRLYQ.js";
import "./chunk-N2K4VRZH.js";
import "./chunk-WL4VPODY.js";
import "./chunk-OMPEZIP5.js";
import {
  s as s3
} from "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import {
  V,
  Wt,
  j,
  t3 as t
} from "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import {
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  A,
  a,
  k as k2
} from "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  o,
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import {
  has,
  k
} from "./chunk-4V6374PV.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/geometry/support/meshVertexSpaceUtils.js
function n(t2) {
  const { vertexSpace: n2 } = t2;
  if (n2.isRelative)
    return t2.clone();
  const { anchor: i2 } = t2, c5 = i2.clone(), a3 = q(s6, [-c5.x, -c5.y, -c5.z]), m4 = new m2({ origin: [c5.x, c5.y, c5.z] }), p3 = t2.cloneWithVertexSpace(m4), { position: u2 } = p3.vertexAttributes;
  return p3.vertexAttributes.position = r2(new Float64Array(u2.length), u2, a3), p3.vertexAttributesChanged(), p3;
}
var s6 = e2();

// node_modules/@arcgis/core/layers/graphics/applyEditsUtils.js
async function u(e3, t2, a3) {
  const { geometry: s7 } = t2, l = { ...t2.attributes };
  if (null != a3 && "mesh" === (s7 == null ? void 0 : s7.type)) {
    const { transformFieldRoles: t3 } = a3, { origin: i2, spatialReference: d, transform: u2 } = s7, c5 = e3.spatialReference;
    await F(d, c5);
    const p3 = b(i2, c5);
    if (l[t3.originX] = p3.x, l[t3.originY] = p3.y, l[t3.originZ] = p3.z ?? 0, null != u2) {
      const { translation: e4, scale: a4, rotation: o3 } = u2, { vertexSpace: n2 } = s7, i3 = n2.isGeoreferenced ? 1 : V2(d) / V2(c5);
      l[t3.translationX] = e4[0] * i3, l[t3.translationY] = e4[2] * i3, l[t3.translationZ] = -e4[1] * i3, l[t3.scaleX] = a4[0], l[t3.scaleY] = a4[2], l[t3.scaleZ] = a4[1], l[t3.rotationX] = o3[0], l[t3.rotationY] = o3[2], l[t3.rotationZ] = -o3[1], l[t3.rotationDeg] = o3[3];
    }
    return { attributes: l };
  }
  return null == s7 ? { attributes: l } : "mesh" === s7.type || "extent" === s7.type ? null : { geometry: s7.toJSON(), attributes: l };
}
async function c4(e3, t2) {
  const a3 = await Promise.all((t2.addAttachments ?? []).map((t3) => p2(e3, t3))), r4 = await Promise.all((t2.updateAttachments ?? []).map((t3) => p2(e3, t3))), s7 = t2.deleteAttachments ?? [];
  return a3.length || r4.length || s7.length ? { adds: a3, updates: r4, deletes: [...s7] } : null;
}
async function p2(e3, t2) {
  var _a;
  const { feature: a3, attachment: r4 } = t2, { globalId: o3, name: n2, contentType: l, data: i2, uploadId: d } = r4, u2 = { globalId: o3 };
  if (a3 && ("attributes" in a3 ? u2.parentGlobalId = (_a = a3.attributes) == null ? void 0 : _a[e3.globalIdField] : a3.globalId && (u2.parentGlobalId = a3.globalId)), d)
    u2.uploadId = d;
  else if (i2) {
    const e4 = await Wt(i2);
    e4 && (u2.contentType = e4.mediaType, u2.data = e4.data), i2 instanceof File && (u2.name = i2.name);
  }
  return n2 && (u2.name = n2), l && (u2.contentType = l), u2;
}
function m3(e3, t2, a3) {
  if (!t2 || 0 === t2.length)
    return [];
  if (a3 && F3(t2))
    return t2.map((e4) => e4.globalId);
  if (b3(t2))
    return t2.map((e4) => e4.objectId);
  const r4 = a3 ? e3.globalIdField : e3.objectIdField;
  return r4 ? t2.map((e4) => e4.getAttribute(r4)) : [];
}
function f2(e3) {
  var _a, _b, _c;
  const t2 = e3 == null ? void 0 : e3.assetMaps;
  if (t2) {
    for (const e4 of t2.addResults)
      e4.success || s.getLogger("esri.layers.graphics.sources.support.sourceUtils").error(`Failed to map asset to feature with globalId ${e4.globalId}.`);
    for (const e4 of t2.updateResults)
      e4.success || s.getLogger("esri.layers.graphics.sources.support.sourceUtils").error(`Failed to map asset to feature with globalId ${e4.globalId}.`);
  }
  const r4 = e3 == null ? void 0 : e3.attachments, s7 = { addFeatureResults: ((_a = e3 == null ? void 0 : e3.addResults) == null ? void 0 : _a.map(g)) ?? [], updateFeatureResults: ((_b = e3 == null ? void 0 : e3.updateResults) == null ? void 0 : _b.map(g)) ?? [], deleteFeatureResults: ((_c = e3 == null ? void 0 : e3.deleteResults) == null ? void 0 : _c.map(g)) ?? [], addAttachmentResults: (r4 == null ? void 0 : r4.addResults) ? r4.addResults.map(g) : [], updateAttachmentResults: (r4 == null ? void 0 : r4.updateResults) ? r4.updateResults.map(g) : [], deleteAttachmentResults: (r4 == null ? void 0 : r4.deleteResults) ? r4.deleteResults.map(g) : [] };
  return (e3 == null ? void 0 : e3.editMoment) && (s7.editMoment = e3.editMoment), s7;
}
function g(e3) {
  const a3 = true === e3.success ? null : e3.error || { code: void 0, description: void 0 };
  return { objectId: e3.objectId, globalId: e3.globalId, error: a3 ? new s2("feature-layer-source:edit-failure", a3.description, { code: a3.code }) : null };
}
function b4(t2, a3) {
  return new c3({ attributes: t2.attributes, geometry: p({ ...t2.geometry, spatialReference: a3 }) });
}
function R(e3, t2) {
  var _a, _b, _c;
  return { adds: ((_a = e3 == null ? void 0 : e3.adds) == null ? void 0 : _a.map((e4) => b4(e4, t2))) || [], updates: ((_b = e3 == null ? void 0 : e3.updates) == null ? void 0 : _b.map((e4) => ({ original: b4(e4[0], t2), current: b4(e4[1], t2) }))) || [], deletes: ((_c = e3 == null ? void 0 : e3.deletes) == null ? void 0 : _c.map((e4) => b4(e4, t2))) || [], spatialReference: t2 };
}
function I(e3) {
  const t2 = e3.details.raw, a3 = +t2.code, r4 = +t2.extendedCode;
  return 500 === a3 && (-2147217144 === r4 || -2147467261 === r4);
}

// node_modules/@arcgis/core/layers/graphics/sources/FeatureLayerSource.js
var L = new s3({ originalAndCurrentFeatures: "original-and-current-features", none: "none" });
var Q2 = /* @__PURE__ */ new Set(["Feature Layer", "Oriented Imagery Layer", "Table"]);
var D = new s3({ Started: "published", Publishing: "publishing", Stopped: "unavailable" });
var P = class extends m {
  constructor() {
    super(...arguments), this.type = "feature-layer", this.refresh = k2(async () => {
      var _a, _b;
      await this.load();
      const e3 = (_a = this.sourceJSON.editingInfo) == null ? void 0 : _a.lastEditDate;
      if (null == e3)
        return { dataChanged: true, updates: {} };
      try {
        await this._fetchService(null);
      } catch {
        return { dataChanged: true, updates: {} };
      }
      const t2 = e3 !== ((_b = this.sourceJSON.editingInfo) == null ? void 0 : _b.lastEditDate);
      return { dataChanged: t2, updates: t2 ? { editingInfo: this.sourceJSON.editingInfo, extent: this.sourceJSON.extent } : null };
    }), this._ongoingAssetUploads = /* @__PURE__ */ new Map();
  }
  load(e3) {
    const t2 = this.layer.sourceJSON, s7 = this._fetchService(t2, { ...e3 }).then(() => this.layer.setUserPrivileges(this.sourceJSON.serviceItemId, e3)).then(() => this._ensureLatestMetadata(e3));
    return this.addResolvingPromise(s7), Promise.resolve(this);
  }
  get queryTask() {
    var _a;
    const { capabilities: e3, parsedUrl: t2, dynamicDataSource: s7, infoFor3D: r4, gdbVersion: a3, spatialReference: i2, fieldsIndex: o3 } = this.layer, n2 = has("featurelayer-pbf") && (e3 == null ? void 0 : e3.query.supportsFormatPBF) && null == r4, u2 = ((_a = e3 == null ? void 0 : e3.operations) == null ? void 0 : _a.supportsQueryAttachments) ?? false;
    return new x({ url: t2.path, pbfSupported: n2, fieldsIndex: o3, infoFor3D: r4, dynamicDataSource: s7, gdbVersion: a3, sourceSpatialReference: i2, queryAttachmentsSupported: u2 });
  }
  async addAttachment(e3, t2) {
    await this.load();
    const { layer: r4 } = this;
    await Q(r4, "editing");
    const a3 = e3.attributes[r4.objectIdField], i2 = r4.parsedUrl.path + "/" + a3 + "/addAttachment", o3 = this._getLayerRequestOptions(), n2 = this._getFormDataForAttachment(t2, o3.query);
    try {
      const e4 = await j(i2, { body: n2 });
      return g(e4.data.addAttachmentResult);
    } catch (u2) {
      throw this._createAttachmentErrorResult(a3, u2);
    }
  }
  async updateAttachment(e3, t2, r4) {
    await this.load();
    const { layer: a3 } = this;
    await Q(a3, "editing");
    const i2 = e3.attributes[a3.objectIdField], o3 = a3.parsedUrl.path + "/" + i2 + "/updateAttachment", n2 = this._getLayerRequestOptions({ query: { attachmentId: t2 } }), u2 = this._getFormDataForAttachment(r4, n2.query);
    try {
      const e4 = await j(o3, { body: u2 });
      return g(e4.data.updateAttachmentResult);
    } catch (l) {
      throw this._createAttachmentErrorResult(i2, l);
    }
  }
  async applyEdits(e3, r4) {
    var _a, _b, _c, _d, _e, _f;
    await this.load();
    const { layer: i2 } = this;
    await Q(i2, "editing");
    const o3 = i2.infoFor3D, n2 = null != o3, u2 = n2 || ((r4 == null ? void 0 : r4.globalIdUsed) ?? false), l = n2 ? await this._uploadMeshesAndGetAssetMapEditsJSON(e3) : null, c5 = ((_a = e3.addFeatures) == null ? void 0 : _a.map((e4) => u(this.layer, e4, o3))) ?? [], d = (await Promise.all(c5)).filter(k), p3 = ((_b = e3.updateFeatures) == null ? void 0 : _b.map((e4) => u(this.layer, e4, o3))) ?? [], y2 = (await Promise.all(p3)).filter(k), h = m3(this.layer, e3.deleteFeatures, u2);
    i(d, y2, i2.spatialReference);
    const m4 = await c4(this.layer, e3), f3 = i2.capabilities.editing.supportsAsyncApplyEdits && n2, g2 = (r4 == null ? void 0 : r4.gdbVersion) || i2.gdbVersion, S = { gdbVersion: g2, rollbackOnFailure: r4 == null ? void 0 : r4.rollbackOnFailureEnabled, useGlobalIds: u2, returnEditMoment: r4 == null ? void 0 : r4.returnEditMoment, usePreviousEditMoment: r4 == null ? void 0 : r4.usePreviousEditMoment, async: f3 };
    await s4(this.layer.url, g2, true);
    const w2 = a2(this.layer.url, g2 || null);
    (r4 == null ? void 0 : r4.returnServiceEditsOption) ? (S.edits = JSON.stringify([{ id: i2.layerId, adds: d, updates: y2, deletes: h, attachments: m4, assetMaps: l }]), S.returnServiceEditsOption = L.toJSON(r4 == null ? void 0 : r4.returnServiceEditsOption), S.returnServiceEditsInSourceSR = r4 == null ? void 0 : r4.returnServiceEditsInSourceSR) : (S.adds = d.length ? JSON.stringify(d) : null, S.updates = y2.length ? JSON.stringify(y2) : null, S.deletes = h.length ? u2 ? JSON.stringify(h) : h.join(",") : null, S.attachments = m4 && JSON.stringify(m4), S.assetMaps = null != l ? JSON.stringify(l) : void 0);
    const q2 = this._getLayerRequestOptions({ method: "post", query: S });
    w2 && (q2.authMode = "immediate", q2.query.returnEditMoment = true, q2.query.sessionId = r3);
    const A2 = (r4 == null ? void 0 : r4.returnServiceEditsOption) ? i2.url : i2.parsedUrl.path;
    let F4;
    try {
      F4 = f3 ? await this._asyncApplyEdits(A2 + "/applyEdits", q2) : await j(A2 + "/applyEdits", q2);
    } catch (_) {
      if (!I(_))
        throw _;
      q2.authMode = "immediate", F4 = f3 ? await this._asyncApplyEdits(A2 + "/applyEdits", q2) : await j(A2 + "/applyEdits", q2);
    }
    if (!((_c = i2.capabilities.operations) == null ? void 0 : _c.supportsEditing) && ((_e = (_d = i2.effectiveCapabilities) == null ? void 0 : _d.operations) == null ? void 0 : _e.supportsEditing)) {
      const e4 = (_f = t) == null ? void 0 : _f.findCredential(i2.url);
      await (e4 == null ? void 0 : e4.refreshToken());
    }
    return this._createEditsResult(F4);
  }
  async deleteAttachments(e3, t2) {
    await this.load();
    const { layer: r4 } = this;
    await Q(r4, "editing");
    const a3 = e3.attributes[r4.objectIdField], i2 = r4.parsedUrl.path + "/" + a3 + "/deleteAttachments";
    try {
      return (await j(i2, this._getLayerRequestOptions({ query: { attachmentIds: t2.join(",") }, method: "post" }))).data.deleteAttachmentResults.map(g);
    } catch (o3) {
      throw this._createAttachmentErrorResult(a3, o3);
    }
  }
  fetchRecomputedExtents(e3 = {}) {
    const t2 = e3.signal;
    return this.load({ signal: t2 }).then(async () => {
      const t3 = this._getLayerRequestOptions({ ...e3, query: { returnUpdates: true } }), { layerId: a3, url: i2 } = this.layer, { data: o3 } = await j(`${i2}/${a3}`, t3), { id: n2, extent: u2, fullExtent: l, timeExtent: c5 } = o3, d = u2 || l;
      return { id: n2, fullExtent: d && M.fromJSON(d), timeExtent: c5 && c2.fromJSON({ start: c5[0], end: c5[1] }) };
    });
  }
  async queryAttachments(e3, t2 = {}) {
    await this.load();
    const s7 = this._getLayerRequestOptions(t2);
    return this.queryTask.executeAttachmentQuery(e3, s7);
  }
  async queryFeatures(e3, t2) {
    var _a;
    await this.load();
    const s7 = await this.queryTask.execute(e3, { ...t2, query: this._createRequestQueryOptions(t2) });
    return ((_a = e3.outStatistics) == null ? void 0 : _a.length) && s7.features.length && s7.features.forEach((t3) => {
      var _a2;
      const s8 = t3.attributes;
      (_a2 = e3.outStatistics) == null ? void 0 : _a2.forEach(({ outStatisticFieldName: e4 }) => {
        if (e4) {
          const t4 = e4.toLowerCase();
          t4 && t4 in s8 && e4 !== t4 && (s8[e4] = s8[t4], delete s8[t4]);
        }
      });
    }), s7;
  }
  async queryFeaturesJSON(e3, t2) {
    return await this.load(), this.queryTask.executeJSON(e3, { ...t2, query: this._createRequestQueryOptions(t2) });
  }
  async queryObjectIds(e3, t2) {
    return await this.load(), this.queryTask.executeForIds(e3, { ...t2, query: this._createRequestQueryOptions(t2) });
  }
  async queryFeatureCount(e3, t2) {
    return await this.load(), this.queryTask.executeForCount(e3, { ...t2, query: this._createRequestQueryOptions(t2) });
  }
  async queryExtent(e3, t2) {
    return await this.load(), this.queryTask.executeForExtent(e3, { ...t2, query: this._createRequestQueryOptions(t2) });
  }
  async queryRelatedFeatures(e3, t2) {
    return await this.load(), this.queryTask.executeRelationshipQuery(e3, { ...t2, query: this._createRequestQueryOptions(t2) });
  }
  async queryRelatedFeaturesCount(e3, t2) {
    return await this.load(), this.queryTask.executeRelationshipQueryForCount(e3, { ...t2, query: this._createRequestQueryOptions(t2) });
  }
  async queryTopFeatures(e3, t2) {
    return await this.load(), this.queryTask.executeTopFeaturesQuery(e3, { ...t2, query: this._createRequestQueryOptions(t2) });
  }
  async queryTopObjectIds(e3, t2) {
    return await this.load(), this.queryTask.executeForTopIds(e3, { ...t2, query: this._createRequestQueryOptions(t2) });
  }
  async queryTopExtents(e3, t2) {
    return await this.load(), this.queryTask.executeForTopExtents(e3, { ...t2, query: this._createRequestQueryOptions(t2) });
  }
  async queryTopCount(e3, t2) {
    return await this.load(), this.queryTask.executeForTopCount(e3, { ...t2, query: this._createRequestQueryOptions(t2) });
  }
  async fetchPublishingStatus() {
    if (!w(this.layer.url))
      return "unavailable";
    const e3 = V(this.layer.url, "status"), t2 = await j(e3, { query: { f: "json" } });
    return D.fromJSON(t2.data.status);
  }
  async uploadAssets(e3, t2) {
    const { uploadAssets: s7 } = await import("./uploadAssets-O4J5MD7J.js");
    return s7(e3, { layer: this.layer, ongoingUploads: this._ongoingAssetUploads }, t2);
  }
  async _asyncApplyEdits(e3, t2) {
    const r4 = (await j(e3, t2)).data.statusUrl;
    for (; ; ) {
      const e4 = (await j(r4, { query: { f: "json" }, responseType: "json" })).data;
      switch (e4.status) {
        case "Completed":
          return j(e4.resultUrl, { query: { f: "json" }, responseType: "json" });
        case "CompletedWithErrors":
          throw new s2("async-applyEdits-failed", "asynchronous applyEdits call failed.");
        case "Failed ImportChanges":
        case "InProgress":
        case "Pending":
        case "ExportAttachments":
        case "ExportChanges":
        case "ExportingData":
        case "ExportingSnapshot":
        case "ImportAttachments":
        case "ProvisioningReplica":
        case "UnRegisteringReplica":
          break;
        default:
          throw new s2("async-applyEdits-failed", "asynchronous applyEdits call failed (undefined response status)");
      }
      await A(V3);
    }
  }
  _createRequestQueryOptions(e3) {
    const t2 = { ...this.layer.customParameters, token: this.layer.apiKey, ...e3 == null ? void 0 : e3.query };
    return this.layer.datesInUnknownTimezone && (t2.timeReferenceUnknownClient = true), t2;
  }
  async _fetchService(e3, t2) {
    if (!e3) {
      const r5 = {};
      has("featurelayer-advanced-symbols") && (r5.returnAdvancedSymbols = true), (t2 == null ? void 0 : t2.cacheBust) && (r5._ts = Date.now());
      const { data: a3 } = await j(this.layer.parsedUrl.path, this._getLayerRequestOptions({ query: r5, signal: t2 == null ? void 0 : t2.signal }));
      e3 = a3;
    }
    this.sourceJSON = await this._patchServiceJSON(e3, t2 == null ? void 0 : t2.signal);
    const r4 = e3.type;
    if (!Q2.has(r4))
      throw new s2("feature-layer-source:unsupported-type", `Source type "${r4}" is not supported`);
  }
  async _patchServiceJSON(e3, t2) {
    var _a;
    if ("Table" !== e3.type && e3.geometryType && !((_a = e3 == null ? void 0 : e3.drawingInfo) == null ? void 0 : _a.renderer) && !e3.defaultSymbol) {
      const t3 = o2(e3.geometryType).renderer;
      o("drawingInfo.renderer", t3, e3);
    }
    if ("esriGeometryMultiPatch" === e3.geometryType && e3.infoFor3D && (e3.geometryType = "mesh"), null == e3.extent)
      try {
        const { data: r4 } = await j(this.layer.url, this._getLayerRequestOptions({ signal: t2 }));
        r4.spatialReference && (e3.extent = { xmin: 0, ymin: 0, xmax: 0, ymax: 0, spatialReference: r4.spatialReference });
      } catch (r4) {
        a(r4);
      }
    return e3;
  }
  async _ensureLatestMetadata(e3) {
    if (this.layer.userHasUpdateItemPrivileges && this.sourceJSON.cacheMaxAge > 0)
      return this._fetchService(null, { ...e3, cacheBust: true });
  }
  async _uploadMeshesAndGetAssetMapEditsJSON(e3) {
    const { addAssetFeatures: t2 } = e3;
    if (!(t2 == null ? void 0 : t2.length))
      return null;
    const s7 = await this._filterRedundantAssetMaps(t2);
    if (!(t2 == null ? void 0 : t2.length))
      return null;
    const r4 = new Array(), a3 = /* @__PURE__ */ new Map();
    for (const i2 of s7) {
      const { geometry: e4 } = i2, { vertexSpace: t3 } = e4;
      if (t3.isRelative)
        r4.push(e4);
      else {
        const t4 = n(e4);
        a3.set(t4, e4), i2.geometry = t4, r4.push(t4);
      }
    }
    await this.uploadAssets(r4);
    for (const [i2, o3] of a3)
      o3.addExternalSources(i2.metadata.externalSources.items);
    return { adds: this._getAssetMapEditsJSON(s7), updates: [], deletes: [] };
  }
  _getAssetMapEditsJSON(e3) {
    const t2 = new Array(), s7 = this.layer.globalIdField, r4 = this.layer.parsedUrl;
    for (const a3 of e3) {
      const e4 = a3.geometry, { metadata: i2 } = e4, o3 = i2.getExternalSourcesOnService(r4), n2 = a3.getAttribute(s7);
      if (0 === o3.length) {
        s.getLogger(this).error(`Skipping feature ${n2}. The mesh it is associated with has not been uploaded to the service and cannot be mapped to it.`);
        continue;
      }
      const { source: l } = o3.find(v) ?? o3[0], { vertexSpace: c5 } = e4, d = c5.isGeoreferenced ? ["PROJECT_VERTICES"] : [];
      for (const s8 of l)
        1 === s8.parts.length ? t2.push({ globalId: r(), parentGlobalId: n2, assetName: s8.assetName, assetHash: s8.parts[0].partHash, flags: d }) : s.getLogger(this).error(`Skipping asset ${s8.assetName}. It does not have exactly one part, so we cannot map it to a feature.`);
    }
    return t2;
  }
  _createEditsResult(e3) {
    const t2 = e3.data, { layerId: s7 } = this.layer, r4 = [];
    let a3 = null;
    if (Array.isArray(t2))
      for (const o3 of t2)
        r4.push({ id: o3.id, editedFeatures: o3.editedFeatures }), o3.id === s7 && (a3 = { addResults: o3.addResults ?? [], updateResults: o3.updateResults ?? [], deleteResults: o3.deleteResults ?? [], attachments: o3.attachments, editMoment: o3.editMoment });
    else
      a3 = t2;
    const i2 = f2(a3);
    if (r4.length > 0) {
      i2.editedFeatureResults = [];
      for (const e4 of r4) {
        const { editedFeatures: t3 } = e4, s8 = (t3 == null ? void 0 : t3.spatialReference) ? new f(t3.spatialReference) : null;
        i2.editedFeatureResults.push({ layerId: e4.id, editedFeatures: R(t3, s8) });
      }
    }
    return i2;
  }
  _createAttachmentErrorResult(e3, t2) {
    var _a;
    const s7 = ((_a = t2.details.messages) == null ? void 0 : _a[0]) || t2.message, r4 = t2.details.httpStatus || t2.details.messageCode;
    return { objectId: e3, globalId: null, error: new s2("feature-layer-source:attachment-failure", s7, { code: r4 }) };
  }
  _getFormDataForAttachment(e3, t2) {
    const s7 = e3 instanceof FormData ? e3 : e3 && e3.elements ? new FormData(e3) : null;
    if (s7)
      for (const r4 in t2) {
        const e4 = t2[r4];
        null != e4 && (s7.set ? s7.set(r4, e4) : s7.append(r4, e4));
      }
    return s7;
  }
  _getLayerRequestOptions(e3 = {}) {
    const { parsedUrl: t2, gdbVersion: s7, dynamicDataSource: r4 } = this.layer;
    return { ...e3, query: { gdbVersion: s7, layer: r4 ? JSON.stringify({ source: r4 }) : void 0, ...t2.query, f: "json", ...this._createRequestQueryOptions(e3) }, responseType: "json" };
  }
  async _filterRedundantAssetMaps(e3) {
    const { layer: t2 } = this, { globalIdField: s7, infoFor3D: r4, parsedUrl: i2 } = t2;
    if (null == r4 || null == s7)
      return e3;
    const o3 = F2(r4);
    if (null == o3)
      return e3;
    const n2 = V(i2.path, `../${o3.id}`), u2 = new Array(), l = new Array();
    for (const a3 of e3)
      a3.geometry.metadata.getExternalSourcesOnService(i2).length > 0 ? l.push(a3) : u2.push(a3);
    const c5 = l.map((e4) => e4.getAttribute(s7)).filter(k);
    if (0 === c5.length)
      return e3;
    const { assetMapFieldRoles: { parentGlobalId: d, assetHash: p3 } } = r4, h = new b2();
    h.where = `${d} IN (${c5.map((e4) => `'${e4}'`)})`, h.outFields = [p3, d], h.returnGeometry = false;
    const m4 = await s5(n2, h), { features: f3 } = m4;
    return 0 === f3.length ? e3 : [...u2, ...l.filter((e4) => {
      const t3 = e4.getAttribute(s7);
      if (!t3)
        return true;
      const { metadata: r5 } = e4.geometry, a3 = f3.filter((e5) => e5.getAttribute(d) === t3);
      if (0 === a3.length)
        return true;
      const o4 = a3.map((e5) => e5.getAttribute(p3));
      return r5.getExternalSourcesOnService(i2).flatMap(({ source: e5 }) => e5.flatMap((e6) => e6.parts.map((e7) => e7.partHash))).some((e5) => o4.every((t4) => e5 !== t4));
    })];
  }
};
e([y()], P.prototype, "type", void 0), e([y({ constructOnly: true })], P.prototype, "layer", void 0), e([y({ readOnly: true })], P.prototype, "queryTask", null), P = e([c("esri.layers.graphics.sources.FeatureLayerSource")], P);
var V3 = 1e3;
var $ = P;
export {
  $ as default
};
//# sourceMappingURL=FeatureLayerSource-CN7XZXJO.js.map
