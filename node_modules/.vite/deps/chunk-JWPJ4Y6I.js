import {
  r
} from "./chunk-OYPRFNII.js";
import {
  e
} from "./chunk-4NEWABLH.js";
import {
  s as s2,
  t
} from "./chunk-FW2Y26A2.js";
import {
  t as t2
} from "./chunk-5WG7GACT.js";
import {
  W2 as W,
  d2 as d
} from "./chunk-HLGIRLYQ.js";
import {
  s3 as s
} from "./chunk-WJ3HJKNC.js";

// node_modules/@arcgis/core/rest/query/operations/pbfOptimizedFeatureSet.js
var n = ["esriGeometryPoint", "esriGeometryMultipoint", "esriGeometryPolyline", "esriGeometryPolygon"];
var a = class {
  constructor(e2) {
    this._options = e2, this.geometryTypes = n, this._coordinatePtr = 0, this._vertexDimension = 0;
  }
  createFeatureResult() {
    return new e();
  }
  prepareFeatures(e2) {
    this._vertexDimension = 2, e2.hasZ && this._vertexDimension++, e2.hasM && this._vertexDimension++;
  }
  finishFeatureResult(o2) {
    if (!(o2 == null ? void 0 : o2.features) || !o2.hasZ || !this._options.sourceSpatialReference || !o2.spatialReference || d(o2.spatialReference, this._options.sourceSpatialReference) || o2.spatialReference.vcsWkid)
      return;
    const i2 = W(this._options.sourceSpatialReference) / W(o2.spatialReference);
    if (1 !== i2)
      for (const e2 of o2.features) {
        if (!s2(e2))
          continue;
        const t4 = e2.geometry.coords;
        for (let e3 = 2; e3 < t4.length; e3 += 3)
          t4[e3] *= i2;
      }
  }
  addFeature(e2, t4) {
    e2.features.push(t4);
  }
  createFeature() {
    return new t();
  }
  createSpatialReference() {
    return { wkid: 0 };
  }
  createGeometry() {
    return new t2();
  }
  addField(e2, t4) {
    e2.fields.push(t4);
  }
  allocateCoordinates(e2) {
    e2.coords.length = e2.lengths.reduce((e3, t4) => e3 + t4, 0) * this._vertexDimension, this._coordinatePtr = 0;
  }
  addCoordinate(e2, t4) {
    e2.coords[this._coordinatePtr++] = t4;
  }
  addCoordinatePoint(e2, t4) {
    e2.coords.push(t4);
  }
  addLength(e2, t4) {
    e2.lengths.push(t4);
  }
  addQueryGeometry(e2, t4) {
    e2.queryGeometry = t4.queryGeometry, e2.queryGeometryType = t4.queryGeometryType;
  }
  createPointGeometry() {
    return new t2();
  }
};

// node_modules/@arcgis/core/rest/query/operations/pbfFeatureServiceParser.js
var a2 = ["esriFieldTypeSmallInteger", "esriFieldTypeInteger", "esriFieldTypeSingle", "esriFieldTypeDouble", "esriFieldTypeString", "esriFieldTypeDate", "esriFieldTypeOID", "esriFieldTypeGeometry", "esriFieldTypeBlob", "esriFieldTypeRaster", "esriFieldTypeGUID", "esriFieldTypeGlobalID", "esriFieldTypeXML", "esriFieldTypeBigInteger", "esriFieldTypeDateOnly", "esriFieldTypeTimeOnly", "esriFieldTypeTimestampOffset"];
var n2 = ["sqlTypeBigInt", "sqlTypeBinary", "sqlTypeBit", "sqlTypeChar", "sqlTypeDate", "sqlTypeDecimal", "sqlTypeDouble", "sqlTypeFloat", "sqlTypeGeometry", "sqlTypeGUID", "sqlTypeInteger", "sqlTypeLongNVarchar", "sqlTypeLongVarbinary", "sqlTypeLongVarchar", "sqlTypeNChar", "sqlTypeNVarchar", "sqlTypeOther", "sqlTypeReal", "sqlTypeSmallInt", "sqlTypeSqlXml", "sqlTypeTime", "sqlTypeTimestamp", "sqlTypeTimestamp2", "sqlTypeTinyInt", "sqlTypeVarbinary", "sqlTypeVarchar"];
var i = ["upperLeft", "lowerLeft"];
function o(e2) {
  return e2 >= a2.length ? null : a2[e2];
}
function c(e2) {
  return e2 >= n2.length ? null : n2[e2];
}
function l(e2) {
  return e2 >= i.length ? null : i[e2];
}
function g(e2, t4) {
  return t4 >= e2.geometryTypes.length ? null : e2.geometryTypes[t4];
}
function p(e2, t4, s3) {
  const r2 = 3, a3 = e2.asUnsafe(), n3 = t4.createPointGeometry(s3);
  for (; a3.next(); )
    switch (a3.tag()) {
      case r2: {
        const e3 = a3.getUInt32(), s4 = a3.pos() + e3;
        let r3 = 0;
        for (; a3.pos() < s4; )
          t4.addCoordinatePoint(n3, a3.getSInt64(), r3++);
        break;
      }
      default:
        a3.skip();
    }
  return n3;
}
function u(e2, t4, s3) {
  const r2 = 2, a3 = 3, n3 = e2.asUnsafe(), i2 = t4.createGeometry(s3), o2 = 2 + (s3.hasZ ? 1 : 0) + (s3.hasM ? 1 : 0);
  for (; n3.next(); )
    switch (n3.tag()) {
      case r2: {
        const e3 = n3.getUInt32(), s4 = n3.pos() + e3;
        let r3 = 0;
        for (; n3.pos() < s4; )
          t4.addLength(i2, n3.getUInt32(), r3++);
        break;
      }
      case a3: {
        const e3 = n3.getUInt32(), s4 = n3.pos() + e3;
        let r3 = 0;
        for (t4.allocateCoordinates(i2); n3.pos() < s4; )
          t4.addCoordinate(i2, n3.getSInt64(), r3), r3++, r3 === o2 && (r3 = 0);
        break;
      }
      default:
        n3.skip();
    }
  return i2;
}
function f(e2) {
  const t4 = 1, a3 = 2, n3 = 3, i2 = e2.asUnsafe(), o2 = new t2();
  let c2 = "esriGeometryPoint";
  for (; i2.next(); )
    switch (i2.tag()) {
      case a3: {
        const e3 = i2.getUInt32(), t5 = i2.pos() + e3;
        for (; i2.pos() < t5; )
          o2.lengths.push(i2.getUInt32());
        break;
      }
      case n3: {
        const e3 = i2.getUInt32(), t5 = i2.pos() + e3;
        for (; i2.pos() < t5; )
          o2.coords.push(i2.getSInt64());
        break;
      }
      case t4:
        c2 = n[i2.getEnum()];
        break;
      default:
        i2.skip();
    }
  return { queryGeometry: o2, queryGeometryType: c2 };
}
function y(e2) {
  const t4 = 1, s3 = 2, r2 = 3, a3 = 4, n3 = 5, i2 = 6, o2 = 7, c2 = 8, l2 = 9, g2 = e2.asUnsafe();
  for (; g2.next(); )
    switch (g2.tag()) {
      case t4:
        return g2.getString();
      case s3:
        return g2.getFloat();
      case r2:
        return g2.getDouble();
      case a3:
        return g2.getSInt32();
      case n3:
        return g2.getUInt32();
      case i2:
        return g2.getInt64();
      case o2:
        return g2.getUInt64();
      case c2:
        return g2.getSInt64();
      case l2:
        return g2.getBool();
      default:
        return g2.skip(), null;
    }
  return null;
}
function b(e2) {
  const t4 = 1, s3 = 2, r2 = 3, a3 = 4, n3 = 5, i2 = 6, l2 = e2.asUnsafe(), g2 = { type: o(0) };
  for (; l2.next(); )
    switch (l2.tag()) {
      case t4:
        g2.name = l2.getString();
        break;
      case s3:
        g2.type = o(l2.getEnum());
        break;
      case r2:
        g2.alias = l2.getString();
        break;
      case a3:
        g2.sqlType = c(l2.getEnum());
        break;
      case n3:
        l2.skip();
        break;
      case i2:
        g2.defaultValue = l2.getString();
        break;
      default:
        l2.skip();
    }
  return g2;
}
function k(e2) {
  const t4 = 1, s3 = 2, r2 = {}, a3 = e2.asUnsafe();
  for (; a3.next(); )
    switch (a3.tag()) {
      case t4:
        r2.name = a3.getString();
        break;
      case s3:
        r2.isSystemMaintained = a3.getBool();
        break;
      default:
        a3.skip();
    }
  return r2;
}
function d2(e2, t4, s3, r2) {
  const a3 = 1, n3 = 2, i2 = 4, o2 = t4.createFeature(s3);
  let c2 = 0;
  for (; e2.next(); )
    switch (e2.tag()) {
      case a3: {
        const t5 = r2[c2++].name;
        o2.attributes[t5] = e2.processMessage(y);
        break;
      }
      case n3:
        o2.geometry = e2.processMessageWithArgs(u, t4, s3);
        break;
      case i2:
        o2.centroid = e2.processMessageWithArgs(p, t4, s3);
        break;
      default:
        e2.skip();
    }
  return o2;
}
function T(e2) {
  const t4 = 1, s3 = 2, r2 = 3, a3 = 4, n3 = [1, 1, 1, 1], i2 = e2.asUnsafe();
  for (; i2.next(); )
    switch (i2.tag()) {
      case t4:
        n3[0] = i2.getDouble();
        break;
      case s3:
        n3[1] = i2.getDouble();
        break;
      case a3:
        n3[2] = i2.getDouble();
        break;
      case r2:
        n3[3] = i2.getDouble();
        break;
      default:
        i2.skip();
    }
  return n3;
}
function m(e2) {
  const t4 = 1, s3 = 2, r2 = 3, a3 = 4, n3 = [0, 0, 0, 0], i2 = e2.asUnsafe();
  for (; i2.next(); )
    switch (i2.tag()) {
      case t4:
        n3[0] = i2.getDouble();
        break;
      case s3:
        n3[1] = i2.getDouble();
        break;
      case a3:
        n3[2] = i2.getDouble();
        break;
      case r2:
        n3[3] = i2.getDouble();
        break;
      default:
        i2.skip();
    }
  return n3;
}
function h(e2) {
  const t4 = 1, s3 = 2, r2 = 3, a3 = { originPosition: l(0) }, n3 = e2.asUnsafe();
  for (; n3.next(); )
    switch (n3.tag()) {
      case t4:
        a3.originPosition = l(n3.getEnum());
        break;
      case s3:
        a3.scale = n3.processMessage(T);
        break;
      case r2:
        a3.translate = n3.processMessage(m);
        break;
      default:
        n3.skip();
    }
  return a3;
}
function F(e2) {
  const t4 = 1, s3 = 2, r2 = 3, a3 = {}, n3 = e2.asUnsafe();
  for (; n3.next(); )
    switch (n3.tag()) {
      case t4:
        a3.shapeAreaFieldName = n3.getString();
        break;
      case s3:
        a3.shapeLengthFieldName = n3.getString();
        break;
      case r2:
        a3.units = n3.getString();
        break;
      default:
        n3.skip();
    }
  return a3;
}
function q(e2, t4) {
  const s3 = 1, r2 = 2, a3 = 3, n3 = 4, i2 = 5, o2 = t4.createSpatialReference();
  for (; e2.next(); )
    switch (e2.tag()) {
      case s3:
        o2.wkid = e2.getUInt32();
        break;
      case i2:
        o2.wkt = e2.getString();
        break;
      case r2:
        o2.latestWkid = e2.getUInt32();
        break;
      case a3:
        o2.vcsWkid = e2.getUInt32();
        break;
      case n3:
        o2.latestVcsWkid = e2.getUInt32();
        break;
      default:
        e2.skip();
    }
  return o2;
}
function I(e2, t4) {
  const s3 = 1, r2 = 2, a3 = 3, n3 = 4, i2 = 5, o2 = 7, c2 = 8, l2 = 9, p2 = 10, u2 = 11, f2 = 12, y2 = 13, T2 = 15, m2 = t4.createFeatureResult(), I2 = e2.asUnsafe();
  m2.geometryType = g(t4, 0);
  let U2 = false;
  for (; I2.next(); )
    switch (I2.tag()) {
      case s3:
        m2.objectIdFieldName = I2.getString();
        break;
      case a3:
        m2.globalIdFieldName = I2.getString();
        break;
      case n3:
        m2.geohashFieldName = I2.getString();
        break;
      case i2:
        m2.geometryProperties = I2.processMessage(F);
        break;
      case o2:
        m2.geometryType = g(t4, I2.getEnum());
        break;
      case c2:
        m2.spatialReference = I2.processMessageWithArgs(q, t4);
        break;
      case p2:
        m2.hasZ = I2.getBool();
        break;
      case u2:
        m2.hasM = I2.getBool();
        break;
      case f2:
        m2.transform = I2.processMessage(h);
        break;
      case l2:
        m2.exceededTransferLimit = I2.getBool();
        break;
      case y2:
        t4.addField(m2, I2.processMessage(b));
        break;
      case T2:
        U2 || (t4.prepareFeatures(m2), U2 = true), t4.addFeature(m2, I2.processMessageWithArgs(d2, t4, m2, m2.fields));
        break;
      case r2:
        m2.uniqueIdField = I2.processMessage(k);
        break;
      default:
        I2.skip();
    }
  return t4.finishFeatureResult(m2), m2;
}
function U(e2, t4) {
  const s3 = 1, r2 = 4, a3 = {};
  let n3 = null;
  for (; e2.next(); )
    switch (e2.tag()) {
      case r2:
        n3 = e2.processMessageWithArgs(f);
        break;
      case s3:
        a3.featureResult = e2.processMessageWithArgs(I, t4);
        break;
      default:
        e2.skip();
    }
  return null != n3 && a3.featureResult && t4.addQueryGeometry(a3, n3), a3;
}
function S(s3, r2) {
  try {
    const e2 = 2, a3 = new r(new Uint8Array(s3), new DataView(s3)), n3 = {};
    for (; a3.next(); )
      if (a3.tag() === e2)
        n3.queryResult = a3.processMessageWithArgs(U, r2);
      else
        a3.skip();
    return n3;
  } catch (a3) {
    throw new s("query:parsing-pbf", "Error while parsing FeatureSet PBF payload", { error: a3 });
  }
}

// node_modules/@arcgis/core/rest/query/operations/pbfQueryUtils.js
function t3(t4, r2) {
  const u2 = S(t4, r2), o2 = u2.queryResult.featureResult, s3 = u2.queryResult.queryGeometry, y2 = u2.queryResult.queryGeometryType;
  if (o2 && o2.features && o2.features.length && o2.objectIdFieldName) {
    const e2 = o2.objectIdFieldName;
    for (const t5 of o2.features)
      t5.attributes && (t5.objectId = t5.attributes[e2]);
  }
  return o2 && (o2.queryGeometry = s3, o2.queryGeometryType = y2), o2;
}

export {
  a,
  b,
  h,
  t3 as t
};
//# sourceMappingURL=chunk-JWPJ4Y6I.js.map
