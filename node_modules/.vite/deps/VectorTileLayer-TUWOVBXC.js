import {
  p as p2
} from "./chunk-CGHFVL5C.js";
import "./chunk-JDPYDQ7A.js";
import {
  T
} from "./chunk-RURX4WVF.js";
import {
  l as l2
} from "./chunk-GWXJUB3T.js";
import "./chunk-X2WF3O7G.js";
import "./chunk-MGMW5F44.js";
import "./chunk-XZLDDXLF.js";
import {
  e as e4
} from "./chunk-4F3D6X6S.js";
import "./chunk-PHDOV32N.js";
import "./chunk-BUMLJETN.js";
import "./chunk-XFC7DZXI.js";
import "./chunk-PPQAHSM4.js";
import "./chunk-RCLKRKWR.js";
import "./chunk-ED5W63C6.js";
import {
  n
} from "./chunk-JLSYG6MV.js";
import "./chunk-MVXU4PVF.js";
import "./chunk-5L3L57TJ.js";
import {
  e as e3
} from "./chunk-GJ4KNHRS.js";
import {
  j as j2,
  p
} from "./chunk-CQMEHG4P.js";
import "./chunk-GZTU5O23.js";
import {
  i
} from "./chunk-TKJNJ6KH.js";
import {
  l
} from "./chunk-36R5EC6A.js";
import {
  o as o2
} from "./chunk-5DLICG33.js";
import {
  j as j3
} from "./chunk-POSLR7O2.js";
import {
  a as a4
} from "./chunk-P5VIVFJT.js";
import "./chunk-SA3C7GIT.js";
import "./chunk-P3R45ANF.js";
import {
  t as t2
} from "./chunk-PIEUUBJ5.js";
import {
  u as u2
} from "./chunk-YIAYIZOZ.js";
import {
  m as m2
} from "./chunk-P5GW5DPX.js";
import "./chunk-VIOPOI6P.js";
import "./chunk-HU7QYAVQ.js";
import "./chunk-T3Y5GTKO.js";
import "./chunk-CSWPLQ7Q.js";
import "./chunk-KWSMYM7P.js";
import "./chunk-AMSVADDY.js";
import "./chunk-6B7VJB6C.js";
import {
  b as b2
} from "./chunk-YXRSJYLG.js";
import "./chunk-JHJVOI7Q.js";
import "./chunk-S6NERLXF.js";
import "./chunk-G557TGXY.js";
import "./chunk-WOGT6UK2.js";
import "./chunk-IATM3RCE.js";
import "./chunk-BEALJUHO.js";
import "./chunk-PJQIAD5D.js";
import "./chunk-Z6KIMOUA.js";
import "./chunk-SZAJDZCO.js";
import "./chunk-M7R7REMB.js";
import "./chunk-ZZYUEH57.js";
import "./chunk-VTWXDFFD.js";
import "./chunk-IPCIO3PX.js";
import "./chunk-EIY2DYTV.js";
import "./chunk-F6MD5VOH.js";
import "./chunk-AOJ6OCPK.js";
import {
  d as d3
} from "./chunk-LMT5JII2.js";
import "./chunk-A43TI6AT.js";
import "./chunk-BHJVWW2P.js";
import "./chunk-4HKQSEUR.js";
import "./chunk-V3U4F2NL.js";
import "./chunk-ZB6PGKG5.js";
import "./chunk-OIIDE5GZ.js";
import "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import "./chunk-TBSVVR6M.js";
import {
  d
} from "./chunk-6TJWLWLO.js";
import "./chunk-H7BKONNV.js";
import "./chunk-K6C6RVSV.js";
import "./chunk-KBJ5Z4R2.js";
import "./chunk-JUZJCTW2.js";
import "./chunk-423VNHLR.js";
import "./chunk-FN47E7YK.js";
import "./chunk-XZS3Q5K4.js";
import "./chunk-XXFXRXFH.js";
import "./chunk-CCXEAKIM.js";
import {
  M
} from "./chunk-Y5D433JZ.js";
import {
  d as d2,
  x2 as x
} from "./chunk-QNOCEWCR.js";
import {
  o
} from "./chunk-WURET5CW.js";
import {
  f,
  r as r2
} from "./chunk-QWPLZ3QH.js";
import {
  N,
  g
} from "./chunk-HLGIRLYQ.js";
import "./chunk-N2K4VRZH.js";
import "./chunk-WL4VPODY.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import {
  Et,
  I,
  K,
  Rt,
  V,
  Y,
  a as a3,
  j,
  pt,
  q,
  qt,
  v
} from "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import {
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c as c2,
  r2 as r
} from "./chunk-SBW6NNVI.js";
import {
  e as e2
} from "./chunk-62CXLI6S.js";
import {
  a as a2,
  b,
  c2 as c,
  m,
  s as s3
} from "./chunk-RFPH3ZTZ.js";
import {
  u
} from "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  a,
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import {
  e2 as e,
  t4 as t
} from "./chunk-4V6374PV.js";
import "./chunk-A34O4XB5.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/support/imageUtils.js
var A = null;
function o3(o5) {
  if (A)
    return A;
  const l6 = { lossy: "UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", lossless: "UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==", alpha: "UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==", animation: "UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA" };
  return A = new Promise((A3) => {
    const n3 = new Image();
    n3.onload = () => {
      n3.onload = n3.onerror = null, A3(n3.width > 0 && n3.height > 0);
    }, n3.onerror = () => {
      n3.onload = n3.onerror = null, A3(false);
    }, n3.src = "data:image/webp;base64," + l6[o5];
  }), A;
}

// node_modules/@arcgis/core/layers/support/SpriteSource.js
var h = 1.15;
var n2 = class {
  constructor(t3, e5) {
    this._spriteSource = t3, this._maxTextureSize = e5, this.devicePixelRatio = 1, this._spriteImageFormat = "png", this._isRetina = false, this._spritesData = {}, this.image = null, this.width = null, this.height = null, this.loadStatus = "not-loaded", "url" === t3.type && t3.spriteFormat && (this._spriteImageFormat = t3.spriteFormat), t3.pixelRatio && (this.devicePixelRatio = t3.pixelRatio), this.baseURL = t3.spriteUrl;
  }
  get spriteNames() {
    const t3 = [];
    for (const e5 in this._spritesData)
      t3.push(e5);
    return t3.sort(), t3;
  }
  getSpriteInfo(t3) {
    return this._spritesData ? this._spritesData[t3] : null;
  }
  async load(t3) {
    if (this.baseURL) {
      this.loadStatus = "loading";
      try {
        await this._loadSprites(t3), this.loadStatus = "loaded";
      } catch {
        this.loadStatus = "failed";
      }
    } else
      this.loadStatus = "failed";
  }
  async _loadSprites(t3) {
    this._isRetina = this.devicePixelRatio > h;
    const { width: s5, height: r4, data: a6, json: o5 } = await this._getSpriteData(this._spriteSource, t3), n3 = Object.keys(o5);
    if (!n3 || 0 === n3.length || !a6)
      return this._spritesData = this.image = null, void (this.width = this.height = 0);
    this._spritesData = o5, this.width = s5, this.height = r4;
    const d6 = Math.max(this._maxTextureSize, 4096);
    if (s5 > d6 || r4 > d6) {
      const t4 = `Sprite resource for style ${this.baseURL} is bigger than the maximum allowed of ${d6} pixels}`;
      throw s.getLogger("esri.layers.support.SpriteSource").error(t4), new s2("SpriteSource", t4);
    }
    let p4;
    for (let e5 = 0; e5 < a6.length; e5 += 4)
      p4 = a6[e5 + 3] / 255, a6[e5] = a6[e5] * p4, a6[e5 + 1] = a6[e5 + 1] * p4, a6[e5 + 2] = a6[e5 + 2] * p4;
    this.image = a6;
  }
  async _getSpriteData(i2, n3) {
    if ("image" === i2.type) {
      let t3, a6;
      if (this.devicePixelRatio < h) {
        if (!i2.spriteSource1x)
          throw new s2("SpriteSource", "no image data provided for low resolution sprites!");
        t3 = i2.spriteSource1x.image, a6 = i2.spriteSource1x.json;
      } else {
        if (!i2.spriteSource2x)
          throw new s2("SpriteSource", "no image data provided for high resolution sprites!");
        t3 = i2.spriteSource2x.image, a6 = i2.spriteSource2x.json;
      }
      return "width" in t3 && "height" in t3 && "data" in t3 && (t(t3.data) || e(t3.data)) ? { width: t3.width, height: t3.height, data: new Uint8Array(t3.data), json: a6 } : { ...d4(t3), json: a6 };
    }
    const p4 = I(this.baseURL), l6 = p4.query ? "?" + v(p4.query) : "", g3 = this._isRetina ? "@2x" : "", u4 = `${p4.path}${g3}.${this._spriteImageFormat}${l6}`, c4 = `${p4.path}${g3}.json${l6}`, [m3, S2] = await Promise.all([j(c4, n3), j(u4, { responseType: "image", ...n3 })]);
    return { ...d4(S2.data), json: m3.data };
  }
};
function d4(t3) {
  const e5 = document.createElement("canvas"), i2 = e5.getContext("2d");
  e5.width = t3.width, e5.height = t3.height, i2.drawImage(t3, 0, 0, t3.width, t3.height);
  const s5 = i2.getImageData(0, 0, t3.width, t3.height);
  return { width: t3.width, height: t3.height, data: new Uint8Array(s5.data) };
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TilemapIndex.js
var l3 = class {
  constructor(e5) {
    this.url = e5;
  }
  destroy() {
    this._tileIndexPromise = null;
  }
  async fetchTileIndex() {
    return this._tileIndexPromise || (this._tileIndexPromise = j(this.url).then((e5) => e5.data.index)), this._tileIndexPromise;
  }
  async dataKey(e5, r4) {
    const l6 = await this.fetchTileIndex();
    return s3(r4), this._getIndexedDataKey(l6, e5);
  }
  _getIndexedDataKey(e5, t3) {
    const l6 = [t3];
    if (t3.level < 0 || t3.row < 0 || t3.col < 0 || t3.row >> t3.level > 0 || t3.col >> t3.level > 0)
      return null;
    let i2 = t3;
    for (; 0 !== i2.level; )
      i2 = new e3(i2.level - 1, i2.row >> 1, i2.col >> 1, i2.world), l6.push(i2);
    let o5, s5, n3 = e5, a6 = l6.pop();
    if (1 === n3)
      return a6;
    for (; l6.length; )
      if (o5 = l6.pop(), s5 = (1 & o5.col) + ((1 & o5.row) << 1), n3) {
        if (0 === n3[s5]) {
          a6 = null;
          break;
        }
        if (1 === n3[s5]) {
          a6 = o5;
          break;
        }
        a6 = o5, n3 = n3[s5];
      }
    return a6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TilemapRequest.js
var l4 = class {
  constructor(e5, t3) {
    this._tilemap = e5, this._tileIndexUrl = t3;
  }
  destroy() {
    this._tilemap = u(this._tilemap), this._tileIndexPromise = null;
  }
  async fetchTileIndex(t3) {
    return this._tileIndexPromise || (this._tileIndexPromise = j(this._tileIndexUrl, { query: { ...t3 == null ? void 0 : t3.query } }).then((e5) => e5.data.index)), this._tileIndexPromise;
  }
  dataKey(e5, t3) {
    const { level: l6, row: s5, col: o5 } = e5, n3 = new e3(e5);
    return this._tilemap.fetchAvailabilityUpsample(l6, s5, o5, n3, t3).then(() => (n3.world = e5.world, n3)).catch((e6) => {
      if (b(e6))
        throw e6;
      return null;
    });
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/style/VectorTilesRequestManager.js
var l5 = class {
  constructor(t3) {
    this._tileUrl = t3, this._promise = null, this._abortController = null, this._abortOptions = [];
  }
  getData(t3) {
    null === this._promise && (this._abortController = new AbortController(), this._promise = this._makeRequest(this._tileUrl, this._abortController.signal));
    const e5 = this._abortOptions;
    return e5.push(t3), m(t3, () => {
      e5.every((t4) => c(t4)) && this._abortController.abort();
    }), this._promise.then((t4) => a(t4));
  }
  async _makeRequest(r4, e5) {
    const { data: o5 } = await j(r4, { responseType: "array-buffer", signal: e5 });
    return o5;
  }
};
var a5 = /* @__PURE__ */ new Map();
function c3(t3, r4, e5, o5, s5) {
  const l6 = I(t3), a6 = l6.query;
  if (a6)
    for (const [i2, n3] of Object.entries(a6))
      switch (n3) {
        case "{x}":
          a6[i2] = o5.toString();
          break;
        case "{y}":
          a6[i2] = e5.toString();
          break;
        case "{z}":
          a6[i2] = r4.toString();
      }
  const c4 = l6.path;
  return p3(Et(c4.replaceAll(/\{z\}/gi, r4.toString()).replaceAll(/\{y\}/gi, e5.toString()).replaceAll(/\{x\}/gi, o5.toString()), { ...l6.query }), s5);
}
function p3(t3, r4) {
  return r(a5, t3, () => new l5(t3)).getData(r4).then((r5) => (a5.delete(t3), r5)).catch((r5) => {
    throw a5.delete(t3), r5;
  });
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/style/VectorTileSource.js
var u3 = class {
  constructor(h3, u4, m3) {
    this.tilemap = null, this.tileInfo = null, this.capabilities = null, this.fullExtent = null, this.initialExtent = null, this.name = h3, this.sourceUrl = u4;
    const f2 = I(this.sourceUrl), c4 = a(m3), x3 = c4.tiles;
    if (f2)
      for (let t3 = 0; t3 < x3.length; t3++) {
        const r4 = I(x3[t3]);
        r4 && (Y(r4.path) || (r4.path = V(f2.path, r4.path)), x3[t3] = Et(r4.path, { ...f2.query, ...r4.query }));
      }
    this.tileServers = x3;
    const d6 = m3.capabilities && m3.capabilities.split(",").map((t3) => t3.toLowerCase().trim()), y2 = true === (m3 == null ? void 0 : m3.exportTilesAllowed), T2 = true === (d6 == null ? void 0 : d6.includes("tilemap")), I2 = y2 && m3.hasOwnProperty("maxExportTilesCount") ? m3.maxExportTilesCount : 0;
    this.capabilities = { operations: { supportsExportTiles: y2, supportsTileMap: T2 }, exportTiles: y2 ? { maxExportTilesCount: +I2 } : null }, this.tileInfo = j2.fromJSON(c4.tileInfo);
    const g3 = m3.tileMap ? Et(V(f2.path, m3.tileMap), f2.query ?? {}) : null;
    T2 ? (this.type = "vector-tile", this.tilemap = new l4(new T({ layer: { parsedUrl: f2, tileInfo: this.tileInfo }, minLOD: c4.minLOD ?? this.tileInfo.lods[0].level, maxLOD: c4.maxLOD ?? this.tileInfo.lods[this.tileInfo.lods.length - 1].level }), g3)) : g3 && (this.tilemap = new l3(g3)), this.fullExtent = M.fromJSON(m3.fullExtent), this.initialExtent = M.fromJSON(m3.initialExtent);
  }
  destroy() {
    var _a;
    (_a = this.tilemap) == null ? void 0 : _a.destroy();
  }
  async getRefKey(t3, e5) {
    var _a;
    return await ((_a = this.tilemap) == null ? void 0 : _a.dataKey(t3, e5)) ?? t3;
  }
  requestTile(t3, e5, i2, l6) {
    const s5 = this.tileServers[e5 % this.tileServers.length];
    return c3(s5, t3, e5, i2, l6);
  }
  isCompatibleWith(t3) {
    const e5 = this.tileInfo, i2 = t3.tileInfo;
    if (!e5.spatialReference.equals(i2.spatialReference))
      return false;
    if (!e5.origin.equals(i2.origin))
      return false;
    if (Math.round(e5.dpi) !== Math.round(i2.dpi))
      return false;
    const l6 = e5.lods, s5 = i2.lods, r4 = Math.min(l6.length, s5.length);
    for (let o5 = 0; o5 < r4; o5++) {
      const t4 = l6[o5], e6 = s5[o5];
      if (t4.level !== e6.level || Math.round(t4.scale) !== Math.round(e6.scale))
        return false;
    }
    return true;
  }
};

// node_modules/@arcgis/core/layers/support/vectorTileLayerLoader.js
async function x2(e5, t3) {
  const r4 = { source: null, sourceBase: null, sourceUrl: null, validatedSource: null, style: null, styleBase: null, styleUrl: null, sourceNameToSource: {}, primarySourceName: "", spriteFormat: "png" }, [s5, o5] = "string" == typeof e5 ? [e5, null] : [null, e5.jsonUrl];
  await S(r4, "esri", e5, o5, t3);
  return { layerDefinition: r4.validatedSource, url: s5, serviceUrl: r4.sourceUrl, style: r4.style, styleUrl: r4.styleUrl, spriteUrl: r4.style.sprite && d5(r4.styleBase, r4.style.sprite), spriteFormat: r4.spriteFormat, glyphsUrl: r4.style.glyphs && d5(r4.styleBase, r4.style.glyphs), sourceNameToSource: r4.sourceNameToSource, primarySourceName: r4.primarySourceName };
}
function d5(...e5) {
  let t3;
  for (const r4 of e5)
    if (null != r4)
      if (pt(r4)) {
        if (t3) {
          const e6 = t3.split("://")[0];
          t3 = e6 + ":" + r4.trim();
        }
      } else
        t3 = Y(r4) ? r4 : V(t3, r4);
  return t3 ? qt(t3) : void 0;
}
async function S(t3, s5, o5, l6, n3) {
  let u4, a6, c4;
  if (s3(n3), "string" == typeof o5) {
    const t4 = K(o5);
    c4 = await j(t4, { ...n3, responseType: "json", query: { f: "json", ...n3 == null ? void 0 : n3.query } }), c4.ssl && (u4 && (u4 = u4.replace(/^http:/i, "https:")), a6 && (a6 = a6.replace(/^http:/i, "https:"))), u4 = t4, a6 = t4;
  } else
    null != o5 && (c4 = { data: o5 }, u4 = o5.jsonUrl || null, a6 = l6);
  const f2 = c4 == null ? void 0 : c4.data;
  if (w(f2))
    return t3.styleUrl = u4 || null, j4(t3, f2, a6, n3);
  if (U(f2))
    return t3.sourceUrl ? g2(t3, f2, a6, false, s5, n3) : (t3.sourceUrl = u4 || null, g2(t3, f2, a6, true, s5, n3));
  throw new Error("You must specify the URL or the JSON for a service or for a style.");
}
function h2(e5) {
  return "object" == typeof e5 && !!e5 && "tilejson" in e5 && null != e5.tilejson;
}
function w(e5) {
  return !!e5 && "sources" in e5 && !!e5.sources;
}
function U(e5) {
  return !w(e5);
}
async function j4(e5, t3, r4, s5) {
  const o5 = r4 ? Rt(r4) : q();
  e5.styleBase = o5, e5.style = t3, t3["sprite-format"] && "webp" === t3["sprite-format"].toLowerCase() && (e5.spriteFormat = "webp");
  const l6 = [];
  if (t3.sources && t3.sources.esri) {
    const r5 = t3.sources.esri;
    r5.url ? await S(e5, "esri", d5(o5, r5.url), void 0, s5) : l6.push(S(e5, "esri", r5, o5, s5));
  }
  for (const n3 of Object.keys(t3.sources))
    "esri" !== n3 && "vector" === t3.sources[n3].type && (t3.sources[n3].url ? l6.push(S(e5, n3, d5(o5, t3.sources[n3].url), void 0, s5)) : t3.sources[n3].tiles && l6.push(S(e5, n3, t3.sources[n3], o5, s5)));
  await Promise.all(l6);
}
async function g2(e5, t3, r4, s5, o5, l6) {
  const i2 = r4 ? qt(r4) + "/" : q(), u4 = v2(t3), f2 = new u3(o5, Et(i2, (l6 == null ? void 0 : l6.query) ?? {}), u4);
  if (!s5 && e5.primarySourceName in e5.sourceNameToSource) {
    const t4 = e5.sourceNameToSource[e5.primarySourceName];
    if (!t4.isCompatibleWith(f2))
      return;
    null != f2.fullExtent && (null != t4.fullExtent ? t4.fullExtent.union(f2.fullExtent) : t4.fullExtent = f2.fullExtent.clone()), t4.tileInfo && f2.tileInfo && t4.tileInfo.lods.length < f2.tileInfo.lods.length && (t4.tileInfo = f2.tileInfo);
  }
  if (s5 && (e5.sourceBase = i2, e5.source = t3, e5.validatedSource = u4, e5.primarySourceName = o5), e5.sourceNameToSource[o5] = f2, !h2(e5) && "defaultStyles" in t3 && !e5.style) {
    if (null == t3.defaultStyles)
      throw new Error();
    return "string" == typeof t3.defaultStyles ? S(e5, "", d5(i2, t3.defaultStyles, "root.json"), void 0, l6) : S(e5, "", t3.defaultStyles, d5(i2, "root.json"), l6);
  }
}
function v2(e5) {
  if (e5.hasOwnProperty("tileInfo"))
    return e5;
  const r4 = { xmin: -20037507067161843e-9, ymin: -20037507067161843e-9, xmax: 20037507067161843e-9, ymax: 20037507067161843e-9, spatialReference: { wkid: 102100, latestWkid: 3857 } };
  let s5 = null;
  if (h2(e5)) {
    const { bounds: r5 } = e5;
    if (r5) {
      const e6 = d2({ x: r5[0], y: r5[1], spatialReference: a(N) }), o6 = d2({ x: r5[2], y: r5[3], spatialReference: a(N) });
      s5 = { xmin: e6.x, ymin: e6.y, xmax: o6.x, ymax: o6.y, spatialReference: a(g) };
    }
  }
  null === s5 && (s5 = r4);
  const o5 = 512;
  let l6 = 78271.51696400007, n3 = 2958287637957775e-7;
  const i2 = [], u4 = e5.hasOwnProperty("maxzoom") && null != e5.maxzoom ? +e5.maxzoom : 22, a6 = 0, c4 = 0;
  for (let t3 = 0; t3 <= u4; t3++)
    i2.push({ level: t3, scale: n3, resolution: l6 }), l6 /= 2, n3 /= 2;
  return { capabilities: "TilesOnly", initialExtent: s5, fullExtent: r4, minScale: a6, maxScale: c4, tiles: e5.tiles, tileInfo: { rows: o5, cols: o5, dpi: 96, format: "pbf", origin: { x: -20037508342787e-6, y: 20037508342787e-6 }, lods: i2, spatialReference: a(g) } };
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/tileInfoUtils.js
var s4 = 1e-6;
function r3(l6, e5) {
  if (l6 === e5)
    return true;
  if (null == l6 && null != e5)
    return false;
  if (null != l6 && null == e5)
    return false;
  if (null == l6 || null == e5)
    return false;
  if (!l6.spatialReference.equals(e5.spatialReference) || l6.dpi !== e5.dpi)
    return false;
  const n3 = l6.origin, r4 = e5.origin;
  if (Math.abs(n3.x - r4.x) >= s4 || Math.abs(n3.y - r4.y) >= s4)
    return false;
  let o5, t3;
  l6.lods[0].scale > e5.lods[0].scale ? (o5 = l6, t3 = e5) : (t3 = l6, o5 = e5);
  for (let i2 = o5.lods[0].scale; i2 >= t3.lods[t3.lods.length - 1].scale - s4; i2 /= 2)
    if (Math.abs(i2 - t3.lods[0].scale) < s4)
      return true;
  return false;
}
function o4(s5, r4) {
  if (s5 === r4)
    return s5;
  if (null == s5 && null != r4)
    return r4;
  if (null != s5 && null == r4)
    return s5;
  if (null == s5 || null == r4)
    return null;
  const o5 = s5.size[0], t3 = s5.format, i2 = s5.dpi, u4 = new x({ x: s5.origin.x, y: s5.origin.y }), a6 = s5.spatialReference, f2 = s5.lods[0].scale > r4.lods[0].scale ? s5.lods[0] : r4.lods[0], d6 = s5.lods[s5.lods.length - 1].scale <= r4.lods[r4.lods.length - 1].scale ? s5.lods[s5.lods.length - 1] : r4.lods[r4.lods.length - 1], c4 = f2.scale, p4 = f2.resolution, g3 = d6.scale, h3 = [];
  let m3 = c4, y2 = p4, x3 = 0;
  for (; m3 > g3; )
    h3.push(new p({ level: x3, resolution: y2, scale: m3 })), x3++, m3 /= 2, y2 /= 2;
  return new j2({ size: [o5, o5], dpi: i2, format: t3 || "pbf", origin: u4, lods: h3, spatialReference: a6 });
}

// node_modules/@arcgis/core/layers/VectorTileLayer.js
var N2 = class extends a4(t2(p2(l(u2(j3(o2(i(m2(b2))))))))) {
  constructor(...e5) {
    super(...e5), this._spriteSourceMap = /* @__PURE__ */ new Map(), this.currentStyleInfo = null, this.isReference = null, this.operationalLayerType = "VectorTileLayer", this.style = null, this.tilemapCache = null, this.type = "vector-tile", this.url = null, this.path = null;
  }
  normalizeCtorArgs(e5, t3) {
    return "string" == typeof e5 ? { url: e5, ...t3 } : e5;
  }
  destroy() {
    var _a;
    if (this.sourceNameToSource)
      for (const e5 of Object.values(this.sourceNameToSource))
        e5 == null ? void 0 : e5.destroy();
    (_a = this.primarySource) == null ? void 0 : _a.destroy(), this._spriteSourceMap.clear();
  }
  async prefetchResources(e5) {
    await this.loadSpriteSource(globalThis.devicePixelRatio || 1, e5);
  }
  load(e5) {
    const r4 = this.loadFromPortal({ supportedTypes: ["Vector Tile Service"], supportsData: false }, e5).catch(a2).then(async () => {
      var _a;
      if (!((_a = this.portalItem) == null ? void 0 : _a.id))
        return;
      const r5 = `${this.portalItem.itemCdnUrl}/resources/styles/root.json`;
      (await j(r5, { ...e5, query: { f: "json", ...this.customParameters, token: this.apiKey } })).data && this.read({ url: r5 }, e4(this.portalItem));
    }).catch(a2).then(() => this._loadStyle(e5));
    return this.addResolvingPromise(r4), Promise.resolve(this);
  }
  get attributionDataUrl() {
    const e5 = this.currentStyleInfo, t3 = (e5 == null ? void 0 : e5.serviceUrl) && I(e5.serviceUrl);
    if (!t3)
      return null;
    const r4 = this._getDefaultAttribution(t3.path);
    return r4 ? Et(r4, { ...this.customParameters, token: this.apiKey }) : null;
  }
  get capabilities() {
    const e5 = this.primarySource;
    return e5 ? e5.capabilities : { operations: { supportsExportTiles: false, supportsTileMap: false }, exportTiles: null };
  }
  get fullExtent() {
    var _a;
    return ((_a = this.primarySource) == null ? void 0 : _a.fullExtent) || null;
  }
  get initialExtent() {
    var _a;
    return ((_a = this.primarySource) == null ? void 0 : _a.initialExtent) || null;
  }
  get parsedUrl() {
    return this.serviceUrl ? I(this.serviceUrl) : null;
  }
  get serviceUrl() {
    var _a;
    return ((_a = this.currentStyleInfo) == null ? void 0 : _a.serviceUrl) || null;
  }
  get spatialReference() {
    var _a;
    return ((_a = this.tileInfo) == null ? void 0 : _a.spatialReference) ?? null;
  }
  get styleUrl() {
    var _a;
    return ((_a = this.currentStyleInfo) == null ? void 0 : _a.styleUrl) || null;
  }
  writeStyleUrl(e5, t3) {
    e5 && pt(e5) && (e5 = `https:${e5}`);
    const r4 = a3(e5);
    t3.styleUrl = d3(e5, r4);
  }
  get tileInfo() {
    var _a;
    const e5 = [];
    for (const r4 in this.sourceNameToSource)
      e5.push(this.sourceNameToSource[r4]);
    let t3 = ((_a = this.primarySource) == null ? void 0 : _a.tileInfo) || new j2();
    if (e5.length > 1)
      for (let r4 = 0; r4 < e5.length; r4++)
        r3(t3, e5[r4].tileInfo) && (t3 = o4(t3, e5[r4].tileInfo));
    return t3;
  }
  readTilemapCache(e5, t3) {
    var _a;
    const r4 = (_a = t3.capabilities) == null ? void 0 : _a.includes("Tilemap");
    return r4 ? new T({ layer: this }) : null;
  }
  readVersion(e5, t3) {
    return t3.version ? parseFloat(t3.version) : parseFloat(t3.currentVersion);
  }
  async loadSpriteSource(e5 = 1, t3) {
    var _a, _b;
    if (!this._spriteSourceMap.has(e5)) {
      const r4 = n("2d").maxTextureSize, i2 = ((_a = this.currentStyleInfo) == null ? void 0 : _a.spriteUrl) ? Et(this.currentStyleInfo.spriteUrl, { ...this.customParameters, token: this.apiKey }) : null, o5 = new n2({ type: "url", spriteUrl: i2, pixelRatio: e5, spriteFormat: (_b = this.currentStyleInfo) == null ? void 0 : _b.spriteFormat }, r4);
      await o5.load(t3), this._spriteSourceMap.set(e5, o5);
    }
    return this._spriteSourceMap.get(e5);
  }
  async setSpriteSource(e5, t3) {
    if (!e5)
      return null;
    const r4 = n("2d").maxTextureSize, i2 = e5.spriteUrl, o5 = i2 ? Et(i2, { ...this.customParameters, token: this.apiKey }) : null;
    if (!o5 && "url" === e5.type)
      return null;
    const s5 = new n2(e5, r4);
    try {
      await s5.load(t3);
      const r5 = e5.pixelRatio || 1;
      return this._spriteSourceMap.clear(), this._spriteSourceMap.set(r5, s5), o5 && this.currentStyleInfo && (this.currentStyleInfo.spriteUrl = o5), this.emit("spriteSource-change", { spriteSource: s5 }), s5;
    } catch (a6) {
      a2(a6);
    }
    return null;
  }
  async loadStyle(e5, t3) {
    var _a;
    const i2 = e5 || this.style || this.url;
    return this._loadingTask && "string" == typeof i2 && this.url === i2 || ((_a = this._loadingTask) == null ? void 0 : _a.abort(), this._loadingTask = d((e6) => (this._spriteSourceMap.clear(), this._getSourceAndStyle(i2, { signal: e6 })), t3)), this._loadingTask.promise;
  }
  getStyleLayerId(e5) {
    return this.styleRepository.getStyleLayerId(e5);
  }
  getStyleLayerIndex(e5) {
    return this.styleRepository.getStyleLayerIndex(e5);
  }
  getPaintProperties(e5) {
    var _a;
    return a((_a = this.styleRepository) == null ? void 0 : _a.getPaintProperties(e5));
  }
  setPaintProperties(e5, t3) {
    const r4 = this.styleRepository.isPainterDataDriven(e5);
    this.styleRepository.setPaintProperties(e5, t3);
    const i2 = this.styleRepository.isPainterDataDriven(e5);
    this.emit("paint-change", { layer: e5, paint: t3, isDataDriven: r4 || i2 });
  }
  getStyleLayer(e5) {
    return a(this.styleRepository.getStyleLayer(e5));
  }
  setStyleLayer(e5, t3) {
    this.styleRepository.setStyleLayer(e5, t3), this.emit("style-layer-change", { layer: e5, index: t3 });
  }
  deleteStyleLayer(e5) {
    this.styleRepository.deleteStyleLayer(e5), this.emit("delete-style-layer", { layer: e5 });
  }
  getLayoutProperties(e5) {
    return a(this.styleRepository.getLayoutProperties(e5));
  }
  setLayoutProperties(e5, t3) {
    this.styleRepository.setLayoutProperties(e5, t3), this.emit("layout-change", { layer: e5, layout: t3 });
  }
  setStyleLayerVisibility(e5, t3) {
    this.styleRepository.setStyleLayerVisibility(e5, t3), this.emit("style-layer-visibility-change", { layer: e5, visibility: t3 });
  }
  getStyleLayerVisibility(e5) {
    return this.styleRepository.getStyleLayerVisibility(e5);
  }
  write(e5, t3) {
    return (t3 == null ? void 0 : t3.origin) && !this.styleUrl ? (t3.messages && t3.messages.push(new s2("vectortilelayer:unsupported", `VectorTileLayer (${this.title}, ${this.id}) with style defined by JSON only are not supported`, { layer: this })), null) : super.write(e5, t3);
  }
  getTileUrl(e5, t3, r4) {
    return null;
  }
  async _getSourceAndStyle(e5, t3) {
    if (!e5)
      throw new Error("invalid style!");
    const r4 = await x2(e5, { ...t3, query: { ...this.customParameters, token: this.apiKey } });
    if ("webp" === r4.spriteFormat) {
      await o3("lossy") || (r4.spriteFormat = "png");
    }
    this._set("currentStyleInfo", { ...r4 }), "string" == typeof e5 ? (this.url = e5, this.style = null) : (this.url = null, this.style = e5), this._set("sourceNameToSource", r4.sourceNameToSource), this._set("primarySource", r4.sourceNameToSource[r4.primarySourceName]), this._set("styleRepository", new l2(r4.style)), this.read(r4.layerDefinition, { origin: "service" }), this.emit("load-style");
  }
  _getDefaultAttribution(e5) {
    const t3 = e5.match(/^https?:\/\/(?:basemaps|basemapsbeta|basemapsdev)(?:-api)?\.arcgis\.com(\/[^\/]+)?\/arcgis\/rest\/services\/([^\/]+(\/[^\/]+)*)\/vectortileserver/i), r4 = ["OpenStreetMap_v2", "OpenStreetMap_Daylight_v2", "OpenStreetMap_Export_v2", "OpenStreetMap_FTS_v2", "OpenStreetMap_GCS_v2", "World_Basemap", "World_Basemap_v2", "World_Basemap_Export_v2", "World_Basemap_GCS_v2", "World_Basemap_WGS84", "World_Contours_v2"];
    if (!t3)
      return;
    const i2 = t3[2] && t3[2].toLowerCase();
    if (!i2)
      return;
    const o5 = t3[1] || "";
    for (const s5 of r4)
      if (s5.toLowerCase().includes(i2))
        return K(`//static.arcgis.com/attribution/Vector${o5}/${s5}`);
  }
  async _loadStyle(e5) {
    var _a;
    return ((_a = this._loadingTask) == null ? void 0 : _a.promise) ?? this.loadStyle(null, e5);
  }
};
e2([y({ readOnly: true })], N2.prototype, "attributionDataUrl", null), e2([y({ type: ["show", "hide"] })], N2.prototype, "listMode", void 0), e2([y({ json: { read: true, write: true } })], N2.prototype, "blendMode", void 0), e2([y({ readOnly: true, json: { read: false } })], N2.prototype, "capabilities", null), e2([y({ readOnly: true })], N2.prototype, "currentStyleInfo", void 0), e2([y({ json: { read: false }, readOnly: true, type: M })], N2.prototype, "fullExtent", null), e2([y({ json: { read: false }, readOnly: true, type: M })], N2.prototype, "initialExtent", null), e2([y({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], N2.prototype, "isReference", void 0), e2([y({ type: ["VectorTileLayer"] })], N2.prototype, "operationalLayerType", void 0), e2([y({ readOnly: true })], N2.prototype, "parsedUrl", null), e2([y()], N2.prototype, "style", void 0), e2([y({ readOnly: true })], N2.prototype, "serviceUrl", null), e2([y({ type: f, readOnly: true })], N2.prototype, "spatialReference", null), e2([y({ readOnly: true })], N2.prototype, "styleRepository", void 0), e2([y({ readOnly: true })], N2.prototype, "sourceNameToSource", void 0), e2([y({ readOnly: true })], N2.prototype, "primarySource", void 0), e2([y({ type: String, readOnly: true, json: { write: { ignoreOrigin: true }, origins: { "web-document": { write: { ignoreOrigin: true, isRequired: true } } } } })], N2.prototype, "styleUrl", null), e2([r2(["portal-item", "web-document"], "styleUrl")], N2.prototype, "writeStyleUrl", null), e2([y({ json: { read: false, origins: { service: { read: false } } }, readOnly: true, type: j2 })], N2.prototype, "tileInfo", null), e2([y()], N2.prototype, "tilemapCache", void 0), e2([o("service", "tilemapCache", ["capabilities", "tileInfo"])], N2.prototype, "readTilemapCache", null), e2([y({ json: { read: false }, readOnly: true, value: "vector-tile" })], N2.prototype, "type", void 0), e2([y({ json: { origins: { "web-document": { read: { source: "styleUrl" } }, "portal-item": { read: { source: "url" } } }, write: false, read: false } })], N2.prototype, "url", void 0), e2([y({ readOnly: true })], N2.prototype, "version", void 0), e2([o("version", ["version", "currentVersion"])], N2.prototype, "readVersion", null), e2([y({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], N2.prototype, "path", void 0), N2 = e2([c2("esri.layers.VectorTileLayer")], N2);
var A2 = N2;
export {
  A2 as default
};
//# sourceMappingURL=VectorTileLayer-TUWOVBXC.js.map
