import {
  n as n7
} from "./chunk-6NVV35A2.js";
import {
  r
} from "./chunk-DOYHEHQS.js";
import {
  o as o3
} from "./chunk-HBFRNOJQ.js";
import {
  a as a3,
  h2,
  m as m3,
  n as n5,
  n2 as n6,
  r as r2,
  w as w4
} from "./chunk-EQVODNOJ.js";
import {
  a as a4
} from "./chunk-INVSGWP7.js";
import {
  m as m4,
  u as u5
} from "./chunk-SBC4OSBO.js";
import {
  w as w3
} from "./chunk-IF6ORLWU.js";
import {
  a as a2
} from "./chunk-AZKAB65C.js";
import {
  f as f4
} from "./chunk-BV5PCIP6.js";
import {
  o as o2
} from "./chunk-63MRXB4A.js";
import {
  h
} from "./chunk-A6KO3R3G.js";
import {
  n as n3,
  p as p2
} from "./chunk-JTZOXJGU.js";
import {
  c as c4
} from "./chunk-DMXA3RSU.js";
import {
  t
} from "./chunk-ODGAHKYT.js";
import {
  te
} from "./chunk-UMP4LYVN.js";
import {
  E,
  T
} from "./chunk-TREPTI6V.js";
import {
  V as V2
} from "./chunk-XFC7DZXI.js";
import {
  F
} from "./chunk-RCLKRKWR.js";
import {
  n as n4
} from "./chunk-JLSYG6MV.js";
import {
  _
} from "./chunk-2FFBPEOX.js";
import {
  l as l3
} from "./chunk-X2Y3P2BF.js";
import {
  e as e3
} from "./chunk-GJ4KNHRS.js";
import {
  n as n2
} from "./chunk-B7TIRUHV.js";
import {
  d as d4,
  w
} from "./chunk-BVTDQR4O.js";
import {
  b as b3,
  c as c3,
  d as d5,
  f as f3,
  v as v2
} from "./chunk-DYYHVSPV.js";
import {
  j
} from "./chunk-VIOPOI6P.js";
import {
  d as d3
} from "./chunk-BYK6DXRK.js";
import {
  i as i2
} from "./chunk-OCLKX5SY.js";
import {
  b as b2
} from "./chunk-45OAWGCA.js";
import {
  m as m2
} from "./chunk-T3Y5GTKO.js";
import {
  l as l2,
  u as u4
} from "./chunk-6BFXMZEZ.js";
import {
  p
} from "./chunk-KBKTS574.js";
import {
  c as c2
} from "./chunk-FWR4JURK.js";
import {
  I,
  J,
  L,
  M as M2,
  O,
  b as b4,
  je,
  v as v3,
  w as w2,
  x as x2
} from "./chunk-Z6KIMOUA.js";
import {
  i as i3
} from "./chunk-M7R7REMB.js";
import {
  u as u3
} from "./chunk-EIY2DYTV.js";
import {
  x
} from "./chunk-A43TI6AT.js";
import {
  u as u2
} from "./chunk-3XSRVKBX.js";
import {
  i
} from "./chunk-MKW4ORPJ.js";
import {
  A,
  P,
  d as d2,
  v
} from "./chunk-TBSVVR6M.js";
import {
  V
} from "./chunk-JUZJCTW2.js";
import {
  M
} from "./chunk-Y5D433JZ.js";
import {
  o
} from "./chunk-WURET5CW.js";
import {
  f as f2
} from "./chunk-QWPLZ3QH.js";
import {
  m
} from "./chunk-N2K4VRZH.js";
import {
  g,
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  C,
  b,
  d,
  e as e2,
  f,
  k as k2
} from "./chunk-RFPH3ZTZ.js";
import {
  l,
  n,
  u
} from "./chunk-WGO3VFQP.js";
import {
  a,
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import {
  has,
  k
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/AggregateGraphic.js
var p3 = class extends c2 {
  constructor() {
    super(...arguments), this.isAggregate = true;
  }
  getEffectivePopupTemplate(e5 = false) {
    var _a;
    if (this.popupTemplate)
      return this.popupTemplate;
    const r8 = (_a = this.sourceLayer) == null ? void 0 : _a.featureReduction;
    return r8 && "popupTemplate" in r8 && r8.popupEnabled ? r8.popupTemplate : null;
  }
  getObjectId() {
    return this.attributes.aggregateId;
  }
};
e([y({ type: Boolean })], p3.prototype, "isAggregate", void 0), p3 = e([c("esri.AggregateGraphic")], p3);
var s3 = p3;

// node_modules/@arcgis/core/layers/effects/FeatureEffectView.js
var c5 = class extends g {
  constructor(e5) {
    super(e5), this._filter = null, this.duration = has("mapview-transitions-duration"), this._excludedEffectView = new a2(e5), this._includedEffectView = new a2(e5);
  }
  get excludedEffects() {
    return this._excludedEffectView.effects;
  }
  set featureEffect(e5) {
    this._get("featureEffect") !== e5 && this._transitionTo(e5);
  }
  get filter() {
    var _a;
    return this._filter || ((_a = this.featureEffect) == null ? void 0 : _a.filter) || null;
  }
  get hasEffects() {
    return this._excludedEffectView.hasEffects || this._includedEffectView.hasEffects;
  }
  get includedEffects() {
    return this._includedEffectView.effects;
  }
  set scale(e5) {
    this._set("scale", e5), this._excludedEffectView.scale = e5, this._includedEffectView.scale = e5;
  }
  get transitioning() {
    return this._excludedEffectView.transitioning || this._includedEffectView.transitioning;
  }
  transitionStep(e5, t5) {
    this._set("scale", t5), this.transitioning ? (this._includedEffectView.transitionStep(e5, t5), this._excludedEffectView.transitionStep(e5, t5), this.transitioning || (this._filter = null)) : (this._excludedEffectView.scale = t5, this._includedEffectView.scale = t5);
  }
  endTransitions() {
    this._includedEffectView.endTransitions(), this._excludedEffectView.endTransitions(), this._filter = null;
  }
  _transitionTo(e5) {
    const t5 = this._get("featureEffect"), i8 = e5, s6 = i8 == null ? void 0 : i8.includedEffect, f6 = i8 == null ? void 0 : i8.excludedEffect, c11 = this._includedEffectView.canTransitionTo(s6) && this._excludedEffectView.canTransitionTo(f6);
    this._includedEffectView.effect = s6, this._excludedEffectView.effect = f6, this._set("featureEffect", i8), this._filter = (i8 == null ? void 0 : i8.filter) || (t5 == null ? void 0 : t5.filter) || null, c11 || this.endTransitions();
  }
};
e([y()], c5.prototype, "_filter", void 0), e([y()], c5.prototype, "_excludedEffectView", void 0), e([y()], c5.prototype, "_includedEffectView", void 0), e([y()], c5.prototype, "duration", void 0), e([y()], c5.prototype, "excludedEffects", null), e([y()], c5.prototype, "featureEffect", null), e([y()], c5.prototype, "filter", null), e([y()], c5.prototype, "hasEffects", null), e([y()], c5.prototype, "includedEffects", null), e([y({ value: 0 })], c5.prototype, "scale", null), e([y()], c5.prototype, "transitioning", null), c5 = e([c("esri.layers.effects.FeatureEffectView")], c5);
var r3 = c5;

// node_modules/@arcgis/core/rest/support/AggregateFeatureSet.js
var c6 = class extends d3 {
  constructor() {
    super(...arguments), this.features = [];
  }
  readFeatures(e5, t5) {
    var _a;
    const o9 = f2.fromJSON(t5.spatialReference), s6 = [];
    for (let a9 = 0; a9 < e5.length; a9++) {
      const t6 = e5[a9], p7 = s3.fromJSON(t6), c11 = (_a = t6.geometry) == null ? void 0 : _a.spatialReference;
      null == p7.geometry || c11 || (p7.geometry.spatialReference = o9);
      const i8 = t6.aggregateGeometries, m6 = p7.aggregateGeometries;
      if (i8 && null != m6)
        for (const e6 in m6) {
          const r8 = m6[e6], t7 = i8[e6], s7 = t7 == null ? void 0 : t7.spatialReference;
          null == r8 || s7 || (r8.spatialReference = o9);
        }
      s6.push(p7);
    }
    return s6;
  }
};
e([y({ type: [s3], json: { write: true } })], c6.prototype, "features", void 0), e([o("features")], c6.prototype, "readFeatures", null), c6 = e([c("esri.rest.support.AggregateFeatureSet")], c6);
var i4 = c6;

// node_modules/@arcgis/core/views/2d/layers/features/tileRenderers/BaseTileRenderer.js
var r4 = class extends g {
  constructor(e5) {
    super(e5), this.tiles = /* @__PURE__ */ new Map();
  }
  destroy() {
    this.tiles.clear(), this.layer = this.layerView = this.tileInfoView = this.tiles = null;
  }
  get updating() {
    return this.isUpdating();
  }
  acquireTile(e5) {
    const t5 = this.createTile(e5);
    return t5.once("isReady", () => this.notifyChange("updating")), this.tiles.set(e5.id, t5), this.notifyChange("updating"), t5;
  }
  forceAttributeTextureUpload() {
  }
  forEachTile(e5) {
    this.tiles.forEach(e5);
  }
  releaseTile(e5) {
    this.tiles.delete(e5.key.id), this.notifyChange("updating"), this.disposeTile(e5);
  }
  isUpdating() {
    let e5 = true;
    this.tiles.forEach((t6) => {
      e5 = e5 && t6.isReady;
    });
    const t5 = !e5;
    if (has("esri-2d-log-updating")) {
      let s6 = "";
      this.tiles.forEach((t6) => {
        const i8 = t6.updateStatus;
        s6 += `-> ${t6.key.id}: isReady: ${t6.isReady} status: ${i8}
`, e5 = e5 && t6.isReady;
      }), console.log(`Updating BaseTileRenderer ${t5}
${s6}`);
    }
    return t5;
  }
  setHighlight() {
  }
  invalidateLabels() {
  }
  requestUpdate() {
    this.layerView.requestUpdate();
  }
};
e([y()], r4.prototype, "layer", void 0), e([y()], r4.prototype, "layerView", void 0), e([y()], r4.prototype, "tileInfoView", void 0), e([y()], r4.prototype, "updating", null), r4 = e([c("esri.views.2d.layers.features.tileRenderers.BaseTileRenderer")], r4);
var o4 = r4;

// node_modules/@arcgis/core/views/2d/layers/features/tileRenderers/support/HeatmapSource.js
var i5 = class {
  constructor() {
    this.gradient = null, this.height = 512, this.intensities = null, this.width = 512;
  }
  render(i8) {
    l2(i8, 512, this.intensities, this.gradient, this.minDensity, this.maxDensity);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/tileRenderers/HeatmapTileRenderer.js
var o5 = class extends o4 {
  constructor(e5) {
    super(e5), this._intensityInfo = { minDensity: 0, maxDensity: 0 }, this.type = "heatmap", this.featuresView = { attributeView: { initialize: () => {
    }, requestUpdate: () => {
    } }, requestRender: () => {
    } }, this._container = new n7(e5.tileInfoView);
  }
  createTile(e5) {
    const t5 = this._container.createTile(e5);
    return this.tileInfoView.getTileCoords(t5.bitmap, e5), t5.bitmap.resolution = this.tileInfoView.getTileResolution(e5), t5;
  }
  onConfigUpdate() {
    const e5 = this.layer.renderer;
    if ("heatmap" === e5.type) {
      const { minDensity: t5, maxDensity: r8, colorStops: s6 } = e5;
      this._intensityInfo.minDensity = t5, this._intensityInfo.maxDensity = r8, this._gradient = u4(s6), this.tiles.forEach((e6) => {
        const i8 = e6.bitmap.source;
        i8 && (i8.minDensity = t5, i8.maxDensity = r8, i8.gradient = this._gradient, e6.bitmap.invalidateTexture(), e6.bitmap.requestRender());
      });
    }
  }
  hitTest() {
    return Promise.resolve([]);
  }
  install(e5) {
    e5.addChild(this._container);
  }
  uninstall(e5) {
    this._container.removeAllChildren(), e5.removeChild(this._container);
  }
  disposeTile(e5) {
    this._container.removeChild(e5), e5.destroy();
  }
  supportsRenderer(e5) {
    return e5 && "heatmap" === e5.type;
  }
  onTileData(e5) {
    const t5 = this.tiles.get(e5.tileKey);
    if (!t5)
      return;
    const i8 = e5.intensityInfo, { minDensity: r8, maxDensity: s6 } = this._intensityInfo, o9 = t5.bitmap.source || new i5();
    o9.intensities = (i8 == null ? void 0 : i8.matrix) || null, o9.minDensity = r8, o9.maxDensity = s6, o9.gradient = this._gradient, t5.bitmap.source = o9, this._container.addChild(t5), this._container.requestRender(), this.requestUpdate();
  }
  onTileError(e5) {
    console.error(e5);
  }
  lockGPUUploads() {
  }
  unlockGPUUploads() {
  }
  fetchResource(e5, t5) {
    return console.error(e5), Promise.reject();
  }
};
o5 = e([c("esri.views.2d.layers.features.tileRenderers.HeatmapTileRenderer")], o5);

// node_modules/@arcgis/core/views/2d/engine/webgl/collisions/MetricReader.js
var t2 = 6;
var s4 = 4294967296;
var e4 = class _e {
  constructor(t5) {
    this._savedCursor = null, this._savedOffset = null, this._head = t5, this._cursor = t5;
  }
  static from(t5) {
    const s6 = r5.from(new Float32Array(t5));
    return new _e(s6);
  }
  get id() {
    return this._cursor.id;
  }
  get baseZoom() {
    return this._cursor.baseZoom;
  }
  get anchorX() {
    return this._cursor.anchorX;
  }
  get anchorY() {
    return this._cursor.anchorY;
  }
  get directionX() {
    return this._cursor.directionX;
  }
  get directionY() {
    return this._cursor.directionY;
  }
  get size() {
    return this._cursor.size;
  }
  get materialKey() {
    return this._cursor.materialKey;
  }
  get boundsCount() {
    return this._cursor.boundsCount;
  }
  computedMinZoom() {
    return this._cursor.computedMinZoom();
  }
  setComputedMinZoom(t5) {
    return this._cursor.setComputedMinZoom(t5);
  }
  boundsComputedAnchorX(t5) {
    return this._cursor.boundsComputedAnchorX(t5);
  }
  boundsComputedAnchorY(t5) {
    return this._cursor.boundsComputedAnchorY(t5);
  }
  setBoundsComputedAnchorX(t5, s6) {
    return this._cursor.setBoundsComputedAnchorX(t5, s6);
  }
  setBoundsComputedAnchorY(t5, s6) {
    return this._cursor.setBoundsComputedAnchorY(t5, s6);
  }
  boundsX(t5) {
    return this._cursor.boundsX(t5);
  }
  boundsY(t5) {
    return this._cursor.boundsY(t5);
  }
  boundsWidth(t5) {
    return this._cursor.boundsWidth(t5);
  }
  boundsHeight(t5) {
    return this._cursor.boundsHeight(t5);
  }
  link(t5) {
    if (null != t5._head)
      return this._cursor.link(t5._head);
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    var _a;
    const t5 = new _e((_a = this._head) == null ? void 0 : _a.copy());
    if (!t5._head)
      return t5;
    let s6 = t5._head, r8 = t5._head._link;
    for (; r8; )
      s6._link = r8.copy(), s6 = r8, r8 = s6._link;
    return t5;
  }
  peekId() {
    return this._cursor.peekId() ?? this._cursor._link.peekId();
  }
  nextId() {
    const t5 = this.id;
    for (; t5 === this.id; )
      if (!this.next())
        return false;
    return true;
  }
  save() {
    this._savedCursor = this._cursor, this._savedOffset = this._cursor._offset;
  }
  restore() {
    this._savedCursor && (this._cursor = this._savedCursor), null != this._savedOffset && (this._cursor._offset = this._savedOffset);
  }
  next() {
    if (!this._cursor)
      return false;
    if (!this._cursor.next()) {
      if (!this._cursor._link)
        return false;
      this._cursor = this._cursor._link, this._cursor._offset = 0;
    }
    return true;
  }
  lookup(t5) {
    for (this._cursor = this._head; this._cursor && !this._cursor.lookup(t5); ) {
      if (!this._cursor._link)
        return false;
      this._cursor = this._cursor._link;
    }
    return !!this._cursor;
  }
  delete(t5) {
    let s6 = this._head, e5 = null;
    for (; s6; ) {
      if (s6.delete(t5))
        return s6.isEmpty() && null != e5 && (e5._link = s6._link), true;
      e5 = s6, s6 = s6._link;
    }
    return false;
  }
};
var r5 = class _r {
  constructor(t5) {
    this._offset = -1, this._link = null, this._count = 0, this._deletedCount = 0, this._offsets = { instance: null }, this._buffer = t5;
  }
  static from(t5) {
    return new _r(new Float32Array(t5));
  }
  isEmpty() {
    return this._deletedCount === this.count;
  }
  get count() {
    return this._count || (this._count = this._computeCount()), this._count;
  }
  get id() {
    return this._buffer[this._offset];
  }
  set id(t5) {
    this._buffer[this._offset] = t5;
  }
  get baseZoom() {
    return this._buffer[this._offset + 1];
  }
  get anchorX() {
    return this._buffer[this._offset + 2];
  }
  get anchorY() {
    return this._buffer[this._offset + 3];
  }
  get directionX() {
    return this._buffer[this._offset + 4];
  }
  get directionY() {
    return this._buffer[this._offset + 5];
  }
  get size() {
    return this._buffer[this._offset + 6];
  }
  get materialKey() {
    return this._buffer[this._offset + 7];
  }
  computedMinZoom() {
    return this._buffer[this._offset + 8];
  }
  setComputedMinZoom(t5) {
    this._buffer[this._offset + 8] = t5;
  }
  get boundsCount() {
    return this._buffer[this._offset + 9];
  }
  boundsComputedAnchorX(s6) {
    return this._buffer[this._offset + 10 + s6 * t2];
  }
  boundsComputedAnchorY(s6) {
    return this._buffer[this._offset + 10 + s6 * t2 + 1];
  }
  setBoundsComputedAnchorX(s6, e5) {
    this._buffer[this._offset + 10 + s6 * t2] = e5;
  }
  setBoundsComputedAnchorY(s6, e5) {
    this._buffer[this._offset + 10 + s6 * t2 + 1] = e5;
  }
  boundsX(s6) {
    return this._buffer[this._offset + 10 + s6 * t2 + 2];
  }
  boundsY(s6) {
    return this._buffer[this._offset + 10 + s6 * t2 + 3];
  }
  boundsWidth(s6) {
    return this._buffer[this._offset + 10 + s6 * t2 + 4];
  }
  boundsHeight(s6) {
    return this._buffer[this._offset + 10 + s6 * t2 + 5];
  }
  link(t5) {
    let s6 = this;
    for (; s6._link; )
      s6 = s6._link;
    s6._link = t5;
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const t5 = new _r(this._buffer);
    return t5._link = this._link, t5._offset = this._offset, t5._deletedCount = this._deletedCount, t5._offsets = this._offsets, t5._count = this._count, t5;
  }
  peekId() {
    const s6 = this._offset + 10 + this.boundsCount * t2 + 0;
    return s6 >= this._buffer.length ? 0 : this._buffer[s6];
  }
  next() {
    let e5 = 0;
    for (; this._offset < this._buffer.length && e5++ < 100 && (-1 === this._offset ? this._offset = 0 : this._offset += 10 + this.boundsCount * t2, this.id === s4); )
      ;
    return this.id !== s4 && this._offset < this._buffer.length;
  }
  delete(t5) {
    const s6 = this._offset, e5 = this.lookup(t5);
    if (e5)
      for (this.id = 4294967295, ++this._deletedCount; this.next() && this.id === t5; )
        this.id = 4294967295, ++this._deletedCount;
    return this._offset = s6, e5;
  }
  lookup(t5) {
    const e5 = this._offset;
    if (null == this._offsets.instance) {
      this._offsets.instance = /* @__PURE__ */ new Map();
      const t6 = this.copy();
      t6._offset = -1;
      let s6 = 0;
      for (; t6.next(); )
        t6.id !== s6 && (this._offsets.instance.set(t6.id, t6._offset), s6 = t6.id);
    }
    return !!this._offsets.instance.has(t5) && (this._offset = this._offsets.instance.get(t5), this.id !== s4 || (this._offset = e5, false));
  }
  _computeCount() {
    const t5 = this._offset;
    let s6 = 0;
    for (this._offset = -1; this.next(); )
      s6++;
    return this._offset = t5, s6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/Buffer.js
var h3 = 1.25;
var n8 = 32767;
var u6 = n8 << 16 | n8;
var a5 = class {
  constructor(t5, e5, r8, s6) {
    const h5 = r.create(e5 * r8 * Uint32Array.BYTES_PER_ELEMENT, s6);
    this.size = e5, this.strideInt = r8, this.bufferType = t5, this.dirty = { start: 1 / 0, end: 0 }, this._gpu = null, this._cpu = h5, this.clear();
  }
  get elementSize() {
    return this._cpu.length / this.strideInt;
  }
  get invalidated() {
    return this.bufferSize > 0 && !this._gpu;
  }
  get invalidatedComputeBuffer() {
    return this.bufferSize > 0 && !this._gpuComputeTriangles;
  }
  invalidate() {
    var _a2;
    this._invalidateTriangleBuffer(), (_a2 = this._gpu) == null ? void 0 : _a2.dispose(), this._gpu = null;
  }
  _invalidateTriangleBuffer() {
    var _a2;
    (_a2 = this._gpuComputeTriangles) == null ? void 0 : _a2.dispose(), this._gpuComputeTriangles = null;
  }
  destroy() {
    var _a2, _b, _c, _d;
    (_a2 = this._gpu) == null ? void 0 : _a2.dispose(), (_b = this._gpuComputeTriangles) == null ? void 0 : _b.dispose(), (_c = this._cpu) == null ? void 0 : _c.destroy(), (_d = this._cpu2) == null ? void 0 : _d.destroy();
  }
  clear() {
    this.dirty.start = 1 / 0, this.dirty.end = 0, this.freeList = new a3({ start: 0, end: this._cpu.length / this.strideInt }), this.fillPointer = 0;
  }
  ensure(t5) {
    if (this.maxAvailableSpace() >= t5)
      return;
    if (t5 * this.strideInt > this._cpu.length - this.fillPointer) {
      this.invalidate();
      const i8 = this._cpu.length / this.strideInt, e5 = Math.round((i8 + t5) * h3), r8 = e5 * this.strideInt;
      this._cpu.expand(r8 * Uint32Array.BYTES_PER_ELEMENT), this.freeList.free(i8, e5 - i8);
    }
  }
  set(t5, i8) {
    this._cpu.array[t5] !== i8 && (this._cpu.array[t5] = i8, this.dirty.start = Math.min(t5, this.dirty.start), this.dirty.end = Math.max(t5, this.dirty.end));
  }
  getGPUBuffer(t5, i8 = false) {
    if (!this.bufferSize)
      return null;
    if (i8) {
      if ("index" !== this.bufferType)
        throw new Error("Tired to get triangle buffer, but target is not an index buffer");
      return null == this._gpuComputeTriangles && (this._gpuComputeTriangles = this._createComputeBuffer(t5)), this._gpuComputeTriangles;
    }
    return null == this._gpu && (this._gpu = this._createBuffer(t5)), this._gpu;
  }
  getCPUBuffer() {
    if (!this._cpu2) {
      const t5 = this._cpu.slice();
      this._cpu2 = t5;
    }
    return this._cpu2.length !== this._cpu.length && this._cpu2.expand(this._cpu.length * this._cpu.array.BYTES_PER_ELEMENT), this._cpu2.set(this._cpu), this._cpu2;
  }
  get bufferSize() {
    return this._cpu.length / this.strideInt;
  }
  maxAvailableSpace() {
    return this.freeList.maxAvailableSpace();
  }
  insert(i8, e5, r8, s6) {
    const h5 = r8 * this.strideInt;
    if (!h5)
      return 0;
    const n11 = e5 * this.strideInt * Uint32Array.BYTES_PER_ELEMENT, u10 = new Uint32Array(i8, n11, h5), a9 = this.freeList.firstFit(r8);
    n(a9, "First fit region must be defined");
    const d8 = a9 * this.strideInt, f6 = h5, p7 = d8 / this.strideInt - e5;
    if (0 !== s6)
      for (let t5 = 0; t5 < u10.length; t5++)
        u10[t5] += s6;
    return this._cpu.array.set(u10, d8), this.dirty.start = Math.min(this.dirty.start, d8), this.dirty.end = Math.max(this.dirty.end, d8 + f6), this.fillPointer = Math.max(this.fillPointer, d8 + f6), p7;
  }
  free(t5, i8, e5) {
    const r8 = t5 * this.strideInt, s6 = (t5 + i8) * this.strideInt;
    if (true === e5)
      for (let h5 = t5; h5 !== t5 + i8; h5++)
        this._cpu.array[h5 * this.strideInt] = u6;
    this.dirty.start = Math.min(this.dirty.start, r8), this.dirty.end = Math.max(this.dirty.end, s6), this.freeList.free(t5, i8);
  }
  upload() {
    if (this.dirty.end) {
      if (this._invalidateTriangleBuffer(), null == this._gpu)
        return this.dirty.start = 1 / 0, void (this.dirty.end = 0);
      this._gpu.setSubData(this._cpu.array, this.dirty.start, this.dirty.start, this.dirty.end), this.dirty.start = 1 / 0, this.dirty.end = 0;
    }
  }
  _createBuffer(t5) {
    const i8 = F.DYNAMIC_DRAW;
    return "index" === this.bufferType ? h.createIndex(t5, i8, this._cpu.array) : h.createVertex(t5, i8, this._cpu.array);
  }
  _createComputeBuffer(t5) {
    const i8 = F.DYNAMIC_DRAW, e5 = new Uint32Array(this.fillPointer / 3);
    for (let r8 = 0; r8 < this.fillPointer; r8 += 3)
      e5[r8 / 3] = this._cpu.array[r8];
    return h.createIndex(t5, i8, e5);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/Geometry.js
var n9 = 0;
var f5 = 1;
var o6 = class {
  constructor(e5, t5) {
    this._vaos = /* @__PURE__ */ new Map(), this._indicesInvalid = false, this.geometryType = e5, this._stage = t5;
  }
  destroy() {
    for (const [e5, t5] of this._vaos)
      t5 == null ? void 0 : t5.disposeVAOOnly();
    this._indexBuffer = u(this._indexBuffer), this._vertexBuffer = u(this._vertexBuffer);
  }
  get records() {
    return this._records;
  }
  insert(e5, t5, i8) {
    if (!e5.records.byteLength)
      return;
    const n11 = e5.stride;
    if (this._vertexBuffer && this._indexBuffer) {
      const r8 = e5.indices.byteLength / 4, i9 = e5.vertices.byteLength / n11;
      this._indexBuffer.ensure(r8), this._vertexBuffer.ensure(i9);
      const { vertices: f6, indices: o9 } = e5, d8 = r2.from(e5.records), h5 = this._vertexBuffer.insert(f6, 0, f6.byteLength / n11, 0), u10 = this._indexBuffer.insert(o9, 0, o9.byteLength / 4, h5);
      if (d8.forEach((e6) => {
        e6.indexFrom += u10, e6.vertexFrom += h5;
      }), this._records.link(d8), t5)
        this._indicesInvalid = true;
      else if (this._displayList) {
        const e6 = d8.getCursor();
        for (; e6.next(); )
          this._displayList.addRecord(e6);
      }
    } else {
      const i9 = e5.indices.byteLength / 4, f6 = e5.vertices.byteLength / n11, o9 = n11 / Uint32Array.BYTES_PER_ELEMENT, d8 = this._stage.bufferPool;
      this._records = r2.from(e5.records), this._indexBuffer = new a5("index", i9, 1, d8), this._vertexBuffer = new a5("vertex", f6, o9, d8), this._indexBuffer.insert(e5.indices, 0, e5.indices.byteLength / 4, 0), this._vertexBuffer.insert(e5.vertices, 0, e5.vertices.byteLength / n11, 0), t5 && (this._indicesInvalid = true);
    }
  }
  remove(e5) {
    if (null != this._records)
      for (const t5 of e5) {
        const e6 = this._records.getCursor();
        if (!e6.lookup(t5))
          continue;
        const r8 = e6.indexFrom, s6 = e6.vertexFrom;
        let i8 = e6.indexCount, n11 = e6.vertexCount;
        for (; e6.next() && e6.id === t5; )
          i8 += e6.indexCount, n11 += e6.vertexCount;
        this._indexBuffer.free(r8, i8), this._vertexBuffer.free(s6, n11, true), this._records.delete(t5);
      }
  }
  getVAO(e5, t5, r8, s6) {
    if (!this._vertexBuffer || !this._indexBuffer || null == this._records || !this._vertexBuffer.bufferSize)
      return null;
    const o9 = s6 ? f5 : n9;
    let d8 = this._vaos.get(o9);
    (this._vertexBuffer.invalidated || this._indexBuffer.invalidated || s6 && this._indexBuffer.invalidatedComputeBuffer) && (d8 == null ? void 0 : d8.disposeVAOOnly(), d8 = null), this._vertexBuffer.upload(), this._indexBuffer.upload();
    const h5 = this._indexBuffer.getGPUBuffer(e5, 1 === o9), u10 = this._vertexBuffer.getGPUBuffer(e5);
    return d8 || (d8 = new f4(e5, r8, t5, { geometry: u10 }, h5), this._vaos.set(o9, d8)), d8;
  }
  forEachCommand(e5) {
    if (null != this._records) {
      if (this._sortIndices(this._records), !this._displayList) {
        const e6 = this._cursorIndexOrder;
        this._displayList = n5.from(this, this.geometryType, this._records.getCursor(), e6);
      }
      this._displayList.forEach(e5);
    }
  }
  _sortIndices(e5) {
    const t5 = !!this._indexBuffer.bufferSize;
    if (!this._indicesInvalid)
      return;
    this._indicesInvalid = false;
    let r8 = 0;
    const s6 = e5.getCursor(), i8 = [], n11 = [], f6 = [];
    for (; s6.next(); )
      n11.push(s6.index), f6.push(s6.sortKey), i8.push(s6.id);
    n11.sort((e6, t6) => {
      const r9 = f6[t6], s7 = f6[e6];
      return s7 === r9 ? i8[t6] - i8[e6] : r9 - s7;
    });
    const o9 = e5.getCursor(), d8 = t5 ? this._indexBuffer.getCPUBuffer() : this._vertexBuffer.getCPUBuffer();
    for (const h5 of n11) {
      if (!o9.seekIndex(h5))
        throw new Error("Expected to find index");
      if (t5) {
        const { indexFrom: e6, indexCount: t6 } = o9;
        o9.indexFrom = r8;
        for (let s7 = 0; s7 < t6; s7++)
          this._indexBuffer.set(r8++, d8.array[e6 + s7]);
      } else {
        const { vertexFrom: e6, vertexCount: t6 } = o9, s7 = this._vertexBuffer.strideInt, i9 = e6 * s7, n12 = i9 + t6 * s7;
        o9.vertexFrom = r8 / s7;
        for (let f7 = i9; f7 < n12; f7++)
          this._vertexBuffer.set(r8++, d8.array[f7]);
      }
    }
    this._cursorIndexOrder = n11, this._displayList = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/FeatureTile.js
var h4 = 50;
var d6 = 4;
var o7 = 100;
var u7 = 0;
var c7 = class extends m3 {
  constructor(r8, s6, i8, a9, n11, h5) {
    super(r8, s6, i8, a9), this.instanceId = u7++, this.patchCount = 0, this._renderState = { current: { geometry: /* @__PURE__ */ new Map(), metrics: null }, next: null, swap: false, swapFrames: 0, locked: false }, this._patches = new t(o7), this._bufferPatches = new t(o7), this._lastCommitTime = 0, this.transforms.labelMat2d = n2(), this._store = n11, this._requestLabelUpdate = h5;
  }
  destroy() {
    super.destroy(), this._renderState.current.geometry.forEach((e5) => e5.destroy()), null != this._renderState.next && this._renderState.next.geometry.forEach((e5) => e5.destroy()), this._renderState.current = null, this._renderState.next = null;
  }
  get labelMetrics() {
    return this._renderState.current.metrics;
  }
  get hasData() {
    return !!this._renderState.current.geometry.size;
  }
  get updateStatus() {
    return `renderState:${!!this._renderState.current}, ${!!this._renderState.next}, hasData:${this.hasData}, queue:${this._patches.size}`;
  }
  getGeometry(e5) {
    return this._renderState.current.geometry.get(e5);
  }
  patch(e5, t5) {
    this.patchCount++, e5.clear && this._patches.size >= h4 && this._dropPatches();
    const r8 = e5, s6 = r8.addOrUpdate && this.key.id !== r8.addOrUpdate.tileKeyOrigin;
    t5 && s6 ? this._bufferPatches.enqueue(r8) : (r8.sort = r8.sort && !t5, this._patches.enqueue(r8)), this.requestRender();
  }
  commit(e5) {
    if (this._lastCommitTime !== e5.time) {
      this._lastCommitTime = e5.time;
      for (let e6 = 0; e6 < d6; e6++)
        this._updateMesh(), this.isReady && this._updateBufferMesh();
      this._renderState.swap && (this._swapRenderStates(), this.requestRender());
    }
  }
  lock() {
    this._renderState.locked = true;
  }
  unlock() {
    this._renderState.locked = false, this._flushUpdates(), this._swap();
  }
  _swapRenderStates() {
    if (this._renderState.next) {
      if (this._renderState.locked)
        return this._renderState.swap = true, void this.requestRender();
      this._renderState.swap = true, this._swap();
    }
  }
  _swap() {
    this._renderState.swap && (this._renderState.swap = false, null != this._renderState.next && (this._renderState.current.geometry.forEach((e5) => e5.destroy()), this._renderState.current = this._renderState.next, this._renderState.next = null, this._requestLabelUpdate()));
  }
  _flushUpdates() {
    let e5 = this._patches.maxSize;
    for (; this._patches.size && e5--; )
      this._updateMesh(), this._swap();
  }
  _updateBufferMesh() {
    const e5 = this._bufferPatches.peek();
    if (null == e5 || !e5.clear || null === this._renderState.next)
      for (; this._bufferPatches.size; ) {
        const e6 = this._bufferPatches.dequeue();
        null != e6 && this._patchBuffer(e6);
      }
  }
  _updateMesh() {
    var _a, _b, _c2, _d;
    const e5 = this._patches.dequeue();
    if (null != e5) {
      if (has("esri-2d-update-debug")) {
        const t5 = e5, r8 = (_a = t5.addOrUpdate) == null ? void 0 : _a.tileKeyOrigin, s6 = this.key.id === r8 ? "SELF" : r8;
        let i8 = "";
        for (let e6 = 0; e6 < 5; e6++)
          i8 += ((_d = (_c2 = (_b = t5.addOrUpdate) == null ? void 0 : _b.data[e6]) == null ? void 0 : _c2.records) == null ? void 0 : _d.byteLength) ? 1 : 0;
        console.debug(this.key.id, "FeatureTile:patch", `[clear: ${t5.clear} origin: ${s6}, end:${t5.end} data:${i8}]`);
      }
      true === e5.clear && (null != this._renderState.next && (this._renderState.next.geometry.forEach((e6) => e6.destroy()), this._renderState.next = null), this._renderState.next = { geometry: /* @__PURE__ */ new Map(), metrics: null }, has("esri-2d-update-debug") && console.debug(this.key.id, "FeatureTile:_updateMesh - Creating new renderState")), this.requestRender(), this._patch(e5), e5.end && (has("esri-2d-update-debug") && console.debug(this.key.id, "FeatureTile:_updateMesh - Encountered end message"), this.ready(), this._swapRenderStates());
    }
  }
  _patch(e5) {
    te((t5) => {
      this._remove(t5, e5.remove), this._insert(t5, e5, false);
    });
  }
  _patchBuffer(e5) {
    te((t5) => {
      this._insert(t5, e5, true);
    });
  }
  _insert(e5, t5, s6) {
    var _a, _b;
    try {
      const i8 = this._renderState.next ?? this._renderState.current, a9 = (_a = t5.addOrUpdate) == null ? void 0 : _a.data[e5], h5 = i8.geometry;
      if (null == a9)
        return;
      h5.has(e5) || (has("esri-2d-update-debug") && console.debug(this.key.id, `FeatureTile:_insert - Creating geometry buffer ${e5}`), h5.set(e5, new o6(e5, this.stage))), has("esri-2d-update-debug") && console.debug(this.key.id, `FeatureTile:_insert - Inserting into ${e5}, version=${(_b = t5.addOrUpdate) == null ? void 0 : _b.version} stride=${a9.stride}`), h5.get(e5).insert(a9, t5.sort, s6), e5 === E.LABEL && this._insertLabelMetrics(t5.type, a9.metrics, t5.clear);
    } catch (i8) {
    }
  }
  _insertLabelMetrics(e5, t5, r8) {
    const s6 = this._renderState.next ?? this._renderState.current;
    if (null == t5)
      return;
    const i8 = e4.from(t5);
    if (null != s6.metrics) {
      if ("update" === e5) {
        const e6 = i8.getCursor();
        for (; e6.next(); )
          s6.metrics.delete(e6.id);
      }
      s6.metrics.link(i8);
    } else
      s6.metrics = i8;
  }
  _remove(e5, t5) {
    const r8 = (this._renderState.next ?? this._renderState.current).geometry.get(e5);
    t5 && t5.length && r8 && (r8.remove(t5), this._removeLabelMetrics(t5));
  }
  _removeLabelMetrics(e5) {
    const { metrics: t5 } = this._renderState.next ?? this._renderState.current;
    if (null != t5 && e5.length)
      for (const r8 of e5)
        for (; t5.delete(r8); )
          ;
  }
  _dropPatches() {
    const e5 = new Array();
    let t5 = false;
    for (; this._patches.size; ) {
      const r8 = this._patches.dequeue();
      if (null == r8)
        break;
      if (r8.clear) {
        if (t5)
          break;
        t5 = true;
      }
      e5.push(r8);
    }
    this._patches.clear(), e5.forEach((e6) => this._patches.enqueue(e6));
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/tileRenderers/support/WGLFeatureView.js
var r6 = has("featurelayer-order-by-server-enabled");
var a6 = class extends o3 {
  constructor(e5, t5, s6, i8) {
    super(e5), this._hitTestsRequests = [], this._layer = s6, this._layerView = t5, this._onUpdate = i8;
  }
  renderChildren(e5) {
    if (this.attributeView.update(), this.hasAnimation) {
      e5.painter.effects.integrate.draw(e5, e5.attributeView);
    }
    super.renderChildren(e5);
  }
  hasEmptyAttributeView() {
    return this.attributeView.isEmpty();
  }
  isUpdating() {
    return this.attributeView.isUpdating();
  }
  hitTest(t5) {
    let s6 = this._hitTestsRequests.find(({ x: e5, y: s7 }) => e5 === t5.x && s7 === t5.y);
    const i8 = C();
    return s6 ? s6.resolvers.push(i8) : (s6 = { x: t5.x, y: t5.y, resolvers: [i8] }, this._hitTestsRequests.push(s6)), this.requestRender(), i8.promise;
  }
  onTileData(e5, t5) {
    const s6 = r6 && "orderBy" in this._layer && this._layer.orderBy, i8 = s6 && (s6 == null ? void 0 : s6.length) && !s6[0].valueExpression && s6[0].field, a9 = !!s6 && this._layerView.orderByFields === i8;
    e5.patch(t5, a9), this.contains(e5) || this.addChild(e5), this.requestRender();
  }
  onTileError(e5) {
    this.contains(e5) || this.addChild(e5);
  }
  updateTransitionProperties(e5, t5) {
    super.updateTransitionProperties(e5, t5), this._layerView.featureEffectView.transitionStep(e5, t5), this._layerView.featureEffectView.transitioning && this.requestRender();
  }
  doRender(e5) {
    const { minScale: t5, maxScale: s6 } = this._layer.effectiveScaleRange, i8 = e5.state.scale;
    i8 <= (t5 || 1 / 0) && i8 >= s6 && super.doRender(e5);
  }
  afterRender(e5) {
    super.afterRender(e5), this._hitTestsRequests.length && this.requestRender();
  }
  onAttributeStoreUpdate() {
    this.hasLabels && this._layerView.view.labelManager.requestUpdate(), this._onUpdate();
  }
  get hasAnimation() {
    return this.hasLabels;
  }
  setStencilReference(e5) {
    const { rendererSchema: t5 } = e5.rendererInfo;
    if ("dot-density" === (t5 == null ? void 0 : t5.type) && (t5 == null ? void 0 : t5.dotSize) > 1 || "heatmap" === (t5 == null ? void 0 : t5.type)) {
      const e6 = 1;
      for (const t6 of this.children)
        t6.stencilRef = t6.key.level + e6;
    } else
      super.setStencilReference(e5);
  }
  get hasHighlight() {
    return this._layerView.hasHighlight();
  }
  get hasLabels() {
    var _a2;
    if ("sublayers" in this._layer)
      return this._layer.sublayers.some((e6) => {
        var _a3;
        return !!((_a3 = e6.labelingInfo) == null ? void 0 : _a3.length) && e6.labelsVisible;
      });
    const e5 = this._layer.featureReduction, t5 = e5 && "labelingInfo" in e5 && e5.labelsVisible && e5.labelingInfo && e5.labelingInfo.length;
    return ((_a2 = this._layer.labelingInfo) == null ? void 0 : _a2.length) && this._layer.labelsVisible || !!t5;
  }
  prepareRenderPasses(e5) {
    const s6 = super.prepareRenderPasses(e5), r8 = e5.registerRenderPass({ name: "label", brushes: [w3.label], target: () => this.hasLabels ? this.children : null, drawPhase: T.LABEL | T.LABEL_ALPHA });
    if (has("featurelayer-force-marker-text-draw-order")) {
      const i8 = e5.registerRenderPass({ name: "geometry", brushes: [w3.fill, w3.dotDensity, w3.line, w3.heatmap, w3.pieChart], target: () => this.children, forceDrawByDisplayOrder: true, enableDefaultDraw: () => !this._layerView.featureEffectView.hasEffects, effects: [{ apply: e5.effects.outsideEffect, enable: () => this._layerView.featureEffectView.hasEffects, args: () => this._layerView.featureEffectView.excludedEffects }, { apply: e5.effects.insideEffect, enable: () => this._layerView.featureEffectView.hasEffects, args: () => this._layerView.featureEffectView.includedEffects }, { apply: e5.effects.hittest, enable: () => !!this._hitTestsRequests.length, args: () => this._hitTestsRequests }] });
      s6.push(i8);
    } else {
      const i8 = e5.registerRenderPass({ name: "geometry", brushes: [w3.fill, w3.dotDensity, w3.line, w3.marker, w3.heatmap, w3.pieChart, w3.text], target: () => this.children, enableDefaultDraw: () => !this._layerView.featureEffectView.hasEffects, effects: [{ apply: e5.effects.outsideEffect, enable: () => this._layerView.featureEffectView.hasEffects, args: () => this._layerView.featureEffectView.excludedEffects }, { apply: e5.effects.insideEffect, enable: () => this._layerView.featureEffectView.hasEffects, args: () => this._layerView.featureEffectView.includedEffects }, { apply: e5.effects.hittest, enable: () => !!this._hitTestsRequests.length, args: () => this._hitTestsRequests }] });
      s6.push(i8);
    }
    const a9 = e5.registerRenderPass({ name: "highlight", brushes: [w3.fill, w3.dotDensity, w3.line, w3.marker, w3.pieChart, w3.text], target: () => this.children, drawPhase: T.HIGHLIGHT, enableDefaultDraw: () => false, effects: [{ apply: e5.effects.highlight, enable: () => !!this._layerView.hasHighlight() }] });
    return s6.push(a9), s6.push(r8), s6;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/tileRenderers/SymbolTileRenderer.js
var p4 = class extends o4 {
  constructor() {
    super(...arguments), this.type = "symbol";
  }
  install(e5) {
    const t5 = () => this.notifyChange("updating"), i8 = new a6(this.tileInfoView, this.layerView, this.layer, t5);
    this.featuresView = i8, e5.addChild(i8);
  }
  uninstall(e5) {
    e5.removeChild(this.featuresView), this.featuresView = u(this.featuresView);
  }
  fetchResource(e5, t5) {
    const { url: r8 } = e5, s6 = this.featuresView.stage;
    try {
      return s6.resourceManager.fetchResource(r8, { signal: t5.signal });
    } catch (a9) {
      return b(a9) ? Promise.resolve({ width: 0, height: 0 }) : Promise.reject(a9);
    }
  }
  isUpdating() {
    var _a;
    const e5 = super.isUpdating(), t5 = !this.featuresView || this.featuresView.isUpdating(), i8 = (_a = this.featuresView) == null ? void 0 : _a.hasEmptyAttributeView(), r8 = e5 || t5 || e5 && i8;
    return has("esri-2d-log-updating") && console.log(`Updating SymbolTileRenderer ${r8}
  -> updatingTiles ${e5}
  -> hasFeaturesView ${!!this.featuresView}
  -> updatingFeaturesView ${t5}`), r8;
  }
  hitTest(e5) {
    return this.featuresView.hitTest(e5);
  }
  supportsRenderer(e5) {
    return null != e5 && ["simple", "class-breaks", "unique-value", "dot-density", "dictionary", "heatmap", "pie-chart"].includes(e5.type);
  }
  onConfigUpdate(e5) {
    let t5 = null;
    if (e5 && "visualVariables" in e5) {
      const i8 = (n6(e5).visualVariables || []).map((e6) => {
        const t6 = e6.clone();
        return "normalizationField" in e6 && (t6.normalizationField = null), e6.valueExpression && "$view.scale" !== e6.valueExpression && (t6.valueExpression = null, t6.field = "nop"), t6;
      });
      t5 = c4(i8);
    }
    this.featuresView.setRendererInfo(e5, t5, this.layerView.featureEffect);
  }
  onTileData(e5) {
    const t5 = this.tiles.get(e5.tileKey);
    t5 && e5.data && this.featuresView.onTileData(t5, e5.data), this.layerView.view.labelManager.requestUpdate();
  }
  onTileError(e5) {
    const t5 = this.tiles.get(e5.tileKey);
    t5 && this.featuresView.onTileError(t5);
  }
  forceAttributeTextureUpload() {
    this.featuresView.attributeView.forceTextureUpload();
  }
  lockGPUUploads() {
    this.featuresView.attributeView.lockTextureUpload(), this.tiles.forEach((e5) => e5.lock());
  }
  unlockGPUUploads() {
    this.featuresView.attributeView.unlockTextureUpload(), this.tiles.forEach((e5) => e5.unlock());
  }
  async getMaterialItems(e5) {
    return this.featuresView.getMaterialItems(e5);
  }
  invalidateLabels() {
    this.featuresView.hasLabels && this.layerView.view.labelManager.requestUpdate();
  }
  createTile(e5) {
    const t5 = this.tileInfoView.getTileBounds(u2(), e5), i8 = () => this.layerView.view.labelManager.requestUpdate(), r8 = this.tileInfoView.getTileResolution(e5.level), o9 = this.featuresView.attributeView;
    return new c7(e5, r8, t5[0], t5[3], o9, i8);
  }
  disposeTile(e5) {
    this.featuresView.removeChild(e5), e5.destroy(), this.layerView.view.labelManager.requestUpdate();
  }
};
p4 = e([c("esri.views.2d.layers.features.tileRenderers.SymbolTileRenderer")], p4);

// node_modules/@arcgis/core/views/2d/layers/features/tileRenderers.js
function t3(t5, n11) {
  if (!t5)
    return null;
  switch (t5.type) {
    case "symbol":
      return new p4(n11);
    case "heatmap":
      return new o5(n11);
  }
}

// node_modules/@arcgis/core/views/2d/layers/support/FeatureCommandQueue.js
function i6(e5) {
  return e5.some((e6) => e6.globalId);
}
function n10(e5) {
  return e5.filter((e6) => !e6.error).map((e6) => e6.objectId ?? e6.globalId).filter((e6) => null != e6);
}
function d7(e5, t5) {
  const s6 = new Set(e5);
  for (const r8 of t5.values())
    s6.add(r8);
  return s6;
}
function a7(e5, t5) {
  const s6 = new Set(e5);
  for (const r8 of t5.values())
    s6.delete(r8);
  return s6;
}
var c8 = class extends g {
  constructor(e5) {
    super(e5), this._hasGlobalIds = false, this._notifyUpdating = () => {
      this.notifyChange("updating");
    };
  }
  normalizeCtorArgs(e5) {
    return this._queueProcessor = new _({ concurrency: 1, process: e5.process }), {};
  }
  destroy() {
    this.clear();
  }
  get updating() {
    return this._queueProcessor.length > 0;
  }
  clear() {
    this._queueProcessor.clear();
  }
  push(e5) {
    const t5 = this._queueProcessor, s6 = t5.last();
    switch (e5.type) {
      case "update":
      case "refresh":
        if ((s6 == null ? void 0 : s6.type) === e5.type)
          return;
        t5.push(e5).then(this._notifyUpdating, this._notifyUpdating);
        break;
      case "edit": {
        const r8 = "processed-edit" === (s6 == null ? void 0 : s6.type) ? s6 : null;
        r8 && t5.popLast();
        const o9 = this._mergeEdits(r8, e5);
        for (const e6 of o9)
          e6 && t5.push(e6).then(this._notifyUpdating, this._notifyUpdating);
        break;
      }
    }
    this.notifyChange("updating");
  }
  _mergeEdits(e5, t5) {
    const { addedFeatures: s6, deletedFeatures: r8, updatedFeatures: o9 } = t5.edits;
    if (this._hasGlobalIds = this._hasGlobalIds || i6(s6) || i6(o9) || i6(r8), this._hasGlobalIds) {
      return [e5, { type: "processed-edit", edits: { addOrModified: [...s6, ...o9], removed: r8 } }];
    }
    const c11 = new Set(n10((e5 == null ? void 0 : e5.edits.addOrModified) ?? [])), p7 = new Set(n10((e5 == null ? void 0 : e5.edits.removed) ?? [])), u10 = /* @__PURE__ */ new Set([...n10(s6), ...n10(o9)]), l7 = new Set(n10(r8));
    return [{ type: "processed-edit", edits: { addOrModified: Array.from(d7(a7(c11, l7), u10)).map((e6) => ({ objectId: e6 })), removed: Array.from(d7(a7(p7, u10), l7)).map((e6) => ({ objectId: e6 })) } }];
  }
};
e([y({ readOnly: true })], c8.prototype, "updating", null), e([y()], c8.prototype, "process", void 0), c8 = e([c("esri.views.2d.layers.support.FeatureCommandQueue")], c8);
var p5 = c8;

// node_modules/@arcgis/core/views/2d/layers/support/FeatureLayerProxy.js
function c9(e5) {
  return Array.isArray(e5);
}
var u8 = class extends m {
  constructor(e5) {
    super(e5), this._startupResolver = C(), this.isReady = false;
  }
  initialize() {
    this._controller = new AbortController(), this.addResolvingPromise(this._startWorker(this._controller.signal));
  }
  destroy() {
    this._controller.abort(), this._connection && this._connection.close();
  }
  set tileRenderer(e5) {
    this.client.tileRenderer = e5;
  }
  get closed() {
    return this._connection.closed;
  }
  async startup(e5, t5, r8, s6) {
    await this.when();
    const o9 = this._controller.signal, i8 = c9(r8.source) ? { transferList: r8.source, signal: o9 } : void 0, n11 = { service: r8, config: t5, tileInfo: e5.tileInfo.toJSON(), tiles: s6 };
    await this._connection.invoke("startup", n11, i8), this._startupResolver.resolve(), this._set("isReady", true);
  }
  async updateTiles(e5) {
    return await this._startupResolver.promise, d(this._connection.invoke("updateTiles", e5));
  }
  async update(e5) {
    const t5 = { config: e5 };
    return await this._startupResolver.promise, this._connection.invoke("update", t5);
  }
  async applyUpdate(e5) {
    return await this._startupResolver.promise, this._connection.invoke("applyUpdate", e5);
  }
  async setHighlight(e5) {
    return await this._startupResolver.promise, d(this._connection.invoke("controller.setHighlight", e5));
  }
  async stop() {
    if (await this._startupResolver.promise, !this.closed)
      return d(this._connection.invoke("stop"));
  }
  async refresh(e5) {
    return await this._startupResolver.promise, d(this._connection.invoke("controller.refresh", e5));
  }
  async querySummaryStatistics(e5, t5, r8) {
    return await this._startupResolver.promise, this._connection.invoke("controller.querySummaryStatistics", { query: e5.toJSON(), params: t5 }, r8);
  }
  async queryAggregateSummaryStatistics(e5, t5, r8) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryAggregateSummaryStatistics", { query: e5.toJSON(), params: t5 }, r8);
  }
  async queryUniqueValues(e5, t5, r8) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryUniqueValues", { query: e5.toJSON(), params: t5 }, r8);
  }
  async queryAggregateUniqueValues(e5, t5, r8) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryAggregateUniqueValues", { query: e5.toJSON(), params: t5 }, r8);
  }
  async queryClassBreaks(e5, t5, r8) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryClassBreaks", { query: e5.toJSON(), params: t5 }, r8);
  }
  async queryAggregateClassBreaks(e5, t5, r8) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryAggregateClassBreaks", { query: e5.toJSON(), params: t5 }, r8);
  }
  async queryHistogram(e5, t5, r8) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryHistogram", { query: e5.toJSON(), params: t5 }, r8);
  }
  async queryAggregateHistogram(e5, t5, r8) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryAggregateHistogram", { query: e5.toJSON(), params: t5 }, r8);
  }
  async queryFeatures(e5, t5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryFeatures", e5 == null ? void 0 : e5.toJSON(), t5);
  }
  async queryVisibleFeatures(e5, t5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryVisibleFeatures", e5 == null ? void 0 : e5.toJSON(), t5);
  }
  async queryObjectIds(e5, t5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryObjectIds", e5 == null ? void 0 : e5.toJSON(), t5);
  }
  async queryFeatureCount(e5, t5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryFeatureCount", e5 == null ? void 0 : e5.toJSON(), t5);
  }
  async queryExtent(e5, t5) {
    return this._connection.invoke("controller.queryExtent", e5.toJSON(), t5);
  }
  async queryLatestObservations(e5, t5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryLatestObservations", e5.toJSON(), t5);
  }
  async queryStatistics(e5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryStatistics", e5);
  }
  async queryAggregates(e5, t5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryAggregates", e5 == null ? void 0 : e5.toJSON(), t5);
  }
  async queryAggregateCount(e5, t5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryAggregateCount", e5 == null ? void 0 : e5.toJSON(), t5);
  }
  async queryAggregateIds(e5, t5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryAggregateIds", e5 == null ? void 0 : e5.toJSON(), t5);
  }
  async getObjectId(e5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.getObjectId", e5);
  }
  async getDisplayId(e5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.getDisplayId", e5);
  }
  async getFeatures(e5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.getFeatures", e5);
  }
  async getAggregates() {
    return await this._startupResolver.promise, this._connection.invoke("controller.getAggregates");
  }
  async getAggregateValueRanges() {
    return await this._startupResolver.promise, this._connection.invoke("controller.getAggregateValueRanges");
  }
  async mapValidDisplayIds(e5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.mapValidDisplayIds", e5);
  }
  async onEdits(e5) {
    return await this._startupResolver.promise, d(this._connection.invoke("controller.onEdits", e5));
  }
  async enableEvent(e5, t5) {
    return await this._startupResolver.promise, d(this._connection.invoke("controller.enableEvent", { name: e5, value: t5 }));
  }
  async pauseStream() {
    return await this._startupResolver.promise, d(this._connection.invoke("controller.pauseStream"));
  }
  async resumeStream() {
    return await this._startupResolver.promise, d(this._connection.invoke("controller.resumeStream"));
  }
  async sendMessageToSocket(e5) {
    return await this._startupResolver.promise, d(this._connection.invoke("controller.sendMessageToSocket", e5));
  }
  async sendMessageToClient(e5) {
    return await this._startupResolver.promise, d(this._connection.invoke("controller.sendMessageToClient", e5));
  }
  async updateCustomParameters(e5) {
    return await this._startupResolver.promise, d(this._connection.invoke("controller.updateCustomParameters", e5));
  }
  async _startWorker(e5) {
    try {
      this._connection = await p("Pipeline", { client: this.client, strategy: "dedicated", signal: e5 });
    } catch (t5) {
      f(t5);
    }
  }
};
e([y()], u8.prototype, "isReady", void 0), e([y({ constructOnly: true })], u8.prototype, "client", void 0), e([y()], u8.prototype, "tileRenderer", null), u8 = e([c("esri.views.2d.layers.support.FeatureLayerProxy")], u8);
var l4 = u8;

// node_modules/@arcgis/core/views/2d/layers/support/visualVariableSimpleUtils.js
var r7 = Math.PI;
function i7(e5, t5) {
  switch (t5.transformationType) {
    case i2.Additive:
      return s5(e5, t5);
    case i2.Constant:
      return o8(t5, e5);
    case i2.ClampedLinear:
      return u9(e5, t5);
    case i2.Proportional:
      return l5(e5, t5);
    case i2.Stops:
      return c10(e5, t5);
    case i2.RealWorldSize:
      return m5(e5, t5);
    case i2.Identity:
      return e5;
    case i2.Unknown:
      return null;
  }
}
function a8(e5, t5) {
  return "number" == typeof e5 ? e5 : i7(t5, e5);
}
function s5(e5, t5) {
  return e5 + (a8(t5.minSize, e5) || t5.minDataValue);
}
function o8(e5, t5) {
  const n11 = e5.stops;
  let r8 = (n11 == null ? void 0 : n11.length) && n11[0].size;
  return null == r8 && (r8 = e5.minSize), a8(r8, t5);
}
function u9(e5, t5) {
  const n11 = t5.minDataValue, r8 = t5.maxDataValue, i8 = (e5 - n11) / (r8 - n11), s6 = a8(t5.minSize, e5), o9 = a8(t5.maxSize, e5);
  return e5 <= n11 ? s6 : e5 >= r8 ? o9 : s6 + i8 * (o9 - s6);
}
function l5(t5, n11) {
  const r8 = t5 / n11.minDataValue, i8 = a8(n11.minSize, t5), s6 = a8(n11.maxSize, t5);
  let o9 = null;
  return o9 = r8 * i8, i(o9, i8, s6);
}
function c10(e5, t5) {
  const [n11, r8, i8] = p6(e5, t5.cache.ipData);
  if (n11 === r8)
    return a8(t5.stops[n11].size, e5);
  {
    const s6 = a8(t5.stops[n11].size, e5);
    return s6 + (a8(t5.stops[r8].size, e5) - s6) * i8;
  }
}
function m5(n11, i8) {
  const s6 = m2[i8.valueUnit], o9 = a8(i8.minSize, n11), u10 = a8(i8.maxSize, n11), { valueRepresentation: l7 } = i8;
  let c11 = null;
  return c11 = "area" === l7 ? 2 * Math.sqrt(n11 / r7) / s6 : "radius" === l7 || "distance" === l7 ? 2 * n11 / s6 : n11 / s6, i(c11, o9, u10);
}
function p6(e5, t5) {
  if (!t5)
    return;
  let n11 = 0, r8 = t5.length - 1;
  return t5.some((t6, i8) => e5 < t6 ? (r8 = i8, true) : (n11 = i8, false)), [n11, r8, (e5 - t5[n11]) / (t5[r8] - t5[n11])];
}

// node_modules/@arcgis/core/views/2d/tiling/TileManager.js
var t4 = 1e-6;
var l6 = class {
  constructor(e5) {
    this._tiles = /* @__PURE__ */ new Map(), this.buffer = 0, this.acquireTile = e5.acquireTile, this.releaseTile = e5.releaseTile, this.tileInfoView = e5.tileInfoView, this.buffer = e5.buffer;
  }
  destroy() {
  }
  clear() {
    this._tiles.forEach((e5) => this._releaseTile(e5));
  }
  tileKeys() {
    const e5 = [];
    return this._tiles.forEach((i8, t5) => e5.push(t5)), e5;
  }
  update(t5) {
    const l7 = this.tileInfoView.getTileCoverage(t5.state, this.buffer, true, "closest"), { spans: s6, lodInfo: r8 } = l7, { level: a9 } = r8, o9 = [], d8 = [], h5 = /* @__PURE__ */ new Set(), n11 = /* @__PURE__ */ new Set();
    for (const { row: e5, colFrom: c11, colTo: f6 } of s6)
      for (let t6 = c11; t6 <= f6; t6++) {
        const l8 = e3.getId(a9, e5, r8.normalizeCol(t6), r8.getWorldForColumn(t6)), s7 = this._getOrAcquireTile(o9, l8);
        h5.add(l8), s7.isReady ? s7.visible = true : n11.add(s7.key);
      }
    n11.forEach((e5) => this._addPlaceholders(h5, e5)), this._tiles.forEach((e5) => {
      h5.has(e5.key.id) || (d8.push(e5.key.id), this._releaseTile(e5));
    }), l3.pool.release(l7);
    return { hasMissingTiles: n11.size > 0, added: o9, removed: d8 };
  }
  _getOrAcquireTile(e5, t5) {
    if (!this._tiles.has(t5)) {
      const l7 = this.acquireTile(new e3(t5));
      e5.push(t5), this._tiles.set(t5, l7), l7.visible = false;
    }
    return this._tiles.get(t5);
  }
  _getTile(e5) {
    return this._tiles.get(e5);
  }
  _releaseTile(e5) {
    this._tiles.delete(e5.key.id), this.releaseTile(e5);
  }
  _addPlaceholders(e5, i8) {
    const l7 = this._addPlaceholderChildren(e5, i8);
    if (!(Math.abs(1 - l7) < t4)) {
      if (!this._addPlaceholderParent(e5, i8)) {
        this._getTile(i8.id).visible = true;
      }
    }
  }
  _addPlaceholderChildren(e5, i8) {
    let t5 = 0;
    return this._tiles.forEach((l7) => {
      t5 += this._addPlaceholderChild(e5, l7, i8);
    }), t5;
  }
  _addPlaceholderChild(e5, i8, t5) {
    if (i8.key.level <= t5.level || !i8.hasData || !t5.contains(i8.key))
      return 0;
    i8.visible = true, e5.add(i8.key.id);
    return 1 / (1 << 2 * (i8.key.level - t5.level));
  }
  _addPlaceholderParent(e5, i8) {
    let t5 = i8.getParentKey(), l7 = 0, s6 = null;
    for (; null != t5; ) {
      if (e5.has(t5.id))
        return true;
      const i9 = this._getTile(t5.id);
      if (i9 == null ? void 0 : i9.isReady) {
        for (const i10 of e5) {
          const e6 = this._getTile(i10);
          e6 && t5.contains(e6.key) && (e6.visible = false);
        }
        return i9.visible = true, e5.add(i9.key.id), true;
      }
      (i9 == null ? void 0 : i9.hasData) && i9.patchCount > l7 && (l7 = i9.patchCount, s6 = i9), t5 = t5.getParentKey();
    }
    return !!s6 && (s6.visible = true, e5.add(s6.key.id), true);
  }
};

// node_modules/@arcgis/core/views/layers/FeatureLayerView.js
var j2 = "esri.views.layers.FeatureLayerView";
var q = s.getLogger(j2);
var P2 = (r8) => {
  let P3 = class extends r8 {
    constructor(...e5) {
      super(...e5), this._updatingRequiredFieldsPromise = null, this.dataUpdating = false, this.filter = null, this.timeExtent = null, this.layer = null, this.requiredFields = [], this.view = null;
    }
    initialize() {
      this.addHandles([d2(() => {
        var _a;
        const e5 = this.layer;
        return [(_a = e5 == null ? void 0 : e5.elevationInfo) == null ? void 0 : _a.featureExpressionInfo, e5 && "displayField" in e5 ? e5.displayField : null, e5 && "timeInfo" in e5 && e5.timeInfo, e5 && "renderer" in e5 && e5.renderer, e5 && "labelingInfo" in e5 && e5.labelingInfo, e5 && "floorInfo" in e5 && e5.floorInfo, this.filter, this.featureEffect, this.timeExtent];
      }, () => this._handleRequiredFieldsChange(), A), v(() => {
        var _a;
        return (_a = this.view) == null ? void 0 : _a.floors;
      }, "change", () => this._handleRequiredFieldsChange()), v(() => {
        const e5 = this.layer;
        return e5 && "sublayers" in e5 ? e5.sublayers : null;
      }, "change", () => this._handleRequiredFieldsChange())]);
    }
    get availableFields() {
      const { layer: e5, layer: { fieldsIndex: t5 }, requiredFields: r9 } = this;
      return "outFields" in e5 && e5.outFields ? I(t5, [...x2(t5, e5.outFields), ...r9]) : I(t5, r9);
    }
    get featureEffect() {
      return this.layer && "featureEffect" in this.layer ? this.layer.featureEffect : null;
    }
    set featureEffect(e5) {
      this._override("featureEffect", e5);
    }
    get maximumNumberOfFeatures() {
      return 0;
    }
    set maximumNumberOfFeatures(e5) {
      q.error("#maximumNumberOfFeatures=", "Setting maximum number of features is not supported");
    }
    get maximumNumberOfFeaturesExceeded() {
      return false;
    }
    highlight(e5) {
      throw new Error("missing implementation");
    }
    createQuery() {
      const e5 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference }, t5 = null != this.filter ? this.filter.createQuery(e5) : new b2(e5);
      if ("feature" === this.layer.type) {
        const e6 = o2(this);
        null != e6 && (t5.where = t5.where ? `(${t5.where}) AND (${e6})` : e6);
      }
      return null != this.timeExtent && (t5.timeExtent = null != t5.timeExtent ? t5.timeExtent.intersection(this.timeExtent) : this.timeExtent.clone()), t5;
    }
    createAggregateQuery() {
      const e5 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference };
      return new b2(e5);
    }
    queryFeatures(e5, t5) {
      throw new Error("missing implementation");
    }
    queryObjectIds(e5, t5) {
      throw new Error("missing implementation");
    }
    queryFeatureCount(e5, t5) {
      throw new Error("missing implementation");
    }
    queryExtent(e5, t5) {
      throw new Error("missing implementation");
    }
    async fetchPopupFeatures(e5, t5) {
      const r9 = this.validateFetchPopupFeatures(t5);
      if (r9)
        throw r9;
      return this.fetchClientPopupFeatures(t5);
    }
    _loadArcadeModules(e5) {
      var _a;
      return ((_a = e5.expressionInfos) == null ? void 0 : _a.length) || Array.isArray(e5.content) && e5.content.some((e6) => "expression" === e6.type) ? i3() : Promise.resolve();
    }
    _handleRequiredFieldsChange() {
      const e5 = this._updateRequiredFields();
      this._set("_updatingRequiredFieldsPromise", e5), e5.then(() => {
        this._updatingRequiredFieldsPromise === e5 && this._set("_updatingRequiredFieldsPromise", null);
      });
    }
    async _updateRequiredFields() {
      if (!this.layer || !this.view)
        return;
      const e5 = "3d" === this.view.type, { layer: t5, layer: { fieldsIndex: r9, objectIdField: i8 } } = this, s6 = "renderer" in t5 && t5.renderer, o9 = "orderBy" in t5 && t5.orderBy, n11 = "featureReduction" in t5 ? t5.featureReduction : null, l7 = /* @__PURE__ */ new Set(), a9 = await Promise.allSettled([s6 ? s6.collectRequiredFields(l7, r9) : null, J(l7, t5), e5 ? v3(l7, t5) : null, null != this.filter ? M2(l7, t5, this.filter) : null, null != this.featureEffect ? M2(l7, t5, this.featureEffect.filter) : null, n11 ? L(l7, t5, n11) : null, o9 ? O(l7, t5, o9) : null]);
      if ("timeInfo" in t5 && t5.timeInfo && this.timeExtent && b4(l7, t5.fieldsIndex, [t5.timeInfo.startField, t5.timeInfo.endField]), "feature" === t5.type && (t5.floorInfo && b4(l7, t5.fieldsIndex, [t5.floorInfo.floorField]), e5 && null != t5.infoFor3D && (null == t5.globalIdField && q.error("globalIdField missing on 3DObjectFeatureLayer"), b4(l7, t5.fieldsIndex, [t5.globalIdField]))), "subtype-group" === t5.type) {
        w2(l7, r9, t5.subtypeField);
        const e6 = t5.sublayers.map((e7) => {
          var _a;
          return Promise.all([(_a = e7.renderer) == null ? void 0 : _a.collectRequiredFields(l7, r9), J(l7, e7)]);
        });
        await Promise.allSettled(e6);
      }
      for (const p7 of a9)
        "rejected" === p7.status && q.error(p7.reason);
      w2(l7, r9, i8), e5 && "displayField" in t5 && t5.displayField && w2(l7, r9, t5.displayField);
      const u10 = Array.from(l7).sort();
      this._set("requiredFields", u10);
    }
    validateFetchPopupFeatures(e5) {
      if (null == e5)
        return null;
      for (const r9 of e5.clientGraphics ?? []) {
        const i8 = r9.layer;
        if ("popupEnabled" in i8 && !i8.popupEnabled)
          return new s2("featurelayerview:fetchPopupFeatures", "Popups are disabled", { layer: i8 });
        if (r9.isAggregate) {
          const e6 = "featureReduction" in i8 ? i8.featureReduction : null;
          if (!(e6 && "popupTemplate" in e6 && e6.popupEnabled && e6.popupTemplate))
            return new s2("featurelayerview:fetchPopupFeatures", "Popups are disabled", { layer: i8 });
        } else if ("popupTemplate" in i8) {
          if (!p2(i8, e5))
            return new s2("featurelayerview:fetchPopupFeatures", "Layer does not define a popup template", { layer: i8 });
        }
      }
    }
    async fetchClientPopupFeatures(e5) {
      const t5 = null != e5 ? e5.clientGraphics : null;
      if (!t5 || 0 === t5.length)
        return [];
      const r9 = new Array(t5.length), i8 = /* @__PURE__ */ new Map(), s6 = await this.createPopupQuery(e5);
      for (let o9 = 0; o9 < t5.length; o9++) {
        const n11 = t5[o9];
        if (n11.isAggregate) {
          r9[o9] = n11;
          continue;
        }
        const l7 = n11.layer;
        if (!("popupEnabled" in l7))
          continue;
        const a9 = x2(this.layer.fieldsIndex, s6.outFields), u10 = p2(l7, e5);
        if (null == u10)
          continue;
        const p7 = await this._loadArcadeModules(u10);
        p7 && p7.arcadeUtils.hasGeometryOperations(u10) || !je(a9, n11) ? i8.set(n11.getObjectId(), { graphic: n11, index: o9 }) : r9[o9] = n11;
      }
      if ("stream" === this.layer.type || 0 === i8.size)
        return r9.filter(Boolean);
      s6.objectIds = Array.from(i8.keys());
      try {
        const e6 = await this.layer.queryFeatures(s6);
        for (const t6 of e6.features) {
          const { graphic: { geometry: e7 }, index: s7 } = i8.get(t6.getObjectId());
          t6.geometry || (t6.geometry = e7), r9[s7] = t6;
        }
      } catch {
      }
      return r9.filter(Boolean);
    }
    async createPopupQuery(e5) {
      const t5 = this.layer.createQuery(), r9 = /* @__PURE__ */ new Set();
      let i8 = false;
      const s6 = (e5 == null ? void 0 : e5.clientGraphics) ? e5.clientGraphics.map((e6) => e6.layer) : [this.layer];
      for (const o9 of s6) {
        if (!("popupEnabled" in o9))
          continue;
        const t6 = p2(o9, e5);
        if (null == t6)
          continue;
        const s7 = await this._loadArcadeModules(t6), n11 = s7 && s7.arcadeUtils.hasGeometryOperations(t6);
        i8 = !("point" !== this.layer.geometryType && !n11);
        const l7 = await n3(this.layer, t6);
        for (const e6 of l7)
          r9.add(e6);
      }
      if (t5.returnGeometry = i8, t5.returnZ = i8, t5.returnM = i8, t5.outFields = Array.from(r9), t5.outSpatialReference = this.view.spatialReference, "feature" === this.layer.type) {
        const e6 = o2(this);
        null != e6 && (t5.where = t5.where ? `(${t5.where}) AND (${e6})` : e6);
      }
      return t5;
    }
    canResume() {
      return !!super.canResume() && (null == this.timeExtent || !this.timeExtent.isEmpty);
    }
  };
  return e([y()], P3.prototype, "_updatingRequiredFieldsPromise", void 0), e([y({ readOnly: true })], P3.prototype, "availableFields", null), e([y({ readOnly: true })], P3.prototype, "dataUpdating", void 0), e([y({ type: w })], P3.prototype, "featureEffect", null), e([y({ type: d4 })], P3.prototype, "filter", void 0), e([y(j)], P3.prototype, "timeExtent", void 0), e([y()], P3.prototype, "layer", void 0), e([y({ type: Number })], P3.prototype, "maximumNumberOfFeatures", null), e([y({ readOnly: true, type: Boolean })], P3.prototype, "maximumNumberOfFeaturesExceeded", null), e([y({ readOnly: true })], P3.prototype, "requiredFields", void 0), e([y()], P3.prototype, "suspended", void 0), e([y()], P3.prototype, "view", void 0), P3 = e([c(j2)], P3), P3;
};

// node_modules/@arcgis/core/views/2d/layers/FeatureLayerView2D.js
function D(e5) {
  return e5 && "openPorts" in e5;
}
function M3(e5) {
  for (const t5 of e5) {
    const e6 = "featureReduction" in t5 && t5.featureReduction && "labelingInfo" in t5.featureReduction ? t5.featureReduction : void 0, r8 = [...t5.labelingInfo || [], ...(e6 == null ? void 0 : e6.labelingInfo) || []];
    if (!t5.labelsVisible || !r8.length)
      continue;
    if (r8.some((e7) => "none" === e7.deconflictionStrategy))
      return true;
  }
  return false;
}
function G(e5) {
  return (t5) => u3(i7(t5, e5));
}
function B(e5) {
  const t5 = null != e5 && "visualVariables" in e5 && e5.visualVariables;
  if (!t5)
    return null;
  for (const r8 of t5)
    if ("size" === r8.type)
      return G(r8);
  return null;
}
var $ = "esri.views.2d.layers.FeatureLayerView2D";
function K(e5) {
  switch (e5.geometryType) {
    case "point":
      return "esriGeometryPoint";
    case "polyline":
      return "esriGeometryPolyline";
    case "polygon":
    case "multipatch":
      return "esriGeometryPolygon";
    case "multipoint":
      return "esriGeometryMultipoint";
    default:
      return s.getLogger($).error(new s2("unsupported-geometry-type", `Geometry type of ${e5.geometryType} is not supported`)), null;
  }
}
var Z = class extends P2(a4(m4(u5))) {
  constructor() {
    super(...arguments), this._pipelineIsUpdating = true, this._commandsQueue = new p5({ process: (e5) => {
      switch (e5.type) {
        case "processed-edit":
          return this._doEdit(e5);
        case "refresh":
          return this._doRefresh(e5.dataChanged);
        case "update":
          return this._doUpdate();
      }
    } }), this._visibilityOverrides = /* @__PURE__ */ new Set(), this._highlightIds = /* @__PURE__ */ new Map(), this._updateHighlight = k2(async () => this._proxy.setHighlight(Array.from(this._highlightIds.keys()))), this._uploadsLocked = false, this._needsClusterSizeUpdate = false, this.featureEffectView = new r3(), this._lastDefinitionExpression = null;
  }
  destroy() {
    var _a, _b;
    (_a = this._updateClusterSizeTask) == null ? void 0 : _a.remove(), (_b = this._proxy) == null ? void 0 : _b.destroy(), this._commandsQueue.destroy();
  }
  initialize() {
    this.addResolvingPromise(Promise.all([this._initProxy(), this._initServiceOptions()])), this.addHandles([this.on("valueRangesChanged", (e5) => {
      this._set("_aggregateValueRanges", e5.valueRanges);
    }), d2(() => this.featureEffect, (e5) => {
      this.featureEffectView.featureEffect = e5;
    }, A)], "constructor"), this.featureEffectView.endTransitions();
  }
  async _initProxy() {
    var _a;
    const e5 = this.layer;
    if ("isTable" in e5 && e5.isTable)
      throw new s2("featurelayerview:table-not-supported", "table feature layer can't be displayed", { layer: this.layer });
    if (("feature" === e5.type || "subtype-group" === e5.type) && !((_a = x(e5)) == null ? void 0 : _a.operations.supportsQuery))
      throw new s2("featurelayerview:query-not-supported", "layer view requires a layer with query capability", { layer: e5 });
    this._proxy && this._proxy.destroy();
    const t5 = this._createClientOptions();
    return this._set("_proxy", new l4({ client: t5 })), this._proxy.when();
  }
  async _initServiceOptions() {
    return this._set("_serviceOptions", await this._createServiceOptions()), this._serviceOptions;
  }
  get _effectiveFeatureReduction() {
    if (!("featureReduction" in this.layer))
      return null;
    const e5 = this.layer.featureReduction;
    return e5 && (!("maxScale" in e5) || !e5.maxScale || e5.maxScale < this.view.scale) ? e5 : null;
  }
  get orderByFields() {
    var _a, _b;
    return "stream" !== ((_a = this._serviceOptions) == null ? void 0 : _a.type) ? (_b = this._serviceOptions) == null ? void 0 : _b.orderByFields : void 0;
  }
  get labelsVisible() {
    const e5 = "subtype-group" === this.layer.type ? this.layer.sublayers.items : [this.layer];
    return !this.suspended && e5.some((e6) => e6.labelingInfo && e6.labelsVisible);
  }
  get labelingCollisionInfos() {
    const { tileRenderer: e5, layer: t5 } = this;
    if (null == e5)
      return null;
    const r8 = "subtype-group" === this.layer.type ? this.layer.sublayers.items : [this.layer], i8 = t5.geometryType, s6 = !M3(r8), a9 = {};
    if ("subtype-group" !== t5.type) {
      if ("heatmap" === (e5 == null ? void 0 : e5.type))
        return null;
      const r9 = B(t5.renderer);
      a9[0] = r9;
    }
    return [{ tileRenderer: e5, vvEvaluators: a9, deconflictionEnabled: s6, geometryType: i8, visible: !this.suspended }];
  }
  get queryMode() {
    var _a;
    return (_a = this._serviceOptions) == null ? void 0 : _a.type;
  }
  get renderingConfigHash() {
    var _a, _b;
    if (!this.layer)
      return null;
    const e5 = this.availableFields, t5 = this.layer, r8 = this.view.floors, { definitionExpression: i8 } = t5, s6 = "subtype-group" !== this.layer.type && this.layer.labelsVisible && this.layer.labelingInfo, a9 = "renderer" in t5 && t5.renderer, n11 = "gdbVersion" in t5 ? t5.gdbVersion : void 0, o9 = "historicMoment" in t5 ? (_a = t5.historicMoment) == null ? void 0 : _a.getTime() : void 0, { timeExtent: l7 } = this, u10 = "customParameters" in t5 ? JSON.stringify(t5.customParameters) : void 0, d8 = "apiKey" in t5 ? t5.apiKey : void 0, h5 = "stream" === t5.type ? `${JSON.stringify(t5.geometryDefinition)}${t5.definitionExpression}` : null, p7 = JSON.stringify(this.clips), c11 = (_b = this._effectiveFeatureReduction) == null ? void 0 : _b.toJSON(), y2 = "orderBy" in this.layer && JSON.stringify(this.layer.orderBy), g2 = "sublayers" in this.layer && this.layer.sublayers.items.reduce((e6, t6) => e6 + `${t6.visible ? 1 : 0}.${JSON.stringify(t6.renderer)}.${t6.labelsVisible}
.${JSON.stringify(t6.labelingInfo)}`, ""), f6 = "subtypeCode" in this.layer && this.layer.subtypeCode;
    return JSON.stringify({ orderBy: y2, sublayerHash: g2, subtypeCode: f6, filterHash: null != this.filter && this.filter.toJSON(), effectHash: null != this.featureEffect && this.featureEffect.toJSON(), streamFilter: h5, gdbVersion: n11, definitionExpression: i8, historicMoment: o9, availableFields: e5, renderer: a9, labelingInfo: s6, timeExtent: l7, floors: r8, clipsHash: p7, featureReduction: c11, customParameters: u10, apiKey: d8, timeZone: this.view.timeZone });
  }
  highlight(e5) {
    let t5;
    e5 instanceof c2 ? t5 = [e5.getObjectId()] : "number" == typeof e5 || "string" == typeof e5 ? t5 = [e5] : V.isCollection(e5) && e5.length > 0 ? t5 = e5.map((e6) => e6 == null ? void 0 : e6.getObjectId()).toArray() : Array.isArray(e5) && e5.length > 0 && (t5 = "number" == typeof e5[0] || "string" == typeof e5[0] ? e5 : e5.map((e6) => e6 == null ? void 0 : e6.getObjectId()));
    const a9 = t5 == null ? void 0 : t5.filter(k);
    return (a9 == null ? void 0 : a9.length) ? (this._addHighlight(a9), e2(() => this._removeHighlight(a9))) : e2();
  }
  hasHighlight() {
    return !!this._highlightIds.size;
  }
  async hitTest(e5, i8) {
    if (!this.tileRenderer)
      return null;
    const s6 = await this.tileRenderer.hitTest(i8);
    if (0 === s6.length)
      return null;
    has("featurelayer-force-marker-text-draw-order") && s6.sort((e6, t5) => e6 - t5);
    const { features: a9, aggregates: n11 } = await this._proxy.getFeatures(s6);
    return [...n11.map((r8) => this._createGraphicHit(e5, s3.fromJSON(r8))), ...a9.map((t5) => this._createGraphicHit(e5, c2.fromJSON(t5)))];
  }
  queryStatistics() {
    return this._proxy.queryStatistics();
  }
  async querySummaryStatistics(e5, t5, r8) {
    const i8 = { ...t5, scale: this.view.scale };
    return this._proxy.querySummaryStatistics(this._cleanUpQuery(e5), i8, r8);
  }
  async queryAggregateSummaryStatistics(e5, t5, r8) {
    const i8 = { ...t5, scale: this.view.scale };
    return this._proxy.queryAggregateSummaryStatistics(this._cleanUpAggregateQuery(e5), i8, r8);
  }
  async queryUniqueValues(e5, t5, r8) {
    const i8 = { ...t5, scale: this.view.scale };
    return this._proxy.queryUniqueValues(this._cleanUpQuery(e5), i8, r8);
  }
  async queryAggregateUniqueValues(e5, t5, r8) {
    const i8 = { ...t5, scale: this.view.scale };
    return this._proxy.queryAggregateUniqueValues(this._cleanUpAggregateQuery(e5), i8, r8);
  }
  async queryClassBreaks(e5, t5, r8) {
    const i8 = { ...t5, scale: this.view.scale };
    return this._proxy.queryClassBreaks(this._cleanUpQuery(e5), i8, r8);
  }
  async queryAggregateClassBreaks(e5, t5, r8) {
    const i8 = { ...t5, scale: this.view.scale };
    return this._proxy.queryAggregateClassBreaks(this._cleanUpAggregateQuery(e5), i8, r8);
  }
  async queryHistogram(e5, t5, r8) {
    const i8 = { ...t5, scale: this.view.scale };
    return this._proxy.queryHistogram(this._cleanUpQuery(e5), i8, r8);
  }
  async queryAggregateHistogram(e5, t5, r8) {
    const i8 = { ...t5, scale: this.view.scale };
    return this._proxy.queryAggregateHistogram(this._cleanUpAggregateQuery(e5), i8, r8);
  }
  queryFeatures(e5, t5) {
    return this.queryFeaturesJSON(e5, t5).then((e6) => {
      const t6 = d3.fromJSON(e6);
      return t6.features.forEach((e7) => this._setLayersForFeature(e7)), t6;
    });
  }
  queryVisibleFeatures(e5, t5) {
    return this._proxy.queryVisibleFeatures(this._cleanUpQuery(e5), t5).then((e6) => {
      const t6 = d3.fromJSON(e6);
      return t6.features.forEach((e7) => this._setLayersForFeature(e7)), t6;
    });
  }
  async queryAggregates(e5, t5) {
    const r8 = await this._proxy.queryAggregates(this._cleanUpAggregateQuery(e5), t5), i8 = i4.fromJSON(r8);
    return i8.features.forEach((e6) => this._setLayersForFeature(e6)), i8;
  }
  queryAggregateIds(e5, t5) {
    return this._proxy.queryAggregateIds(this._cleanUpAggregateQuery(e5), t5);
  }
  queryAggregateCount(e5, t5) {
    return this._proxy.queryAggregateCount(this._cleanUpAggregateQuery(e5), t5);
  }
  queryAggregateJSON(e5, t5) {
    return this._proxy.queryAggregates(this._cleanUpAggregateQuery(e5), t5);
  }
  queryFeaturesJSON(e5, t5) {
    return this._proxy.queryFeatures(this._cleanUpQuery(e5), t5);
  }
  queryObjectIds(e5, t5) {
    return this._proxy.queryObjectIds(this._cleanUpQuery(e5), t5);
  }
  queryFeatureCount(e5, t5) {
    return this._proxy.queryFeatureCount(this._cleanUpQuery(e5), t5);
  }
  queryExtent(e5, t5) {
    return this._proxy.queryExtent(this._cleanUpQuery(e5), t5).then((e6) => ({ count: e6.count, extent: M.fromJSON(e6.extent) }));
  }
  setVisibility(e5, t5) {
    t5 ? this._visibilityOverrides.delete(e5) : this._visibilityOverrides.add(e5), this._update();
  }
  update(e5) {
    if (!this._tileStrategy || !this.tileRenderer)
      return;
    const { hasMissingTiles: t5, added: r8, removed: i8 } = this._tileStrategy.update(e5);
    (r8.length || i8.length) && this._proxy.updateTiles({ added: r8, removed: i8 }), t5 && this.requestUpdate(), this.notifyChange("updating");
  }
  attach() {
    this.view.timeline.record(`${this.layer.title} (FeatureLayer) Attach`), this._tileStrategy = new l6({ acquireTile: (e5) => this._acquireTile(e5), releaseTile: (e5) => this._releaseTile(e5), tileInfoView: this.view.featuresTilingScheme, buffer: 0 }), this.addAttachHandles(d2(() => this.renderingConfigHash, () => this._update(), P)), "stream" !== this.layer.type && this.addAttachHandles(this.layer.on("edits", (e5) => this._edit(e5)));
  }
  detach() {
    var _a, _b;
    this._commandsQueue.clear(), (_a = this._proxy) == null ? void 0 : _a.stop(), this.container.removeAllChildren(), (_b = this.tileRenderer) == null ? void 0 : _b.uninstall(this.container), this.tileRenderer = null, this._tileStrategy = u(this._tileStrategy), this._tileRendererHash = null;
  }
  moveStart() {
    this.requestUpdate();
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this.requestUpdate();
  }
  isUpdating() {
    var _a;
    const e5 = "renderer" in this.layer && null != this.layer.renderer, t5 = this._commandsQueue.updating, r8 = null != this._updatingRequiredFieldsPromise, i8 = !this._proxy || !this._proxy.isReady, s6 = this._pipelineIsUpdating, a9 = null == this.tileRenderer || ((_a = this.tileRenderer) == null ? void 0 : _a.updating), n11 = e5 && (t5 || r8 || i8 || s6 || this.dataUpdating || a9);
    return has("esri-2d-log-updating") && console.log(`Updating FLV2D (${this.layer.id}): ${n11}
  -> hasRenderer ${e5}
  -> hasPendingCommand ${t5}
  -> updatingRequiredFields ${r8}
  -> updatingProxy ${i8}
  -> updatingPipeline ${s6}
  -> updatingData: ${this.dataUpdating}
  -> updatingTileRenderer ${a9}
`), n11;
  }
  _createClientOptions() {
    return { setUpdating: (e5) => {
      this._set("_pipelineIsUpdating", e5);
    }, setDataUpdating: (e5) => {
      this._set("dataUpdating", e5);
    }, emitEvent: (e5) => {
      this.emit(e5.name, e5.event);
    } };
  }
  async _detectQueryMode(e5) {
    var _a;
    const t5 = "path" in e5, { layer: r8 } = this, i8 = "editingInfo" in r8 && ((_a = r8.editingInfo) == null ? void 0 : _a.lastEditDate), s6 = "refreshInterval" in r8 && !!r8.refreshInterval, a9 = !i8 && s6, n11 = x(r8);
    if (t5 && ("feature" === r8.type || "subtype-group" === r8.type) && "point" === r8.geometryType && (n11 == null ? void 0 : n11.query.supportsPagination) && !(n11 == null ? void 0 : n11.operations.supportsEditing) && !a9 && has("featurelayer-snapshot-enabled"))
      try {
        const e6 = await r8.queryFeatureCount();
        if (e6 <= has("featurelayer-snapshot-point-min-threshold"))
          return { mode: "snapshot", featureCount: e6 };
        const t6 = has("featurelayer-snapshot-point-max-threshold"), i9 = has("featurelayer-snapshot-point-coverage"), s7 = this.view.extent, a10 = r8.fullExtent, n12 = a10 == null ? void 0 : a10.clone().intersection(s7), o9 = null != n12 ? n12.width * n12.height : 0, l7 = (a10 == null ? void 0 : a10.width) * (a10 == null ? void 0 : a10.height);
        if (e6 <= t6 && (0 === l7 ? 0 : o9 / l7) >= i9)
          return { mode: "snapshot", featureCount: e6 };
      } catch (o9) {
        s.getLogger(this).warn("mapview-feature-layer", "Encountered an error when querying for featureCount", { error: o9 });
      }
    return { mode: "on-demand" };
  }
  async _createServiceOptions() {
    var _a, _b;
    const e5 = this.layer;
    if ("stream" === e5.type)
      return null;
    const t5 = x(e5), { capabilities: r8, objectIdField: i8 } = e5, s6 = e5.fieldsIndex.toJSON(), a9 = s6.fields, n11 = null != e5.fullExtent ? e5.fullExtent.toJSON() : null, l7 = K(e5), u10 = "timeInfo" in e5 && ((_a = e5.timeInfo) == null ? void 0 : _a.toJSON()) || null, d8 = e5.spatialReference ? e5.spatialReference.toJSON() : null, h5 = "feature" === e5.type ? e5.globalIdField : null;
    let p7;
    "ogc-feature" === e5.type ? p7 = e5.source.getSource() : D(e5.source) ? p7 = await e5.source.openPorts() : e5.parsedUrl && (p7 = a(e5.parsedUrl), "dynamicDataSource" in e5 && e5.dynamicDataSource && (p7.query = { layer: JSON.stringify({ source: e5.dynamicDataSource }) }));
    const c11 = "datesInUnknownTimezone" in this.layer && this.layer.datesInUnknownTimezone, y2 = ("subtypeField" in this.layer ? this.layer.subtypeField : null) ?? null, { mode: g2, featureCount: f6 } = await this._detectQueryMode(p7);
    let m6 = this.layer.objectIdField;
    if ("feature" === this.layer.type && null != this.layer.orderBy && this.layer.orderBy.length) {
      const e6 = !this.layer.orderBy[0].valueExpression && this.layer.orderBy[0].field;
      e6 && (m6 = e6);
    }
    return { type: g2, typeIdField: "typeIdField" in e5 && e5.typeIdField || void 0, types: "types" in e5 && ((_b = e5.types) == null ? void 0 : _b.map((e6) => e6.toJSON())) || void 0, timeReferenceUnknownClient: c11, subtypeField: y2, featureCount: f6, globalIdField: h5, maxRecordCount: r8.query.maxRecordCount, tileMaxRecordCount: r8.query.tileMaxRecordCount, capabilities: r8, effectiveCapabilities: t5, fields: a9, fieldsIndex: s6, fullExtent: n11, geometryType: l7, objectIdField: i8, source: p7, timeInfo: u10, spatialReference: d8, orderByFields: m6 };
  }
  async _createMemoryServiceOptions(e5) {
    const t5 = await e5.openPorts();
    return { ...this._createServiceOptions(), type: "memory", source: t5 };
  }
  _cleanUpQuery(e5) {
    const t5 = b2.from(e5) || this.createQuery();
    return t5.outSpatialReference || (t5.outSpatialReference = this.view.spatialReference), t5;
  }
  _cleanUpAggregateQuery(e5) {
    const t5 = b2.from(e5) || this.createAggregateQuery();
    return t5.outSpatialReference || (t5.outSpatialReference = this.view.spatialReference), t5;
  }
  async _update() {
    return this._commandsQueue.push({ type: "update" });
  }
  async _edit(e5) {
    if (this.suspended)
      return void this._clearTiles();
    return this._validateEdit(e5) ? this._commandsQueue.push({ type: "edit", edits: e5 }) : void 0;
  }
  async doRefresh(e5) {
    if (this.attached && this._tileStrategy.tileKeys().length)
      return this.suspended && e5 ? void this._clearTiles() : this._commandsQueue.push({ type: "refresh", dataChanged: e5 });
  }
  _clearTiles() {
    this._tileStrategy.tileKeys().length && (this._proxy.updateTiles({ added: [], removed: this._tileStrategy.tileKeys() }), this._tileStrategy.clear(), this.requestUpdate(), this._commandsQueue.clear(), this._update());
  }
  _validateEdit(e5) {
    const t5 = "globalIdField" in this.layer && this.layer.globalIdField, r8 = e5.deletedFeatures.some((e6) => -1 === e6.objectId || !e6.objectId), i8 = t5 && this.availableFields.includes(t5);
    return r8 && !i8 ? (s.getLogger(this).error(new s2("mapview-apply-edits", `Editing the specified service requires the layer's globalIdField, ${t5} to be included the layer's outFields for updates to be reflected on the map`)), null) : e5;
  }
  async _doUpdate() {
    var _a, _b;
    try {
      if (this.destroyed || !this._hasRequiredSupport(this.layer) || !this._tileStrategy)
        return;
      const { featureEffectView: t5, filter: r8 } = this;
      if (await this._updateRequiredFields(), this.destroyed)
        return;
      const { renderer: i8 } = this._getEffectiveRenderer();
      this._set("_effectiveRenderer", i8);
      const s6 = this._createSchemaConfig(), a9 = this._createConfiguration(s6, r8, t5.filter), n11 = this._lastDefinitionExpression !== a9.schema.source.definitionExpression;
      this._lastDefinitionExpression = a9.schema.source.definitionExpression;
      const o9 = a9.schema.tileRenderer, u10 = this._createTileRendererHash(o9);
      if ("snapshot" === this._serviceOptions.type && (a9.schema.source.initialFeatureCount = this._serviceOptions.featureCount), u10 !== this._tileRendererHash) {
        this._initTileRenderer(o9, i8);
        const e5 = this.layer, t6 = "stream" === e5.type ? await this._initServiceOptions() : this._serviceOptions;
        this.tileRenderer.onConfigUpdate(i8), "stream" !== e5.type && D(e5.source) && (t6.source = await e5.source.openPorts());
        const r9 = { added: this._tileStrategy.tileKeys(), removed: [] };
        has("esri-2d-update-debug") && console.debug("FeatureLayerView2D: Proxy startup"), await this._proxy.startup(this.view.featuresTilingScheme, a9, t6, r9), has("esri-2d-update-debug") && console.debug("FeatureLayerView2D: Finished proxy startup"), this.hasHighlight() && (has("esri-2d-update-debug") && console.debug("FeatureLayerView2D: Updating highlight"), await this._proxy.setHighlight(Array.from(this._highlightIds.keys())), has("esri-2d-update-debug") && console.debug("FeatureLayerView2D: Finished highlight update")), has("esri-2d-update-debug") && console.debug("FeatureLayerView2D: onConfigUpdate start"), this.tileRenderer.onConfigUpdate(i8), has("esri-2d-update-debug") && console.debug("FeatureLayerView2D: onConfigUpdate end");
      } else {
        "snapshot" === this._serviceOptions.type && n11 && (a9.schema.source.changedFeatureCount = await this.layer.queryFeatureCount()), has("esri-2d-update-debug") && console.debug("FeatureLayerView2D: Updating proxy");
        const t6 = await this._proxy.update(a9);
        has("esri-2d-update-debug") && console.debug("FeatureLayerView2D: Finished proxy update"), (t6.mesh || ((_a = t6.targets) == null ? void 0 : _a.aggregate)) && (has("esri-2d-update-debug") && console.debug("FeatureLayerView2D: Locking GPU Uploads"), this._lockGPUUploads());
        try {
          has("esri-2d-update-debug") && console.debug("FeatureLayerView2D: Applying update to proxy"), await this._proxy.applyUpdate(t6), has("esri-2d-update-debug") && console.debug("FeatureLayerView2D: Finished applying update to proxy");
        } catch (e5) {
          b(e5) || s.getLogger(this).error(e5);
        }
        (t6.mesh || ((_b = t6.targets) == null ? void 0 : _b.aggregate)) && this._unlockGPUUploads(), this.tileRenderer.onConfigUpdate(i8), this._updateClusterSizeVariable(), this._forceAttributeTextureUpload();
      }
      this._tileRendererHash = u10, this.tileRenderer.invalidateLabels(), this.requestUpdate();
    } catch (e5) {
    }
  }
  async _doEdit(e5) {
    try {
      await this._proxy.onEdits(e5);
    } catch (t5) {
      b(t5), 0;
    }
  }
  async _doRefresh(e5) {
    this._lockGPUUploads();
    try {
      let t5;
      e5 && "snapshot" === this.queryMode && "queryFeatureCount" in this.layer && (t5 = await this.layer.queryFeatureCount()), await this._proxy.refresh({ dataChanged: e5, featureCount: t5 });
    } catch (t5) {
      b(t5), 0;
    }
    this._unlockGPUUploads(), this._effectiveFeatureReduction && this._updateClusterSizeVariable();
  }
  _updateClusterSizeVariable() {
    this._needsClusterSizeUpdate && (this.tileRenderer.onConfigUpdate(this._effectiveRenderer), this._needsClusterSizeUpdate = false);
  }
  _createUpdateClusterSizeTask(e5, t5) {
    return d2(() => this._aggregateValueRanges, (r8) => {
      this._updateClusterEffectiveRendererSizeVariable(e5, t5, r8), this._needsClusterSizeUpdate = true, this._uploadsLocked || this._updateClusterSizeVariable();
    });
  }
  async _updateClusterEffectiveRendererSizeVariable(e5, t5, r8) {
    if (e5.dynamicClusterSize && "visualVariables" in e5 && e5.visualVariables) {
      const i8 = d5(e5.visualVariables);
      if (null != i8 && "cluster_count" === i8.field) {
        const s6 = e5.visualVariables.indexOf(i8);
        e5.visualVariables[s6] = v2(t5, r8);
        const a9 = e5.clone();
        a9.dynamicClusterSize = true, this._set("_effectiveRenderer", a9);
      }
    }
  }
  _getEffectiveRenderer() {
    var _a;
    const e5 = this.layer, t5 = "renderer" in e5 ? e5.renderer : null, r8 = this._effectiveFeatureReduction;
    if (this._updateClusterSizeTask = l(this._updateClusterSizeTask), r8 && "renderer" in r8 && r8.renderer && !((_a = r8.renderer.authoringInfo) == null ? void 0 : _a.isAutoGenerated)) {
      const e6 = r8.fields;
      if ("cluster" === r8.type) {
        const { renderer: t6, didInject: i8 } = f3(r8.renderer, r8, this._aggregateValueRanges);
        return i8 && (this._updateClusterSizeTask = this._createUpdateClusterSizeTask(t6, r8)), { renderer: t6, aggregateFields: e6, featureReduction: r8 };
      }
      return { renderer: r8.renderer, aggregateFields: e6, featureReduction: r8 };
    }
    if (r8 && "cluster" === r8.type && t5 && b3(t5)) {
      const e6 = r8, i8 = [], s6 = c3(i8, t5, e6, this._aggregateValueRanges, true);
      return this._updateClusterSizeTask = this._createUpdateClusterSizeTask(s6, e6), { renderer: s6, aggregateFields: i8, featureReduction: r8 };
    }
    return { renderer: t5, aggregateFields: [], featureReduction: null };
  }
  _acquireTile(e5) {
    const t5 = this.tileRenderer.acquireTile(e5);
    return t5.once("attach", () => {
      this.requestUpdate();
    }), t5;
  }
  _releaseTile(e5) {
    this.tileRenderer.releaseTile(e5);
  }
  _initTileRenderer(e5, t5) {
    const r8 = t3(e5, { layerView: this, tileInfoView: this.view.featuresTilingScheme, layer: this.layer });
    return this.tileRenderer && (this._tileStrategy.clear(), this.tileRenderer.uninstall(this.container), this.tileRenderer = u(this.tileRenderer)), this.destroyed ? null : (this._proxy.tileRenderer = r8, this._set("tileRenderer", r8), this.tileRenderer.install(this.container), this.tileRenderer.onConfigUpdate(t5), this.requestUpdate(), this.tileRenderer);
  }
  _createTileRendererHash(e5) {
    return `${e5.type}`;
  }
  get hasFilter() {
    const e5 = !!("floorInfo" in this.layer && this.layer.floorInfo && this.view.floors && this.view.floors.length);
    return !!this.filter || e5 || !!this._visibilityOverrides.size || !!this.timeExtent;
  }
  _injectOverrides(e5) {
    const t5 = null != e5 ? e5.timeExtent : null, r8 = null != this.timeExtent && null != t5 ? this.timeExtent.intersection(t5) : this.timeExtent || t5;
    let i8 = null;
    const s6 = "floorInfo" in this.layer && this.layer.floorInfo;
    if (s6) {
      const t6 = null != e5 ? e5.where : null;
      i8 = this._addFloorFilterClause(t6);
    }
    if (!this._visibilityOverrides.size && !r8 && !s6)
      return null != e5 ? e5.toJSON() : null;
    (e5 = null != e5 && e5.clone() || new d4()).timeExtent = r8, i8 && (e5.where = i8);
    const a9 = e5.toJSON();
    return a9.hiddenIds = Array.from(this._visibilityOverrides), a9;
  }
  _addFloorFilterClause(e5) {
    var _a;
    const t5 = this.layer;
    let r8 = e5 || "";
    if ("floorInfo" in t5 && t5.floorInfo) {
      let e6 = this.view.floors;
      if (!(e6 == null ? void 0 : e6.length))
        return r8;
      ((_a = t5.floorInfo.viewAllLevelIds) == null ? void 0 : _a.length) && (e6 = t5.floorInfo.viewAllLevelIds);
      const i8 = e6.filter((e7) => "" !== e7).map((e7) => "'" + e7 + "'");
      i8.push("''");
      const s6 = t5.floorInfo.floorField;
      let a9 = "(" + s6 + " IN ({ids}) OR " + s6 + " IS NULL)";
      if (a9 = a9.replace("{ids}", i8.join(", ")), null != r8 && r8.includes(s6)) {
        let e7 = new RegExp("AND \\(" + s6 + ".*NULL\\)", "g");
        r8 = r8.replace(e7, ""), e7 = new RegExp("\\(" + s6 + ".*NULL\\)", "g"), r8 = r8.replace(e7, ""), r8 = r8.replaceAll(/\s+/g, " ").trim();
      }
      r8 = "" !== r8 ? "(" + r8 + ") AND " + a9 : a9;
    }
    return "" !== r8 ? r8 : null;
  }
  _createConfiguration(e5, t5, r8) {
    const i8 = "feature" === this.layer.type && this.layer.historicMoment ? this.layer.historicMoment.getTime() : void 0, s6 = "feature" === this.layer.type ? this.layer.gdbVersion ?? void 0 : void 0, a9 = new Array(V2), n11 = this._injectOverrides(t5);
    a9[0] = n11, a9[1] = null != r8 ? r8.toJSON() : null;
    const o9 = w4(e5);
    if (null == o9)
      return null;
    const l7 = n4("2d");
    return { availableFields: this.availableFields, gdbVersion: s6, historicMoment: i8, devicePixelRatio: window.devicePixelRatio || 1, filters: a9, schema: o9, supportsTextureFloat: l7.supportsTextureFloat, maxTextureSize: l7.maxTextureSize, timeZone: this.view.timeZone };
  }
  _hasRequiredSupport(e5) {
    return !("renderer" in e5) || h2(e5.renderer);
  }
  _lockGPUUploads() {
    this.tileRenderer && (this._uploadsLocked = true, this.tileRenderer.lockGPUUploads());
  }
  _unlockGPUUploads() {
    this.tileRenderer && (this._uploadsLocked = false, this.tileRenderer.unlockGPUUploads());
  }
  _forceAttributeTextureUpload() {
    this.tileRenderer && this.tileRenderer.forceAttributeTextureUpload();
  }
  _createSchemaConfig() {
    const e5 = this.layer;
    return { renderer: "renderer" in e5 ? e5.renderer : null, spatialReference: e5.spatialReference, timeExtent: "timeExtent" in e5 ? e5.timeExtent : null, definitionExpression: e5.definitionExpression, featureReduction: this._effectiveFeatureReduction, fields: e5.fields, geometryType: e5.geometryType, historicMoment: "historicMoment" in e5 ? e5.historicMoment : null, labelsVisible: "labelsVisible" in e5 && e5.labelsVisible, labelingInfo: "labelingInfo" in e5 ? e5.labelingInfo : null, availableFields: this.availableFields, featureEffect: this.featureEffect, filter: this.filter, gdbVersion: "gdbVersion" in e5 ? e5.gdbVersion : null, pixelBuffer: 0, orderBy: "orderBy" in e5 && e5.orderBy ? e5.orderBy : null, customParameters: { ..."customParameters" in e5 ? e5.customParameters : void 0, token: "apiKey" in e5 ? e5.apiKey ?? void 0 : void 0 }, subtypeCode: "subtypeCode" in e5 ? e5.subtypeCode : void 0, subtypeField: "subtypeField" in e5 ? e5.subtypeField : void 0 };
  }
  _addHighlight(e5) {
    for (const t5 of e5)
      if (this._highlightIds.has(t5)) {
        const e6 = this._highlightIds.get(t5);
        this._highlightIds.set(t5, e6 + 1);
      } else
        this._highlightIds.set(t5, 1);
    this._updateHighlight().catch((e6) => {
      b(e6) || s.getLogger(this).error(e6);
    });
  }
  _removeHighlight(e5) {
    for (const t5 of e5)
      if (this._highlightIds.has(t5)) {
        const e6 = this._highlightIds.get(t5) - 1;
        0 === e6 ? this._highlightIds.delete(t5) : this._highlightIds.set(t5, e6);
      }
    this._updateHighlight().catch((e6) => {
      b(e6) || s.getLogger(this).error(e6);
    });
  }
  _setLayersForFeature(e5) {
    const t5 = this.layer;
    e5.layer = t5, e5.sourceLayer = t5;
  }
  _createGraphicHit(e5, t5) {
    return this._setLayersForFeature(t5), null != t5.geometry && (t5.geometry.spatialReference = this.view.spatialReference), { type: "graphic", graphic: t5, layer: this.layer, mapPoint: e5 };
  }
};
e([y()], Z.prototype, "_serviceOptions", void 0), e([y()], Z.prototype, "_proxy", void 0), e([y()], Z.prototype, "_pipelineIsUpdating", void 0), e([y()], Z.prototype, "_effectiveRenderer", void 0), e([y()], Z.prototype, "_effectiveFeatureReduction", null), e([y()], Z.prototype, "_aggregateValueRanges", void 0), e([y()], Z.prototype, "_commandsQueue", void 0), e([y()], Z.prototype, "featureEffectView", void 0), e([y()], Z.prototype, "labelsVisible", null), e([y()], Z.prototype, "labelingCollisionInfos", null), e([y({ readOnly: true })], Z.prototype, "queryMode", null), e([y()], Z.prototype, "renderingConfigHash", null), e([y()], Z.prototype, "tileRenderer", void 0), e([y()], Z.prototype, "updating", void 0), Z = e([c($)], Z);
var W = Z;

export {
  W
};
//# sourceMappingURL=chunk-SKVJAD2X.js.map
