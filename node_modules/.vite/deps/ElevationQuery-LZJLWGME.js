import {
  t
} from "./chunk-GZTU5O23.js";
import "./chunk-ZZYUEH57.js";
import "./chunk-VTWXDFFD.js";
import "./chunk-IPCIO3PX.js";
import {
  F,
  b
} from "./chunk-4HKQSEUR.js";
import "./chunk-V3U4F2NL.js";
import "./chunk-ZB6PGKG5.js";
import {
  m3 as m,
  u
} from "./chunk-OIIDE5GZ.js";
import {
  R,
  c,
  o,
  u as u2,
  w
} from "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import {
  _
} from "./chunk-6TJWLWLO.js";
import "./chunk-FN47E7YK.js";
import "./chunk-Y5D433JZ.js";
import {
  g,
  x2 as x
} from "./chunk-QNOCEWCR.js";
import "./chunk-WURET5CW.js";
import "./chunk-QWPLZ3QH.js";
import {
  z
} from "./chunk-HLGIRLYQ.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import "./chunk-LXXF7K7W.js";
import "./chunk-SBW6NNVI.js";
import "./chunk-62CXLI6S.js";
import {
  a,
  e,
  h
} from "./chunk-RFPH3ZTZ.js";
import {
  n
} from "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import "./chunk-4V6374PV.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/support/ElevationSampler.js
var l = s.getLogger("esri.layers.support.ElevationSampler");
var m2 = class {
  queryElevation(e2) {
    return p(e2.clone(), this);
  }
  on() {
    return e();
  }
  projectIfRequired(e2, t4) {
    return h2(e2, t4);
  }
};
var c2 = class extends m2 {
  get spatialReference() {
    return this.extent.spatialReference;
  }
  constructor(e2, t4, i) {
    super(), this.tile = e2, this.noDataValue = i;
    const o2 = e2.tile.extent;
    this.extent = c(o2, t4.spatialReference), this.extent.zmin = e2.zmin, this.extent.zmax = e2.zmax, this._aaExtent = o2;
    const a2 = z(t4.spatialReference), r = t4.lodAt(e2.tile.level).resolution * a2;
    this.demResolution = { min: r, max: r };
  }
  contains(e2) {
    const t4 = this.projectIfRequired(e2, this.spatialReference);
    return null != t4 && this.containsAt(t4.x, t4.y);
  }
  containsAt(e2, t4) {
    return w(this._aaExtent, e2, t4);
  }
  elevationAt(e2, t4) {
    if (!this.containsAt(e2, t4)) {
      const n2 = this.extent, s3 = `${n2.xmin}, ${n2.ymin}, ${n2.xmax}, ${n2.ymax}`;
      return l.warn("#elevationAt()", `Point used to sample elevation (${e2}, ${t4}) is outside of the sampler extent (${s3})`), this.noDataValue;
    }
    return this.tile.sample(e2, t4) ?? this.noDataValue;
  }
};
var u3 = class extends m2 {
  get spatialReference() {
    return this.extent.spatialReference;
  }
  constructor(e2, t4, n2) {
    let i;
    super(), "number" == typeof t4 ? (this.noDataValue = t4, i = null) : (i = t4, this.noDataValue = n2), this.samplers = i ? e2.map((e3) => new c2(e3, i, this.noDataValue)) : e2;
    const a2 = this.samplers[0];
    if (a2) {
      this.extent = a2.extent.clone();
      const { min: e3, max: t5 } = a2.demResolution;
      this.demResolution = { min: e3, max: t5 };
      for (let n3 = 1; n3 < this.samplers.length; n3++) {
        const e4 = this.samplers[n3];
        this.extent.union(e4.extent), this.demResolution.min = Math.min(this.demResolution.min, e4.demResolution.min), this.demResolution.max = Math.max(this.demResolution.max, e4.demResolution.max);
      }
    } else
      this.extent = c(u2(), i.spatialReference), this.demResolution = { min: 0, max: 0 };
  }
  elevationAt(e2, t4) {
    for (const n2 of this.samplers)
      if (n2.containsAt(e2, t4))
        return n2.elevationAt(e2, t4);
    return l.warn("#elevationAt()", `Point used to sample elevation (${e2}, ${t4}) is outside of the sampler`), this.noDataValue;
  }
};
function p(e2, t4) {
  const n2 = h2(e2, t4.spatialReference);
  if (!n2)
    return null;
  switch (e2.type) {
    case "point":
      f(e2, n2, t4);
      break;
    case "polyline":
      x2(e2, n2, t4);
      break;
    case "multipoint":
      R2(e2, n2, t4);
  }
  return e2;
}
function h2(e2, t4) {
  if (null == e2)
    return null;
  const n2 = e2.spatialReference;
  if (n2.equals(t4))
    return e2;
  const s3 = g(e2, t4);
  return s3 || l.error(`Cannot project geometry spatial reference (wkid:${n2.wkid}) to elevation sampler spatial reference (wkid:${t4.wkid})`), s3;
}
function f(e2, t4, n2) {
  e2.z = n2.elevationAt(t4.x, t4.y);
}
function x2(e2, t4, n2) {
  d.spatialReference = t4.spatialReference;
  const s3 = e2.hasM && !e2.hasZ;
  for (let i = 0; i < e2.paths.length; i++) {
    const o2 = e2.paths[i], a2 = t4.paths[i];
    for (let e3 = 0; e3 < o2.length; e3++) {
      const t5 = o2[e3], i2 = a2[e3];
      d.x = i2[0], d.y = i2[1], s3 && (t5[3] = t5[2]), t5[2] = n2.elevationAt(d.x, d.y);
    }
  }
  e2.hasZ = true;
}
function R2(e2, t4, n2) {
  d.spatialReference = t4.spatialReference;
  const s3 = e2.hasM && !e2.hasZ;
  for (let i = 0; i < e2.points.length; i++) {
    const o2 = e2.points[i], a2 = t4.points[i];
    d.x = a2[0], d.y = a2[1], s3 && (o2[3] = o2[2]), o2[2] = n2.elevationAt(d.x, d.y);
  }
  e2.hasZ = true;
}
var d = new x();

// node_modules/@arcgis/core/layers/support/ElevationSamplerData.js
var t2 = class {
  constructor(t4, h3) {
    this.data = t4, this.safeWidth = 0.99999999 * (t4.width - 1), this.dx = (t4.width - 1) / (h3[2] - h3[0]), this.dy = (t4.width - 1) / (h3[3] - h3[1]), this.x0 = h3[0], this.y1 = h3[3];
  }
};

// node_modules/@arcgis/core/layers/support/ElevationTile.js
var t3 = class {
  constructor(t4, l3 = null) {
    if (this.tile = t4, null != l3 && null != t4) {
      const e2 = t4.extent;
      this._samplerData = new t2(l3, e2);
    }
  }
  get zmin() {
    return null != this._samplerData ? this._samplerData.data.minValue : 0;
  }
  get zmax() {
    return null != this._samplerData ? this._samplerData.data.maxValue : 0;
  }
  sample(a2, t4) {
    if (null == this._samplerData)
      return;
    const { safeWidth: e2, data: r, dx: s3, dy: n2, y1: i, x0: u4 } = this._samplerData, { width: m3, values: o2, noDataValue: h3 } = r, p2 = l2(n2 * (i - t4), 0, e2), D = l2(s3 * (a2 - u4), 0, e2), f2 = Math.floor(p2), c3 = Math.floor(D), d2 = f2 * m3 + c3, _3 = d2 + m3, x4 = o2[d2], V = o2[_3], g3 = o2[d2 + 1], v2 = o2[_3 + 1];
    if (x4 !== h3 && V !== h3 && g3 !== h3 && v2 !== h3) {
      const a3 = D - c3, t5 = x4 + (g3 - x4) * a3;
      return t5 + (V + (v2 - V) * a3 - t5) * (p2 - f2);
    }
  }
};
function l2(a2, t4, l3) {
  return a2 < t4 ? t4 : a2 > l3 ? l3 : a2;
}

// node_modules/@arcgis/core/layers/support/ElevationQuery.js
var T = class {
  async queryAll(e2, i, n2) {
    if (!(e2 = n2 && n2.ignoreInvisibleLayers ? e2.filter((e3) => e3.visible) : e2.slice()).length)
      throw new s2("elevation-query:invalid-layer", "Elevation queries require at least one elevation layer to fetch tiles from");
    const l3 = v.fromGeometry(i);
    let s3 = false;
    n2 && n2.returnSampleInfo || (s3 = true);
    const o2 = { ...R3, ...n2, returnSampleInfo: true }, a2 = await this.query(e2[e2.length - 1], l3, o2), r = await this._queryAllContinue(e2, a2, o2);
    return r.geometry = r.geometry.export(), s3 && delete r.sampleInfo, r;
  }
  async query(e2, i, n2) {
    if (!e2)
      throw new s2("elevation-query:invalid-layer", "Elevation queries require an elevation layer to fetch tiles from");
    if (!i || !(i instanceof v) && "point" !== i.type && "multipoint" !== i.type && "polyline" !== i.type)
      throw new s2("elevation-query:invalid-geometry", "Only point, polyline and multipoint geometries can be used to query elevation");
    const l3 = { ...R3, ...n2 }, s3 = new x3(e2, i.spatialReference, l3), o2 = l3.signal;
    return await e2.load({ signal: o2 }), await this._createGeometryDescriptor(s3, i, o2), await this._selectTiles(s3, o2), await this._populateElevationTiles(s3, o2), this._sampleGeometryWithElevation(s3), this._createQueryResult(s3, o2);
  }
  async createSampler(e2, i, n2) {
    if (!e2)
      throw new s2("elevation-query:invalid-layer", "Elevation queries require an elevation layer to fetch tiles from");
    if (!i || "extent" !== i.type)
      throw new s2("elevation-query:invalid-extent", "Invalid or undefined extent");
    const l3 = { ...R3, ...n2 };
    return this._createSampler(e2, i, l3);
  }
  async createSamplerAll(e2, i, n2) {
    if (!(e2 = n2 && n2.ignoreInvisibleLayers ? e2.filter((e3) => e3.visible) : e2.slice()).length)
      throw new s2("elevation-query:invalid-layer", "Elevation queries require at least one elevation layer to fetch tiles from");
    if (!i || "extent" !== i.type)
      throw new s2("elevation-query:invalid-extent", "Invalid or undefined extent");
    const l3 = { ...R3, ...n2, returnSampleInfo: true }, s3 = await this._createSampler(e2[e2.length - 1], i, l3);
    return this._createSamplerAllContinue(e2, i, s3, l3);
  }
  async _createSampler(e2, t4, i, n2) {
    const l3 = i.signal;
    await e2.load({ signal: l3 });
    const s3 = t4.spatialReference, o2 = e2.tileInfo.spatialReference;
    s3.equals(o2) || (await F([{ source: s3, dest: o2 }], { signal: l3 }), t4 = b(t4, o2));
    const a2 = new _2(e2, t4, i, n2);
    return await this._selectTiles(a2, l3), await this._populateElevationTiles(a2, l3), new u3(a2.elevationTiles, a2.layer.tileInfo, a2.options.noDataValue);
  }
  async _createSamplerAllContinue(e2, t4, i, n2) {
    if (e2.pop(), !e2.length)
      return i;
    const l3 = i.samplers.map((e3) => o(e3.extent)), s3 = await this._createSampler(e2[e2.length - 1], t4, n2, l3);
    if (0 === s3.samplers.length)
      return i;
    const o2 = i.samplers.concat(s3.samplers), a2 = new u3(o2, n2.noDataValue);
    return this._createSamplerAllContinue(e2, t4, a2, n2);
  }
  async _queryAllContinue(e2, t4, n2) {
    const l3 = e2.pop(), s3 = t4.geometry.coordinates, o2 = t4.sampleInfo;
    n(o2);
    const a2 = [], r = [];
    for (let i = 0; i < s3.length; i++) {
      const t5 = o2[i];
      t5.demResolution >= 0 ? t5.source || (t5.source = l3) : e2.length && (a2.push(s3[i]), r.push(i));
    }
    if (!e2.length || 0 === a2.length)
      return t4;
    const c3 = t4.geometry.clone(a2), u4 = await this.query(e2[e2.length - 1], c3, n2), h3 = u4.sampleInfo;
    if (!h3)
      throw new Error("no sampleInfo");
    return r.forEach((e3, t5) => {
      s3[e3].z = u4.geometry.coordinates[t5].z, o2[e3].demResolution = h3[t5].demResolution;
    }), this._queryAllContinue(e2, t4, n2);
  }
  async _createQueryResult(e2, t4) {
    const n2 = await e2.geometry.project(e2.outSpatialReference, t4);
    n(n2);
    const l3 = { geometry: n2.export(), noDataValue: e2.options.noDataValue };
    return e2.options.returnSampleInfo && (l3.sampleInfo = this._extractSampleInfo(e2)), e2.geometry.coordinates.forEach((e3) => {
      e3.tile = null, e3.elevationTile = null;
    }), l3;
  }
  async _createGeometryDescriptor(e2, i, n2) {
    let l3;
    const s3 = e2.layer.tileInfo.spatialReference;
    if (i instanceof v ? l3 = await i.project(s3, n2) : (await F([{ source: i.spatialReference, dest: s3 }], { signal: n2 }), l3 = b(i, s3)), !l3)
      throw new s2("elevation-query:spatial-reference-mismatch", `Cannot query elevation in '${i.spatialReference.wkid}' on an elevation service in '${s3.wkid}'`);
    e2.geometry = v.fromGeometry(l3);
  }
  async _selectTiles(e2, i) {
    "geometry" === e2.type && this._preselectOutsideLayerExtent(e2);
    const n2 = e2.options.demResolution;
    if ("number" == typeof n2)
      this._selectTilesClosestResolution(e2, n2);
    else if ("finest-contiguous" === n2)
      await this._selectTilesFinestContiguous(e2, i);
    else {
      if ("auto" !== n2)
        throw new s2("elevation-query:invalid-dem-resolution", `Invalid dem resolution value '${n2}', expected a number, "finest-contiguous" or "auto"`);
      await this._selectTilesAuto(e2, i);
    }
  }
  _preselectOutsideLayerExtent(e2) {
    if (null == e2.layer.fullExtent)
      return;
    const t4 = new t3(null);
    t4.sample = () => e2.options.noDataValue, e2.outsideExtentTile = t4;
    const i = e2.layer.fullExtent;
    e2.geometry.coordinates.forEach((e3) => {
      const n2 = e3.x, l3 = e3.y;
      (n2 < i.xmin || n2 > i.xmax || l3 < i.ymin || l3 > i.ymax) && (e3.elevationTile = t4);
    });
  }
  _selectTilesClosestResolution(e2, t4) {
    const i = this._findNearestDemResolutionLODIndex(e2, t4);
    e2.selectTilesAtLOD(i);
  }
  _findNearestDemResolutionLODIndex(e2, t4) {
    const { tileInfo: i, tilemapCache: n2 } = e2.layer, l3 = t4 / z(i.spatialReference), o2 = q(i, n2);
    let a2 = o2[0], r = 0;
    for (let s3 = 1; s3 < o2.length; s3++) {
      const e3 = o2[s3];
      Math.abs(e3.resolution - l3) < Math.abs(a2.resolution - l3) && (a2 = e3, r = s3);
    }
    return r;
  }
  async _selectTilesFinestContiguous(e2, t4) {
    const { tileInfo: i, tilemapCache: n2 } = e2.layer, l3 = E(i, n2, e2.options.minDemResolution);
    await this._selectTilesFinestContiguousAt(e2, l3, t4);
  }
  async _selectTilesFinestContiguousAt(e2, i, s3) {
    const o2 = e2.layer;
    if (e2.selectTilesAtLOD(i), i < 0)
      return;
    const a2 = o2.tilemapCache, r = e2.getTilesToFetch();
    try {
      if (a2 && !I(a2))
        await h(Promise.all(r.map((e3) => a2.fetchAvailability(e3.level, e3.row, e3.col, { signal: s3 }))), s3);
      else if (await this._populateElevationTiles(e2, s3), !e2.allElevationTilesFetched())
        throw e2.clearElevationTiles(), new s2("elevation-query:has-unavailable-tiles");
    } catch (c3) {
      a(c3), await this._selectTilesFinestContiguousAt(e2, i - 1, s3);
    }
  }
  async _populateElevationTiles(e2, t4) {
    const i = e2.getTilesToFetch(), l3 = {}, s3 = e2.options.cache, o2 = e2.options.noDataValue, a2 = i.map(async (i2) => {
      if (null == i2.id)
        return;
      const n2 = `${e2.layer.uid}:${i2.id}:${o2}`, a3 = null != s3 ? s3.get(n2) : null, r = null != a3 ? a3 : await e2.layer.fetchTile(i2.level, i2.row, i2.col, { noDataValue: o2, signal: t4 });
      null != s3 && s3.put(n2, r), l3[i2.id] = new t3(i2, r);
    });
    await h(Promise.allSettled(a2), t4), e2.populateElevationTiles(l3);
  }
  async _selectTilesAuto(t4, i) {
    this._selectTilesAutoFinest(t4), this._reduceTilesForMaximumRequests(t4);
    const s3 = t4.layer.tilemapCache;
    if (!s3 || I(s3))
      return this._selectTilesAutoPrefetchUpsample(t4, i);
    const o2 = t4.getTilesToFetch(), a2 = {}, r = o2.map(async (t5) => {
      const n2 = new t(null, 0, 0, 0, u2()), o3 = await _(s3.fetchAvailabilityUpsample(t5.level, t5.row, t5.col, n2, { signal: i }));
      false !== o3.ok ? null != t5.id && (a2[t5.id] = n2) : a(o3.error);
    });
    await h(Promise.all(r), i), t4.remapTiles(a2);
  }
  _reduceTilesForMaximumRequests(e2) {
    const t4 = e2.layer.tileInfo;
    let i = 0;
    const n2 = {}, l3 = (e3) => {
      null != e3.id && (e3.id in n2 ? n2[e3.id]++ : (n2[e3.id] = 1, i++));
    }, s3 = (e3) => {
      if (null == e3.id)
        return;
      const t5 = n2[e3.id];
      1 === t5 ? (delete n2[e3.id], i--) : n2[e3.id] = t5 - 1;
    };
    e2.forEachTileToFetch(l3, s3);
    let o2 = true;
    for (; o2 && (o2 = false, e2.forEachTileToFetch((n3) => {
      i <= e2.options.maximumAutoTileRequests || (s3(n3), t4.upsampleTile(n3) && (o2 = true), l3(n3));
    }, s3), o2); )
      ;
  }
  _selectTilesAutoFinest(e2) {
    const { tileInfo: t4, tilemapCache: i } = e2.layer, n2 = E(t4, i, e2.options.minDemResolution);
    e2.selectTilesAtLOD(n2, e2.options.maximumAutoTileRequests);
  }
  async _selectTilesAutoPrefetchUpsample(e2, t4) {
    const i = e2.layer.tileInfo;
    await this._populateElevationTiles(e2, t4);
    let n2 = false;
    e2.forEachTileToFetch((e3, t5) => {
      i.upsampleTile(e3) ? n2 = true : t5();
    }), n2 && await this._selectTilesAutoPrefetchUpsample(e2, t4);
  }
  _sampleGeometryWithElevation(e2) {
    e2.geometry.coordinates.forEach((t4) => {
      const i = t4.elevationTile;
      let n2 = e2.options.noDataValue;
      if (i) {
        const e3 = i.sample(t4.x, t4.y);
        null != e3 ? n2 = e3 : t4.elevationTile = null;
      }
      t4.z = n2;
    });
  }
  _extractSampleInfo(e2) {
    const t4 = e2.layer.tileInfo, i = z(t4.spatialReference);
    return e2.geometry.coordinates.map((n2) => {
      let l3 = -1;
      if (n2.elevationTile && n2.elevationTile !== e2.outsideExtentTile) {
        l3 = t4.lodAt(n2.elevationTile.tile.level).resolution * i;
      }
      return { demResolution: l3 };
    });
  }
};
var v = class _v {
  export() {
    return this._exporter(this.coordinates, this.spatialReference);
  }
  clone(e2) {
    const t4 = new _v();
    return t4.geometry = this.geometry, t4.spatialReference = this.spatialReference, t4.coordinates = e2 || this.coordinates.map((e3) => e3.clone()), t4._exporter = this._exporter, t4;
  }
  async project(e2, t4) {
    if (this.spatialReference.equals(e2))
      return this.clone();
    await F([{ source: this.spatialReference, dest: e2 }], { signal: t4 });
    const i = new u({ spatialReference: this.spatialReference, points: this.coordinates.map((e3) => [e3.x, e3.y]) }), n2 = b(i, e2);
    if (!n2)
      return null;
    const l3 = this.coordinates.map((e3, t5) => {
      const i2 = e3.clone(), l4 = n2.points[t5];
      return i2.x = l4[0], i2.y = l4[1], i2;
    }), s3 = this.clone(l3);
    return s3.spatialReference = e2, s3;
  }
  static fromGeometry(e2) {
    const t4 = new _v();
    if (t4.geometry = e2, t4.spatialReference = e2.spatialReference, e2 instanceof _v)
      t4.coordinates = e2.coordinates.map((e3) => e3.clone()), t4._exporter = (t5, i) => {
        const n2 = e2.clone(t5);
        return n2.spatialReference = i, n2;
      };
    else
      switch (e2.type) {
        case "point": {
          const i = e2, { hasZ: n2, hasM: l3 } = i;
          t4.coordinates = n2 && l3 ? [new w2(i.x, i.y, i.z, i.m)] : n2 ? [new w2(i.x, i.y, i.z)] : l3 ? [new w2(i.x, i.y, null, i.m)] : [new w2(i.x, i.y)], t4._exporter = (t5, i2) => e2.hasM ? new x(t5[0].x, t5[0].y, t5[0].z, t5[0].m, i2) : new x(t5[0].x, t5[0].y, t5[0].z, i2);
          break;
        }
        case "multipoint": {
          const i = e2, { hasZ: n2, hasM: l3 } = i;
          t4.coordinates = n2 && l3 ? i.points.map((e3) => new w2(e3[0], e3[1], e3[2], e3[3])) : n2 ? i.points.map((e3) => new w2(e3[0], e3[1], e3[2])) : l3 ? i.points.map((e3) => new w2(e3[0], e3[1], null, e3[2])) : i.points.map((e3) => new w2(e3[0], e3[1])), t4._exporter = (t5, i2) => e2.hasM ? new u({ points: t5.map((e3) => [e3.x, e3.y, e3.z, e3.m]), hasZ: true, hasM: true, spatiaReference: i2 }) : new u(t5.map((e3) => [e3.x, e3.y, e3.z]), i2);
          break;
        }
        case "polyline": {
          const i = e2, n2 = [], l3 = [], { hasZ: s3, hasM: o2 } = e2;
          let a2 = 0;
          for (const e3 of i.paths)
            if (l3.push([a2, a2 + e3.length]), a2 += e3.length, s3 && o2)
              for (const t5 of e3)
                n2.push(new w2(t5[0], t5[1], t5[2], t5[3]));
            else if (s3)
              for (const t5 of e3)
                n2.push(new w2(t5[0], t5[1], t5[2]));
            else if (o2)
              for (const t5 of e3)
                n2.push(new w2(t5[0], t5[1], null, t5[2]));
            else
              for (const t5 of e3)
                n2.push(new w2(t5[0], t5[1]));
          t4.coordinates = n2, t4._exporter = (t5, i2) => {
            const n3 = e2.hasM ? t5.map((e3) => [e3.x, e3.y, e3.z, e3.m]) : t5.map((e3) => [e3.x, e3.y, e3.z]), s4 = l3.map((e3) => n3.slice(e3[0], e3[1]));
            return new m({ paths: s4, hasM: e2.hasM, hasZ: true, spatialReference: i2 });
          };
          break;
        }
      }
    return t4;
  }
};
var w2 = class _w {
  constructor(e2, t4, i = null, n2 = null, l3 = null, s3 = null) {
    this.x = e2, this.y = t4, this.z = i, this.m = n2, this.tile = l3, this.elevationTile = s3;
  }
  clone() {
    return new _w(this.x, this.y, this.z, this.m);
  }
};
var g2 = class {
  constructor(e2, t4) {
    this.layer = e2, this.options = t4;
  }
};
var x3 = class extends g2 {
  constructor(e2, t4, i) {
    super(e2, i), this.outSpatialReference = t4, this.type = "geometry";
  }
  selectTilesAtLOD(e2) {
    if (e2 < 0)
      this.geometry.coordinates.forEach((e3) => e3.tile = null);
    else {
      const { tileInfo: t4, tilemapCache: i } = this.layer, n2 = q(t4, i)[e2].level;
      this.geometry.coordinates.forEach((e3) => e3.tile = t4.tileAt(n2, e3.x, e3.y));
    }
  }
  allElevationTilesFetched() {
    return !this.geometry.coordinates.some((e2) => !e2.elevationTile);
  }
  clearElevationTiles() {
    for (const e2 of this.geometry.coordinates)
      e2.elevationTile !== this.outsideExtentTile && (e2.elevationTile = null);
  }
  populateElevationTiles(e2) {
    var _a;
    for (const t4 of this.geometry.coordinates)
      !t4.elevationTile && ((_a = t4.tile) == null ? void 0 : _a.id) && (t4.elevationTile = e2[t4.tile.id]);
  }
  remapTiles(e2) {
    var _a;
    for (const t4 of this.geometry.coordinates) {
      const i = (_a = t4.tile) == null ? void 0 : _a.id;
      t4.tile = i ? e2[i] : null;
    }
  }
  getTilesToFetch() {
    var _a;
    const e2 = {}, t4 = [];
    for (const i of this.geometry.coordinates) {
      const n2 = i.tile;
      if (!n2)
        continue;
      const l3 = (_a = i.tile) == null ? void 0 : _a.id;
      i.elevationTile || !l3 || e2[l3] || (e2[l3] = n2, t4.push(n2));
    }
    return t4;
  }
  forEachTileToFetch(e2) {
    for (const t4 of this.geometry.coordinates)
      t4.tile && !t4.elevationTile && e2(t4.tile, () => {
        t4.tile = null;
      });
  }
};
var _2 = class extends g2 {
  constructor(e2, t4, i, n2) {
    super(e2, i), this.type = "extent", this.elevationTiles = [], this._candidateTiles = [], this._fetchedCandidates = /* @__PURE__ */ new Set(), this.extent = t4.intersection(e2.fullExtent), this.maskExtents = n2;
  }
  selectTilesAtLOD(e2, t4) {
    const i = this._maximumLodForRequests(t4), n2 = Math.min(i, e2);
    n2 < 0 ? this._candidateTiles.length = 0 : this._selectCandidateTilesCoveringExtentAt(n2);
  }
  _maximumLodForRequests(e2) {
    const { tileInfo: t4, tilemapCache: i } = this.layer, n2 = q(t4, i);
    if (!e2)
      return n2.length - 1;
    const l3 = this.extent;
    if (null == l3)
      return -1;
    for (let s3 = n2.length - 1; s3 >= 0; s3--) {
      const i2 = n2[s3], o2 = i2.resolution * t4.size[0], a2 = i2.resolution * t4.size[1];
      if (Math.ceil(l3.width / o2) * Math.ceil(l3.height / a2) <= e2)
        return s3;
    }
    return -1;
  }
  allElevationTilesFetched() {
    return this._candidateTiles.length === this.elevationTiles.length;
  }
  clearElevationTiles() {
    this.elevationTiles.length = 0, this._fetchedCandidates.clear();
  }
  populateElevationTiles(e2) {
    for (const t4 of this._candidateTiles) {
      const i = t4.id && e2[t4.id];
      i && (this._fetchedCandidates.add(t4), this.elevationTiles.push(i));
    }
  }
  remapTiles(e2) {
    this._candidateTiles = this._uniqueNonOverlappingTiles(this._candidateTiles.map((t4) => e2[t4.id]));
  }
  getTilesToFetch() {
    return this._candidateTiles;
  }
  forEachTileToFetch(e2, t4) {
    const i = this._candidateTiles;
    this._candidateTiles = [], i.forEach((i2) => {
      if (this._fetchedCandidates.has(i2))
        return void (t4 && t4(i2));
      let n2 = false;
      e2(i2, () => n2 = true), n2 ? t4 && t4(i2) : this._candidateTiles.push(i2);
    }), this._candidateTiles = this._uniqueNonOverlappingTiles(this._candidateTiles, t4);
  }
  _uniqueNonOverlappingTiles(e2, t4) {
    const i = {}, n2 = [];
    for (const s3 of e2) {
      const e3 = s3.id;
      e3 && !i[e3] ? (i[e3] = s3, n2.push(s3)) : t4 && t4(s3);
    }
    const l3 = n2.sort((e3, t5) => e3.level - t5.level);
    return l3.filter((e3, i2) => {
      for (let n3 = 0; n3 < i2; n3++) {
        const i3 = l3[n3].extent;
        if (i3 && e3.extent && R(i3, e3.extent))
          return t4 && t4(e3), false;
      }
      return true;
    });
  }
  _selectCandidateTilesCoveringExtentAt(e2) {
    this._candidateTiles.length = 0;
    const t4 = this.extent;
    if (null == t4)
      return;
    const { tileInfo: i, tilemapCache: n2 } = this.layer, l3 = q(i, n2)[e2], s3 = i.tileAt(l3.level, t4.xmin, t4.ymin), o2 = s3.extent;
    if (null == o2)
      return;
    const a2 = l3.resolution * i.size[0], r = l3.resolution * i.size[1], c3 = Math.ceil((t4.xmax - o2[0]) / a2), u4 = Math.ceil((t4.ymax - o2[1]) / r);
    for (let h3 = 0; h3 < u4; h3++)
      for (let e3 = 0; e3 < c3; e3++) {
        const t5 = new t(null, s3.level, s3.row - h3, s3.col + e3);
        i.updateTileInfo(t5), this._tileIsMasked(t5) || this._candidateTiles.push(t5);
      }
  }
  _tileIsMasked(e2) {
    return !!this.maskExtents && this.maskExtents.some((t4) => e2.extent && R(t4, e2.extent));
  }
};
function E(e2, t4, i = 0) {
  const n2 = q(e2, t4);
  let l3 = n2.length - 1;
  if (i > 0) {
    const t5 = i / z(e2.spatialReference), o2 = n2.findIndex((e3) => e3.resolution < t5);
    0 === o2 ? l3 = 0 : o2 > 0 && (l3 = o2 - 1);
  }
  return l3;
}
var R3 = { maximumAutoTileRequests: 20, noDataValue: 0, returnSampleInfo: false, demResolution: "auto", minDemResolution: 0 };
function q(e2, t4) {
  const i = e2.lods;
  if (I(t4)) {
    const { effectiveMinLOD: e3, effectiveMaxLOD: n2 } = t4;
    return i.filter((t5) => t5.level >= e3 && t5.level <= n2);
  }
  return i;
}
function I(e2) {
  return null != (e2 == null ? void 0 : e2.tileInfo);
}
export {
  T as ElevationQuery,
  v as GeometryDescriptor,
  E as getFinestLodIndex
};
//# sourceMappingURL=ElevationQuery-LZJLWGME.js.map
