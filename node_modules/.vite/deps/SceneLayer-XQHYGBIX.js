import {
  j as j4
} from "./chunk-O2KD3APD.js";
import "./chunk-WK4UDTKV.js";
import {
  ie,
  s as s5
} from "./chunk-VQEOBITG.js";
import {
  n as n2,
  p as p6
} from "./chunk-JTZOXJGU.js";
import "./chunk-VSTWO7FV.js";
import {
  l as l3,
  m as m3,
  s as s6,
  u as u4
} from "./chunk-XG6EA6F3.js";
import {
  E,
  P
} from "./chunk-WJQF5YT2.js";
import {
  E as E2,
  b as b4,
  x as x2
} from "./chunk-WICI4OJR.js";
import "./chunk-T73MCNAU.js";
import "./chunk-ZKKM4KJT.js";
import "./chunk-A5EZPHEN.js";
import "./chunk-NQ7SK7XM.js";
import "./chunk-IGVJ7QLR.js";
import "./chunk-TJ5AKOA7.js";
import "./chunk-LXYMQMWX.js";
import "./chunk-XJLKESB7.js";
import "./chunk-QLCCKKQG.js";
import "./chunk-GLBAW5CR.js";
import "./chunk-SD4PEUIA.js";
import "./chunk-4OLZTDWK.js";
import "./chunk-JYYKU27J.js";
import "./chunk-SKLWU2B3.js";
import "./chunk-2RN2AAP7.js";
import "./chunk-ED5W63C6.js";
import "./chunk-673OQ2U7.js";
import {
  l
} from "./chunk-XUTOEHFJ.js";
import {
  a as a3
} from "./chunk-7QZ2LBIE.js";
import "./chunk-DXAIPMHS.js";
import "./chunk-CMGHBCKF.js";
import "./chunk-YVNEJWNQ.js";
import {
  p as p2,
  t as t2
} from "./chunk-UIN5EOGE.js";
import "./chunk-DT2VHQBL.js";
import {
  p
} from "./chunk-Z6LZMG5A.js";
import {
  i as i3
} from "./chunk-TKJNJ6KH.js";
import {
  l as l2
} from "./chunk-36R5EC6A.js";
import {
  s as s4
} from "./chunk-KLPBCYCG.js";
import {
  i as i4
} from "./chunk-DCL3YBJN.js";
import {
  C as C2
} from "./chunk-3ZWLSDVT.js";
import {
  p as p3
} from "./chunk-HPFRYEGX.js";
import {
  u as u2
} from "./chunk-F64GI7MS.js";
import "./chunk-4LDWKTSM.js";
import {
  j as j3
} from "./chunk-POSLR7O2.js";
import {
  t as t4
} from "./chunk-PIEUUBJ5.js";
import {
  u as u3
} from "./chunk-YIAYIZOZ.js";
import {
  m
} from "./chunk-P5GW5DPX.js";
import {
  c as c3,
  f as f2,
  m as m2,
  p as p5,
  y as y2
} from "./chunk-VIOPOI6P.js";
import {
  T,
  V as V3
} from "./chunk-DOALI2C2.js";
import "./chunk-E3I4MGUC.js";
import "./chunk-UHNBENSV.js";
import "./chunk-GDKL26HH.js";
import "./chunk-2CL4LRYG.js";
import "./chunk-64EQFPYJ.js";
import "./chunk-HKYMYCLL.js";
import "./chunk-ICVVQFO6.js";
import "./chunk-UTCX6DGX.js";
import {
  F
} from "./chunk-HBL2432S.js";
import {
  t as t3
} from "./chunk-T2S5L26W.js";
import "./chunk-7VNZ6V2N.js";
import "./chunk-VKTTTBW2.js";
import "./chunk-TTZWDXX5.js";
import "./chunk-OCLKX5SY.js";
import "./chunk-SEKLTVY5.js";
import {
  n
} from "./chunk-HX5GOVNX.js";
import "./chunk-2Q2Q2Z4U.js";
import "./chunk-S6MJEC4A.js";
import "./chunk-HU7QYAVQ.js";
import {
  b as b2
} from "./chunk-45OAWGCA.js";
import "./chunk-X2TA76Q5.js";
import "./chunk-T3Y5GTKO.js";
import "./chunk-XN6LAULS.js";
import {
  Z
} from "./chunk-M7OEQQRX.js";
import "./chunk-CSWPLQ7Q.js";
import "./chunk-KWSMYM7P.js";
import "./chunk-RP5SAUAF.js";
import "./chunk-6BFXMZEZ.js";
import "./chunk-AMSVADDY.js";
import "./chunk-6B7VJB6C.js";
import "./chunk-GAJBN4TM.js";
import "./chunk-BADPOP5P.js";
import {
  b as b3
} from "./chunk-YXRSJYLG.js";
import {
  c as c2
} from "./chunk-FWR4JURK.js";
import {
  k
} from "./chunk-BELGAUAK.js";
import "./chunk-JHJVOI7Q.js";
import "./chunk-TWNBDJHC.js";
import "./chunk-HITXLR5N.js";
import "./chunk-WYZCKLOR.js";
import {
  r
} from "./chunk-S6NERLXF.js";
import "./chunk-4TSAC52K.js";
import "./chunk-H4ZZ5S37.js";
import "./chunk-G557TGXY.js";
import "./chunk-2AXFVQBN.js";
import "./chunk-WOGT6UK2.js";
import "./chunk-IRNKV32L.js";
import "./chunk-BEALJUHO.js";
import "./chunk-GRHSIT57.js";
import "./chunk-PJQIAD5D.js";
import {
  p as p4,
  x
} from "./chunk-Z6KIMOUA.js";
import "./chunk-SZAJDZCO.js";
import "./chunk-M7R7REMB.js";
import "./chunk-ZZYUEH57.js";
import "./chunk-VTWXDFFD.js";
import "./chunk-IPCIO3PX.js";
import "./chunk-EIY2DYTV.js";
import {
  i as i2
} from "./chunk-WJ4LS3YG.js";
import "./chunk-F6MD5VOH.js";
import "./chunk-V2RPSCV3.js";
import {
  w as w2
} from "./chunk-AOJ6OCPK.js";
import {
  i
} from "./chunk-LMT5JII2.js";
import "./chunk-A43TI6AT.js";
import "./chunk-BHJVWW2P.js";
import {
  D,
  nn
} from "./chunk-4HKQSEUR.js";
import "./chunk-V3U4F2NL.js";
import "./chunk-ZB6PGKG5.js";
import {
  j as j2
} from "./chunk-OIIDE5GZ.js";
import "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import "./chunk-APYNYYQC.js";
import {
  C,
  v,
  w
} from "./chunk-TBSVVR6M.js";
import "./chunk-6TJWLWLO.js";
import "./chunk-H7BKONNV.js";
import "./chunk-K6C6RVSV.js";
import "./chunk-KBJ5Z4R2.js";
import {
  V as V2
} from "./chunk-JUZJCTW2.js";
import "./chunk-423VNHLR.js";
import "./chunk-FN47E7YK.js";
import "./chunk-XZS3Q5K4.js";
import "./chunk-XXFXRXFH.js";
import "./chunk-CCXEAKIM.js";
import "./chunk-Y5D433JZ.js";
import "./chunk-QNOCEWCR.js";
import {
  o
} from "./chunk-WURET5CW.js";
import "./chunk-QWPLZ3QH.js";
import "./chunk-HLGIRLYQ.js";
import "./chunk-N2K4VRZH.js";
import "./chunk-WL4VPODY.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import {
  V,
  j
} from "./chunk-R5DM4YAB.js";
import {
  f,
  u2 as u
} from "./chunk-NSRXJNTS.js";
import {
  e2,
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c,
  s3,
  t
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  a as a2,
  b
} from "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  a,
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import "./chunk-4V6374PV.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/support/RangeInfo.js
var s7 = class extends f {
  constructor() {
    super(...arguments), this.name = null, this.field = null, this.currentRangeExtent = null, this.fullRangeExtent = null, this.type = "rangeInfo";
  }
};
e([y({ type: String, json: { read: true, write: true } })], s7.prototype, "name", void 0), e([y({ type: String, json: { read: true, write: true } })], s7.prototype, "field", void 0), e([y({ type: [Number], json: { read: true, write: true } })], s7.prototype, "currentRangeExtent", void 0), e([y({ type: [Number], json: { read: true, write: true } })], s7.prototype, "fullRangeExtent", void 0), e([y({ type: ["rangeInfo"], readOnly: true, json: { read: false, write: true } })], s7.prototype, "type", void 0), s7 = e([c("esri.layers.support.RangeInfo")], s7);

// node_modules/@arcgis/core/layers/support/PolygonCollection.js
var c4;
var p7 = c4 = class extends u(V2.ofType(j2)) {
  constructor(e3) {
    super(e3);
  }
  clone() {
    return new c4(this.items.map((e3) => e3.clone()));
  }
  write(e3, r2) {
    return this.toJSON(r2);
  }
  toJSON(e3) {
    var _a;
    const r2 = (_a = e3 == null ? void 0 : e3.layer) == null ? void 0 : _a.spatialReference;
    return r2 ? this.toArray().map((t5) => {
      if (!r2.equals(t5.spatialReference)) {
        if (!D(t5.spatialReference, r2))
          return (e3 == null ? void 0 : e3.messages) && e3.messages.push(new s3("scenefilter:unsupported", "Scene filters with incompatible spatial references are not supported", { modification: this, spatialReference: e3.layer.spatialReference, context: e3 })), null;
        const s9 = new j2();
        nn(t5, s9, r2), t5 = s9;
      }
      const s8 = t5.toJSON(e3);
      return delete s8.spatialReference, s8;
    }).filter((e4) => null != e4) : ((e3 == null ? void 0 : e3.messages) && e3.messages.push(new s3("scenefilter:unsupported", "Writing Scene filters without context layer is not supported", { modification: this, spatialReference: e3.layer.spatialReference, context: e3 })), this.toArray().map((r3) => r3.toJSON(e3)));
  }
  static fromJSON(e3, r2) {
    const t5 = new c4();
    return e3.forEach((e4) => t5.add(j2.fromJSON(e4, r2))), t5;
  }
};
p7 = c4 = e([c("esri.layers.support.PolygonCollection")], p7);
var l4 = p7;

// node_modules/@arcgis/core/layers/support/SceneFilter.js
var u5;
var g = u5 = class extends f {
  constructor(e3) {
    super(e3), this.spatialRelationship = "disjoint", this.geometries = new l4(), this._geometriesSource = null;
  }
  initialize() {
    this.addHandles(v(() => this.geometries, "after-changes", () => this.geometries = this.geometries, C));
  }
  readGeometries(e3, r2, o2) {
    Array.isArray(e3) ? this.geometries = l4.fromJSON(e3, o2) : this._geometriesSource = { url: i(e3, o2), context: o2 };
  }
  async loadGeometries(e3, o2) {
    if (null == this._geometriesSource)
      return;
    const { url: s8, context: t5 } = this._geometriesSource, i5 = await j(s8, { responseType: "json", signal: o2 == null ? void 0 : o2.signal }), a4 = e3.toJSON(), p8 = i5.data.map((e4) => ({ ...e4, spatialReference: a4 }));
    this.geometries = l4.fromJSON(p8, t5), this._geometriesSource = null;
  }
  clone() {
    const e3 = new u5({ geometries: a(this.geometries), spatialRelationship: this.spatialRelationship });
    return e3._geometriesSource = this._geometriesSource, e3;
  }
};
e([y({ type: ["disjoint", "contains"], nonNullable: true, json: { write: true } })], g.prototype, "spatialRelationship", void 0), e([y({ type: l4, nonNullable: true, json: { write: true } }), j4({ origins: ["web-scene", "portal-item"], type: "resource", prefix: "geometries", contentAddressed: true })], g.prototype, "geometries", void 0), e([o(["web-scene", "portal-item"], "geometries")], g.prototype, "readGeometries", null), g = u5 = e([c("esri.layers.support.SceneFilter")], g);
var h = g;

// node_modules/@arcgis/core/layers/SceneLayer.js
var ye = /* @__PURE__ */ new Set(["3DObject", "Point"]);
var ue = s4();
var ce = class extends F(E(l2(u3(j3(t4(m(i3(i2(b3))))))))) {
  constructor(...e3) {
    super(...e3), this.featureReduction = null, this.rangeInfos = null, this.operationalLayerType = "ArcGISSceneServiceLayer", this.type = "scene", this.fields = null, this.floorInfo = null, this.outFields = null, this.nodePages = null, this.materialDefinitions = null, this.textureSetDefinitions = null, this.geometryDefinitions = null, this.serviceUpdateTimeStamp = null, this.excludeObjectIds = new V2(), this.definitionExpression = null, this.filter = null, this.path = null, this.labelsVisible = true, this.labelingInfo = null, this.legendEnabled = true, this.priority = null, this.semantic = null, this.cachedDrawingInfo = { color: false }, this.popupEnabled = true, this.popupTemplate = null, this.objectIdField = null, this.globalIdField = null, this._fieldUsageInfo = {}, this.screenSizePerspectiveEnabled = true, this.serviceItemId = void 0;
  }
  normalizeCtorArgs(e3, t5) {
    return "string" == typeof e3 ? { url: e3, ...t5 } : e3;
  }
  destroy() {
    this._set("renderer", null);
  }
  getField(e3) {
    return this.fieldsIndex.get(e3);
  }
  getFieldDomain(e3, t5) {
    var _a, _b, _c;
    const r2 = (_b = (_a = this.getFeatureType(t5 == null ? void 0 : t5.feature)) == null ? void 0 : _a.domains) == null ? void 0 : _b[e3];
    return r2 && "inherited" !== r2.type ? r2 : ((_c = this.getField(e3)) == null ? void 0 : _c.domain) ?? null;
  }
  getFeatureType(e3) {
    return e3 && this.associatedLayer ? this.associatedLayer.getFeatureType(e3) : null;
  }
  get types() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.types) ?? [];
  }
  get typeIdField() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.typeIdField) ?? null;
  }
  get templates() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.templates) ?? null;
  }
  get formTemplate() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.formTemplate) ?? null;
  }
  get fieldsIndex() {
    return new Z(this.fields);
  }
  readNodePages(e3, t5, r2) {
    return "Point" === t5.layerType && (e3 = t5.pointNodePages), null == e3 || "object" != typeof e3 ? null : s6.fromJSON(e3, r2);
  }
  set elevationInfo(e3) {
    this._set("elevationInfo", e3), this.loaded && this._validateElevationInfo();
  }
  get effectiveCapabilities() {
    var _a;
    return this._capabilitiesFromAssociatedFeatureLayer((_a = this.associatedLayer) == null ? void 0 : _a.effectiveCapabilities);
  }
  get effectiveEditingEnabled() {
    return null != this.associatedLayer && T(this.associatedLayer);
  }
  get geometryType() {
    return fe[this.profile] || "mesh";
  }
  set renderer(e3) {
    p4(e3, this.fieldsIndex), this._set("renderer", e3);
  }
  readCachedDrawingInfo(e3) {
    return null != e3 && "object" == typeof e3 || (e3 = {}), null == e3.color && (e3.color = false), e3;
  }
  get capabilities() {
    var _a;
    return this._capabilitiesFromAssociatedFeatureLayer((_a = this.associatedLayer) == null ? void 0 : _a.capabilities);
  }
  _capabilitiesFromAssociatedFeatureLayer(e3) {
    var _a;
    e3 = null != e3 ? e3 : s5;
    const { query: t5, queryRelated: r2, editing: { supportsGlobalId: i5, supportsRollbackOnFailure: s8, supportsUploadWithItemId: o2, supportsGeometryUpdate: a4, supportsReturnServiceEditsInSourceSpatialReference: n3 }, data: { supportsZ: l5, supportsM: p8, isVersioned: d, supportsAttachment: y3 }, operations: { supportsEditing: u6, supportsAdd: c5, supportsUpdate: h2, supportsDelete: f3, supportsQuery: m4, supportsQueryAttachments: g2, supportsAsyncConvert3D: v2 } } = e3, b5 = e3.operations.supportsChangeTracking, I = !!((_a = this.associatedLayer) == null ? void 0 : _a.infoFor3D) && n();
    return { query: t5, queryRelated: r2, editing: { supportsGlobalId: i5, supportsReturnServiceEditsInSourceSpatialReference: n3, supportsRollbackOnFailure: s8, supportsGeometryUpdate: I && a4, supportsUploadWithItemId: o2 }, data: { supportsAttachment: y3, supportsZ: l5, supportsM: p8, isVersioned: d }, operations: { supportsQuery: m4, supportsQueryAttachments: g2, supportsEditing: u6 && b5, supportsAdd: I && c5 && b5, supportsDelete: I && f3 && b5, supportsUpdate: h2 && b5, supportsAsyncConvert3D: v2 } };
  }
  get editingEnabled() {
    var _a;
    return this._isOverridden("editingEnabled") ? this._get("editingEnabled") : ((_a = this.associatedLayer) == null ? void 0 : _a.editingEnabled) ?? false;
  }
  set editingEnabled(e3) {
    this._overrideIfSome("editingEnabled", e3);
  }
  get infoFor3D() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.infoFor3D) ?? null;
  }
  get relationships() {
    var _a;
    return (_a = this.associatedLayer) == null ? void 0 : _a.relationships;
  }
  get defaultPopupTemplate() {
    return this.associatedLayer || this.attributeStorageInfo ? this.createPopupTemplate() : null;
  }
  readObjectIdField(e3, t5) {
    return !e3 && t5.fields && t5.fields.some((t6) => ("esriFieldTypeOID" === t6.type && (e3 = t6.name), !!e3)), e3 || void 0;
  }
  readGlobalIdField(e3, t5) {
    return !e3 && t5.fields && t5.fields.some((t6) => ("esriFieldTypeGlobalID" === t6.type && (e3 = t6.name), !!e3)), e3 || void 0;
  }
  get displayField() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.displayField) ?? null;
  }
  readProfile(e3, t5) {
    const r2 = t5.store.profile;
    return null != r2 && he[r2] ? he[r2] : (s.getLogger(this).error("Unknown or missing profile", { profile: r2, layer: this }), "mesh-pyramids");
  }
  load(e3) {
    return this.addResolvingPromise(this._load(e3)), Promise.resolve(this);
  }
  async _load(e3) {
    const t5 = null != e3 ? e3.signal : null;
    await this.loadFromPortal({ supportedTypes: ["Scene Service"] }, e3).catch(a2), await this._fetchService(t5), await Promise.all([this._fetchIndexAndUpdateExtent(this.nodePages, t5), this._setAssociatedFeatureLayer(t5), this._loadFilterGeometries()]), this._validateElevationInfo(), this._applyAssociatedLayerOverrides(), this._populateFieldUsageInfo(), await t3(this, { origin: "service" }, t5), p4(this.renderer, this.fieldsIndex), await this.finishLoadEditablePortalLayer(e3);
  }
  async beforeSave() {
    null != this.filter && (this.filter = this.filter.clone(), await this.load());
  }
  async _loadFilterGeometries() {
    if (this.filter)
      try {
        await this.filter.loadGeometries(this.spatialReference);
      } catch (e3) {
        s.getLogger(this).error("#_loadFilterGeometries()", this, "Failed to load filter geometries. Geometry filter will not be applied for this layer.", { error: e3 }), this.filter = null;
      }
  }
  createQuery() {
    const e3 = new b2();
    return "mesh" !== this.geometryType && (e3.returnGeometry = true, e3.returnZ = true), e3.where = this.definitionExpression || "1=1", e3.sqlFormat = "standard", e3.outFields = ["*"], e3;
  }
  queryExtent(e3, t5) {
    return this._getAssociatedLayerForQuery().then((r2) => r2.queryExtent(e3 || this.createQuery(), t5));
  }
  queryFeatureCount(e3, t5) {
    return this._getAssociatedLayerForQuery().then((r2) => r2.queryFeatureCount(e3 || this.createQuery(), t5));
  }
  queryFeatures(e3, t5) {
    return this._getAssociatedLayerForQuery().then((r2) => r2.queryFeatures(e3 || this.createQuery(), t5)).then((e4) => {
      if (e4 == null ? void 0 : e4.features)
        for (const t6 of e4.features)
          t6.layer = this, t6.sourceLayer = this;
      return e4;
    });
  }
  async queryRelatedFeatures(e3, t5) {
    if (await this.load(), !this.associatedLayer)
      throw new s2("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", { layer: this });
    return this.associatedLayer.queryRelatedFeatures(e3, t5);
  }
  async queryRelatedFeaturesCount(e3, t5) {
    if (await this.load(), !this.associatedLayer)
      throw new s2("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", { layer: this });
    return this.associatedLayer.queryRelatedFeaturesCount(e3, t5);
  }
  async queryCachedAttributes(e3, t5) {
    const r2 = x(this.fieldsIndex, await n2(this, p6(this)));
    return ie(this.parsedUrl.path, this.attributeStorageInfo ?? [], e3, t5, r2);
  }
  async queryCachedFeature(e3, r2) {
    const i5 = await this.queryCachedAttributes(e3, [r2]);
    if (!i5 || 0 === i5.length)
      throw new s2("scenelayer:feature-not-in-cached-data", "Feature not found in cached data");
    const s8 = new c2();
    return s8.attributes = i5[0], s8.layer = this, s8.sourceLayer = this, s8;
  }
  queryObjectIds(e3, t5) {
    return this._getAssociatedLayerForQuery().then((r2) => r2.queryObjectIds(e3 || this.createQuery(), t5));
  }
  queryAttachments(e3, t5) {
    return this._getAssociatedLayerForQuery().then((r2) => r2.queryAttachments(e3, t5));
  }
  getFieldUsageInfo(e3) {
    const t5 = { supportsLabelingInfo: false, supportsRenderer: false, supportsPopupTemplate: false, supportsLayerQuery: false };
    return this.loaded ? this._fieldUsageInfo[e3] || t5 : (s.getLogger(this).error("#getFieldUsageInfo()", "Unavailable until layer is loaded"), t5);
  }
  createPopupTemplate(e3) {
    return p3(this, e3);
  }
  _getAssociatedLayerForQuery() {
    const e3 = this.associatedLayer;
    return (e3 == null ? void 0 : e3.loaded) ? Promise.resolve(e3) : this._loadAssociatedLayerForQuery();
  }
  async _loadAssociatedLayerForQuery() {
    if (await this.load(), !this.associatedLayer)
      throw new s2("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", { layer: this });
    try {
      await this.associatedLayer.load();
    } catch (e3) {
      throw new s2("scenelayer:query-not-available", "SceneLayer associated feature layer could not be loaded", { layer: this, error: e3 });
    }
    return this.associatedLayer;
  }
  hasCachedStatistics(e3) {
    return null != this.statisticsInfo && this.statisticsInfo.some((t5) => t5.name === e3);
  }
  async queryCachedStatistics(e3, t5) {
    if (await this.load(t5), !this.statisticsInfo)
      throw new s2("scenelayer:no-cached-statistics", "Cached statistics are not available for this layer");
    const r2 = this.fieldsIndex.get(e3);
    if (!r2)
      throw new s2("scenelayer:field-unexisting", `Field '${e3}' does not exist on the layer`);
    for (const i5 of this.statisticsInfo)
      if (i5.name === r2.name) {
        const e4 = V(this.parsedUrl.path, i5.href);
        return j(e4, { query: { f: "json", token: this.apiKey }, responseType: "json", signal: t5 ? t5.signal : null }).then((e5) => e5.data);
      }
    throw new s2("scenelayer:no-cached-statistics", "Cached statistics for this attribute are not available");
  }
  async saveAs(e3, t5) {
    return this._debouncedSaveOperations(P.SAVE_AS, { ...t5, getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "scene" }, e3);
  }
  async save() {
    const e3 = { getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "scene" };
    return this._debouncedSaveOperations(P.SAVE, e3);
  }
  async applyEdits(e3, t5) {
    const { applyEdits: r2 } = await import("./editingSupport-FJFXL3HI.js");
    let i5 = t5;
    await this.load();
    const s8 = this.associatedLayer;
    if (!s8)
      throw new s2(`${this.type}-layer:not-editable`, "Service is not editable");
    await s8.load();
    const { globalIdField: o2 } = s8, a4 = !!s8.infoFor3D, l5 = (i5 == null ? void 0 : i5.globalIdUsed) ?? true;
    if (a4 && null == o2)
      throw new s2(`${this.type}-layer:not-editable`, "Valid globalIdField expected on editable SceneLayer");
    if (a4 && !l5)
      throw new s2(`${this.type}-layer:globalid-required`, "globalIdUsed must not be false for SceneLayer editing as globalIds are required.");
    return w2(s8.url) && a4 && null != e3.deleteFeatures && null != o2 && (i5 = { ...i5, globalIdToObjectId: await V3(s8, e3.deleteFeatures, o2) }), r2(this, s8.source, e3, i5);
  }
  async uploadAssets(e3, t5) {
    if (await this.load(), null == this.associatedLayer)
      throw new s2(`${this.type}-layer:not-editable`, "Service is not editable");
    return await this.associatedLayer.load(), this.associatedLayer.uploadAssets(e3, t5);
  }
  on(e3, t5) {
    return super.on(e3, t5);
  }
  validateLayer(e3) {
    if (e3.layerType && !ye.has(e3.layerType))
      throw new s2("scenelayer:layer-type-not-supported", "SceneLayer does not support this layer type", { layerType: e3.layerType });
    if (isNaN(this.version.major) || isNaN(this.version.minor))
      throw new s2("layer:service-version-not-supported", "Service version is not supported.", { serviceVersion: this.version.versionString, supportedVersions: "1.x, 2.x" });
    if (this.version.major > 2)
      throw new s2("layer:service-version-too-new", "Service version is too new.", { serviceVersion: this.version.versionString, supportedVersions: "1.x, 2.x" });
    function t5(e4, t6) {
      let r2 = false, i5 = false;
      if (null == e4)
        r2 = true, i5 = true;
      else {
        const s8 = t6 && t6.isGeographic;
        switch (e4) {
          case "east-north-up":
          case "earth-centered":
            r2 = true, i5 = s8;
            break;
          case "vertex-reference-frame":
            r2 = true, i5 = !s8;
            break;
          default:
            r2 = false;
        }
      }
      if (!r2)
        throw new s2("scenelayer:unsupported-normal-reference-frame", "Normal reference frame is invalid.");
      if (!i5)
        throw new s2("scenelayer:incompatible-normal-reference-frame", "Normal reference frame is incompatible with layer spatial reference.");
    }
    t5(this.normalReferenceFrame, this.spatialReference);
  }
  _getTypeKeywords() {
    const e3 = [];
    if ("points" === this.profile)
      e3.push("Point");
    else {
      if ("mesh-pyramids" !== this.profile)
        throw new s2("scenelayer:unknown-profile", "SceneLayer:save() encountered an unknown SceneLayer profile: " + this.profile);
      e3.push("3DObject");
    }
    return e3;
  }
  _populateFieldUsageInfo() {
    var _a, _b;
    if (this._fieldUsageInfo = {}, this.fields)
      for (const e3 of this.fields) {
        const t5 = !(!this.attributeStorageInfo || !this.attributeStorageInfo.some((t6) => t6.name === e3.name)), r2 = !!((_b = (_a = this.associatedLayer) == null ? void 0 : _a.fields) == null ? void 0 : _b.some((t6) => t6 && e3.name === t6.name)), i5 = { supportsLabelingInfo: t5, supportsRenderer: t5, supportsPopupTemplate: t5 || r2, supportsLayerQuery: r2 };
        this._fieldUsageInfo[e3.name] = i5;
      }
  }
  _applyAssociatedLayerOverrides() {
    this._applyAssociatedLayerFieldsOverrides(), this._applyAssociatedLayerPopupOverrides(), this._applyAssociatedLayerExtentOverride(), this._applyAssociatedLayerPrivileges();
  }
  _applyAssociatedLayerFieldsOverrides() {
    var _a;
    if (!((_a = this.associatedLayer) == null ? void 0 : _a.fields))
      return;
    let e3 = null;
    for (const t5 of this.associatedLayer.fields) {
      const r2 = this.getField(t5.name);
      r2 ? (!r2.domain && t5.domain && (r2.domain = t5.domain.clone()), r2.editable = t5.editable, r2.nullable = t5.nullable, r2.length = t5.length) : (e3 || (e3 = this.fields ? this.fields.slice() : []), e3.push(t5.clone()));
    }
    e3 && this._set("fields", e3);
  }
  _applyAssociatedLayerPopupOverrides() {
    if (!this.associatedLayer)
      return;
    const e3 = ["popupTemplate", "popupEnabled"], t5 = t(this);
    for (let r2 = 0; r2 < e3.length; r2++) {
      const i5 = e3[r2], s8 = this.originIdOf(i5), o2 = this.associatedLayer.originIdOf(i5);
      s8 < o2 && (o2 === e2.SERVICE || o2 === e2.PORTAL_ITEM) && t5.setAtOrigin(i5, this.associatedLayer[i5], o2);
    }
  }
  _applyAssociatedLayerExtentOverride() {
    var _a, _b, _c, _d, _e, _f, _g;
    const e3 = (_b = (_a = this.associatedLayer) == null ? void 0 : _a.editingInfo) == null ? void 0 : _b.lastEditDate, t5 = (_c = this.associatedLayer) == null ? void 0 : _c.serverGens, r2 = (_d = this.associatedLayer) == null ? void 0 : _d.getAtOrigin("fullExtent", "service");
    if (!n() || null == ((_e = this.associatedLayer) == null ? void 0 : _e.infoFor3D) || !r2 || !w2((_f = this.associatedLayer) == null ? void 0 : _f.url) || !e3 || ((_g = this.serviceUpdateTimeStamp) == null ? void 0 : _g.lastUpdate) === e3.getTime() || !this.serviceUpdateTimeStamp && (t5 == null ? void 0 : t5.minServerGen) === (t5 == null ? void 0 : t5.serverGen))
      return;
    t(this).setAtOrigin("fullExtent", r2.clone(), e2.SERVICE);
  }
  _applyAssociatedLayerPrivileges() {
    const e3 = this.associatedLayer;
    e3 && (this._set("userHasEditingPrivileges", e3.userHasEditingPrivileges), this._set("userHasFullEditingPrivileges", e3.userHasFullEditingPrivileges), this._set("userHasUpdateItemPrivileges", e3.userHasUpdateItemPrivileges));
  }
  async _setAssociatedFeatureLayer(e3) {
    if (["mesh-pyramids", "points"].includes(this.profile))
      try {
        const { serverUrl: t5, layerId: r2, portalItem: i5 } = await l(`${this.url}/layers/${this.layerId}`, { sceneLayerItem: this.portalItem, apiKey: this.apiKey, signal: e3 }), s8 = await a3.FeatureLayer();
        this.associatedLayer = new s8({ url: t5, layerId: r2, portalItem: i5 }), await this.associatedLayer.load();
      } catch (t5) {
        b(t5) || this._logWarningOnPopupEnabled();
      }
  }
  async _logWarningOnPopupEnabled() {
    await w(() => this.popupEnabled && null != this.popupTemplate);
    const e3 = `this SceneLayer: ${this.title}`;
    null == this.attributeStorageInfo ? s.getLogger(this).warn(`Associated FeatureLayer could not be loaded and no binary attributes found. Popups will not work on ${e3}`) : s.getLogger(this).info(`Associated FeatureLayer could not be loaded. Falling back to binary attributes for Popups on ${e3}`);
  }
  _validateElevationInfo() {
    const e3 = this.elevationInfo;
    "mesh-pyramids" === this.profile && x2(s.getLogger(this), b4("Mesh scene layers", "relative-to-scene", e3)), x2(s.getLogger(this), E2("Scene layers", e3));
  }
};
e([y({ types: { key: "type", base: t2, typeMap: { selection: p2 } }, json: { origins: { "web-scene": { name: "layerDefinition.featureReduction", write: true }, "portal-item": { name: "layerDefinition.featureReduction", write: true } } } })], ce.prototype, "featureReduction", void 0), e([y({ type: [s7], json: { read: false, origins: { "web-scene": { name: "layerDefinition.rangeInfos", write: true }, "portal-item": { name: "layerDefinition.rangeInfos", write: true } } } })], ce.prototype, "rangeInfos", void 0), e([y({ json: { read: false } })], ce.prototype, "associatedLayer", void 0), e([y({ type: ["show", "hide"] })], ce.prototype, "listMode", void 0), e([y({ type: ["ArcGISSceneServiceLayer"] })], ce.prototype, "operationalLayerType", void 0), e([y({ json: { read: false }, readOnly: true })], ce.prototype, "type", void 0), e([y({ ...ue.fields, readOnly: true, json: { read: false, origins: { service: { read: true } } } })], ce.prototype, "fields", void 0), e([y()], ce.prototype, "types", null), e([y()], ce.prototype, "typeIdField", null), e([y()], ce.prototype, "templates", null), e([y()], ce.prototype, "formTemplate", null), e([y({ readOnly: true, clonable: false })], ce.prototype, "fieldsIndex", null), e([y({ type: p, json: { read: { source: "layerDefinition.floorInfo" }, write: { target: "layerDefinition.floorInfo" } } })], ce.prototype, "floorInfo", void 0), e([y(ue.outFields)], ce.prototype, "outFields", void 0), e([y({ type: s6, readOnly: true, json: { read: false } })], ce.prototype, "nodePages", void 0), e([o("service", "nodePages", ["nodePages", "pointNodePages"])], ce.prototype, "readNodePages", null), e([y({ type: [l3], readOnly: true })], ce.prototype, "materialDefinitions", void 0), e([y({ type: [u4], readOnly: true })], ce.prototype, "textureSetDefinitions", void 0), e([y({ type: [m3], readOnly: true })], ce.prototype, "geometryDefinitions", void 0), e([y({ readOnly: true })], ce.prototype, "serviceUpdateTimeStamp", void 0), e([y({ readOnly: true })], ce.prototype, "attributeStorageInfo", void 0), e([y({ readOnly: true })], ce.prototype, "statisticsInfo", void 0), e([y({ type: V2.ofType(Number), nonNullable: true, json: { origins: { service: { read: false, write: false } }, name: "layerDefinition.excludeObjectIds", write: { enabled: true } } })], ce.prototype, "excludeObjectIds", void 0), e([y({ type: String, json: { origins: { service: { read: false, write: false } }, name: "layerDefinition.definitionExpression", write: { enabled: true, allowNull: true } } })], ce.prototype, "definitionExpression", void 0), e([y({ type: h, json: { name: "layerDefinition.polygonFilter", write: { enabled: true, allowNull: true }, origins: { service: { read: false, write: false } } } })], ce.prototype, "filter", void 0), e([y({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], ce.prototype, "path", void 0), e([y(f2)], ce.prototype, "elevationInfo", null), e([y({ readOnly: true, json: { read: false } })], ce.prototype, "effectiveCapabilities", null), e([y({ readOnly: true })], ce.prototype, "effectiveEditingEnabled", null), e([y({ type: String })], ce.prototype, "geometryType", null), e([y(m2)], ce.prototype, "labelsVisible", void 0), e([y({ type: [C2], json: { origins: { service: { name: "drawingInfo.labelingInfo", read: { reader: i4 }, write: false } }, name: "layerDefinition.drawingInfo.labelingInfo", read: { reader: i4 }, write: true } })], ce.prototype, "labelingInfo", void 0), e([y(c3)], ce.prototype, "legendEnabled", void 0), e([y({ type: Number, json: { origins: { "web-document": { default: 1, write: { enabled: true, target: { opacity: { type: Number }, "layerDefinition.drawingInfo.transparency": { type: Number } } }, read: { source: ["opacity", "layerDefinition.drawingInfo.transparency"], reader(e3, t5) {
  var _a, _b;
  if ("number" == typeof e3 && e3 >= 0 && e3 <= 1)
    return e3;
  const r2 = (_b = (_a = t5.layerDefinition) == null ? void 0 : _a.drawingInfo) == null ? void 0 : _b.transparency;
  return void 0 !== r2 ? r(r2) : void 0;
} } }, "portal-item": { write: true }, service: { read: false } } } })], ce.prototype, "opacity", void 0), e([y({ type: ["Low", "High"], readOnly: true, json: { read: false, origins: { service: { read: true } } } })], ce.prototype, "priority", void 0), e([y({ type: ["Labels"], readOnly: true, json: { read: false, origins: { service: { read: true } } } })], ce.prototype, "semantic", void 0), e([y({ types: u2, json: { origins: { service: { read: { source: "drawingInfo.renderer" } } }, name: "layerDefinition.drawingInfo.renderer", write: true }, value: null })], ce.prototype, "renderer", null), e([y({ json: { read: false } })], ce.prototype, "cachedDrawingInfo", void 0), e([o("service", "cachedDrawingInfo")], ce.prototype, "readCachedDrawingInfo", null), e([y({ readOnly: true, json: { read: false } })], ce.prototype, "capabilities", null), e([y({ type: Boolean, json: { read: false } })], ce.prototype, "editingEnabled", null), e([y({ readOnly: true, json: { write: false, read: false } })], ce.prototype, "infoFor3D", null), e([y({ readOnly: true, json: { write: false, read: false } })], ce.prototype, "relationships", null), e([y(y2)], ce.prototype, "popupEnabled", void 0), e([y({ type: k, json: { name: "popupInfo", write: true } })], ce.prototype, "popupTemplate", void 0), e([y({ readOnly: true, json: { read: false } })], ce.prototype, "defaultPopupTemplate", null), e([y({ type: String, json: { read: false } })], ce.prototype, "objectIdField", void 0), e([o("service", "objectIdField", ["objectIdField", "fields"])], ce.prototype, "readObjectIdField", null), e([y({ type: String, json: { read: false } })], ce.prototype, "globalIdField", void 0), e([o("service", "globalIdField", ["globalIdField", "fields"])], ce.prototype, "readGlobalIdField", null), e([y({ readOnly: true, type: String, json: { read: false } })], ce.prototype, "displayField", null), e([y({ type: String, json: { read: false } })], ce.prototype, "profile", void 0), e([o("service", "profile", ["store.profile"])], ce.prototype, "readProfile", null), e([y({ readOnly: true, type: String, json: { origins: { service: { read: { source: "store.normalReferenceFrame" } } }, read: false } })], ce.prototype, "normalReferenceFrame", void 0), e([y(p5)], ce.prototype, "screenSizePerspectiveEnabled", void 0), e([y({ json: { read: false, origins: { service: { read: true } } } })], ce.prototype, "serviceItemId", void 0), ce = e([c("esri.layers.SceneLayer")], ce);
var he = { "mesh-pyramids": "mesh-pyramids", meshpyramids: "mesh-pyramids", "features-meshes": "mesh-pyramids", points: "points", "features-points": "points", lines: "lines", "features-lines": "lines", polygons: "polygons", "features-polygons": "polygons" };
var fe = { "mesh-pyramids": "mesh", points: "point", lines: "polyline", polygons: "polygon" };
var me = ce;
export {
  me as default
};
//# sourceMappingURL=SceneLayer-XQHYGBIX.js.map
