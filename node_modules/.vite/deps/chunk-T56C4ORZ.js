import {
  A,
  B,
  D,
  G,
  L,
  M,
  P,
  U,
  V,
  c
} from "./chunk-RCLKRKWR.js";
import {
  n
} from "./chunk-MVXU4PVF.js";
import {
  o
} from "./chunk-MKW4ORPJ.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import {
  has
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/views/webgl/checkWebGLError.js
var o2 = s.getLogger("esri.views.webgl.checkWebGLError");
function t(e3, r2) {
  switch (r2) {
    case e3.INVALID_ENUM:
      return "Invalid Enum. An unacceptable value has been specified for an enumerated argument.";
    case e3.INVALID_VALUE:
      return "Invalid Value. A numeric argument is out of range.";
    case e3.INVALID_OPERATION:
      return "Invalid Operation. The specified command is not allowed for the current state.";
    case e3.INVALID_FRAMEBUFFER_OPERATION:
      return "Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";
    case e3.OUT_OF_MEMORY:
      return "Out of memory. Not enough memory is left to execute the command.";
    case e3.CONTEXT_LOST_WEBGL:
      return "WebGL context has been lost";
    default:
      return "Unknown error";
  }
}
var n2 = !!has("enable-feature:webgl-debug");
function a() {
  return n2;
}
function c2() {
  return n2;
}
function u(r2) {
  if (a()) {
    const n3 = r2.getError();
    if (n3) {
      const a4 = t(r2, n3), c3 = new Error().stack;
      o2.error(new s2("webgl-error", "WebGL error occurred", { message: a4, stack: c3 }));
    }
  }
}

// node_modules/@arcgis/core/views/webgl/GLObjectType.js
var e;
!function(e3) {
  e3[e3.Texture = 0] = "Texture", e3[e3.RenderBuffer = 1] = "RenderBuffer";
}(e || (e = {}));

// node_modules/@arcgis/core/views/webgl/Util.js
function a2(e3) {
  const r2 = e3.gl;
  switch (r2.getError()) {
    case r2.NO_ERROR:
      return null;
    case r2.INVALID_ENUM:
      return "An unacceptable value has been specified for an enumerated argument";
    case r2.INVALID_VALUE:
      return "An unacceptable value has been specified for an argument";
    case r2.INVALID_OPERATION:
      return "The specified command is not allowed for the current state";
    case r2.INVALID_FRAMEBUFFER_OPERATION:
      return "The currently bound framebuffer is not framebuffer complete";
    case r2.OUT_OF_MEMORY:
      return "Not enough memory is left to execute the command";
    case r2.CONTEXT_LOST_WEBGL:
      return "WebGL context is lost";
  }
  return "Unknown error";
}
function i(e3, r2, t2, s3, c3 = 0) {
  var _a, _b, _c;
  const a4 = e3.gl;
  e3.bindBuffer(t2);
  for (const n3 of s3) {
    const t3 = r2.get(n3.name);
    void 0 === t3 && console.error(`There is no location for vertex attribute '${n3.name}' defined.`);
    const s4 = c3 * n3.stride;
    if (n3.count <= 4)
      a4.vertexAttribPointer(t3, n3.count, n3.type, n3.normalized, n3.stride, n3.offset + s4), a4.enableVertexAttribArray(t3), n3.divisor > 0 && ((_a = e3.gl2) == null ? void 0 : _a.vertexAttribDivisor(t3, n3.divisor));
    else if (9 === n3.count)
      for (let r3 = 0; r3 < 3; r3++)
        a4.vertexAttribPointer(t3 + r3, 3, n3.type, n3.normalized, n3.stride, n3.offset + 12 * r3 + s4), a4.enableVertexAttribArray(t3 + r3), n3.divisor > 0 && ((_b = e3.gl2) == null ? void 0 : _b.vertexAttribDivisor(t3 + r3, n3.divisor));
    else if (16 === n3.count)
      for (let r3 = 0; r3 < 4; r3++)
        a4.vertexAttribPointer(t3 + r3, 4, n3.type, n3.normalized, n3.stride, n3.offset + 16 * r3 + s4), a4.enableVertexAttribArray(t3 + r3), n3.divisor > 0 && ((_c = e3.gl2) == null ? void 0 : _c.vertexAttribDivisor(t3 + r3, n3.divisor));
    else
      console.error("Unsupported vertex attribute element count: " + n3.count);
  }
}
function o3(r2, t2, s3, c3) {
  var _a, _b, _c;
  const a4 = r2.gl;
  r2.bindBuffer(s3);
  for (const e3 of c3) {
    const s4 = t2.get(e3.name);
    if (e3.count <= 4)
      a4.disableVertexAttribArray(s4), e3.divisor && e3.divisor > 0 && ((_a = r2.gl2) == null ? void 0 : _a.vertexAttribDivisor(s4, 0));
    else if (9 === e3.count)
      for (let t3 = 0; t3 < 3; t3++)
        a4.disableVertexAttribArray(s4 + t3), e3.divisor && e3.divisor > 0 && ((_b = r2.gl2) == null ? void 0 : _b.vertexAttribDivisor(s4 + t3, 0));
    else if (16 === e3.count)
      for (let t3 = 0; t3 < 4; t3++)
        a4.disableVertexAttribArray(s4 + t3), e3.divisor && e3.divisor > 0 && ((_c = r2.gl2) == null ? void 0 : _c.vertexAttribDivisor(s4 + t3, 0));
    else
      console.error("Unsupported vertex attribute element count: " + e3.count);
  }
  r2.unbindBuffer(A.ARRAY_BUFFER);
}
function E(e3) {
  switch (e3) {
    case G.ALPHA:
    case G.LUMINANCE:
    case G.RED:
    case G.RED_INTEGER:
    case P.R8:
    case P.R8I:
    case P.R8UI:
    case P.R8_SNORM:
    case B.STENCIL_INDEX8:
      return 1;
    case G.LUMINANCE_ALPHA:
    case G.RG:
    case G.RG_INTEGER:
    case P.RGBA4:
    case P.R16F:
    case P.R16I:
    case P.R16UI:
    case P.RG8:
    case P.RG8I:
    case P.RG8UI:
    case P.RG8_SNORM:
    case P.RGB565:
    case P.RGB5_A1:
    case B.DEPTH_COMPONENT16:
      return 2;
    case G.DEPTH_COMPONENT:
    case G.RGB:
    case G.RGB_INTEGER:
    case P.RGB8:
    case P.RGB8I:
    case P.RGB8UI:
    case P.RGB8_SNORM:
    case P.SRGB8:
    case B.DEPTH_COMPONENT24:
      return 3;
    case G.DEPTH_STENCIL:
    case G.DEPTH24_STENCIL8:
    case G.RGBA:
    case G.RGBA_INTEGER:
    case P.RGBA8:
    case P.R32F:
    case P.R11F_G11F_B10F:
    case P.RG16F:
    case P.R32I:
    case P.R32UI:
    case P.RG16I:
    case P.RG16UI:
    case P.RGBA8I:
    case P.RGBA8UI:
    case P.RGBA8_SNORM:
    case P.SRGB8_ALPHA8:
    case P.RGB9_E5:
    case P.RGB10_A2UI:
    case P.RGB10_A2:
    case B.DEPTH_STENCIL:
    case B.DEPTH_COMPONENT32F:
    case B.DEPTH24_STENCIL8:
      return 4;
    case B.DEPTH32F_STENCIL8:
      return 5;
    case P.RGB16F:
    case P.RGB16I:
    case P.RGB16UI:
      return 6;
    case P.RG32F:
    case P.RG32I:
    case P.RG32UI:
    case P.RGBA16F:
    case P.RGBA16I:
    case P.RGBA16UI:
      return 8;
    case P.RGB32F:
    case P.RGB32I:
    case P.RGB32UI:
      return 12;
    case P.RGBA32F:
    case P.RGBA32I:
    case P.RGBA32UI:
      return 16;
    case c.COMPRESSED_RGB_S3TC_DXT1_EXT:
    case c.COMPRESSED_RGBA_S3TC_DXT1_EXT:
      return 0.5;
    case c.COMPRESSED_RGBA_S3TC_DXT3_EXT:
    case c.COMPRESSED_RGBA_S3TC_DXT5_EXT:
      return 1;
    case c.COMPRESSED_R11_EAC:
    case c.COMPRESSED_SIGNED_R11_EAC:
    case c.COMPRESSED_RGB8_ETC2:
    case c.COMPRESSED_SRGB8_ETC2:
    case c.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
    case c.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:
      return 0.5;
    case c.COMPRESSED_RG11_EAC:
    case c.COMPRESSED_SIGNED_RG11_EAC:
    case c.COMPRESSED_RGBA8_ETC2_EAC:
    case c.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:
      return 1;
  }
  return 0;
}

// node_modules/@arcgis/core/views/webgl/TextureDescriptor.js
var e2 = class {
  constructor(p = 0, e3 = p) {
    this.width = p, this.height = e3, this.target = M.TEXTURE_2D, this.pixelFormat = G.RGBA, this.dataType = U.UNSIGNED_BYTE, this.samplingMode = L.LINEAR, this.wrapMode = D.REPEAT, this.maxAnisotropy = 1, this.flipped = false, this.hasMipmap = false, this.isOpaque = false, this.unpackAlignment = 4, this.preMultiplyAlpha = false, this.depth = 1, this.isImmutable = false;
  }
};
function r(t2) {
  return t2.width <= 0 || t2.height <= 0 ? 0 : t2.width * t2.height * (t2.hasMipmap ? 4 / 3 : 1) * (null == t2.internalFormat ? 4 : E(t2.internalFormat));
}

// node_modules/@arcgis/core/views/webgl/ValidatedTextureDescriptor.js
var a3 = class _a extends e2 {
  constructor(t2, a4) {
    switch (super(), this.context = t2, Object.assign(this, a4), this.internalFormat) {
      case P.R16F:
      case P.R16I:
      case P.R16UI:
      case P.R32F:
      case P.R32I:
      case P.R32UI:
      case P.R8_SNORM:
      case P.R8:
      case P.R8I:
      case P.R8UI:
        this.pixelFormat = G.RED;
    }
  }
  static validate(s3, e3) {
    return new _a(s3, e3);
  }
};

// node_modules/@arcgis/core/views/webgl/Texture.js
var u2 = 4;
var T = class {
  constructor(e3, i2 = null, o4 = null) {
    if (this.type = e.Texture, this._glName = null, this._samplingModeDirty = false, this._wrapModeDirty = false, this._wasImmutablyAllocated = false, "context" in e3)
      this._descriptor = e3, o4 = i2;
    else {
      const r2 = a3.validate(e3, i2);
      if (!r2)
        throw new s2("Texture descriptor invalid");
      this._descriptor = r2;
    }
    if (this._descriptor.context.type !== n.WEBGL2 && (this._descriptor.isImmutable && (this._descriptor.isImmutable = false), R(this._descriptor.target)))
      throw new s2("3D and array textures are not supported in WebGL1");
    this._descriptor.target === M.TEXTURE_CUBE_MAP ? this._setDataCubeMap(o4) : this.setData(o4);
  }
  get glName() {
    return this._glName;
  }
  get descriptor() {
    return this._descriptor;
  }
  get gpuMemoryUsage() {
    return P2.delete(this), r(this._descriptor);
  }
  get isDirty() {
    return this._samplingModeDirty || this._wrapModeDirty;
  }
  dispose() {
    this._glName && this._descriptor.context.instanceCounter.decrement(V.Texture, this), this._descriptor.context.gl && this._glName && (this._descriptor.context.unbindTexture(this), this._descriptor.context.gl.deleteTexture(this._glName), this._glName = null);
  }
  release() {
    this.dispose();
  }
  resize(e3, i2) {
    const r2 = this._descriptor;
    if (r2.width !== e3 || r2.height !== i2) {
      if (this._wasImmutablyAllocated)
        throw new s2("Immutable textures can't be resized!");
      r2.width = e3, r2.height = i2, this._descriptor.target === M.TEXTURE_CUBE_MAP ? this._setDataCubeMap(null) : this.setData(null);
    }
  }
  _setDataCubeMap(t2 = null) {
    for (let e3 = M.TEXTURE_CUBE_MAP_POSITIVE_X; e3 <= M.TEXTURE_CUBE_MAP_NEGATIVE_Z; e3++)
      this._setData(t2, e3);
  }
  setData(t2) {
    this._setData(t2);
  }
  _setData(e3, r2) {
    var _a;
    if (!((_a = this._descriptor.context) == null ? void 0 : _a.gl))
      return;
    const s3 = this._descriptor.context.gl;
    u(s3), this._glName || (this._glName = s3.createTexture(), this._glName && this._descriptor.context.instanceCounter.increment(V.Texture, this)), void 0 === e3 && (e3 = null);
    const a4 = this._descriptor, n3 = r2 ?? a4.target, h = R(n3);
    null === e3 && (a4.width = a4.width || u2, a4.height = a4.height || u2, h && (a4.depth = a4.depth ?? 1));
    const p = this._descriptor.context.bindTexture(this, T.TEXTURE_UNIT_FOR_UPDATES);
    this._descriptor.context.setActiveTexture(T.TEXTURE_UNIT_FOR_UPDATES), g(this._descriptor.context, a4), this._configurePixelStorage(), u(s3);
    const l = this._deriveInternalFormat();
    if (D2(e3)) {
      let t2 = "width" in e3 ? e3.width : e3.codedWidth, r3 = "height" in e3 ? e3.height : e3.codedHeight;
      const o4 = 1;
      e3 instanceof HTMLVideoElement && (t2 = e3.videoWidth, r3 = e3.videoHeight), a4.width && a4.height, h && a4.depth, a4.isImmutable && !this._wasImmutablyAllocated && this._texStorage(n3, l, a4.hasMipmap, t2, r3, o4), this._texImage(n3, 0, l, t2, r3, o4, e3), u(s3), a4.hasMipmap && this.generateMipmap(), a4.width || (a4.width = t2), a4.height || (a4.height = r3), h && !a4.depth && (a4.depth = o4);
    } else {
      const { width: r3, height: o4, depth: p2 } = a4;
      if (null == r3 || null == o4)
        throw new s2("Width and height must be specified!");
      if (h && null == p2)
        throw new s2("Depth must be specified!");
      if (a4.isImmutable && !this._wasImmutablyAllocated && this._texStorage(n3, l, a4.hasMipmap, r3, o4, p2), A2(e3)) {
        const i2 = e3.levels, h2 = b(n3, r3, o4, p2), d = Math.min(h2 - 1, i2.length - 1);
        null != this._descriptor.context.gl2 ? s3.texParameteri(a4.target, this._descriptor.context.gl2.TEXTURE_MAX_LEVEL, d) : a4.hasMipmap = a4.hasMipmap && h2 === i2.length;
        const c3 = l;
        if (!w(c3))
          throw new s2("Attempting to use compressed data with an uncompressed format!");
        this._forEachMipmapLevel((t2, e4, r4, s4) => {
          const o5 = i2[Math.min(t2, i2.length - 1)];
          this._compressedTexImage(n3, t2, c3, e4, r4, s4, o5);
        }, d);
      } else
        this._texImage(n3, 0, l, r3, o4, p2, e3), u(s3), a4.hasMipmap && this.generateMipmap();
    }
    x(s3, this._descriptor), E2(s3, this._descriptor), f(this._descriptor.context, this._descriptor), u(s3), this._descriptor.context.bindTexture(p, T.TEXTURE_UNIT_FOR_UPDATES);
  }
  updateData(e3, i2, r2, s3, o4, a4, n3 = 0) {
    a4 || console.error("An attempt to use uninitialized data!"), this._glName || console.error("An attempt to update uninitialized texture!");
    const h = this._descriptor.context.gl, p = this._descriptor.context.gl2, l = this._descriptor, d = this._deriveInternalFormat(), { pixelFormat: c3, dataType: _, target: m, isImmutable: u3 } = l;
    if (u3 && !this._wasImmutablyAllocated)
      throw new s2("Cannot update immutable texture before allocation!");
    const g2 = this._descriptor.context.bindTexture(this, T.TEXTURE_UNIT_FOR_UPDATES, true);
    if ((i2 < 0 || r2 < 0 || s3 > l.width || o4 > l.height || i2 + s3 > l.width || r2 + o4 > l.height) && console.error("An attempt to update out of bounds of the texture!"), this._configurePixelStorage(), n3) {
      if (!p)
        return void console.error("Webgl2 must be enabled to use dataRowOffset!");
      h.pixelStorei(p.UNPACK_SKIP_ROWS, n3);
    }
    if (D2(a4) ? p ? p.texSubImage2D(m, e3, i2, r2, s3, o4, c3, _, a4) : h.texSubImage2D(m, e3, i2, r2, c3, _, a4) : A2(a4) ? h.compressedTexSubImage2D(m, e3, i2, r2, s3, o4, d, a4.levels[e3]) : h.texSubImage2D(m, e3, i2, r2, s3, o4, c3, _, a4), n3) {
      if (!p)
        return void console.error("Webgl2 must be enabled to use dataRowOffset!");
      h.pixelStorei(p.UNPACK_SKIP_ROWS, 0);
    }
    this._descriptor.context.bindTexture(g2, T.TEXTURE_UNIT_FOR_UPDATES);
  }
  updateData3D(e3, i2, r2, s3, o4, a4, n3, h) {
    h || console.error("An attempt to use uninitialized data!"), this._glName || console.error("An attempt to update uninitialized texture!");
    const p = this._descriptor.context.gl2;
    if (null == p)
      throw new s2("3D textures are not supported in WebGL1");
    const l = this._descriptor, d = this._deriveInternalFormat(), { pixelFormat: c3, dataType: _, isImmutable: m, target: u3 } = l;
    if (m && !this._wasImmutablyAllocated)
      throw new s2("Cannot update immutable texture before allocation!");
    R(u3) || console.warn("Attempting to set 3D texture data on a non-3D texture");
    const g2 = this._descriptor.context.bindTexture(this, T.TEXTURE_UNIT_FOR_UPDATES);
    if (this._descriptor.context.setActiveTexture(T.TEXTURE_UNIT_FOR_UPDATES), (i2 < 0 || r2 < 0 || s3 < 0 || o4 > l.width || a4 > l.height || n3 > l.depth || i2 + o4 > l.width || r2 + a4 > l.height || s3 + n3 > l.depth) && console.error("An attempt to update out of bounds of the texture!"), this._configurePixelStorage(), A2(h))
      h = h.levels[e3], p.compressedTexSubImage3D(u3, e3, i2, r2, s3, o4, a4, n3, d, h);
    else {
      const t2 = h;
      p.texSubImage3D(u3, e3, i2, r2, s3, o4, a4, n3, c3, _, t2);
    }
    this._descriptor.context.bindTexture(g2, T.TEXTURE_UNIT_FOR_UPDATES);
  }
  generateMipmap() {
    const e3 = this._descriptor;
    if (!e3.hasMipmap) {
      if (this._wasImmutablyAllocated)
        throw new s2("Cannot add mipmaps to immutable texture after allocation");
      e3.hasMipmap = true, this._samplingModeDirty = true, g(this._descriptor.context, e3);
    }
    e3.samplingMode === L.LINEAR ? (this._samplingModeDirty = true, e3.samplingMode = L.LINEAR_MIPMAP_NEAREST) : e3.samplingMode === L.NEAREST && (this._samplingModeDirty = true, e3.samplingMode = L.NEAREST_MIPMAP_NEAREST);
    const i2 = this._descriptor.context.bindTexture(this, T.TEXTURE_UNIT_FOR_UPDATES);
    this._descriptor.context.setActiveTexture(T.TEXTURE_UNIT_FOR_UPDATES);
    this._descriptor.context.gl.generateMipmap(e3.target), this._descriptor.context.bindTexture(i2, T.TEXTURE_UNIT_FOR_UPDATES);
  }
  setSamplingMode(t2) {
    t2 !== this._descriptor.samplingMode && (this._descriptor.samplingMode = t2, this._samplingModeDirty = true);
  }
  setWrapMode(t2) {
    t2 !== this._descriptor.wrapMode && (this._descriptor.wrapMode = t2, g(this._descriptor.context, this._descriptor), this._wrapModeDirty = true);
  }
  applyChanges() {
    const t2 = this._descriptor.context.gl, e3 = this._descriptor;
    this._samplingModeDirty && (x(t2, e3), this._samplingModeDirty = false), this._wrapModeDirty && (E2(t2, e3), this._wrapModeDirty = false);
  }
  _deriveInternalFormat() {
    if (this._descriptor.context.type === n.WEBGL1)
      return this._descriptor.internalFormat = this._descriptor.pixelFormat;
    if (null != this._descriptor.internalFormat)
      return this._descriptor.internalFormat === G.DEPTH_STENCIL && (this._descriptor.internalFormat = G.DEPTH24_STENCIL8), this._descriptor.internalFormat;
    switch (this._descriptor.dataType) {
      case U.FLOAT:
        switch (this._descriptor.pixelFormat) {
          case G.RGBA:
            return this._descriptor.internalFormat = P.RGBA32F;
          case G.RGB:
            return this._descriptor.internalFormat = P.RGB32F;
          default:
            throw new s2("Unable to derive format");
        }
      case U.UNSIGNED_BYTE:
        switch (this._descriptor.pixelFormat) {
          case G.RGBA:
            return this._descriptor.internalFormat = P.RGBA8;
          case G.RGB:
            return this._descriptor.internalFormat = P.RGB8;
        }
    }
    return this._descriptor.internalFormat = this._descriptor.pixelFormat === G.DEPTH_STENCIL ? G.DEPTH24_STENCIL8 : this._descriptor.pixelFormat;
  }
  _configurePixelStorage() {
    const t2 = this._descriptor.context.gl, { unpackAlignment: e3, flipped: i2, preMultiplyAlpha: r2 } = this._descriptor;
    t2.pixelStorei(t2.UNPACK_ALIGNMENT, e3), t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, i2 ? 1 : 0), t2.pixelStorei(t2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r2 ? 1 : 0);
  }
  _texStorage(e3, i2, r2, s3, o4, a4) {
    const n3 = this._descriptor.context.gl2;
    if (null == n3)
      throw new s2("Immutable textures are not supported in WebGL1");
    if (!M2(i2))
      throw new s2("Immutable textures must have a sized internal format");
    if (!this._descriptor.isImmutable)
      return;
    const h = r2 ? b(e3, s3, o4, a4) : 1;
    if (R(e3)) {
      if (null == a4)
        throw new s2("Missing depth dimension for 3D texture upload");
      n3.texStorage3D(e3, h, i2, s3, o4, a4);
    } else
      n3.texStorage2D(e3, h, i2, s3, o4);
    this._wasImmutablyAllocated = true;
  }
  _texImage(e3, i2, s3, o4, a4, n3, h) {
    const p = this._descriptor.context.gl, l = R(e3), { isImmutable: d, pixelFormat: c3, dataType: _ } = this._descriptor, m = this._descriptor.context.type === n.WEBGL2, u3 = m ? p : null;
    if (m || !D2(h))
      if (d) {
        if (null != h) {
          const r2 = h;
          if (l) {
            if (null == n3)
              throw new s2("Missing depth dimension for 3D texture upload");
            u3.texSubImage3D(e3, i2, 0, 0, 0, o4, a4, n3, c3, _, r2);
          } else
            p.texSubImage2D(e3, i2, 0, 0, o4, a4, c3, _, r2);
        }
      } else {
        const r2 = h;
        if (l) {
          if (null == n3)
            throw new s2("Missing depth dimension for 3D texture upload");
          u3.texImage3D(e3, i2, s3, o4, a4, n3, 0, c3, _, r2);
        } else
          p.texImage2D(e3, i2, s3, o4, a4, 0, c3, _, r2);
      }
    else
      p.texImage2D(e3, 0, s3, c3, _, h);
  }
  _compressedTexImage(e3, i2, s3, o4, a4, n3, h) {
    const p = this._descriptor.context.gl;
    let l = null;
    const d = R(e3), c3 = this._descriptor.isImmutable;
    if (d) {
      if (this._descriptor.context.type !== n.WEBGL2)
        throw new s2("3D textures are not supported in WebGL1");
      l = p;
    }
    if (c3) {
      if (null != h)
        if (d) {
          if (null == n3)
            throw new s2("Missing depth dimension for 3D texture upload");
          l.compressedTexSubImage3D(e3, i2, 0, 0, 0, o4, a4, n3, s3, h);
        } else
          p.compressedTexSubImage2D(e3, i2, 0, 0, o4, a4, s3, h);
    } else if (d) {
      if (null == n3)
        throw new s2("Missing depth dimension for 3D texture upload");
      l.compressedTexImage3D(e3, i2, s3, o4, a4, n3, 0, h);
    } else
      p.compressedTexImage2D(e3, i2, s3, o4, a4, 0, h);
  }
  _forEachMipmapLevel(e3, i2 = 1 / 0) {
    let { width: r2, height: o4, depth: a4, hasMipmap: n3, target: h } = this._descriptor;
    const p = h === M.TEXTURE_3D;
    if (null == r2 || null == o4 || p && null == a4)
      throw new s2("Missing texture dimensions for mipmap calculation");
    for (let t2 = 0; e3(t2, r2, o4, a4), n3 && (1 !== r2 || 1 !== o4 || p && 1 !== a4) && !(t2 >= i2); ++t2)
      r2 = Math.max(1, r2 >> 1), o4 = Math.max(1, o4 >> 1), p && (a4 = Math.max(1, a4 >> 1));
  }
};
function g(t2, i2) {
  (null != i2.width && i2.width < 0 || null != i2.height && i2.height < 0 || null != i2.depth && i2.depth < 0) && console.error("Negative dimension parameters are not allowed!");
  const s3 = t2.type === n.WEBGL2;
  if (s3 || !i2.isImmutable && !R(i2.target) || console.error("Immutable and 3D-like textures are not supported in WebGL1!"), s3)
    return;
  null != i2.width && o(i2.width) && null != i2.height && o(i2.height) || ("number" == typeof i2.wrapMode ? i2.wrapMode !== D.CLAMP_TO_EDGE && console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!") : i2.wrapMode.s === D.CLAMP_TO_EDGE && i2.wrapMode.t === D.CLAMP_TO_EDGE || console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"), i2.hasMipmap && console.error("Mipmapping requires power-of-two textures!"));
}
function x(t2, e3) {
  let i2 = e3.samplingMode, r2 = e3.samplingMode;
  i2 === L.LINEAR_MIPMAP_NEAREST || i2 === L.LINEAR_MIPMAP_LINEAR ? (i2 = L.LINEAR, e3.hasMipmap || (r2 = L.LINEAR)) : i2 !== L.NEAREST_MIPMAP_NEAREST && i2 !== L.NEAREST_MIPMAP_LINEAR || (i2 = L.NEAREST, e3.hasMipmap || (r2 = L.NEAREST)), t2.texParameteri(e3.target, t2.TEXTURE_MAG_FILTER, i2), t2.texParameteri(e3.target, t2.TEXTURE_MIN_FILTER, r2);
}
function E2(t2, e3) {
  "number" == typeof e3.wrapMode ? (t2.texParameteri(e3.target, t2.TEXTURE_WRAP_S, e3.wrapMode), t2.texParameteri(e3.target, t2.TEXTURE_WRAP_T, e3.wrapMode)) : (t2.texParameteri(e3.target, t2.TEXTURE_WRAP_S, e3.wrapMode.s), t2.texParameteri(e3.target, t2.TEXTURE_WRAP_T, e3.wrapMode.t));
}
function f(t2, e3) {
  const i2 = t2.capabilities.textureFilterAnisotropic;
  if (!i2)
    return;
  t2.gl.texParameterf(e3.target, i2.TEXTURE_MAX_ANISOTROPY, e3.maxAnisotropy ?? 1);
}
function M2(t2) {
  return t2 in P;
}
function w(t2) {
  return t2 in c;
}
function A2(t2) {
  return null != t2 && "type" in t2 && "compressed" === t2.type;
}
function I(t2) {
  return null != t2 && "byteLength" in t2;
}
function D2(t2) {
  return null != t2 && !A2(t2) && !I(t2);
}
function R(t2) {
  return t2 === M.TEXTURE_3D || t2 === M.TEXTURE_2D_ARRAY;
}
function b(t2, e3, i2, r2 = 1) {
  let o4 = Math.max(e3, i2);
  return t2 === M.TEXTURE_3D && (o4 = Math.max(o4, r2)), Math.round(Math.log(o4) / Math.LN2) + 1;
}
T.TEXTURE_UNIT_FOR_UPDATES = 0;
var P2 = /* @__PURE__ */ new Map();

export {
  a,
  c2 as c,
  u,
  e,
  a2,
  i,
  o3 as o,
  E,
  e2,
  T
};
//# sourceMappingURL=chunk-T56C4ORZ.js.map
