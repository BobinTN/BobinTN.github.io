import {
  L,
  c as c4
} from "./chunk-SD4PEUIA.js";
import {
  m as m3,
  o as o4,
  t as t2
} from "./chunk-TOWKJZW4.js";
import {
  m as m2
} from "./chunk-SLEGPWAA.js";
import {
  n as n3,
  r as r3,
  s as s2
} from "./chunk-GLOKOXWD.js";
import {
  e as e4,
  o as o2
} from "./chunk-4OLZTDWK.js";
import {
  v,
  x,
  y as y2
} from "./chunk-JYYKU27J.js";
import {
  e as e5
} from "./chunk-SKLWU2B3.js";
import {
  e as e3
} from "./chunk-2RN2AAP7.js";
import {
  T,
  i
} from "./chunk-YHB3DQSV.js";
import {
  B as B2,
  a,
  g,
  o as o3
} from "./chunk-YVNEJWNQ.js";
import {
  i as i2
} from "./chunk-WJ4LS3YG.js";
import {
  B,
  C as C2,
  P,
  c as c3,
  f as f4,
  h
} from "./chunk-F6MD5VOH.js";
import {
  o
} from "./chunk-V2RPSCV3.js";
import {
  D
} from "./chunk-4HKQSEUR.js";
import {
  n as n2
} from "./chunk-ZB6PGKG5.js";
import {
  M,
  m
} from "./chunk-MKW4ORPJ.js";
import {
  F,
  O,
  O2,
  S,
  _,
  b,
  e as e2,
  f as f3,
  n,
  r,
  r2,
  t,
  z
} from "./chunk-YTH6VA7N.js";
import {
  f as f2
} from "./chunk-QNOCEWCR.js";
import {
  C,
  V,
  c as c2,
  j,
  p
} from "./chunk-HLGIRLYQ.js";
import {
  f
} from "./chunk-NSRXJNTS.js";
import {
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  s2 as s
} from "./chunk-WJ3HJKNC.js";

// node_modules/@arcgis/core/geometry/support/MeshGeoreferencedVertexSpace.js
var c5 = class extends i2(f) {
  constructor() {
    super({}), this.type = "georeferenced", this.isRelative = false, this.isGeoreferenced = true;
  }
};
e([o({ georeferenced: "georeferenced" }, { readOnly: true })], c5.prototype, "type", void 0), c5 = e([c("esri.geometry.support.MeshGeoreferencedVertexSpace")], c5);
var p2 = c5;

// node_modules/@arcgis/core/geometry/support/axisAngleDegrees.js
function h2(n4 = z2) {
  return [n4[0], n4[1], n4[2], n4[3]];
}
function q(n4, r5, t3 = h2()) {
  return r2(l(t3), n4), t3[3] = r5, t3;
}
function U(r5, s3, c6 = h2()) {
  return v(A, l(r5), w(r5)), v(B3, l(s3), w(s3)), y2(A, B3, A), y3(c6, m(x(l(c6), A)));
}
function g2(n4, r5, t3, u = h2()) {
  return q(_, n4, D2), q(O, r5, E), q(b, t3, F2), U(D2, E, D2), U(D2, F2, u), u;
}
function l(n4) {
  return n4;
}
function x2(n4) {
  return n4[3];
}
function w(n4) {
  return M(n4[3]);
}
function y3(n4, r5) {
  return n4[3] = r5, n4;
}
var z2 = [0, 0, 1, 0];
var A = e5();
var B3 = e5();
var C3 = h2();
var D2 = h2();
var E = h2();
var F2 = h2();

// node_modules/@arcgis/core/geometry/support/MeshTransform.js
var v2;
var b2 = v2 = class extends f {
  constructor(t3) {
    super(t3), this.translation = n(), this.rotationAxis = e2(z2), this.rotationAngle = 0, this.scale = r(1, 1, 1);
  }
  get rotation() {
    return q(this.rotationAxis, this.rotationAngle);
  }
  set rotation(t3) {
    this.rotationAxis = t(l(t3)), this.rotationAngle = x2(t3);
  }
  get localMatrix() {
    const t3 = e4();
    return v(M2, l(this.rotation), w(this.rotation)), P(t3, M2, this.translation, this.scale), t3;
  }
  get localMatrixInverse() {
    return h(e4(), this.localMatrix);
  }
  applyLocal(t3, o6) {
    return O2(o6, t3, this.localMatrix);
  }
  applyLocalInverse(t3, o6) {
    return O2(o6, t3, this.localMatrixInverse);
  }
  equals(t3) {
    return this === t3 || null != t3 && B(this.localMatrix, t3.localMatrix);
  }
  clone() {
    const t3 = { translation: t(this.translation), rotationAxis: t(this.rotationAxis), rotationAngle: this.rotationAngle, scale: t(this.scale) };
    return new v2(t3);
  }
};
e([y({ type: [Number], nonNullable: true, json: { write: true } })], b2.prototype, "translation", void 0), e([y({ type: [Number], nonNullable: true, json: { write: true } })], b2.prototype, "rotationAxis", void 0), e([y({ type: Number, nonNullable: true, json: { write: true } })], b2.prototype, "rotationAngle", void 0), e([y({ type: [Number], nonNullable: true, json: { write: true } })], b2.prototype, "scale", void 0), e([y()], b2.prototype, "rotation", null), e([y()], b2.prototype, "localMatrix", null), e([y()], b2.prototype, "localMatrixInverse", null), b2 = v2 = e([c("esri.geometry.support.MeshTransform")], b2);
var M2 = e5();
var N = b2;

// node_modules/@arcgis/core/geometry/support/meshUtils/geographicUtils.js
function r4(e6, r5) {
  return e6.isGeographic || e6.isWebMercator && ((r5 == null ? void 0 : r5.geographic) ?? true);
}
function o5(r5, o6, g4) {
  const i3 = !r5.isGeoreferenced;
  null != (g4 == null ? void 0 : g4.geographic) && g4.geographic !== i3 && s.getLogger(o6).warnOnce(`Specifying the 'geographic' parameter (${g4.geographic}) for a Mesh vertex space of type "${r5.type}" is not supported. This parameter will be ignored.`);
}

// node_modules/@arcgis/core/geometry/support/meshUtils/projection.js
var g3 = s.getLogger("esri.geometry.support.meshUtils.normalProjection");
function j2(r5, e6, o6, t3, n4) {
  return k2(t3) ? (V2(U2.TO_PCPF, i.fromTypedArray(r5), T.fromTypedArray(e6), T.fromTypedArray(o6), t3, i.fromTypedArray(n4)), n4) : (g3.error("Cannot convert spatial reference to PCPF"), n4);
}
function _3(r5, e6, o6, t3, n4) {
  return k2(t3) ? (V2(U2.FROM_PCPF, i.fromTypedArray(r5), T.fromTypedArray(e6), T.fromTypedArray(o6), t3, i.fromTypedArray(n4)), n4) : (g3.error("Cannot convert to spatial reference from PCPF"), n4);
}
function h3(r5, e6, o6) {
  return n2(r5, e6, 0, o6, c4(e6), 0, r5.length / 3), o6;
}
function O3(r5, e6, o6) {
  return n2(r5, c4(o6), 0, e6, o6, 0, r5.length / 3), e6;
}
function E2(r5, t3, n4) {
  return g(N2, n4), n3(t3, r5, N2), B2(N2) || s2(t3, t3), t3;
}
function M3(r5, t3, n4) {
  if (g(N2, n4), n3(t3, r5, N2, 4), B2(N2) || s2(t3, t3, 4), r5 !== t3)
    for (let e6 = 3; e6 < r5.length; e6 += 4)
      t3[e6] = r5[e6];
  return t3;
}
function R(r5, e6, o6, t3, n4) {
  if (!k2(t3))
    return g3.error("Cannot convert spatial reference to PCPF"), n4;
  V2(U2.TO_PCPF, i.fromTypedArray(r5, 4 * Float32Array.BYTES_PER_ELEMENT), T.fromTypedArray(e6), T.fromTypedArray(o6), t3, i.fromTypedArray(n4, 4 * Float32Array.BYTES_PER_ELEMENT));
  for (let f5 = 3; f5 < r5.length; f5 += 4)
    n4[f5] = r5[f5];
  return n4;
}
function v3(r5, e6, o6, t3, n4) {
  if (!k2(t3))
    return g3.error("Cannot convert to spatial reference from PCPF"), n4;
  V2(U2.FROM_PCPF, i.fromTypedArray(r5, 16), T.fromTypedArray(e6), T.fromTypedArray(o6), t3, i.fromTypedArray(n4, 16));
  for (let f5 = 3; f5 < r5.length; f5 += 4)
    n4[f5] = r5[f5];
  return n4;
}
function V2(r5, e6, o6, f5, a2, c6) {
  if (!e6)
    return;
  const u = o6.count, y4 = c4(a2);
  if (B4(a2))
    for (let s3 = 0; s3 < u; s3++)
      f5.getVec(s3, b3), e6.getVec(s3, S2), L(y4, b3, w2, y4), a(N2, w2), r5 === U2.FROM_PCPF && o3(N2, N2), S(S2, S2, N2), c6.setVec(s3, S2);
  else
    for (let m4 = 0; m4 < u; m4++) {
      f5.getVec(m4, b3), e6.getVec(m4, S2), L(y4, b3, w2, y4), a(N2, w2);
      const a3 = f2(o6.get(m4, 1));
      let u2 = Math.cos(a3);
      r5 === U2.TO_PCPF && (u2 = 1 / u2), N2[0] *= u2, N2[1] *= u2, N2[2] *= u2, N2[3] *= u2, N2[4] *= u2, N2[5] *= u2, r5 === U2.FROM_PCPF && o3(N2, N2), S(S2, S2, N2), z(S2, S2), c6.setVec(m4, S2);
    }
  return c6;
}
function k2(r5) {
  return B4(r5) || L2(r5);
}
function B4(r5) {
  return r5.isWGS84 || C(r5) || c2(r5) || p(r5);
}
function L2(r5) {
  return r5.isWebMercator;
}
var U2;
!function(r5) {
  r5[r5.TO_PCPF = 0] = "TO_PCPF", r5[r5.FROM_PCPF = 1] = "FROM_PCPF";
}(U2 || (U2 = {}));
var b3 = n();
var S2 = n();
var w2 = e4();
var N2 = e3();

// node_modules/@arcgis/core/geometry/support/meshUtils/georeference.js
function U3(n4, t3, e6) {
  return r4(t3.spatialReference, e6) ? W(n4, t3, e6) : L3(n4, t3, e6);
}
function V3(n4, t3 = o2) {
  const { position: e6, normal: r5, tangent: o6 } = n4;
  return { position: r3(new Float64Array(e6.length), e6, t3), normal: null != r5 ? E2(r5, new Float32Array(r5.length), t3) : null, tangent: null != o6 ? M3(o6, new Float32Array(o6.length), t3) : null };
}
function q2(n4, t3, e6, r5) {
  const { position: o6, normal: i3, tangent: a2 } = n4;
  if (!t3.isRelative)
    return { position: o6, normal: i3, tangent: a2 };
  return U3(V3(n4, e6 == null ? void 0 : e6.localMatrix), t3.getOriginPoint(r5), { geographic: !t3.isGeoreferenced });
}
function B5(n4, t3, e6) {
  if (e6 == null ? void 0 : e6.useTransform) {
    const { position: r5, normal: o6, tangent: i3 } = n4, { x: a2, y: s3, z: l2 } = t3, c6 = r(a2, s3, l2 ?? 0);
    return { vertexAttributes: { position: r5, normal: o6, tangent: i3 }, vertexSpace: e6.geographic ?? 1 ? new m3({ origin: c6 }) : new m2({ origin: c6 }), transform: new N() };
  }
  return { vertexAttributes: U3(n4, t3, e6), vertexSpace: new p2(), transform: null };
}
function D3(n4, t3, e6) {
  return r4(t3.spatialReference, e6) ? K(n4, t3, e6) : J(n4, t3, e6);
}
function E3(n4, t3, e6, r5, o6) {
  if (!t3.isRelative)
    return D3(n4, r5, o6);
  const { spatialReference: i3 } = r5, a2 = q2(n4, t3, e6, i3);
  return r5.equals(t3.getOriginPoint(i3)) ? J(a2, r5, o6) : D3(a2, r5, o6);
}
function I({ positions: n4, transform: t3, vertexSpace: e6, inSpatialReference: i3, outSpatialReference: a2, outPositions: l2, localMode: f5 }) {
  const p3 = e6.isRelative ? e6.origin : f3, w3 = e6.isRelative ? (t3 == null ? void 0 : t3.localMatrix) ?? o2 : o2;
  if (e6.isGeoreferenced) {
    const t4 = l2 ?? t2(n4.length);
    if (C2(w3, o2) ? o4(t4, n4) : r3(t4, n4, w3), !F(p3, f3)) {
      const [n5, e7, r5] = p3;
      for (let o6 = 0; o6 < t4.length; o6 += 3)
        t4[o6] += n5, t4[o6 + 1] += e7, t4[o6 + 2] += r5;
    }
    return n2(t4, i3, 0, t4, a2, 0, t4.length / 3), t4;
  }
  let A2 = i3;
  const x3 = c4(i3);
  A2 = a2.isWebMercator && f5 || !D(i3, x3) ? A2 : x3, L(i3, p3, _4, A2), c3(_4, _4, w3);
  const v4 = l2 ?? t2(n4.length);
  return r3(v4, n4, _4), n2(v4, A2, 0, v4, a2, 0, v4.length / 3), v4;
}
function L3(n4, t3, e6) {
  const r5 = new Float64Array(n4.position.length), o6 = n4.position, i3 = t3.x, a2 = t3.y, s3 = t3.z ?? 0, l2 = $(e6 ? e6.unit : null, t3.spatialReference);
  for (let c6 = 0; c6 < o6.length; c6 += 3)
    r5[c6] = o6[c6] * l2 + i3, r5[c6 + 1] = o6[c6 + 1] * l2 + a2, r5[c6 + 2] = o6[c6 + 2] * l2 + s3;
  return { position: r5, normal: n4.normal, tangent: n4.tangent };
}
function W(n4, t3, e6) {
  const r5 = t3.spatialReference, o6 = N3(t3, e6, _4), i3 = new Float64Array(n4.position.length), a2 = Z(n4.position, o6, r5, i3), s3 = g(tn, o6);
  return { position: a2, normal: C4(a2, i3, n4.normal, s3, r5), tangent: H(a2, i3, n4.tangent, s3, r5) };
}
function Z(n4, t3, e6, r5) {
  r3(r5, n4, t3);
  const o6 = new Float64Array(n4.length);
  return O3(r5, o6, e6);
}
function C4(n4, t3, e6, r5, o6) {
  if (null == e6)
    return null;
  const i3 = new Float32Array(e6.length);
  return n3(i3, e6, r5), _3(i3, n4, t3, o6, i3), i3;
}
function H(n4, t3, e6, r5, o6) {
  if (null == e6)
    return null;
  const i3 = new Float32Array(e6.length);
  n3(i3, e6, r5, 4);
  for (let a2 = 3; a2 < i3.length; a2 += 4)
    i3[a2] = e6[a2];
  return v3(i3, n4, t3, o6, i3), i3;
}
function J(n4, t3, e6) {
  const r5 = new Float64Array(n4.position.length), o6 = n4.position, i3 = t3.x, a2 = t3.y, s3 = t3.z ?? 0, l2 = $(e6 ? e6.unit : null, t3.spatialReference);
  for (let c6 = 0; c6 < o6.length; c6 += 3)
    r5[c6] = (o6[c6] - i3) / l2, r5[c6 + 1] = (o6[c6 + 1] - a2) / l2, r5[c6 + 2] = (o6[c6 + 2] - s3) / l2;
  return { position: r5, normal: n4.normal, tangent: n4.tangent };
}
function K(n4, t3, e6) {
  const r5 = t3.spatialReference;
  N3(t3, e6, _4);
  const o6 = h(nn, _4), a2 = new Float64Array(n4.position.length), s3 = Q(n4.position, r5, o6, a2), l2 = g(tn, o6);
  return { position: s3, normal: X(n4.normal, n4.position, a2, r5, l2), tangent: Y(n4.tangent, n4.position, a2, r5, l2) };
}
function N3(n4, t3, e6) {
  L(n4.spatialReference, [n4.x, n4.y, n4.z ?? 0], e6, c4(n4.spatialReference));
  const r5 = $(t3 ? t3.unit : null, n4.spatialReference);
  return f4(e6, e6, [r5, r5, r5]), e6;
}
function Q(n4, t3, e6, r5) {
  const o6 = h3(n4, t3, r5), i3 = new Float64Array(o6.length);
  return r3(i3, o6, e6), i3;
}
function X(n4, t3, e6, r5, o6) {
  if (null == n4)
    return null;
  const i3 = j2(n4, t3, e6, r5, new Float32Array(n4.length));
  return n3(i3, i3, o6), i3;
}
function Y(n4, t3, e6, r5, o6) {
  if (null == n4)
    return null;
  const i3 = R(n4, t3, e6, r5, new Float32Array(n4.length));
  return n3(i3, i3, o6, 4), i3;
}
function $(e6, r5) {
  if (null == e6)
    return 1;
  const o6 = V(r5);
  return 1 / j(o6, "meters", e6);
}
var _4 = e4();
var nn = e4();
var tn = e3();

export {
  p2 as p,
  h2 as h,
  U,
  g2 as g,
  l,
  w,
  N,
  r4 as r,
  o5 as o,
  j2 as j,
  _3 as _,
  h3 as h2,
  O3 as O,
  R,
  v3 as v,
  U3 as U2,
  V3 as V,
  q2 as q,
  B5 as B,
  D3 as D,
  E3 as E,
  I
};
//# sourceMappingURL=chunk-5VOKVSCM.js.map
