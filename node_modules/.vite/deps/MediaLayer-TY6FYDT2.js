import {
  h as h2,
  i as i3,
  j as j3
} from "./chunk-7DXPUA4N.js";
import "./chunk-L7TO2DFS.js";
import {
  p as p2
} from "./chunk-WK4UDTKV.js";
import {
  e as e2,
  t
} from "./chunk-2RN2AAP7.js";
import {
  o as o4
} from "./chunk-QAQNFI3S.js";
import "./chunk-PUYNEESA.js";
import {
  p
} from "./chunk-SBUFDP7O.js";
import {
  n as n5,
  r as r4
} from "./chunk-CMGHBCKF.js";
import {
  u as u2
} from "./chunk-YVNEJWNQ.js";
import {
  A,
  L,
  r as r3
} from "./chunk-NDKHIQMD.js";
import "./chunk-HYU6N3H3.js";
import "./chunk-X5VYGREB.js";
import {
  a
} from "./chunk-P5VIVFJT.js";
import "./chunk-SA3C7GIT.js";
import "./chunk-P3R45ANF.js";
import {
  t as t2
} from "./chunk-PIEUUBJ5.js";
import {
  u as u3
} from "./chunk-YIAYIZOZ.js";
import {
  m as m3
} from "./chunk-P5GW5DPX.js";
import "./chunk-VIOPOI6P.js";
import "./chunk-HU7QYAVQ.js";
import "./chunk-T3Y5GTKO.js";
import {
  b as b2
} from "./chunk-YXRSJYLG.js";
import {
  i
} from "./chunk-JHJVOI7Q.js";
import "./chunk-S6NERLXF.js";
import "./chunk-WOGT6UK2.js";
import "./chunk-IATM3RCE.js";
import "./chunk-BEALJUHO.js";
import {
  n as n4
} from "./chunk-GRHSIT57.js";
import "./chunk-PJQIAD5D.js";
import "./chunk-Z6KIMOUA.js";
import "./chunk-SZAJDZCO.js";
import "./chunk-M7R7REMB.js";
import "./chunk-ZZYUEH57.js";
import "./chunk-VTWXDFFD.js";
import "./chunk-IPCIO3PX.js";
import {
  c as c3
} from "./chunk-EIY2DYTV.js";
import {
  l
} from "./chunk-WJ4LS3YG.js";
import "./chunk-F6MD5VOH.js";
import {
  R,
  U,
  c as c2,
  i as i2
} from "./chunk-LMT5JII2.js";
import {
  F,
  U as U2,
  b
} from "./chunk-4HKQSEUR.js";
import "./chunk-V3U4F2NL.js";
import "./chunk-ZB6PGKG5.js";
import {
  j as j2
} from "./chunk-OIIDE5GZ.js";
import {
  o as o3
} from "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import {
  h,
  m as m2
} from "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import {
  r as r2
} from "./chunk-GINTRQSD.js";
import {
  n as n3
} from "./chunk-APYNYYQC.js";
import {
  d
} from "./chunk-TBSVVR6M.js";
import "./chunk-6TJWLWLO.js";
import "./chunk-H7BKONNV.js";
import "./chunk-K6C6RVSV.js";
import "./chunk-KBJ5Z4R2.js";
import {
  V as V2
} from "./chunk-JUZJCTW2.js";
import {
  o
} from "./chunk-423VNHLR.js";
import "./chunk-FN47E7YK.js";
import "./chunk-XZS3Q5K4.js";
import {
  m
} from "./chunk-CCXEAKIM.js";
import {
  M,
  x as x2
} from "./chunk-Y5D433JZ.js";
import {
  x2 as x
} from "./chunk-QNOCEWCR.js";
import {
  o as o2
} from "./chunk-WURET5CW.js";
import {
  f,
  r
} from "./chunk-QWPLZ3QH.js";
import {
  d2
} from "./chunk-HLGIRLYQ.js";
import {
  n as n2
} from "./chunk-N2K4VRZH.js";
import "./chunk-WL4VPODY.js";
import {
  s as s4
} from "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import {
  V,
  Y,
  Z,
  j,
  tt,
  ut
} from "./chunk-R5DM4YAB.js";
import {
  u2 as u
} from "./chunk-NSRXJNTS.js";
import {
  g,
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  n,
  s as s3
} from "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import "./chunk-4V6374PV.js";
import "./chunk-A34O4XB5.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/support/GeoreferenceBase.js
var c4 = class extends l {
  projectOrWarn(e3, r5) {
    if (null == e3)
      return e3;
    const { geometry: t3, pending: c5 } = U2(e3, r5);
    return c5 ? null : c5 || t3 ? t3 : (s.getLogger(this).warn("geometry could not be projected to the spatial reference", { georeference: this, geometry: e3, sourceSpatialReference: e3.spatialReference, targetSpatialReference: r5 }), null);
  }
};
c4 = e([c("esri.layers.support.GeoreferenceBase")], c4);
var a2 = c4;

// node_modules/@arcgis/core/layers/support/ControlPointsGeoreference.js
var C = e2();
var T = n5();
var _ = class extends g {
  constructor() {
    super(...arguments), this.sourcePoint = null, this.mapPoint = null;
  }
};
e([y()], _.prototype, "sourcePoint", void 0), e([y({ type: x })], _.prototype, "mapPoint", void 0), _ = e([c("esri.layers.support.ControlPoint")], _);
var O = class extends u(a2) {
  constructor(o5) {
    super(o5), this.controlPoints = null, this.height = 0, this.type = "control-points", this.width = 0;
  }
  readControlPoints(o5, t3) {
    const r5 = f.fromJSON(t3.spatialReference), n6 = t(...t3.coefficients, 1);
    return o5.map((o6) => (r3(T, o6.x, o6.y), h2(T, T, n6), { sourcePoint: o6, mapPoint: new x({ x: T[0], y: T[1], spatialReference: r5 }) }));
  }
  writeControlPoints(o5, t3, n6, i4) {
    if (null != this.transform)
      null != o5 && k(o5[0]) && (t3.controlPoints = o5.map((o6) => {
        const t4 = o6.sourcePoint;
        return { x: t4.x, y: t4.y };
      }), t3.spatialReference = o5[0].mapPoint.spatialReference.toJSON(), t3.coefficients = this.transform.slice(0, 8));
    else {
      const o6 = new s2("web-document-write:invalid-georeference", "Invalid 'controlPoints', 'width', 'height' configuration.", { layer: i4 == null ? void 0 : i4.layer, georeference: this });
      (i4 == null ? void 0 : i4.messages) ? i4.messages.push(o6) : s.getLogger(this).error(o6.name, o6.message);
    }
  }
  get coords() {
    if (null == this.controlPoints)
      return null;
    const o5 = this._updateTransform(C);
    if (null == o5 || !k(this.controlPoints[0]))
      return null;
    const t3 = this.controlPoints[0].mapPoint.spatialReference;
    return K(o5, this.width, this.height, t3);
  }
  set coords(o5) {
    if (null == this.controlPoints || !k(this.controlPoints[0]))
      return;
    const t3 = this.controlPoints[0].mapPoint.spatialReference;
    if (null == (o5 = this.projectOrWarn(o5, t3)))
      return;
    const { width: r5, height: n6 } = this, { rings: [[e3, s5, c5, a4]] } = o5, p4 = { sourcePoint: c3(0, n6), mapPoint: new x({ x: e3[0], y: e3[1], spatialReference: t3 }) }, u6 = { sourcePoint: c3(0, 0), mapPoint: new x({ x: s5[0], y: s5[1], spatialReference: t3 }) }, m4 = { sourcePoint: c3(r5, 0), mapPoint: new x({ x: c5[0], y: c5[1], spatialReference: t3 }) }, f4 = { sourcePoint: c3(r5, n6), mapPoint: new x({ x: a4[0], y: a4[1], spatialReference: t3 }) };
    k(p4) && k(u6) && k(m4) && k(f4) && (E(C, p4, u6, m4, f4), this.controlPoints = this.controlPoints.map(({ sourcePoint: o6 }) => (r3(T, o6.x, o6.y), h2(T, T, C), { sourcePoint: o6, mapPoint: new x({ x: T[0], y: T[1], spatialReference: t3 }) })));
  }
  get inverseTransform() {
    return null == this.transform ? null : u2(e2(), this.transform);
  }
  get transform() {
    return this._updateTransform();
  }
  toMap(o5) {
    if (null == o5 || null == this.transform || null == this.controlPoints || !k(this.controlPoints[0]))
      return null;
    r3(T, o5.x, o5.y);
    const t3 = this.controlPoints[0].mapPoint.spatialReference;
    return h2(T, T, this.transform), new x({ x: T[0], y: T[1], spatialReference: t3 });
  }
  toSource(o5) {
    if (null == o5 || null == this.inverseTransform || null == this.controlPoints || !k(this.controlPoints[0]))
      return null;
    const t3 = this.controlPoints[0].mapPoint.spatialReference;
    return o5 = o5.normalize(), null == (o5 = U2(o5, t3).geometry) ? null : (r3(T, o5.x, o5.y), h2(T, T, this.inverseTransform), c3(T[0], T[1]));
  }
  toSourceNormalized(o5) {
    const t3 = this.toSource(o5);
    return null != t3 && (t3.x /= this.width, t3.y /= this.height), t3;
  }
  _updateTransform(o5) {
    const { controlPoints: t3, width: r5, height: n6 } = this;
    if (!(null != t3 && r5 > 0 && n6 > 0))
      return null;
    const [e3, i4, s5, l3] = t3;
    if (!k(e3))
      return null;
    const c5 = e3.mapPoint.spatialReference, a4 = this._projectControlPoint(i4, c5), p4 = this._projectControlPoint(s5, c5), u6 = this._projectControlPoint(l3, c5);
    if (!a4.valid || !p4.valid || !u6.valid)
      return null;
    if (!k(a4.controlPoint))
      return null;
    null == o5 && (o5 = e2());
    let m4 = null;
    return m4 = k(p4.controlPoint) && k(u6.controlPoint) ? E(o5, e3, a4.controlPoint, p4.controlPoint, u6.controlPoint) : k(p4.controlPoint) ? B(o5, e3, a4.controlPoint, p4.controlPoint) : q(o5, e3, a4.controlPoint), m4.every((o6) => 0 === o6) ? null : m4;
  }
  _projectControlPoint(o5, t3) {
    if (!k(o5))
      return { valid: true, controlPoint: o5 };
    const { sourcePoint: r5, mapPoint: n6 } = o5, { geometry: i4, pending: s5 } = U2(n6, t3);
    return s5 ? { valid: false, controlPoint: null } : s5 || i4 ? { valid: true, controlPoint: { sourcePoint: r5, mapPoint: i4 } } : (s.getLogger(this).warn("map point could not be projected to the spatial reference", { georeference: this, controlPoint: o5, sourceSpatialReference: n6.spatialReference, targetSpatialReference: t3 }), { valid: false, controlPoint: null });
  }
};
function k(o5) {
  return null != (o5 == null ? void 0 : o5.sourcePoint) && null != o5.mapPoint;
}
e([y({ type: [_], json: { write: { allowNull: false, isRequired: true } } })], O.prototype, "controlPoints", void 0), e([o2("controlPoints")], O.prototype, "readControlPoints", null), e([r("controlPoints")], O.prototype, "writeControlPoints", null), e([y()], O.prototype, "coords", null), e([y({ json: { write: true } })], O.prototype, "height", void 0), e([y({ readOnly: true })], O.prototype, "inverseTransform", null), e([y({ readOnly: true })], O.prototype, "transform", null), e([y({ json: { write: true } })], O.prototype, "width", void 0), O = e([c("esri.layers.support.ControlPointsGeoreference")], O);
var N = n5();
var b3 = n5();
var I = n5();
var M2 = n5();
var A2 = n5();
var J = n5();
var L2 = n5();
var U3 = n5();
var z = Math.PI / 2;
function G(o5, t3, r5) {
  r3(o5, r5.sourcePoint.x, r5.sourcePoint.y), r3(t3, r5.mapPoint.x, r5.mapPoint.y);
}
function q(o5, t3, r5) {
  return G(N, A2, t3), G(b3, J, r5), L(I, b3, N, z), L(M2, N, b3, z), L(L2, J, A2, -z), L(U3, A2, J, -z), H(o5, N, b3, I, M2, A2, J, L2, U3);
}
function B(o5, t3, r5, n6) {
  return G(N, A2, t3), G(b3, J, r5), G(I, L2, n6), A(M2, N, b3, 0.5), L(M2, I, M2, Math.PI), A(U3, A2, J, 0.5), L(U3, L2, U3, Math.PI), H(o5, N, b3, I, M2, A2, J, L2, U3);
}
function E(o5, t3, r5, n6, e3) {
  return G(N, A2, t3), G(b3, J, r5), G(I, L2, n6), G(M2, U3, e3), H(o5, N, b3, I, M2, A2, J, L2, U3);
}
var W = new Array(8).fill(0);
var D = new Array(8).fill(0);
function F2(o5, t3, r5, n6, e3) {
  return o5[0] = t3[0], o5[1] = t3[1], o5[2] = r5[0], o5[3] = r5[1], o5[4] = n6[0], o5[5] = n6[1], o5[6] = e3[0], o5[7] = e3[1], o5;
}
function H(o5, t3, r5, n6, e3, i4, l3, c5, a4) {
  return j3(o5, F2(W, t3, r5, n6, e3), F2(D, i4, l3, c5, a4));
}
function K(o5, t3, r5, n6) {
  const e3 = r4(0, r5), s5 = r4(0, 0), l3 = r4(t3, 0), c5 = r4(t3, r5);
  return h2(e3, e3, o5), h2(s5, s5, o5), h2(l3, l3, o5), h2(c5, c5, o5), new j2({ rings: [[e3, s5, l3, c5, e3]], spatialReference: n6 });
}
var Q = O;

// node_modules/@arcgis/core/layers/support/CornersGeoreference.js
var f2 = n5();
var y2 = class extends a2 {
  constructor(t3) {
    super(t3), this.bottomLeft = null, this.bottomRight = null, this.topLeft = null, this.topRight = null, this.type = "corners";
  }
  get coords() {
    let { topLeft: t3, topRight: o5, bottomLeft: e3, bottomRight: r5 } = this;
    if (null == t3 || null == o5 || null == e3 || null == r5)
      return null;
    const s5 = t3.spatialReference;
    return o5 = this.projectOrWarn(o5, s5), e3 = this.projectOrWarn(e3, s5), r5 = this.projectOrWarn(r5, s5), null == o5 || null == e3 || null == r5 ? null : new j2({ rings: [[[e3.x, e3.y], [t3.x, t3.y], [o5.x, o5.y], [r5.x, r5.y], [e3.x, e3.y]]], spatialReference: s5 });
  }
  set coords(t3) {
    const { topLeft: o5 } = this;
    if (null == o5)
      return;
    const e3 = o5.spatialReference;
    if (null == (t3 = this.projectOrWarn(t3, e3)))
      return;
    const { rings: [[r5, s5, n6, i4]] } = t3;
    this.bottomLeft = new x({ x: r5[0], y: r5[1], spatialReference: e3 }), this.topLeft = new x({ x: s5[0], y: s5[1], spatialReference: e3 }), this.topRight = new x({ x: n6[0], y: n6[1], spatialReference: e3 }), this.bottomRight = new x({ x: i4[0], y: i4[1], spatialReference: e3 });
  }
  toSourceNormalized(t3) {
    const { topLeft: s5, topRight: n6, bottomRight: p4, bottomLeft: c5 } = this;
    if (null == t3 || null == s5 || null == n6 || null == p4 || null == c5)
      return null;
    const u6 = s5.spatialReference;
    t3 = t3.normalize();
    const a4 = U2(t3, u6).geometry;
    if (null == a4)
      return null;
    r3(f2, a4.x, a4.y);
    const y3 = j3(e2(), [s5.x, s5.y, c5.x, c5.y, n6.x, n6.y, p4.x, p4.y], [0, 0, 0, 1, 1, 0, 1, 1]);
    return h2(f2, f2, y3), c3(f2[0], f2[1]);
  }
};
e([y()], y2.prototype, "coords", null), e([y({ type: x })], y2.prototype, "bottomLeft", void 0), e([y({ type: x })], y2.prototype, "bottomRight", void 0), e([y({ type: x })], y2.prototype, "topLeft", void 0), e([y({ type: x })], y2.prototype, "topRight", void 0), y2 = e([c("esri.layers.support.CornersGeoreference")], y2);
var h3 = y2;

// node_modules/@arcgis/core/layers/support/ExtentAndRotationGeoreference.js
var p3 = class extends a2 {
  constructor(t3) {
    super(t3), this.extent = null, this.rotation = 0, this.type = "extent-and-rotation";
  }
  get coords() {
    if (null == this.extent)
      return null;
    const { xmin: t3, ymin: e3, xmax: r5, ymax: o5, spatialReference: n6 } = this.extent;
    let s5;
    if (this.rotation) {
      const { x: n7, y: i4 } = this.extent.center, a4 = u4(n7, i4, this.rotation);
      s5 = [a4(t3, e3), a4(t3, o5), a4(r5, o5), a4(r5, e3)], s5.push(s5[0]);
    } else
      s5 = [[t3, e3], [t3, o5], [r5, o5], [r5, e3], [t3, e3]];
    return new j2({ rings: [s5], spatialReference: n6 });
  }
  set coords(t3) {
    if (null == t3 || null == this.extent)
      return;
    const r5 = this.extent.spatialReference;
    if (t3 = this.projectOrWarn(t3, r5), null == (t3 == null ? void 0 : t3.extent))
      return;
    const { rings: [[o5, n6, s5]], extent: { center: { x: i4, y: c5 } } } = t3, m4 = m2(Math.PI / 2 - Math.atan2(n6[1] - o5[1], n6[0] - o5[0])), l3 = u4(i4, c5, -m4), [p4, x4] = l3(o5[0], o5[1]), [f4, y3] = l3(s5[0], s5[1]);
    this.extent = new M({ xmin: p4, ymin: x4, xmax: f4, ymax: y3, spatialReference: r5 }), this.rotation = m4;
  }
  toSourceNormalized(t3) {
    const { extent: e3, rotation: n6 } = this;
    if (null == t3 || null == e3)
      return null;
    const { xmin: s5, ymin: i4, xmax: a4, ymax: c5, center: l3, spatialReference: p4 } = e3;
    t3 = t3.normalize();
    const x4 = U2(t3, p4).geometry;
    if (null == x4)
      return null;
    let f4 = x4.x, y3 = x4.y;
    return n6 && ([f4, y3] = u4(l3.x, l3.y, -n6)(f4, y3)), c3(h(f4, s5, a4, 0, 1), h(y3, c5, i4, 0, 1));
  }
};
function u4(t3, e3, r5) {
  const o5 = r2(r5), n6 = Math.cos(o5), s5 = Math.sin(o5);
  return (r6, o6) => [n6 * (r6 - t3) + s5 * (o6 - e3) + t3, n6 * (o6 - e3) - s5 * (r6 - t3) + e3];
}
e([y()], p3.prototype, "coords", null), e([y({ type: M })], p3.prototype, "extent", void 0), e([y({ type: Number })], p3.prototype, "rotation", void 0), p3 = e([c("esri.layers.support.ExtentAndRotationGeoreference")], p3);
var x3 = p3;

// node_modules/@arcgis/core/layers/support/MediaElementBase.js
var l2 = { key: "type", base: a2, typeMap: { "control-points": Q, corners: h3, "extent-and-rotation": x3 } };
var u5 = class extends i(u(m)) {
  constructor(e3) {
    super(e3), this.georeference = null, this.opacity = 1;
  }
  readGeoreference(e3) {
    return Q.fromJSON(e3);
  }
  get contentWidth() {
    return 0;
  }
  get contentHeight() {
    return 0;
  }
  toSource(e3) {
    const { georeference: r5, contentWidth: o5, contentHeight: t3 } = this;
    if (null == e3 || null == r5 || 0 === o5 || 0 === t3)
      return null;
    const s5 = r5.toSourceNormalized(e3);
    return null == s5 ? null : (s5.x *= o5, s5.y *= t3, s5);
  }
};
e([y({ types: l2, json: { write: true } })], u5.prototype, "georeference", void 0), e([o2("georeference")], u5.prototype, "readGeoreference", null), e([y()], u5.prototype, "opacity", void 0), u5 = e([c("esri.layers.support.MediaElementBase")], u5);
var f3 = u5;

// node_modules/@arcgis/core/layers/support/ImageElement.js
var I2 = class extends f3 {
  constructor(t3) {
    super(t3), this.animationOptions = null, this.content = null, this.image = null, this.type = "image", this.image = null;
  }
  load() {
    const t3 = this.image;
    if ("string" == typeof t3) {
      const e3 = p(t3).then((t4) => {
        this._set("content", t4);
      });
      this.addResolvingPromise(e3);
    } else if (t3 instanceof HTMLImageElement) {
      const e3 = t3.decode().then(() => {
        this._set("content", t3);
      });
      this.addResolvingPromise(e3);
    } else
      t3 ? this._set("content", t3) : this.addResolvingPromise(Promise.reject(new s2("image-element:invalid-image-type", "Invalid image type", { image: t3 })));
    return Promise.resolve(this);
  }
  get contentWidth() {
    return null == this.content ? 0 : this.content instanceof HTMLImageElement ? this.content.naturalWidth : this.content.width;
  }
  get contentHeight() {
    return null == this.content ? 0 : this.content instanceof HTMLImageElement ? this.content.naturalHeight : this.content.height;
  }
  readImage(t3, e3, r5) {
    return i2(e3.url, r5);
  }
  writeImage(t3, e3, r5, o5) {
    if (null == t3)
      return;
    const a4 = o5 == null ? void 0 : o5.portalItem, l3 = o5 == null ? void 0 : o5.resources;
    if (!a4 || !l3)
      return void ("string" == typeof t3 && (e3[r5] = c2(t3, o5)));
    const m4 = "string" != typeof t3 || tt(t3) || Z(t3) ? null : t3;
    if (m4) {
      if (null == U(m4))
        return void (e3[r5] = m4);
      const t4 = c2(m4, { ...o5, verifyItemRelativeUrls: (o5 == null ? void 0 : o5.verifyItemRelativeUrls) ? { writtenUrls: o5.verifyItemRelativeUrls.writtenUrls, rootPath: void 0 } : void 0 }, R.NO);
      if (a4 && t4 && !Y(t4))
        return l3.toKeep.push({ resource: a4.resourceFromPath(t4), compress: false }), void (e3[r5] = t4);
    }
    e3[r5] = "<pending>", l3.pendingOperations.push(w(t3).then((t4) => {
      const o6 = H2(t4, a4);
      e3[r5] = o6.itemRelativeUrl, l3.toAdd.push({ resource: o6, content: { type: "blob", blob: t4 }, compress: false, finish: (t5) => {
        this.image = t5.url;
      } });
    }));
  }
};
e([y()], I2.prototype, "animationOptions", void 0), e([y({ readOnly: true })], I2.prototype, "content", void 0), e([y({ readOnly: true })], I2.prototype, "contentWidth", null), e([y({ readOnly: true })], I2.prototype, "contentHeight", null), e([y({ json: { name: "url", type: String } })], I2.prototype, "image", void 0), e([o2("image", ["url"])], I2.prototype, "readImage", null), e([r("image")], I2.prototype, "writeImage", null), e([y({ readOnly: true, json: { name: "mediaType" } })], I2.prototype, "type", void 0), I2 = e([c("esri.layers.support.ImageElement")], I2);
var b4 = I2;
async function w(t3) {
  if ("string" == typeof t3) {
    if (tt(t3))
      return ut(t3);
    return (await j(t3, { responseType: "blob" })).data;
  }
  return new Promise((e3) => E2(t3).toBlob(e3));
}
function E2(t3) {
  if (t3 instanceof HTMLCanvasElement)
    return t3;
  const e3 = t3 instanceof HTMLImageElement ? t3.naturalWidth : t3.width, r5 = t3 instanceof HTMLImageElement ? t3.naturalHeight : t3.height, o5 = document.createElement("canvas"), n6 = o5.getContext("2d");
  return o5.width = e3, o5.height = r5, t3 instanceof HTMLImageElement ? n6.drawImage(t3, 0, 0, t3.width, t3.height) : t3 instanceof ImageData && n6.putImageData(t3, 0, 0), o5;
}
function H2(t3, e3) {
  const r5 = n3(), o5 = `${V("media", r5)}.${p2({ type: "blob", blob: t3 })}`;
  return e3.resourceFromPath(o5);
}

// node_modules/@arcgis/core/layers/support/VideoElement.js
var a3 = class extends f3 {
  constructor(e3) {
    super(e3), this.autoplay = true, this.content = null, this.type = "video";
  }
  load() {
    const e3 = this.video;
    if ("string" == typeof e3) {
      const o5 = document.createElement("video");
      o5.src = e3, o5.crossOrigin = "anonymous", o5.autoplay = true, o5.muted = true, o5.loop = true, this.addResolvingPromise(this._loadVideo(o5).then(() => {
        this._set("content", o5);
      }));
    } else
      e3 instanceof HTMLVideoElement ? this.addResolvingPromise(this._loadVideo(e3).then(() => {
        this._set("content", e3);
      })) : this.addResolvingPromise(Promise.reject(new s2("video-element:invalid-video-type", "Invalid video type", { video: e3 })));
    return Promise.resolve(this);
  }
  get contentWidth() {
    var _a;
    return ((_a = this.content) == null ? void 0 : _a.videoWidth) ?? 0;
  }
  get contentHeight() {
    var _a;
    return ((_a = this.content) == null ? void 0 : _a.videoHeight) ?? 0;
  }
  set video(e3) {
    "not-loaded" === this.loadStatus ? this._set("video", e3) : s.getLogger(this).error("#video", "video cannot be changed after the element is loaded.");
  }
  _loadVideo(e3) {
    return new Promise((o5, s5) => {
      var _a;
      const r5 = n(e3, "canplay", () => {
        this.removeHandles("canplay"), this.autoplay ? e3.play().then(o5, s5) : o5();
      });
      this.addHandles(r5, "canplay"), "anonymous" !== e3.crossOrigin && (e3.crossOrigin = "anonymous", ((_a = e3.src) == null ? void 0 : _a.includes("blob:")) || (e3.src = e3.src));
    });
  }
};
e([y()], a3.prototype, "autoplay", void 0), e([y({ readOnly: true })], a3.prototype, "content", void 0), e([y({ readOnly: true })], a3.prototype, "contentWidth", null), e([y({ readOnly: true })], a3.prototype, "contentHeight", null), e([y()], a3.prototype, "video", null), a3 = e([c("esri.layers.support.VideoElement")], a3);
var d3 = a3;

// node_modules/@arcgis/core/layers/support/LocalMediaElementSource.js
var w2 = { key: "type", defaultKeyValue: "image", base: f3, typeMap: { image: b4, video: d3 } };
var M3 = V2.ofType(w2);
var I3 = class extends m.LoadableMixin(n2(o.EventedAccessor)) {
  constructor(e3) {
    super(e3), this._index = new o4(), this._elementViewsMap = /* @__PURE__ */ new Map(), this._elementsIndexes = /* @__PURE__ */ new Map(), this._elementsChangedHandler = (e4) => {
      for (const s5 of e4.removed) {
        const e5 = this._elementViewsMap.get(s5);
        this._elementViewsMap.delete(s5), this._index.delete(e5), this.removeHandles(e5), e5.destroy(), this.notifyChange("fullExtent");
      }
      const { spatialReference: t3 } = this;
      for (const s5 of e4.added) {
        if (this._elementViewsMap.get(s5))
          continue;
        const e5 = new i3({ spatialReference: t3, element: s5 });
        this._elementViewsMap.set(s5, e5);
        const r5 = d(() => e5.coords, () => this._updateIndexForElement(e5, false));
        this._updateIndexForElement(e5, true), this.addHandles(r5, e5);
      }
      this._elementsIndexes.clear(), this.elements.forEach((e5, t4) => this._elementsIndexes.set(e5, t4)), this.emit("refresh");
    }, this.elements = new M3();
  }
  async load(e3) {
    if (s3(e3), !this.spatialReference) {
      const e4 = this.elements.find((e5) => {
        var _a;
        return null != ((_a = e5.georeference) == null ? void 0 : _a.coords);
      });
      this._set("spatialReference", e4 ? e4.georeference.coords.spatialReference : f.WGS84);
    }
    return this._elementsChangedHandler({ added: this.elements.items, removed: [] }), this.addHandles(this.elements.on("change", this._elementsChangedHandler)), this;
  }
  destroy() {
    this._index.clear(), this._elementViewsMap.clear(), this._elementsIndexes.clear();
  }
  set elements(e3) {
    this._set("elements", n4(e3, this._get("elements"), M3));
  }
  get fullExtent() {
    if ("not-loaded" === this.loadStatus)
      return null;
    const e3 = this._index.fullBounds;
    return null == e3 ? null : new M({ xmin: e3[0], ymin: e3[1], xmax: e3[2], ymax: e3[3], spatialReference: this.spatialReference });
  }
  set spatialReference(e3) {
    "not-loaded" === this.loadStatus ? this._set("spatialReference", e3) : s.getLogger(this).error("#spatialReference", "spatialReference cannot be changed after the source is loaded.");
  }
  async queryElements(e3, t3) {
    await this.load(), await F(e3.spatialReference, this.spatialReference, null, t3);
    const s5 = d2(e3.spatialReference, this.spatialReference) ? e3 : b(e3, this.spatialReference);
    if (!s5)
      return [];
    const r5 = s5.normalize(), o5 = [];
    for (const n6 of r5)
      this._index.forEachInBounds(o3(n6), ({ normalizedCoords: e4, element: t4 }) => {
        null != e4 && x2(n6, e4) && o5.push(t4);
      });
    return o5.sort((e4, t4) => this._elementsIndexes.get(e4) - this._elementsIndexes.get(t4)), o5;
  }
  _updateIndexForElement(e3, t3) {
    const s5 = e3.normalizedBounds, r5 = this._index.has(e3), o5 = null != s5;
    this._index.delete(e3), o5 && this._index.set(e3, s5), this.notifyChange("fullExtent"), t3 || (r5 !== o5 ? this.emit("refresh") : this.emit("change", { element: e3.element }));
  }
};
e([y()], I3.prototype, "elements", null), e([y({ readOnly: true })], I3.prototype, "fullExtent", null), e([y()], I3.prototype, "spatialReference", null), I3 = e([c("esri.layers.support.LocalMediaElementSource")], I3);
var S = I3;

// node_modules/@arcgis/core/layers/MediaLayer.js
function S2(e3) {
  return "object" == typeof e3 && null != e3 && "type" in e3;
}
var g2 = class extends a(t2(u3(m3(b2)))) {
  constructor(e3) {
    super(e3), this.effectiveSource = null, this.copyright = null, this.operationalLayerType = "MediaLayer", this.spatialReference = null, this.type = "media", this.source = new S();
  }
  load(e3) {
    const t3 = this.source;
    if (!t3)
      return this.addResolvingPromise(Promise.reject(new s2("media-layer:source-missing", "Set 'MediaLayer.source' before loading the layer."))), Promise.resolve(this);
    const s5 = S2(t3) ? new S({ elements: new V2([t3]) }) : t3;
    this._set("effectiveSource", s5), this.spatialReference && (s5.spatialReference = this.spatialReference);
    const i4 = s5.load(e3).then(() => {
      this.spatialReference = s5.spatialReference;
    });
    return this.addResolvingPromise(i4), Promise.resolve(this);
  }
  destroy() {
    var _a, _b;
    (_a = this.effectiveSource) == null ? void 0 : _a.destroy(), (_b = this.source) == null ? void 0 : _b.destroy();
  }
  get fullExtent() {
    return this.loaded ? this.effectiveSource.fullExtent : null;
  }
  set source(e3) {
    "not-loaded" === this.loadStatus ? this._set("source", e3) : s.getLogger(this).error("#source", "source cannot be changed after the layer is loaded.");
  }
  castSource(e3) {
    return e3 ? Array.isArray(e3) ? new S({ elements: new V2(e3) }) : e3 instanceof V2 ? new S({ elements: e3 }) : e3 : null;
  }
  readSource(e3, r5, o5) {
    const t3 = "image" === r5.mediaType ? new b4() : "video" === r5.mediaType ? new d3() : null;
    return t3 == null ? void 0 : t3.read(r5, o5), t3;
  }
  writeSource(e3, r5, t3, s5) {
    var _a;
    e3 && S2(e3) && "image" === e3.type ? e3.write(r5, s5) : (s5 == null ? void 0 : s5.messages) && ((_a = s5 == null ? void 0 : s5.messages) == null ? void 0 : _a.push(new s2("media-layer:unsupported-source", "source must be an 'ImageElement'")));
  }
};
e([y({ readOnly: true })], g2.prototype, "effectiveSource", void 0), e([y({ type: String })], g2.prototype, "copyright", void 0), e([y({ readOnly: true })], g2.prototype, "fullExtent", null), e([y({ type: ["MediaLayer"] })], g2.prototype, "operationalLayerType", void 0), e([y({ type: ["show", "hide"] })], g2.prototype, "listMode", void 0), e([y({ nonNullable: true, json: { write: { enabled: true, allowNull: false } } })], g2.prototype, "source", null), e([s4("source")], g2.prototype, "castSource", null), e([o2("source", ["url"])], g2.prototype, "readSource", null), e([r("source")], g2.prototype, "writeSource", null), e([y()], g2.prototype, "spatialReference", void 0), e([y({ readOnly: true })], g2.prototype, "type", void 0), g2 = e([c("esri.layers.MediaLayer")], g2);
var j4 = g2;
export {
  j4 as default
};
//# sourceMappingURL=MediaLayer-TY6FYDT2.js.map
