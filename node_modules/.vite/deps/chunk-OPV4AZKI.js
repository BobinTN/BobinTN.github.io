import {
  t as t2
} from "./chunk-5WG7GACT.js";
import {
  f as f3,
  l,
  m,
  s,
  u as u2
} from "./chunk-IPCIO3PX.js";
import {
  c,
  f,
  f3 as f2,
  i,
  t
} from "./chunk-OIIDE5GZ.js";
import {
  u
} from "./chunk-3XSRVKBX.js";
import {
  G
} from "./chunk-Y5D433JZ.js";
import {
  a
} from "./chunk-WJ3HJKNC.js";

// node_modules/@arcgis/core/geometry/GeometryCursor.js
var a2 = class {
  static fromOptimized(t4, e, s2 = false, i2 = false) {
    return new p().initialize(t4, e, s2, i2, 1);
  }
  static fromJSON(t4, e = false, s2 = false) {
    const [i2, h2] = u3(t4);
    return new d().initialize(i2, h2, e, s2, 1);
  }
  static fromOptimizedCIM(t4, e, s2 = false, i2 = false) {
    return new m2().initialize(t4, e, s2, i2, 1);
  }
  static fromJSONCIM(t4, e = false, s2 = false) {
    const [i2, h2] = u3(t4);
    return new y().initialize(i2, h2, e, s2, 1);
  }
  static fromFeatureSetReader(t4) {
    const e = t4.readGeometryForDisplay(), s2 = t4.geometryType;
    return e && s2 ? this.fromOptimized(e, s2) : null;
  }
  static fromFeatureSetReaderCIM(t4) {
    const e = t4.readGeometryForDisplay(), s2 = t4.geometryType;
    return e && s2 ? this.fromOptimizedCIM(e, s2) : null;
  }
  static createEmptyOptimized(t4, e = false, s2 = false) {
    return new p().initialize(new t2(), t4, e, s2, 1);
  }
  static createEmptyJSON(t4, e = false, s2 = false) {
    return new d().initialize([], t4, e, s2, 1);
  }
  static createEmptyOptimizedCIM(t4, e = false, s2 = false) {
    return new m2().initialize(new t2(), t4, e, s2, 1);
  }
  static createEmptyJSONCIM(t4, e = false, s2 = false) {
    return new y().initialize([], t4, e, s2, 1);
  }
  asJSON() {
    const t4 = t(this);
    return "esriGeometryEnvelope" === this.geometryType ? { xmin: t4[0][0][0], ymin: t4[0][0][1], xmax: t4[0][2][0], ymax: t4[0][2][1] } : "esriGeometryMultipoint" === this.geometryType ? { points: t4.flat() } : "esriGeometryPoint" === this.geometryType ? { x: t4[0][0][0], y: t4[0][0][1] } : "esriGeometryPolygon" === this.geometryType ? { rings: t4 } : { paths: t4 };
  }
  getCurrentRingArea() {
    if (!this || this.pathSize < 3)
      return 0;
    let t4, e, s2 = 0;
    if (this.seekPathStart(), !this.nextPoint())
      return 0;
    t4 = this.x, e = this.y;
    const i2 = t4, h2 = e;
    for (; this.nextPoint(); )
      s2 += (t4 - this.x) * (e + this.y), t4 = this.x, e = this.y;
    return s2 += (t4 - i2) * (e + h2), -0.5 * s2;
  }
  invertY() {
    this.yFactor *= -1;
  }
};
var p = class _p extends a2 {
  constructor() {
    super(...arguments), this._end = -1;
  }
  initialize(t4, e, s2, i2, h2) {
    return this.hasZ = s2, this.hasM = i2, this.geometryType = e, this._stride = 2 + Number(s2) + Number(i2), this._geometry = t4, this._pathIndex = -1, this._pathOffset = 0, this._pointOffset = -this._stride, this._end = -1, this.yFactor = h2, this;
  }
  reset() {
    this.initialize(this._geometry, this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  seekPath(t4) {
    if (t4 >= 0 && t4 < this.totalSize) {
      if (this._pathIndex < t4)
        for (; this._pathIndex < t4 && this.nextPath(); )
          ;
      else if (this._pathIndex > t4)
        for (; this._pathIndex > t4 && this.prevPath(); )
          ;
      return true;
    }
    return false;
  }
  seekPathStart() {
    this._pointOffset = this._pathOffset - this._stride;
  }
  seekPathEnd() {
    this._pointOffset = this._end;
  }
  seekInPath(t4) {
    const e = this._pathOffset + t4 * this._stride;
    return e >= 0 && e < this._end && (this._pointOffset = e, true);
  }
  nextPoint() {
    return (this._pointOffset += this._stride) < this._end;
  }
  prevPoint() {
    return (this._pointOffset -= this._stride) >= this._pathOffset;
  }
  nextPath() {
    if (this._pathIndex >= 0) {
      const t5 = this._geometry.isPoint ? 1 : this._geometry.lengths[this._pathIndex];
      this._pathOffset += this._stride * t5;
    }
    this._pointOffset = this._pathOffset - this._stride;
    const t4 = this._geometry.isPoint ? 1 : this._geometry.lengths[this._pathIndex + 1];
    return this._end = this._pointOffset + this._stride + this._stride * t4, ++this._pathIndex < this.totalSize;
  }
  prevPath() {
    this._end = this._pathOffset;
    const t4 = this._geometry.isPoint ? 1 : this._geometry.lengths[this._pathIndex - 1];
    return this._pathOffset -= this._stride * t4, this._pointOffset = this._pathOffset - this._stride, --this._pathIndex >= 0;
  }
  pathLength() {
    const t4 = this._end, e = this._stride, s2 = this._geometry.coords;
    let i2 = 0;
    for (let h2 = this._pathOffset + e; h2 < t4; h2 += e) {
      const t5 = s2[h2 - e], r = s2[h2 - e + 1], n = s2[h2] - t5, o = s2[h2 + 1] - r;
      i2 += Math.sqrt(n * n + o * o);
    }
    return i2;
  }
  startPath() {
    this._geometry.lengths.push(0);
  }
  pushPath(t4) {
    this.startPath(), this.pushPoints(t4);
  }
  pushPoint(t4) {
    for (let e = 0; e < this._stride; ++e)
      this._geometry.coords.push(t4[e]);
    this._geometry.lengths[this.totalSize - 1]++;
  }
  pushXY(t4, e) {
    this._geometry.coords.push(t4, e), this._geometry.lengths[this.totalSize - 1]++;
  }
  pushPoints(t4) {
    for (const e of t4)
      for (let t5 = 0; t5 < this._stride; ++t5)
        this._geometry.coords.push(e[t5]);
    this._geometry.lengths[this.totalSize - 1] += t4.length;
  }
  pushCursor(t4) {
    const e = t4.asOptimized();
    this._geometry.coords.push(...e.coords), this._geometry.lengths.push(...e.lengths);
  }
  asOptimized() {
    const t4 = this._geometry.clone();
    if (1 !== this.yFactor)
      for (let e = 1; e < t4.coords.length; e += this._stride)
        t4.coords[e] *= this.yFactor;
    return "esriGeometryPoint" === this.geometryType && (t4.lengths.length = 0), t4;
  }
  isClosed() {
    const t4 = this._geometry.coords, e = this._pathOffset, s2 = this._end - this._stride;
    for (let i2 = 0; i2 < this._stride; i2++)
      if (t4[e + i2] !== t4[s2 + i2])
        return false;
    return true;
  }
  clone() {
    return new _p().initialize(this._geometry.clone(), this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  get totalPoints() {
    return this._geometry.coords.length / this._stride;
  }
  get pathSize() {
    const { lengths: t4 } = this._geometry;
    return this._pathIndex < 0 || this._pathIndex > t4.length - 1 ? 0 : t4[this._pathIndex];
  }
  get totalSize() {
    return this._geometry.lengths.length;
  }
  get x() {
    return this._geometry.coords[this._pointOffset];
  }
  set x(t4) {
    this._geometry.coords[this._pointOffset] = t4;
  }
  get y() {
    return this.yFactor * this._geometry.coords[this._pointOffset + 1];
  }
  set y(t4) {
    this._geometry.coords[this._pointOffset + 1] = this.yFactor * t4;
  }
  get z() {
    return this._geometry.coords[this._pointOffset + 2];
  }
  set z(t4) {
    this._geometry.coords[this._pointOffset + 2] = t4;
  }
  get m() {
    const t4 = this.hasZ ? 3 : 2;
    return this._geometry.coords[this._pointOffset + t4];
  }
  set m(t4) {
    this._geometry.coords[this._pointOffset + 3] = t4;
  }
  get pathIndex() {
    return this._pathIndex;
  }
  get _coordIndex() {
    return this._pointOffset / this._stride;
  }
};
function _(t4) {
  const e = [t4.x, t4.y];
  return t4.z && e.push(t4.z), t4.m && e.push(t4.m), e;
}
function u3(t4) {
  return f3(t4) ? [t4.rings, "esriGeometryPolygon"] : s(t4) ? [t4.paths, "esriGeometryPolyline"] : u2(t4) ? [[t4.points], "esriGeometryMultipoint"] : m(t4) ? [[[[t4.xmin, t4.ymin], [t4.xmin, t4.ymax], [t4.xmax, t4.ymax], [t4.xmax, t4.ymin], [t4.xmin, t4.ymin]]], "esriGeometryEnvelope"] : l(t4) ? [[[_(t4)]], "esriGeometryPoint"] : [[], "esriGeometryPolyline"];
}
var d = class _d extends a2 {
  initialize(t4, e, s2, i2, h2) {
    return this._paths = t4, this.geometryType = e, this.hasZ = s2, this.hasM = i2, this._pathIndex = this._pointIndex = -1, this.yFactor = h2, this._mIndex = this.hasZ ? 3 : 2, this;
  }
  reset() {
    this._pathIndex = this._pointIndex = -1;
  }
  seekPath(t4) {
    return t4 >= 0 && t4 < this.totalSize && (this._pathIndex = t4, this._pointIndex = -1, this._currentPath = this._paths[t4], true);
  }
  seekPathStart() {
    this._pointIndex = -1;
  }
  seekPathEnd() {
    this._pointIndex = this._currentPath.length;
  }
  seekInPath(t4) {
    return t4 >= 0 && t4 < this._currentPath.length && (this._pointIndex = t4, this._currentPoint = this._currentPath[this._pointIndex], true);
  }
  nextPoint() {
    return this._currentPoint = this._currentPath[++this._pointIndex], this._pointIndex < this._currentPath.length;
  }
  prevPoint() {
    return this._currentPoint = this._currentPath[--this._pointIndex], this._pointIndex >= 0;
  }
  nextPath() {
    return this._pointIndex = -1, this._currentPath = this._paths[++this._pathIndex], this._pathIndex < this.totalSize;
  }
  prevPath() {
    return this._pointIndex = -1, this._currentPath = this._paths[--this._pathIndex], this._pathIndex >= 0;
  }
  pathLength() {
    const t4 = this._currentPath.length, e = this._currentPath;
    let s2 = 0;
    for (let i2 = 1; i2 < t4; i2++) {
      const t5 = e[i2 - 1], h2 = e[i2], r = t5[0], n = t5[1], o = h2[0] - r, a3 = h2[1] - n;
      s2 += Math.sqrt(o * o + a3 * a3);
    }
    return s2;
  }
  startPath() {
    this._paths.push([]);
  }
  pushPath(t4) {
    this._paths.push(t4);
  }
  pushPoint(t4) {
    this._paths[this.totalSize - 1].push(t4);
  }
  pushXY(t4, e) {
    this._paths[this.totalSize - 1].push([t4, e]);
  }
  pushPoints(t4) {
    this._paths[this.totalSize - 1].push(...t4);
  }
  pushCursor(t4) {
    const s2 = t(t4);
    for (const e of s2)
      this.pushPath(e);
  }
  asOptimized() {
    const t4 = new t2();
    if ("esriGeometryPoint" === this.geometryType)
      t4.coords.push(...this._paths[0][0]), t4.lengths.length = 0;
    else
      for (const e of this._paths) {
        for (const s2 of e)
          t4.coords.push(s2[0]), t4.coords.push(s2[1] * this.yFactor), this.hasZ && t4.coords.push(s2[2]), this.hasM && t4.coords.push(s2[this._mIndex]);
        t4.lengths.push(e.length);
      }
    return t4;
  }
  isClosed() {
    const t4 = this._currentPath[0], e = this._currentPath[this._currentPath.length - 1];
    for (let s2 = 0; s2 < t4.length; s2++)
      if (t4[s2] !== e[s2])
        return false;
    return true;
  }
  clone() {
    return new _d().initialize(a(this._paths), this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  get totalPoints() {
    return this._paths.map((t4) => t4.length).reduce((t4, e) => t4 + e);
  }
  get pathSize() {
    return this._pathIndex < 0 || this._pathIndex > this.totalSize - 1 ? -1 : this._paths[this._pathIndex].length;
  }
  get totalSize() {
    return this._paths.length;
  }
  get x() {
    return this._currentPoint[0];
  }
  set x(t4) {
    this._currentPoint[0] = t4;
  }
  get y() {
    return this.yFactor * this._currentPoint[1];
  }
  set y(t4) {
    this._currentPoint[1] = this.yFactor * t4;
  }
  get z() {
    return this._currentPoint[2];
  }
  set z(t4) {
    this._currentPoint[2] = t4;
  }
  get m() {
    return this._currentPoint[this._mIndex];
  }
  set m(t4) {
    this._currentPoint[this._mIndex] = t4;
  }
  get pathIndex() {
    return this._pathIndex;
  }
};
var c2 = 4;
var l2 = 1;
var m2 = class _m extends p {
  initialize(t4, e, s2, i2, h2) {
    return super.initialize(t4, e, s2, i2, h2), this._controlPoints || (this._controlPoints = this._controlPoints = new Array(this.totalSize).fill(void 0).map((t5) => /* @__PURE__ */ new Set())), this;
  }
  startPath() {
    super.startPath(), this._controlPoints.push(/* @__PURE__ */ new Set());
  }
  clone() {
    const t4 = new _m().initialize(this._geometry.clone(), this.geometryType, this.hasZ, this.hasM, this.yFactor);
    return t4._controlPoints = this._controlPoints, t4;
  }
  setControlPoint() {
    this._controlPoints[this.pathIndex].add(this._coordIndex);
  }
  getControlPoint() {
    return this._controlPoints[this.pathIndex].has(this._coordIndex);
  }
  setControlPointAt(t4) {
    this._controlPoints[this.pathIndex].add(t4);
  }
  getControlPointAt(t4) {
    return this._controlPoints[this.pathIndex].has(t4);
  }
};
var y = class _y extends d {
  initialize(t4, e, s2, i2, h2) {
    return super.initialize(t4, e, s2, i2, h2);
  }
  clone() {
    return new _y().initialize(a(this._paths), this.geometryType, this.hasZ, this.hasM, 1);
  }
  setControlPoint() {
    this._paths[this.pathIndex][this._pointIndex][c2] = l2;
  }
  getControlPoint() {
    return this._paths[this.pathIndex][this._pointIndex][c2] === l2;
  }
  setControlPointAt(t4) {
    this._paths[this.pathIndex][t4][c2] = l2;
  }
  getControlPointAt(t4) {
    return this._paths[this.pathIndex][t4][c2] === l2;
  }
};

// node_modules/@arcgis/core/geometry/support/labelPoint.js
var N = 100 * 222045e-21;
function l4(t4) {
  if (0 === t4.totalSize)
    return null;
  const a3 = c(t4);
  if (!a3)
    return null;
  const o = 4 * (Math.abs(a3[0]) + Math.abs(a3[2]) + Math.abs(a3[1]) + Math.abs(a3[3]) + 1) * N;
  let s2 = 0, c3 = 0;
  t4.reset();
  for (let e = 0; t4.nextPath(); e++) {
    const n = t4.getCurrentRingArea();
    n > c3 && (c3 = n, s2 = e);
  }
  if (t4.seekPath(s2), 0 === t4.pathSize)
    return null;
  t4.seekPathStart();
  const l5 = f2(t4);
  if (Math.abs(c3) <= 2 * o * o)
    return [(l5[0] + l5[2]) / 2, (l5[1] + l5[3]) / 2];
  t4.seekPathStart();
  const x2 = i(t4, u());
  if (null === x2)
    return null;
  if (t4.totalPoints < 4)
    return x2;
  const m4 = [[NaN, NaN], [NaN, NaN], [NaN, NaN], [NaN, NaN]], d3 = [NaN, NaN, NaN, NaN], P2 = [NaN, NaN, NaN, NaN];
  let y3 = false, M2 = f4(x2, t4, true);
  0 === M2.distance && (y3 = true, m4[0][0] = x2[0], m4[0][1] = x2[1], M2 = f4(x2, t4, false)), d3[0] = M2.distance, P2[0] = 0;
  const b2 = [NaN, NaN];
  let S = false, k = 0.25, z = -1, g = NaN;
  do {
    if (g = NaN, m4[1] = h(t4, w(l5[0], l5[2], k), o, a3), isNaN(m4[1][0]) || isNaN(m4[1][1]) || (M2 = f4(m4[1], t4, false), g = M2.distance), !isNaN(g) && g > o && u4(m4[1], t4))
      S = true, d3[1] = g, P2[1] = p2(m4[1], x2);
    else if (!isNaN(g) && g > z && (z = g, b2[0] = m4[1][0], b2[1] = m4[1][1]), k -= 0.01, k < 0.1) {
      if (!(z >= 0))
        break;
      S = true, d3[1] = z, m4[1][0] = b2[0], m4[1][1] = b2[1], P2[1] = p2(m4[1], x2);
    }
  } while (!S);
  S = false, k = 0.5, z = -1;
  let q = 0.01, j = 1;
  do {
    if (g = NaN, m4[2] = h(t4, w(l5[0], l5[2], k), o, a3), isNaN(m4[2][0]) || isNaN(m4[2][1]) || (M2 = f4(m4[2], t4, false), g = M2.distance), !isNaN(g) && g > o && u4(m4[2], t4))
      S = true, d3[2] = g, P2[2] = p2(m4[2], x2);
    else if (!isNaN(g) && g > z)
      z = g, b2[0] = m4[2][0], b2[1] = m4[2][1];
    else if (g > z && (z = g, b2[0] = m4[2][0], b2[1] = m4[2][1]), k = 0.5 + q * j, q += 0.01, j *= -1, k < 0.3 || k > 0.7) {
      if (!(z >= 0))
        break;
      S = true, d3[2] = z, m4[2][0] = b2[0], m4[2][1] = b2[1], P2[2] = p2(m4[2], x2);
    }
  } while (!S);
  S = false, k = 0.75, z = -1;
  do {
    if (g = NaN, m4[3] = h(t4, w(l5[0], l5[2], k), o, a3), isNaN(m4[3][0]) || isNaN(m4[3][1]) || (M2 = f4(m4[3], t4, false), g = M2.distance), !isNaN(g) && g > o && u4(m4[3], t4))
      S = true, d3[3] = g, P2[3] = p2(m4[3], x2);
    else if (g > z && (z = g, b2[0] = m4[3][0], b2[1] = m4[3][1]), k += 0.01, k > 0.9) {
      if (!(z >= 0))
        break;
      S = true, d3[3] = z, m4[3][0] = b2[0], m4[3][1] = b2[1], P2[3] = p2(m4[3], x2);
    }
  } while (!S);
  const T = [0, 1, 2, 3], D = y3 ? 0 : 1;
  let R;
  for (let e = D; e < 4; e++)
    for (let t5 = D; t5 < 3; t5++) {
      const e2 = P2[t5], n = P2[t5 + 1];
      C(e2, n) > 0 && (R = T[t5], T[t5] = T[t5 + 1], T[t5 + 1] = R, P2[t5] = n, P2[t5 + 1] = e2);
    }
  let B = D, Q = 0, U = 0;
  for (let e = D; e < 4; e++) {
    switch (e) {
      case 0:
        U = 2 * d3[T[e]];
        break;
      case 1:
        U = 1.66666666 * d3[T[e]];
        break;
      case 2:
        U = 1.33333333 * d3[T[e]];
        break;
      case 3:
        U = d3[T[e]];
    }
    U > Q && (Q = U, B = T[e]);
  }
  return m4[B];
}
function u4(t4, e) {
  let n, i2, r, a3, o = 0;
  for (e.reset(); e.nextPath() && e.nextPoint(); )
    for (n = e.x, i2 = e.y; e.nextPoint(); n = r, i2 = a3) {
      if (r = e.x, a3 = e.y, i2 > t4[1] == a3 > t4[1])
        continue;
      (r - n) * (t4[1] - i2) - (a3 - i2) * (t4[0] - n) > 0 ? o++ : o--;
    }
  return 0 !== o;
}
function f4(t4, e, n) {
  if (n && u4(t4, e))
    return { coord: t4, distance: 0 };
  let i2 = 1 / 0, r = 0, a3 = 0, s2 = [0, 0], c3 = [0, 0];
  const N2 = [0, 0];
  for (e.reset(); e.nextPath() && e.nextPoint(); )
    if (!(e.pathSize < 2))
      for (s2[0] = e.x, s2[1] = e.y; e.nextPoint(); s2 = c3) {
        c3 = [e.x, e.y], f(N2, t4, s2, c3);
        const n2 = p2(t4, N2);
        n2 < i2 && (i2 = n2, r = N2[0], a3 = N2[1]);
      }
  return { coord: [r, a3], distance: Math.sqrt(i2) };
}
function h(t4, n, i2, r) {
  const a3 = [n, 0];
  let o = 1 / 0, s2 = 1 / 0, N2 = false, l5 = false;
  const u5 = [[n, r[1] - 1], [n, r[3] + 1]], f5 = [0, 0], h2 = [0, 0], m4 = [0, 0], d3 = [[0, 0], [0, 0]], P2 = u();
  for (t4.reset(); t4.nextPath() && t4.nextPoint(); )
    if (!(t4.pathSize < 2))
      for (d3[0][0] = t4.x, d3[0][1] = t4.y; t4.nextPoint(); d3[0][0] = d3[1][0], d3[0][1] = d3[1][1]) {
        if (d3[1][0] = t4.x, d3[1][1] = t4.y, null === x(P2, d3))
          continue;
        if (h2[0] = u5[0][0], h2[1] = u5[0][1], m4[0] = u5[1][0], m4[1] = u5[1][1], 0 === M(P2, h2, m4))
          continue;
        if (!G(u5[0], u5[1], d3[0], d3[1], f5))
          continue;
        const e = f5[1];
        o > s2 ? e < o && (o = e, N2 = true) : e < s2 && (s2 = e, l5 = true);
      }
  return N2 && l5 ? a3[1] = (o + s2) / 2 : a3[0] = a3[1] = NaN, a3;
}
function x(t4, n) {
  if (n.length < 2)
    return null;
  t4 || (t4 = u());
  const [i2, r] = n[0], [a3, o] = n[1];
  return t4[0] = Math.min(i2, a3), t4[1] = Math.min(r, o), t4[2] = Math.max(i2, a3), t4[3] = Math.max(r, o), t4;
}
var m3 = 1;
var d2 = 4;
var P = 3;
var y2 = 12;
function M(t4, e, n) {
  let i2 = b(e, t4), r = b(n, t4);
  const a3 = t4[0], o = t4[1], s2 = t4[2], c3 = t4[3];
  if (i2 & r)
    return 0;
  if (!(i2 | r))
    return 4;
  const N2 = (i2 ? 1 : 0) | (r ? 2 : 0);
  do {
    const N3 = n[0] - e[0], l5 = n[1] - e[1];
    if (N3 > l5)
      i2 & P ? (i2 & m3 ? (e[1] += l5 * (a3 - e[0]) / N3, e[0] = a3) : (e[1] += l5 * (s2 - e[0]) / N3, e[0] = s2), i2 = b(e, t4)) : r & P ? (r & m3 ? (n[1] += l5 * (a3 - n[0]) / N3, n[0] = a3) : (n[1] += l5 * (s2 - n[0]) / N3, n[0] = s2), r = b(n, t4)) : i2 ? (i2 & d2 ? (e[0] += N3 * (o - e[1]) / l5, e[1] = o) : (e[0] += N3 * (c3 - e[1]) / l5, e[1] = c3), i2 = b(e, t4)) : (r & d2 ? (n[0] += N3 * (o - n[1]) / l5, n[1] = o) : (n[0] += N3 * (c3 - n[1]) / l5, n[1] = c3), r = b(n, t4));
    else if (i2 & y2 ? (i2 & d2 ? (e[0] += N3 * (o - e[1]) / l5, e[1] = o) : (e[0] += N3 * (c3 - e[1]) / l5, e[1] = c3), i2 = b(e, t4)) : r & y2 ? (r & d2 ? (n[0] += N3 * (o - n[1]) / l5, n[1] = o) : (n[0] += N3 * (c3 - n[1]) / l5, n[1] = c3), r = b(n, t4)) : i2 ? (i2 & m3 ? (e[1] += l5 * (a3 - e[0]) / N3, e[0] = a3) : (e[1] += l5 * (s2 - e[0]) / N3, e[0] = s2), i2 = b(e, t4)) : (r & m3 ? (n[1] += l5 * (a3 - n[0]) / N3, n[0] = a3) : (n[1] += l5 * (s2 - n[0]) / N3, n[0] = s2), r = b(n, t4)), i2 & r)
      return 0;
  } while (i2 | r);
  return N2;
}
function b(t4, e) {
  return (t4[0] < e[0] ? 1 : 0) | (t4[0] > e[2] ? 1 : 0) << 1 | (t4[1] < e[1] ? 1 : 0) << 2 | (t4[1] > e[3] ? 1 : 0) << 3;
}
function w(t4, e, n) {
  return t4 + (e - t4) * n;
}
function p2(t4, e) {
  return (t4[0] - e[0]) * (t4[0] - e[0]) + (t4[1] - e[1]) * (t4[1] - e[1]);
}
function C(t4, e) {
  if (t4 < e)
    return -1;
  if (t4 > e)
    return 1;
  if (t4 === e)
    return 0;
  const n = isNaN(t4), i2 = isNaN(e);
  return n < i2 ? -1 : n > i2 ? 1 : 0;
}

export {
  a2 as a,
  l4 as l
};
//# sourceMappingURL=chunk-OPV4AZKI.js.map
