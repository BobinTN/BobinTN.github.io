import {
  N,
  i
} from "./chunk-Z3CHIB6Q.js";
import {
  G2 as G,
  H,
  J2 as J,
  K,
  P2 as P,
  Q,
  X,
  a,
  de,
  r,
  t,
  ve,
  z
} from "./chunk-24PJGGGS.js";
import {
  st
} from "./chunk-747B2TEO.js";
import {
  m,
  n,
  n2
} from "./chunk-W4QVNWBV.js";
import {
  Z
} from "./chunk-M7OEQQRX.js";
import {
  p as p2
} from "./chunk-IPCIO3PX.js";
import {
  p,
  x2 as x
} from "./chunk-QNOCEWCR.js";

// node_modules/@arcgis/core/arcade/Feature.js
var D = class _D {
  constructor() {
    this.arcadeDeclaredClass = "esri.arcade.Feature", this._optimizedGeomDefinition = null, this._geometry = null, this.attributes = null, this._layer = null, this._fieldTypesFixed = true, this.fieldsIndex = null, this.contextTimeZone = null, this.immutable = true, this._fieldsToFixDataTypes = null, this.immutable = true;
  }
  static createFromGraphic(e, t2) {
    const i2 = new _D();
    return i2.contextTimeZone = t2 ?? null, i2._geometry = null != e.geometry ? e.geometry : null, void 0 === e.attributes || null === e.attributes ? i2.attributes = {} : i2.attributes = e.attributes, e._sourceLayer ? (i2._layer = e._sourceLayer, i2._fieldTypesFixed = false) : e._layer ? (i2._layer = e._layer, i2._fieldTypesFixed = false) : e.layer && "fields" in e.layer ? (i2._layer = e.layer, i2._fieldTypesFixed = false) : e.sourceLayer && "fields" in e.sourceLayer && (i2._layer = e.sourceLayer, i2._fieldTypesFixed = false), i2._layer && !i2._fieldTypesFixed && (i2.fieldsIndex = this.hydrateFieldsIndex(i2._layer)), i2;
  }
  static createFromArcadeFeature(e) {
    if (e instanceof _D) {
      const t3 = new _D();
      return t3._fieldTypesFixed = e._fieldTypesFixed, t3.attributes = e.attributes, t3._geometry = e._geometry, t3._optimizedGeomDefinition = e._optimizedGeomDefinition, e._layer && (t3._layer = e._layer), t3.fieldsIndex = e.fieldsIndex, t3.contextTimeZone = e.contextTimeZone, t3;
    }
    const t2 = {};
    for (const i2 of e.keys())
      t2[i2] = e.field(i2);
    return _D.createFromGraphicLikeObject(e.geometry(), t2, e.fullSchema(), e.contextTimeZone);
  }
  static createFromOptimisedFeature(e, t2, i2) {
    const s = new _D();
    return s._geometry = e.geometry ? { geometry: e.geometry } : null, s._optimizedGeomDefinition = i2, s.attributes = e.attributes || {}, s._layer = t2, s._fieldTypesFixed = false, s;
  }
  static createFromArcadeDictionary(e) {
    const t2 = new _D();
    return t2.attributes = e.field("attributes"), null !== t2.attributes && t2.attributes instanceof N ? (t2.attributes = t2.attributes.attributes, null === t2.attributes && (t2.attributes = {})) : t2.attributes = {}, t2._geometry = e.field("geometry"), null !== t2._geometry && (t2._geometry instanceof N ? t2._geometry = _D.parseGeometryFromDictionary(t2._geometry) : t2._geometry instanceof p || (t2._geometry = null)), t2;
  }
  static createFromGraphicLikeObject(e, t2, i2 = null, s) {
    const r2 = new _D();
    return r2.contextTimeZone = s ?? null, null === t2 && (t2 = {}), r2.attributes = t2, r2._geometry = null != e ? e : null, r2._layer = i2, r2._layer && (r2._fieldTypesFixed = false, r2.fieldsIndex = this.hydrateFieldsIndex(r2._layer)), r2;
  }
  static hydrateFieldsIndex(e) {
    return null === e ? null : H(e) ? e.getFieldsIndex() : e.fieldsIndex ? e.fieldsIndex : Z.fromLayerJSON({ datesInUnknownTimezone: e.datesInUnknownTimezone, fields: e.fields, timeInfo: e.timeInfo, editFieldsInfo: e.editFieldsInfo, dateFieldsTimeReference: e.dateFieldsTimeReference ?? { timeZone: "UTC", respectsDaylightSaving: false } });
  }
  repurposeFromGraphicLikeObject(e, t2, i2 = null) {
    null === t2 && (t2 = {}), this.attributes = t2, this._geometry = e ?? null, this._layer = i2, this._layer ? this._fieldTypesFixed = false : this._fieldTypesFixed = true;
  }
  castToText(t2 = false) {
    let i2 = "";
    false === this._fieldTypesFixed && this._fixFieldTypes();
    for (const s in this.attributes) {
      "" !== i2 && (i2 += ",");
      const r2 = this.attributes[s];
      null == r2 ? i2 += JSON.stringify(s) + ":null" : G(r2) || z(r2) || P(r2) ? i2 += JSON.stringify(s) + ":" + JSON.stringify(r2) : r2 instanceof p ? i2 += JSON.stringify(s) + ":" + de(r2) : r2 instanceof n2 || r2 instanceof n ? i2 += `${JSON.stringify(s)}:${JSON.stringify(r2.toString())}` : r2 instanceof t || r2 instanceof Array ? i2 += JSON.stringify(s) + ":" + de(r2, null, t2) : r2 instanceof m ? i2 += t2 ? JSON.stringify(s) + ":" + JSON.stringify(r2.getTime()) : JSON.stringify(s) + ":" + r2.stringify() : null !== r2 && "object" == typeof r2 && void 0 !== r2.castToText && (i2 += JSON.stringify(s) + ":" + r2.castToText(t2));
    }
    return '{"geometry":' + (null === this.geometry() ? "null" : de(this.geometry())) + ',"attributes":{' + i2 + "}}";
  }
  _fixFieldTypes() {
    var _a;
    if (this._fieldsToFixDataTypes && ((_a = this._fieldsToFixDataTypes) == null ? void 0 : _a.length) > 0)
      return this._fixAllFields(this._fieldsToFixDataTypes), void (this._fieldTypesFixed = true);
    const e = [], t2 = this._layer.fields;
    for (let i2 = 0; i2 < t2.length; i2++) {
      const s = t2[i2], { name: r2, type: n3 } = s;
      switch (n3) {
        case "date":
        case "esriFieldTypeDate":
          e.push({ field: r2, dataType: "date" });
          break;
        case "date-only":
        case "esriFieldTypeDateOnly":
          e.push({ field: r2, dataType: "date-only" });
          break;
        case "time-only":
        case "esriFieldTypeTimeOnly":
          e.push({ field: r2, dataType: "time-only" });
          break;
        case "timestamp-offset":
        case "esriFieldTypeTimestampOffset":
          e.push({ field: r2, dataType: "timestamp-offset" });
      }
    }
    this._fieldsToFixDataTypes = e, e.length > 0 && this._fixAllFields(e), this._fieldTypesFixed = true;
  }
  isUnknownDateTimeField(e) {
    var _a;
    return "unknown" === ((_a = this.fieldsIndex) == null ? void 0 : _a.getTimeZone(e));
  }
  _fixAllFields(t2) {
    this.attributes = { ...this.attributes };
    const i2 = this.contextTimeZone ?? "system";
    for (let s = 0; s < t2.length; s++) {
      const r2 = t2[s].field, n3 = t2[s].dataType;
      let o = this.attributes[r2];
      if (void 0 === o) {
        for (const t3 in this.attributes)
          if (t3.toLowerCase() === r2.toLowerCase()) {
            if (o = this.attributes[t3], null !== o) {
              if ("time-only" === n3) {
                K(o) || (this.attributes[t3] = n2.fromReader(o.toString()));
                break;
              }
              if ("date-only" === n3) {
                X(o) || (this.attributes[t3] = n.fromReader(o.toString()));
                break;
              }
              if ("timestamp-offset" === n3) {
                Q(o) || (this.attributes[t3] = m.fromReaderAsTimeStampOffset(o.toString()));
                break;
              }
              const s2 = this.isUnknownDateTimeField(t3);
              o instanceof Date ? this.attributes[t3] = s2 ? m.unknownDateJSToArcadeDate(o) : m.dateJSAndZoneToArcadeDate(o, i2) : Q(o) || (this.attributes[t3] = s2 ? m.unknownEpochToArcadeDate(o) : m.epochToArcadeDate(o, i2));
            }
            break;
          }
      } else if (null !== o) {
        if ("time-only" === n3) {
          K(o) ? this.attributes[r2] = o : this.attributes[r2] = n2.fromReader(o.toString());
          continue;
        }
        if ("date-only" === n3) {
          X(o) ? this.attributes[r2] = o : this.attributes[r2] = n.fromReader(o.toString());
          continue;
        }
        if ("timestamp-offset" === n3) {
          Q(o) ? this.attributes[r2] = o : this.attributes[r2] = m.fromReaderAsTimeStampOffset(o.toString());
          continue;
        }
        const t3 = this.isUnknownDateTimeField(r2);
        Q(o) ? this.attributes[r2] = o : o instanceof Date ? this.attributes[r2] = t3 ? m.unknownDateJSToArcadeDate(o) : m.dateJSAndZoneToArcadeDate(o, i2) : this.attributes[r2] = t3 ? m.unknownEpochToArcadeDate(o) : m.epochToArcadeDate(o, i2);
      }
    }
  }
  geometry() {
    return null === this._geometry || this._geometry instanceof p || (this._optimizedGeomDefinition ? (this._geometry = p2(st(this._geometry, this._optimizedGeomDefinition.geometryType, this._optimizedGeomDefinition.hasZ, this._optimizedGeomDefinition.hasM)), this._geometry.spatialReference = this._optimizedGeomDefinition.spatialReference) : this._geometry = p2(this._geometry)), this._geometry;
  }
  field(e) {
    this._fieldTypesFixed || this._fixFieldTypes();
    const t2 = this.attributes[e];
    if (void 0 !== t2)
      return t2;
    const i2 = e.toLowerCase();
    for (const s in this.attributes)
      if (s.toLowerCase() === i2)
        return this.attributes[s];
    if (this._hasFieldDefinition(i2))
      return null;
    throw new a(null, r.FieldNotFound, null, { key: e });
  }
  _hasFieldDefinition(e) {
    if (null === this._layer)
      return false;
    for (let t2 = 0; t2 < this._layer.fields.length; t2++) {
      if (this._layer.fields[t2].name.toLowerCase() === e)
        return true;
    }
    return false;
  }
  setField(t2, i2) {
    if (this.immutable)
      throw new a(null, r.Immutable, null);
    if (i2 instanceof Date && (i2 = this.isUnknownDateTimeField(t2) ? m.unknownDateJSToArcadeDate(i2) : m.dateJSToArcadeDate(i2)), false === J(i2))
      throw new a(null, r.TypeNotAllowedInFeature, null);
    const n3 = t2.toLowerCase();
    if (void 0 === this.attributes[t2]) {
      for (const e in this.attributes)
        if (e.toLowerCase() === n3)
          return void (this.attributes[e] = i2);
      this.attributes[t2] = i2;
    } else
      this.attributes[t2] = i2;
  }
  hasField(e) {
    const t2 = e.toLowerCase();
    if (void 0 !== this.attributes[e])
      return true;
    for (const i2 in this.attributes)
      if (i2.toLowerCase() === t2)
        return true;
    return !!this._hasFieldDefinition(t2);
  }
  keys() {
    let e = [];
    const t2 = {};
    for (const i2 in this.attributes)
      e.push(i2), t2[i2.toLowerCase()] = 1;
    if (null !== this._layer)
      for (let i2 = 0; i2 < this._layer.fields.length; i2++) {
        const s = this._layer.fields[i2];
        1 !== t2[s.name.toLowerCase()] && e.push(s.name);
      }
    return e = e.sort(), e;
  }
  static parseGeometryFromDictionary(e) {
    const t2 = _D._convertDictionaryToJson(e, true);
    return void 0 !== t2.hasm && (t2.hasM = t2.hasm, delete t2.hasm), void 0 !== t2.hasz && (t2.hasZ = t2.hasz, delete t2.hasz), void 0 !== t2.spatialreference && (t2.spatialReference = t2.spatialreference, delete t2.spatialreference), void 0 !== t2.rings && (t2.rings = this._fixPathArrays(t2.rings, true === t2.hasZ, true === t2.hasZ)), void 0 !== t2.paths && (t2.paths = this._fixPathArrays(t2.paths, true === t2.hasZ, true === t2.hasM)), void 0 !== t2.points && (t2.points = this._fixPointArrays(t2.points, true === t2.hasZ, true === t2.hasM)), p2(t2);
  }
  static _fixPathArrays(e, t2, i2) {
    const s = [];
    if (e instanceof Array)
      for (let r2 = 0; r2 < e.length; r2++)
        s.push(this._fixPointArrays(e[r2], t2, i2));
    else if (e instanceof t)
      for (let r2 = 0; r2 < e.length(); r2++)
        s.push(this._fixPointArrays(e.get(r2), t2, i2));
    return s;
  }
  static _fixPointArrays(e, t2, i2) {
    const s = [];
    if (e instanceof Array)
      for (let r2 = 0; r2 < e.length; r2++) {
        const o = e[r2];
        o instanceof x ? t2 && i2 ? s.push([o.x, o.y, o.z, o.m]) : t2 ? s.push([o.x, o.y, o.z]) : i2 ? s.push([o.x, o.y, o.m]) : s.push([o.x, o.y]) : o instanceof t ? s.push(o.toArray()) : s.push(o);
      }
    else if (e instanceof t)
      for (let r2 = 0; r2 < e.length(); r2++) {
        const o = e.get(r2);
        o instanceof x ? t2 && i2 ? s.push([o.x, o.y, o.z, o.m]) : t2 ? s.push([o.x, o.y, o.z]) : i2 ? s.push([o.x, o.y, o.m]) : s.push([o.x, o.y]) : o instanceof t ? s.push(o.toArray()) : s.push(o);
      }
    return s;
  }
  static _convertDictionaryToJson(e, t2 = false) {
    const s = {};
    for (const r2 in e.attributes) {
      let n3 = e.attributes[r2];
      n3 instanceof N && (n3 = _D._convertDictionaryToJson(n3)), t2 ? s[r2.toLowerCase()] = n3 : s[r2] = n3;
    }
    return s;
  }
  static parseAttributesFromDictionary(e) {
    const t2 = {};
    for (const i2 in e.attributes) {
      const n3 = e.attributes[i2];
      if (!J(n3))
        throw new a(null, r.InvalidParameter, null);
      t2[i2] = n3;
    }
    return t2;
  }
  static fromJson(e, t2) {
    let i2 = null;
    null !== e.geometry && void 0 !== e.geometry && (i2 = p2(e.geometry));
    const n3 = {};
    if (null !== e.attributes && void 0 !== e.attributes)
      for (const o in e.attributes) {
        const t3 = e.attributes[o];
        if (null === t3)
          n3[o] = t3;
        else {
          if (!(P(t3) || z(t3) || G(t3) || Q(t3) || K(t3) || X(t3)))
            throw new a(null, r.InvalidParameter, null);
          n3[o] = t3;
        }
      }
    return _D.createFromGraphicLikeObject(i2, n3, null, t2 ?? null);
  }
  fullSchema() {
    return this._layer;
  }
  gdbVersion() {
    var _a;
    if (null === this._layer)
      return "";
    const e = this._layer.gdbVersion;
    return void 0 === e ? "" : "" === e && ((_a = this._layer.capabilities) == null ? void 0 : _a.isVersioned) ? "SDE.DEFAULT" : e;
  }
  castAsJson(e) {
    var _a;
    const t2 = { attributes: {}, geometry: true === (e == null ? void 0 : e.keepGeometryType) ? this.geometry() : ((_a = this.geometry()) == null ? void 0 : _a.toJSON()) ?? null };
    for (const i2 in this.attributes) {
      const s = this.attributes[i2];
      void 0 !== s && (t2.attributes[i2] = ve(s, e));
    }
    return t2;
  }
  async castAsJsonAsync(e = null, t2) {
    return this.castAsJson(t2);
  }
};
i(D);

export {
  D
};
//# sourceMappingURL=chunk-TXUI2PB2.js.map
