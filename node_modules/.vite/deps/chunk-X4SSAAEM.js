import {
  d as d3,
  l as l2
} from "./chunk-GKZKNWGZ.js";
import {
  L,
  c,
  e,
  h as h2,
  l,
  m,
  n,
  o,
  p as p2,
  s as s3,
  t,
  u as u2
} from "./chunk-QS4IQWBR.js";
import {
  d as d2,
  g as g2,
  h,
  p,
  y2
} from "./chunk-6JCSK7BN.js";
import {
  y,
  z
} from "./chunk-XZLDDXLF.js";
import {
  g
} from "./chunk-AHDIKORE.js";
import {
  d,
  j
} from "./chunk-HITXLR5N.js";
import {
  u
} from "./chunk-EIY2DYTV.js";
import {
  a
} from "./chunk-SJZIFARA.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";

// node_modules/@arcgis/core/symbols/support/previewSymbol3D.js
var P = t.size;
var D = t.maxSize;
var U = t.maxOutlineSize;
var O = t.lineWidth;
var C = t.tallSymbolWidth;
function R(e2) {
  const t2 = e2.outline, l3 = null != e2.material ? e2.material.color : null, a2 = null != l3 ? l3.toHex() : null;
  if (null == t2 || "pattern" in t2 && null != t2.pattern && "style" === t2.pattern.type && "none" === t2.pattern.style)
    return "fill" === e2.type && "#ffffff" === a2 ? { color: "#bdc3c7", width: 0.75 } : null;
  const s4 = u(t2.size) || 0;
  return { color: "rgba(" + (null != t2.color ? t2.color.toRgba() : "255,255,255,1") + ")", width: Math.min(s4, U), style: "pattern" in t2 && null != t2.pattern && "style" === t2.pattern.type ? d2(t2.pattern.style) : null, join: "butt", cap: "patternCap" in t2 ? t2.patternCap : "butt" };
}
async function E(t2, l3) {
  var _a, _b, _c;
  if ((_a = t2.thumbnail) == null ? void 0 : _a.url)
    return t2.thumbnail.url;
  if ("icon" === l3.type) {
    const e2 = (_b = l3 == null ? void 0 : l3.resource) == null ? void 0 : _b.href;
    if (e2)
      return p(l3);
  }
  const a2 = a("esri/images/Legend/legend3dsymboldefault.png");
  if (t2.styleOrigin && (t2.styleOrigin.styleName || t2.styleOrigin.styleUrl)) {
    const e2 = await g(t2.styleOrigin, { portal: t2.styleOrigin.portal }, "webRef").catch(() => null);
    if (e2 && "thumbnail" in e2 && ((_c = e2.thumbnail) == null ? void 0 : _c.url))
      return e2.thumbnail.url;
  }
  return a2;
}
function I(e2, a2 = 1) {
  const s4 = e2.a, n2 = z(e2), r = n2.h, o2 = n2.s / a2, i = 100 - (100 - n2.v) / a2, { r: c2, g: p3, b: u3 } = y({ h: r, s: o2, v: i });
  return [c2, p3, u3, s4];
}
function Z(e2) {
  var _a;
  return "water" === e2.type ? null == e2.color ? null : e2.color : null == ((_a = e2.material) == null ? void 0 : _a.color) ? null : e2.material.color;
}
function q(e2, t2 = 0) {
  const l3 = Z(e2);
  if (!l3) {
    if ("fill" === e2.type)
      return null;
    const l4 = g2.r, a3 = h2(l4, t2);
    return [a3, a3, a3, 100];
  }
  const a2 = l3.toRgba();
  for (let s4 = 0; s4 < 3; s4++)
    a2[s4] = h2(a2[s4], t2);
  return a2;
}
async function H(t2, l3) {
  const a2 = t2.style;
  if ("none" === a2)
    return null;
  return { type: "pattern", x: 0, y: 0, src: await h(a(`esri/symbols/patterns/${a2}.png`), l3.toCss(true)), width: 5, height: 5 };
}
function N(e2) {
  return e2.outline ? R(e2) : { color: "rgba(0, 0, 0, 1)", width: 1.5 };
}
function T(e2, t2) {
  const l3 = Z(e2);
  if (!l3)
    return null;
  let a2 = "rgba(";
  return a2 += h2(l3.r, t2) + ",", a2 += h2(l3.g, t2) + ",", a2 += h2(l3.b, t2) + ",", a2 + l3.a + ");";
}
function W(e2, t2) {
  const l3 = T(e2, t2);
  if (!l3)
    return {};
  if ("pattern" in e2 && null != e2.pattern && "style" === e2.pattern.type && "none" === e2.pattern.style)
    return null;
  return { color: l3, width: Math.min(e2.size ? u(e2.size) : 0.75, U), style: "pattern" in e2 && null != e2.pattern && "style" === e2.pattern.type ? d2(e2.pattern.style) : null, cap: "cap" in e2 ? e2.cap : null, join: "join" in e2 ? "miter" === e2.join ? u(2) : e2.join : null };
}
function F(e2, t2, l3) {
  const a2 = null != l3 ? 0.75 * l3 : 0;
  return { type: "linear", x1: a2 ? 0.25 * a2 : 0, y1: a2 ? 0.5 * a2 : 0, x2: a2 || 4, y2: a2 ? 0.5 * a2 : 4, colors: [{ color: e2, offset: 0 }, { color: t2, offset: 1 }] };
}
function $(e2) {
  const t2 = e2.depth, l3 = e2.height, a2 = e2.width;
  return 0 !== a2 && 0 !== t2 && 0 !== l3 && a2 === t2 && null != a2 && null != l3 && a2 < l3;
}
function A(e2, t2, l3) {
  const a2 = [];
  if (!e2)
    return a2;
  switch (e2.type) {
    case "icon": {
      const l4 = 0, s4 = 0, n2 = t2, r = t2;
      switch (e2.resource && e2.resource.primitive || j) {
        case "circle":
          a2.push({ shape: { type: "circle", cx: 0, cy: 0, r: 0.5 * t2 }, fill: q(e2, 0), stroke: R(e2) });
          break;
        case "square":
          a2.push({ shape: { type: "path", path: [{ command: "M", values: [l4, r] }, { command: "L", values: [l4, s4] }, { command: "L", values: [n2, s4] }, { command: "L", values: [n2, r] }, { command: "Z", values: [] }] }, fill: q(e2, 0), stroke: R(e2) });
          break;
        case "triangle":
          a2.push({ shape: { type: "path", path: [{ command: "M", values: [l4, r] }, { command: "L", values: [0.5 * n2, s4] }, { command: "L", values: [n2, r] }, { command: "Z", values: [] }] }, fill: q(e2, 0), stroke: R(e2) });
          break;
        case "cross":
          a2.push({ shape: { type: "path", path: [{ command: "M", values: [0.5 * n2, s4] }, { command: "L", values: [0.5 * n2, r] }, { command: "M", values: [l4, 0.5 * r] }, { command: "L", values: [n2, 0.5 * r] }] }, stroke: N(e2) });
          break;
        case "x":
          a2.push({ shape: { type: "path", path: [{ command: "M", values: [l4, s4] }, { command: "L", values: [n2, r] }, { command: "M", values: [n2, s4] }, { command: "L", values: [l4, r] }] }, stroke: N(e2) });
          break;
        case "kite":
          a2.push({ shape: { type: "path", path: [{ command: "M", values: [l4, 0.5 * r] }, { command: "L", values: [0.5 * n2, s4] }, { command: "L", values: [n2, 0.5 * r] }, { command: "L", values: [0.5 * n2, r] }, { command: "Z", values: [] }] }, fill: q(e2, 0), stroke: R(e2) });
      }
      break;
    }
    case "object":
      switch (e2.resource && e2.resource.primitive || d) {
        case "cone": {
          const s4 = F(q(e2, 0), q(e2, -0.6), l3 ? C : t2), n2 = l(t2, l3);
          a2.push({ shape: n2[0], fill: s4 }, { shape: n2[1], fill: s4 });
          break;
        }
        case "inverted-cone": {
          const l4 = q(e2, 0), s4 = F(l4, q(e2, -0.6), t2), n2 = o(t2);
          a2.push({ shape: n2[0], fill: s4 }, { shape: n2[1], fill: l4 });
          break;
        }
        case "cube": {
          const s4 = L(t2, l3);
          a2.push({ shape: s4[0], fill: q(e2, 0) }, { shape: s4[1], fill: q(e2, -0.3) }, { shape: s4[2], fill: q(e2, -0.5) });
          break;
        }
        case "cylinder": {
          const s4 = F(q(e2, 0), q(e2, -0.6), l3 ? C : t2), n2 = n(t2, l3);
          a2.push({ shape: n2[0], fill: s4 }, { shape: n2[1], fill: s4 }, { shape: n2[2], fill: q(e2, 0) });
          break;
        }
        case "diamond": {
          const l4 = s3(t2);
          a2.push({ shape: l4[0], fill: q(e2, -0.3) }, { shape: l4[1], fill: q(e2, 0) }, { shape: l4[2], fill: q(e2, -0.3) }, { shape: l4[3], fill: q(e2, -0.7) });
          break;
        }
        case "sphere": {
          const l4 = F(q(e2, 0), q(e2, -0.6));
          l4.x1 = 0, l4.y1 = 0, l4.x2 = 0.25 * t2, l4.y2 = 0.25 * t2, a2.push({ shape: { type: "circle", cx: 0, cy: 0, r: 0.5 * t2 }, fill: l4 });
          break;
        }
        case "tetrahedron": {
          const l4 = u2(t2);
          a2.push({ shape: l4[0], fill: q(e2, -0.3) }, { shape: l4[1], fill: q(e2, 0) }, { shape: l4[2], fill: q(e2, -0.6) });
          break;
        }
      }
      break;
  }
  return a2;
}
function B(e2) {
  const t2 = "number" == typeof (e2 == null ? void 0 : e2.size) ? e2 == null ? void 0 : e2.size : null;
  return t2 ? u(t2) : null;
}
function G(e2) {
  return "icon" === e2.type ? "multiply" : "tint";
}
async function J(e2, t2) {
  const l3 = B(t2), a2 = (t2 == null ? void 0 : t2.maxSize) ? u(t2.maxSize) : null, r = (t2 == null ? void 0 : t2.disableUpsampling) ?? false, o2 = e2.symbolLayers, i = [];
  let c2 = 0, p3 = 0;
  const u3 = o2.at(-1);
  let h3;
  u3 && "icon" === u3.type && (h3 = u3.size && u(u3.size)), o2.forEach((s4) => {
    var _a, _b;
    if ("icon" !== s4.type && "object" !== s4.type)
      return;
    const o3 = "icon" === s4.type ? s4.size && u(s4.size) : 0, u4 = l3 || o3 ? Math.ceil(Math.min(l3 || o3, a2 || D)) : P;
    if ((_a = s4 == null ? void 0 : s4.resource) == null ? void 0 : _a.href) {
      const t3 = E(e2, s4).then((e3) => {
        var _a2;
        const t4 = (_a2 = s4 == null ? void 0 : s4.material) == null ? void 0 : _a2.color, l4 = G(s4);
        return d3(e3, u4, t4, l4, r);
      }).then((e3) => {
        const t4 = e3.width, l4 = e3.height;
        return c2 = Math.max(c2, t4), p3 = Math.max(p3, l4), [{ shape: { type: "image", x: 0, y: 0, width: t4, height: l4, src: e3.url }, fill: null, stroke: null }];
      });
      i.push(t3);
    } else {
      let e3 = u4;
      "icon" === s4.type && h3 && l3 && (e3 = u4 * (o3 / h3));
      const a3 = "tall" === (t2 == null ? void 0 : t2.symbolConfig) || ((_b = t2 == null ? void 0 : t2.symbolConfig) == null ? void 0 : _b.isTall) || "object" === s4.type && $(s4);
      c2 = Math.max(c2, a3 ? C : e3), p3 = Math.max(p3, e3), i.push(Promise.resolve(A(s4, e3, a3)));
    }
  });
  const m2 = await Promise.allSettled(i), f = [];
  return m2.forEach((e3) => {
    "fulfilled" === e3.status ? f.push(e3.value) : e3.reason && s.getLogger("esri.symbols.support.previewSymbol3D").warn("error while building swatchInfo!", e3.reason);
  }), l2(f, [c2, p3], { node: t2 == null ? void 0 : t2.node, scale: false, opacity: t2 == null ? void 0 : t2.opacity, ariaLabel: t2 == null ? void 0 : t2.ariaLabel });
}
function K(e2, t2) {
  const l3 = e2.symbolLayers, a2 = [], s4 = y2(e2), r = B(t2), o2 = ((t2 == null ? void 0 : t2.maxSize) ? u(t2.maxSize) : null) || U;
  let i, c2 = 0, p3 = 0;
  return l3.forEach((e3, t3) => {
    if (!e3)
      return;
    if ("line" !== e3.type && "path" !== e3.type)
      return;
    const l4 = [];
    switch (e3.type) {
      case "line": {
        const a3 = W(e3, 0);
        if (null == a3)
          break;
        const s5 = (a3 == null ? void 0 : a3.width) || 0;
        0 === t3 && (i = s5);
        const n2 = Math.min(r || s5, o2), u3 = 0 === t3 ? n2 : r ? n2 * (s5 / i) : n2, h3 = u3 > O / 2 ? 2 * u3 : O;
        p3 = Math.max(p3, u3), c2 = Math.max(c2, h3), a3.width = u3, l4.push({ shape: { type: "path", path: [{ command: "M", values: [0, 0.5 * p3] }, { command: "L", values: [c2, 0.5 * p3] }] }, stroke: a3 });
        break;
      }
      case "path": {
        const t4 = Math.min(r || P, o2), a3 = q(e3, 0), s5 = q(e3, -0.2), n2 = T(e3, -0.4), i2 = n2 ? { color: n2, width: 1 } : {};
        if ("quad" === e3.profile) {
          const t5 = e3.width, n3 = e3.height, r2 = m(t5 && n3 ? t5 / n3 : 1, 0 === n3, 0 === t5), o3 = { ...i2, join: "bevel" };
          l4.push({ shape: r2[0], fill: s5, stroke: o3 }, { shape: r2[1], fill: s5, stroke: o3 }, { shape: r2[2], fill: a3, stroke: o3 });
        } else
          l4.push({ shape: e.pathSymbol3DLayer[0], fill: s5, stroke: i2 }, { shape: e.pathSymbol3DLayer[1], fill: a3, stroke: i2 });
        p3 = Math.max(p3, t4), c2 = p3;
      }
    }
    a2.push(l4);
  }), Promise.resolve(l2(a2, [c2, p3], { node: t2 == null ? void 0 : t2.node, scale: s4, opacity: t2 == null ? void 0 : t2.opacity, ariaLabel: t2 == null ? void 0 : t2.ariaLabel }));
}
async function Q(e2, t2) {
  const l3 = "mesh-3d" === e2.type, a2 = e2.symbolLayers, s4 = B(t2), r = (t2 == null ? void 0 : t2.maxSize) ? u(t2.maxSize) : null, o2 = s4 || P, i = [];
  let c2 = 0, p3 = 0, u3 = false;
  for (let n2 = 0; n2 < a2.length; n2++) {
    const e3 = a2.at(n2), t3 = [];
    if (!l3 || "fill" === e3.type) {
      switch (e3.type) {
        case "fill": {
          const a3 = Math.min(o2, r || D);
          if (c2 = Math.max(c2, a3), p3 = Math.max(p3, a3), u3 = true, l3) {
            const l4 = e.meshSymbol3DFill, a4 = T(e3, -0.4), s5 = a4 ? { color: a4, width: 1, join: "round" } : {};
            t3.push({ shape: l4[0], fill: q(e3, 0), stroke: s5 }, { shape: l4[1], fill: q(e3, -0.2), stroke: s5 }, { shape: l4[2], fill: q(e3, -0.6), stroke: s5 });
          } else {
            let l4 = q(e3, 0);
            const a4 = "pattern" in e3 ? e3.pattern : null, s5 = R(e3), n3 = Z(e3);
            null != a4 && "style" === a4.type && "solid" !== a4.style && n3 && (l4 = await H(a4, n3)), t3.push({ shape: e.fill[0], fill: l4, stroke: s5 });
          }
          break;
        }
        case "line": {
          const l4 = W(e3, 0);
          if (null == l4)
            break;
          const a3 = { stroke: l4, shape: e.fill[0] };
          c2 = Math.max(c2, P), p3 = Math.max(p3, P), t3.push(a3);
          break;
        }
        case "extrude": {
          const l4 = { join: "round", width: 1, ...W(e3, -0.4) }, a3 = q(e3, 0), s5 = q(e3, -0.2), n3 = Math.min(o2, r || D), i2 = c(n3);
          l4.width = 1, t3.push({ shape: i2[0], fill: s5, stroke: l4 }, { shape: i2[1], fill: s5, stroke: l4 }, { shape: i2[2], fill: a3, stroke: l4 });
          const u4 = P, h3 = 0.7 * P + 0.5 * n3;
          c2 = Math.max(c2, u4), p3 = Math.max(p3, h3);
          break;
        }
        case "water": {
          const l4 = Z(e3), a3 = I(l4), s5 = I(l4, 2), n3 = I(l4, 3), i2 = p2();
          u3 = true, t3.push({ shape: i2[0], fill: a3 }, { shape: i2[1], fill: s5 }, { shape: i2[2], fill: n3 });
          const h3 = Math.min(o2, r || D);
          c2 = Math.max(c2, h3), p3 = Math.max(p3, h3);
          break;
        }
      }
      i.push(t3);
    }
  }
  return l2(i, [c2, p3], { node: t2 == null ? void 0 : t2.node, scale: u3, opacity: t2 == null ? void 0 : t2.opacity, ariaLabel: t2 == null ? void 0 : t2.ariaLabel });
}
function V(e2, t2) {
  if (0 === e2.symbolLayers.length)
    return Promise.reject(new s2("symbolPreview: renderPreviewHTML3D", "No symbolLayers in the symbol."));
  switch (e2.type) {
    case "point-3d":
      return J(e2, t2);
    case "line-3d":
      return K(e2, t2);
    case "polygon-3d":
    case "mesh-3d":
      return Q(e2, t2);
  }
  return Promise.reject(new s2("symbolPreview: swatchInfo3D", "symbol not supported."));
}

export {
  q,
  H,
  B,
  V
};
//# sourceMappingURL=chunk-X4SSAAEM.js.map
