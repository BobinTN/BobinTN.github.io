import {
  h as h2,
  m
} from "./chunk-K6C6RVSV.js";
import {
  j as j2
} from "./chunk-KBJ5Z4R2.js";
import {
  c,
  h
} from "./chunk-WL4VPODY.js";
import {
  a
} from "./chunk-SJZIFARA.js";
import {
  j
} from "./chunk-R5DM4YAB.js";
import {
  r,
  s2 as s,
  s3 as s2,
  t
} from "./chunk-WJ3HJKNC.js";

// node_modules/@arcgis/core/intl/number.js
var r2 = { ar: "ar-u-nu-latn" };
var a2 = /* @__PURE__ */ new WeakMap();
var e = {};
function i(t2) {
  const i5 = t2 || e;
  if (!a2.has(i5)) {
    const e2 = c(), o3 = r2[c()] || e2;
    a2.set(i5, new Intl.NumberFormat(o3, t2));
  }
  return a2.get(i5);
}
function o(t2 = {}) {
  const n = {};
  return null != t2.digitSeparator && (n.useGrouping = t2.digitSeparator), null != t2.places && (n.minimumFractionDigits = n.maximumFractionDigits = t2.places), n;
}
function u(t2, n) {
  return Object.is(t2, -0) && (t2 = 0), i(n).format(t2);
}
h(() => {
  a2 = /* @__PURE__ */ new WeakMap(), e = {};
});

// node_modules/@arcgis/core/intl/substitute.js
var i2 = s.getLogger("esri.intl.substitute");
function s3(t2, r4, n = {}) {
  const { format: o3 = {} } = n;
  return r(t2, (t3) => u2(t3, r4, o3));
}
function u2(t2, e2, n) {
  let o3, i5;
  const s6 = t2.indexOf(":");
  if (-1 === s6 ? o3 = t2.trim() : (o3 = t2.slice(0, s6).trim(), i5 = t2.slice(s6 + 1).trim()), !o3)
    return "";
  const u3 = t(o3, e2);
  if (null == u3)
    return "";
  const m2 = (i5 ? n == null ? void 0 : n[i5] : null) ?? (n == null ? void 0 : n[o3]);
  return m2 ? c2(u3, m2) : i5 ? a3(u3, i5) : f(u3);
}
function c2(t2, r4) {
  switch (r4.type) {
    case "date":
      return j2(t2, r4.intlOptions);
    case "number":
      return u(t2, r4.intlOptions);
    default:
      return i2.warn("missing format descriptor for key {key}"), f(t2);
  }
}
function a3(t2, r4) {
  switch (r4.toLowerCase()) {
    case "dateformat":
      return j2(t2);
    case "numberformat":
      return u(t2);
    default:
      return i2.warn(`inline format is unsupported since 4.12: ${r4}`), /^(dateformat|datestring)/i.test(r4) ? j2(t2) : /^numberformat/i.test(r4) ? u(t2) : f(t2);
  }
}
function f(t2) {
  switch (typeof t2) {
    case "string":
      return t2;
    case "number":
      return u(t2);
    case "boolean":
      return "" + t2;
    default:
      return t2 instanceof Date ? j2(t2) : "";
  }
}

// node_modules/@arcgis/core/intl/t9n.js
async function r3(e2, r4, s6, i5) {
  const a5 = r4.exec(s6);
  if (!a5)
    throw new s2("esri-intl:invalid-bundle", `Bundle id "${s6}" is not compatible with the pattern "${r4}"`);
  const c3 = a5[1] ? `${a5[1]}/` : "", l = a5[2], w = m(i5), h3 = `${c3}${l}.json`, u3 = w ? `${c3}${l}_${w}.json` : h3;
  let d;
  try {
    d = await o2(e2(u3));
  } catch (f4) {
    if (u3 === h3)
      throw new s2("intl:unknown-bundle", `Bundle "${s6}" cannot be loaded`, { error: f4 });
    try {
      d = await o2(e2(h3));
    } catch (f5) {
      throw new s2("intl:unknown-bundle", `Bundle "${s6}" cannot be loaded`, { error: f5 });
    }
  }
  return d;
}
async function o2(t2) {
  if (null != a4.fetchBundleAsset)
    return a4.fetchBundleAsset(t2);
  const n = await j(t2, { responseType: "text" });
  return JSON.parse(n.data);
}
var s4 = class {
  constructor({ base: e2 = "", pattern: t2, location: n = new URL(window.location.href) }) {
    let r4;
    r4 = "string" == typeof n ? (e3) => new URL(e3, new URL(n, window.location.href)).href : n instanceof URL ? (e3) => new URL(e3, n).href : n, this.pattern = "string" == typeof t2 ? new RegExp(`^${t2}`) : t2, this.getAssetUrl = r4, e2 = e2 ? e2.endsWith("/") ? e2 : e2 + "/" : "", this.matcher = new RegExp(`^${e2}(?:(.*)/)?(.*)$`);
  }
  fetchMessageBundle(e2, t2) {
    return r3(this.getAssetUrl, this.matcher, e2, t2);
  }
};
function i3(e2) {
  return new s4(e2);
}
var a4 = {};

// node_modules/@arcgis/core/intl.js
h2(i3({ pattern: "esri/", location: a }));

export {
  o,
  u,
  s3 as s
};
//# sourceMappingURL=chunk-H7BKONNV.js.map
