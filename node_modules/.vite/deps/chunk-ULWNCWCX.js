import {
  d as d3,
  l as l2,
  t as t2
} from "./chunk-U5E2VNHU.js";
import {
  l
} from "./chunk-2AXTYAMY.js";
import {
  i,
  u as u4
} from "./chunk-OJ65P3EQ.js";
import {
  o as o3
} from "./chunk-TWNBDJHC.js";
import {
  n as n2,
  r as r2
} from "./chunk-S6NERLXF.js";
import {
  u as u3
} from "./chunk-G557TGXY.js";
import {
  b as b2,
  m as m2,
  y as y2
} from "./chunk-HLM2UN42.js";
import {
  R
} from "./chunk-5WWPLX36.js";
import {
  t
} from "./chunk-OFRZSMZB.js";
import {
  n
} from "./chunk-GRHSIT57.js";
import {
  o as o2
} from "./chunk-V2RPSCV3.js";
import {
  O,
  x
} from "./chunk-A43TI6AT.js";
import {
  V
} from "./chunk-JUZJCTW2.js";
import {
  o
} from "./chunk-423VNHLR.js";
import {
  m
} from "./chunk-CCXEAKIM.js";
import {
  r
} from "./chunk-QWPLZ3QH.js";
import {
  d2
} from "./chunk-HLGIRLYQ.js";
import {
  s as s4
} from "./chunk-OMPEZIP5.js";
import {
  f,
  u2
} from "./chunk-NSRXJNTS.js";
import {
  g,
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  T,
  c,
  d
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  b,
  s as s3
} from "./chunk-RFPH3ZTZ.js";
import {
  u
} from "./chunk-WGO3VFQP.js";
import {
  a,
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";

// node_modules/@arcgis/core/ground/NavigationConstraint.js
var t3;
var p = t3 = class extends f {
  constructor(r3) {
    super(r3), this.type = "none";
  }
  clone() {
    return new t3({ type: this.type });
  }
};
e([o2({ none: "none", stayAbove: "stay-above" })], p.prototype, "type", void 0), p = t3 = e([c("esri.ground.NavigationConstraint")], p);

// node_modules/@arcgis/core/Ground.js
var S;
var C = S = class extends u2(m) {
  constructor(r3) {
    super(r3), this.opacity = 1, this.surfaceColor = null, this.navigationConstraint = null, this.layers = new V();
    const e2 = (r4) => {
      r4.parent && r4.parent !== this && "remove" in r4.parent && r4.parent.remove(r4), r4.parent = this, "elevation" !== r4.type && "base-elevation" !== r4.type && s.getLogger(this).error(`Layer '${r4.title}, id:${r4.id}' of type '${r4.type}' is not supported as a ground layer and will therefore be ignored. Only layers of type 'elevation' are supported.`);
    }, t5 = (r4) => {
      r4.parent = null;
    };
    this.addHandles([this.layers.on("after-add", (r4) => e2(r4.item)), this.layers.on("after-remove", (r4) => t5(r4.item))]);
  }
  initialize() {
    this.when().catch((r3) => {
      b(r3) || s.getLogger(this).error("#load()", "Failed to load ground", r3);
    }), this.resourceInfo && this.read(this.resourceInfo.data, this.resourceInfo.context);
  }
  destroy() {
    const r3 = this.layers.removeAll();
    for (const e2 of r3)
      u(e2);
    this.layers.destroy();
  }
  normalizeCtorArgs(r3) {
    return r3 && "resourceInfo" in r3 && (this._set("resourceInfo", r3.resourceInfo), delete (r3 = { ...r3 }).resourceInfo), r3;
  }
  set layers(r3) {
    this._set("layers", n(r3, this._get("layers")));
  }
  writeLayers(r3, e2, o5, t5) {
    const i3 = [];
    r3 ? (t5 = { ...t5, layerContainerType: "ground" }, r3.forEach((r4) => {
      if ("write" in r4) {
        const e3 = {};
        o3(r4)().write(e3, t5) && i3.push(e3);
      } else
        (t5 == null ? void 0 : t5.messages) && t5.messages.push(new s2("layer:unsupported", `Layers (${r4.title}, ${r4.id}) of type '${r4.declaredClass}' cannot be persisted in the ground`, { layer: r4 }));
    }), e2.layers = i3) : e2.layers = i3;
  }
  load(r3) {
    return this.addResolvingPromise(this._loadFromSource(r3)), Promise.resolve(this);
  }
  loadAll() {
    return t(this, (r3) => {
      r3(this.layers);
    });
  }
  async queryElevation(r3, e2) {
    await this.load({ signal: e2 == null ? void 0 : e2.signal });
    const { ElevationQuery: o5 } = await import("./ElevationQuery-LZJLWGME.js");
    s3(e2);
    const t5 = new o5(), s5 = this.layers.filter(L).toArray();
    return t5.queryAll(s5, r3, e2);
  }
  async createElevationSampler(r3, e2) {
    await this.load({ signal: e2 == null ? void 0 : e2.signal });
    const { ElevationQuery: o5 } = await import("./ElevationQuery-LZJLWGME.js");
    s3(e2);
    const t5 = new o5(), s5 = this.layers.filter(L).toArray();
    return t5.createSamplerAll(s5, r3, e2);
  }
  clone() {
    const r3 = { opacity: this.opacity, surfaceColor: a(this.surfaceColor), navigationConstraint: a(this.navigationConstraint), layers: this.layers.slice() };
    return this.loaded && (r3.loadStatus = "loaded"), new S({ resourceInfo: this.resourceInfo }).set(r3);
  }
  read(r3, e2) {
    this.resourceInfo || this._set("resourceInfo", { data: r3, context: e2 }), super.read(r3, e2);
  }
  _loadFromSource(r3) {
    const e2 = this.resourceInfo;
    return e2 ? this._loadLayersFromJSON(e2.data, e2.context, r3) : Promise.resolve();
  }
  async _loadLayersFromJSON(r3, e2, o5) {
    const t5 = (e2 == null ? void 0 : e2.origin) || "web-scene", s5 = (e2 == null ? void 0 : e2.portal) || null, a3 = (e2 == null ? void 0 : e2.url) || null, { populateOperationalLayers: i3 } = await import("./layersCreator-STMN4LSU.js");
    s3(o5);
    const n4 = [];
    if (r3.layers && Array.isArray(r3.layers)) {
      const e3 = { context: { origin: t5, url: a3, portal: s5, layerContainerType: "ground" }, defaultLayerType: "ArcGISTiledElevationServiceLayer" };
      n4.push(i3(this.layers, r3.layers, e3));
    }
    await Promise.allSettled(n4);
  }
};
function I(r3) {
  return r3 && "createElevationSampler" in r3;
}
function L(r3) {
  return "elevation" === r3.type || I(r3);
}
e([y({ json: { read: false } })], C.prototype, "layers", null), e([r("layers")], C.prototype, "writeLayers", null), e([y({ readOnly: true })], C.prototype, "resourceInfo", void 0), e([y({ type: Number, nonNullable: true, range: { min: 0, max: 1 }, json: { type: T, read: { reader: r2, source: "transparency" }, write: { writer: (r3, e2) => {
  e2.transparency = n2(r3);
}, target: "transparency" } } })], C.prototype, "opacity", void 0), e([y({ type: u3, json: { type: [T], write: (r3, e2) => {
  e2.surfaceColor = r3.toJSON().slice(0, 3);
} } })], C.prototype, "surfaceColor", void 0), e([y({ type: p, json: { write: true } })], C.prototype, "navigationConstraint", void 0), C = S = e([c("esri.Ground")], C);
var b3 = C;

// node_modules/@arcgis/core/layers/support/editableLayers.js
function o4(e2) {
  var _a, _b;
  return !(!(e2 && "object" == typeof e2 && "loaded" in e2 && e2.loaded && ((_b = (_a = x(e2)) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsEditing) && "type" in e2) || "editingEnabled" in e2 && !O(e2) || "scene" === e2.type && !n3(e2));
}
function n3(s5) {
  const { associatedLayer: a3 } = s5, o5 = a3 == null ? void 0 : a3.infoFor3D;
  if (!!!o5)
    return true;
  const { supportedFormats: n4, queryFormats: l3 } = o5, d4 = u4("model/gltf-binary", n4) ?? i("glb", n4);
  if (!(null != d4 && l3.includes(d4)))
    return s.getLogger("esri.layers.support.editableLayers").warnOnce(`SceneLayer (${s5.title ?? "Untitled layer"}, ${s5.id}) is not editable because it does not support GLB queries.`), false;
  const c2 = s5.spatialReference, p3 = a3.spatialReference;
  if (!d2(c2, p3))
    return s.getLogger("esri.layers.support.editableLayers").warnOnce(`SceneLayer (${s5.title ?? "Untitled layer"}, ${s5.id}) is not editable because its spatial reference (wkid:${c2.wkid}) is different from its associated FeatureLayer's spatial reference (wkid:${p3.wkid}).`), false;
  const f2 = a3.sourceJSON.sourceSpatialReference;
  return !(null != f2 && !d2(f2, p3)) || (s.getLogger("esri.layers.support.editableLayers").warnOnce(`SceneLayer (${s5.title ?? "Untitled layer"}, ${s5.id}) is not editable because the spatial reference of its associated FeatureLayer's service (wkid:${p3.wkid}) is different from its source spatial reference (wkid:${f2.wkid}).`), false);
}

// node_modules/@arcgis/core/support/groundUtils.js
var i2 = { "world-elevation": { id: "worldElevation", url: "//elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer", layerType: "ArcGISTiledElevationServiceLayer" }, "world-topobathymetry": { id: "worldTopoBathymetry", url: "//elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/TopoBathy3D/ImageServer", layerType: "ArcGISTiledElevationServiceLayer" } };
function t4(t5) {
  let a3 = null;
  if ("string" == typeof t5)
    if (t5 in i2) {
      const r3 = i2[t5];
      a3 = new b3({ resourceInfo: { data: { layers: [r3] } } });
    } else
      s.getLogger("esri.support.groundUtils").warn(`Unable to find ground definition for: ${t5}. Try "world-elevation"`);
  else
    a3 = d(b3, t5);
  return a3;
}

// node_modules/@arcgis/core/Map.js
var j = class extends l2(d3(o.EventedMixin(g))) {
  constructor(s5) {
    super(s5), this.allLayers = new l({ getCollections: () => {
      var _a, _b, _c;
      return [(_a = this.basemap) == null ? void 0 : _a.baseLayers, (_b = this.ground) == null ? void 0 : _b.layers, this.layers, (_c = this.basemap) == null ? void 0 : _c.referenceLayers];
    }, getChildrenFunction: (s6) => "layers" in s6 ? s6.layers : null }), this.allTables = t2(this), this.basemap = null, this.editableLayers = new l({ getCollections: () => [this.allLayers], itemFilterFunction: o4 }), this.ground = new b3(), this._basemapCache = y2();
  }
  destroy() {
    m2(this._basemapCache), this._basemapCache = null, this.allLayers.destroy(), this.allTables.destroy(), this.editableLayers.destroy(), this.basemap = u(this.basemap), u(this.ground), this._set("ground", null);
  }
  castBasemap(s5) {
    return b2(s5, this._basemapCache);
  }
  castGround(s5) {
    const e2 = t4(s5);
    return e2 ?? this._get("ground");
  }
  findLayerById(s5) {
    return this.allLayers.find((e2) => e2.id === s5);
  }
  findTableById(s5) {
    return this.allTables.find((e2) => e2.id === s5);
  }
};
e([y({ readOnly: true, dependsOn: [] })], j.prototype, "allLayers", void 0), e([y({ readOnly: true })], j.prototype, "allTables", void 0), e([y({ type: R, json: { read: { source: "baseMap" }, write: { target: "baseMap" } } })], j.prototype, "basemap", void 0), e([s4("basemap")], j.prototype, "castBasemap", null), e([y({ readOnly: true })], j.prototype, "editableLayers", void 0), e([y({ type: b3, nonNullable: true })], j.prototype, "ground", void 0), e([s4("ground")], j.prototype, "castGround", null), j = e([c("esri.Map")], j);
var g2 = j;

// node_modules/@arcgis/core/webmap/background/ColorBackground.js
var p2;
var a2 = p2 = class extends f {
  constructor(o5) {
    super(o5), this.color = new u3([0, 0, 0, 1]);
  }
  clone() {
    return new p2(a({ color: this.color }));
  }
};
e([y({ type: u3, json: { write: true } })], a2.prototype, "color", void 0), a2 = p2 = e([c("esri.webmap.background.ColorBackground")], a2);
var m3 = a2;

export {
  g2 as g,
  m3 as m
};
//# sourceMappingURL=chunk-ULWNCWCX.js.map
