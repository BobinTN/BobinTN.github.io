import {
  $,
  B,
  G2 as G,
  H,
  J2 as J,
  Je,
  K,
  P2 as P,
  Q,
  U,
  V,
  W,
  X,
  a,
  be,
  ce,
  de,
  ge,
  pe,
  q,
  r,
  s,
  t,
  v2 as v,
  ve,
  z
} from "./chunk-24PJGGGS.js";
import {
  m
} from "./chunk-W4QVNWBV.js";
import {
  p
} from "./chunk-QNOCEWCR.js";

// node_modules/@arcgis/core/arcade/deepClone.js
function i(a2) {
  m2 = a2;
}
var m2;
function p2(i2) {
  return null === i2 ? null : Q(i2) ? i2.clone() : J(i2) ? i2 : V(i2) ? i2.clone() : $(i2) ? i2.toArray().map((a2) => p2(a2)) : q(i2) ? i2.map((a2) => p2(a2)) : U(i2) ? m2.createFromArcadeFeature(i2) : W(i2) || H(i2) ? i2 : B(i2) || "esri.arcade.Attachment" === (i2 == null ? void 0 : i2.declaredClass) ? i2.deepClone() : ("esri.arcade.Portal" === (i2 == null ? void 0 : i2.declaredClass) || i2 instanceof s || v(i2), i2);
}

// node_modules/@arcgis/core/arcade/Dictionary.js
function v2(t2, s2, i2 = false, e = false) {
  if (null == t2)
    return null;
  if (z(t2))
    return pe(t2);
  if (G(t2))
    return be(t2);
  if (P(t2))
    return ce(t2);
  if (Q(t2))
    return ge(t2, s2);
  if (X(t2))
    return t2;
  if (K(t2))
    return t2;
  if (q(t2)) {
    const r3 = [];
    for (const n of t2)
      r3.push(v2(n, s2, i2, e));
    return r3;
  }
  if (e && V(t2))
    return t2;
  const r2 = new N();
  r2.immutable = false;
  for (const n of Object.keys(t2)) {
    const o = t2[n];
    void 0 !== o && r2.setField(n, v2(o, s2, i2, e));
  }
  return r2.immutable = i2, r2;
}
var N = class _N {
  constructor(t2) {
    this.declaredClass = "esri.arcade.Dictionary", this.attributes = null, this.plain = false, this.immutable = true, this.attributes = t2 instanceof _N ? t2.attributes : t2 ?? {};
  }
  field(t2) {
    const s2 = t2.toLowerCase(), r2 = this.attributes[t2];
    if (void 0 !== r2)
      return r2;
    for (const i2 in this.attributes)
      if (i2.toLowerCase() === s2)
        return this.attributes[i2];
    throw new a(null, r.FieldNotFound, null, { key: t2 });
  }
  setField(s2, r2) {
    if (this.immutable)
      throw new a(null, r.Immutable, null);
    if (v(r2))
      throw new a(null, r.NoFunctionInDictionary, null);
    const o = s2.toLowerCase();
    r2 instanceof Date && (r2 = m.dateJSToArcadeDate(r2));
    if (void 0 === this.attributes[s2]) {
      for (const t2 in this.attributes)
        if (t2.toLowerCase() === o)
          return void (this.attributes[t2] = r2);
      this.attributes[s2] = r2;
    } else
      this.attributes[s2] = r2;
  }
  hasField(t2) {
    const s2 = t2.toLowerCase();
    if (void 0 !== this.attributes[t2])
      return true;
    for (const i2 in this.attributes)
      if (i2.toLowerCase() === s2)
        return true;
    return false;
  }
  keys() {
    let t2 = [];
    for (const s2 in this.attributes)
      t2.push(s2);
    return t2 = t2.sort(), t2;
  }
  castToText(s2 = false) {
    let i2 = "";
    for (const e in this.attributes) {
      "" !== i2 && (i2 += ",");
      const n = this.attributes[e];
      null == n ? i2 += JSON.stringify(e) + ":null" : G(n) || z(n) || P(n) ? i2 += JSON.stringify(e) + ":" + JSON.stringify(n) : n instanceof p ? i2 += JSON.stringify(e) + ":" + de(n) : n instanceof t || n instanceof Array ? i2 += JSON.stringify(e) + ":" + de(n, null, s2) : n instanceof m ? i2 += s2 ? JSON.stringify(e) + ":" + JSON.stringify(n.getTime()) : JSON.stringify(e) + ":" + n.stringify() : null !== n && "object" == typeof n && void 0 !== n.castToText && (i2 += JSON.stringify(e) + ":" + n.castToText(s2));
    }
    return "{" + i2 + "}";
  }
  static convertObjectToArcadeDictionary(t2, s2, i2 = true, e = false) {
    const r2 = new _N();
    r2.immutable = false;
    for (const n in t2) {
      const o = t2[n];
      void 0 !== o && r2.setField(n.toString(), v2(o, s2, i2, e));
    }
    return r2.immutable = i2, r2;
  }
  static convertJsonToArcade(t2, s2, i2 = false) {
    return v2(t2, s2, i2);
  }
  castAsJson(t2 = null) {
    const s2 = {};
    for (let i2 in this.attributes) {
      const e = this.attributes[i2];
      void 0 !== e && ((t2 == null ? void 0 : t2.keyTranslate) && (i2 = t2.keyTranslate(i2)), s2[i2] = ve(e, t2));
    }
    return s2;
  }
  async castDictionaryValueAsJsonAsync(t2, s2, i2, e = null, r2) {
    const n = await Je(i2, e, r2);
    return t2[s2] = n, n;
  }
  async castAsJsonAsync(s2 = null, i2 = null) {
    const e = {}, r2 = [];
    for (let n in this.attributes) {
      const o = this.attributes[n];
      (i2 == null ? void 0 : i2.keyTranslate) && (n = i2.keyTranslate(n)), void 0 !== o && (J(o) || o instanceof p || o instanceof m ? e[n] = ve(o, i2) : r2.push(this.castDictionaryValueAsJsonAsync(e, n, o, s2, i2)));
    }
    return r2.length > 0 && await Promise.all(r2), e;
  }
  deepClone() {
    const t2 = new _N();
    t2.immutable = false;
    for (const i2 of this.keys())
      t2.setField(i2, p2(this.field(i2)));
    return t2;
  }
};

export {
  i,
  p2 as p,
  N
};
//# sourceMappingURL=chunk-Z3CHIB6Q.js.map
