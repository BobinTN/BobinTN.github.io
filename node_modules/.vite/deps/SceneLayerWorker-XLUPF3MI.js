import "./chunk-TJ5AKOA7.js";
import {
  m as m2,
  y
} from "./chunk-TOWKJZW4.js";
import {
  m
} from "./chunk-SLEGPWAA.js";
import {
  n,
  s
} from "./chunk-GLOKOXWD.js";
import "./chunk-4OLZTDWK.js";
import "./chunk-SKLWU2B3.js";
import "./chunk-2RN2AAP7.js";
import "./chunk-ED5W63C6.js";
import "./chunk-CMGHBCKF.js";
import "./chunk-AMSVADDY.js";
import "./chunk-WJ4LS3YG.js";
import "./chunk-F6MD5VOH.js";
import "./chunk-V2RPSCV3.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import "./chunk-QNOCEWCR.js";
import "./chunk-WURET5CW.js";
import {
  f
} from "./chunk-QWPLZ3QH.js";
import "./chunk-HLGIRLYQ.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import {
  a
} from "./chunk-SJZIFARA.js";
import "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import "./chunk-LXXF7K7W.js";
import "./chunk-SBW6NNVI.js";
import "./chunk-62CXLI6S.js";
import "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import "./chunk-WJ3HJKNC.js";
import "./chunk-4V6374PV.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/libs/i3s/enums.js
var n2;
var e;
!function(n5) {
  n5[n5.None = 0] = "None", n5[n5.Int16 = 1] = "Int16", n5[n5.Int32 = 2] = "Int32";
}(n2 || (n2 = {})), function(n5) {
  n5[n5.Replace = 0] = "Replace", n5[n5.Outside = 1] = "Outside", n5[n5.Inside = 2] = "Inside", n5[n5.Finished = 3] = "Finished";
}(e || (e = {}));

// node_modules/@arcgis/core/libs/i3s/I3SModule.js
function e2() {
  return n3 || (n3 = new Promise((t2) => import("./i3s-7PAK5RXB.js").then((t3) => t3.i).then(({ default: e3 }) => {
    const n5 = e3({ locateFile: i, onRuntimeInitialized: () => t2(n5) });
    delete n5.then;
  })).catch((t2) => {
    throw t2;
  })), n3;
}
function i(e3) {
  return a(`esri/libs/i3s/${e3}`);
}
var n3;

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SNode.js
var t;
var n4;
var o;
var a2;
var s2;
!function(e3) {
  e3[e3.Unmodified = 0] = "Unmodified", e3[e3.Culled = 1] = "Culled", e3[e3.NotChecked = 2] = "NotChecked";
}(t || (t = {})), function(e3) {
  e3[e3.Unmodified = 0] = "Unmodified", e3[e3.PotentiallyModified = 1] = "PotentiallyModified", e3[e3.Culled = 2] = "Culled", e3[e3.Unknown = 3] = "Unknown", e3[e3.NotChecked = 4] = "NotChecked";
}(n4 || (n4 = {}));
!function(e3) {
  e3[e3.Unknown = 0] = "Unknown", e3[e3.Uncached = 1] = "Uncached", e3[e3.Cached = 2] = "Cached";
}(o || (o = {})), function(e3) {
  e3[e3.None = 0] = "None", e3[e3.MaxScreenThreshold = 1] = "MaxScreenThreshold", e3[e3.ScreenSpaceRelative = 2] = "ScreenSpaceRelative", e3[e3.RemovedFeatureDiameter = 3] = "RemovedFeatureDiameter", e3[e3.DistanceRangeFromDefaultCamera = 4] = "DistanceRangeFromDefaultCamera";
}(a2 || (a2 = {})), function(e3) {
  e3[e3.Hole = 0] = "Hole", e3[e3.Leaf = 1] = "Leaf";
}(s2 || (s2 = {}));

// node_modules/@arcgis/core/views/3d/layers/SceneLayerWorker.js
async function l(e3) {
  g = await j();
  const r = [e3.geometryBuffer];
  return { result: w(g, e3, r), transferList: r };
}
async function c(e3) {
  var _a;
  g = await j();
  const r = [e3.geometryBuffer], { geometryBuffer: t2 } = e3, o2 = t2.byteLength, n5 = g._malloc(o2), s3 = new Uint8Array(g.HEAPU8.buffer, n5, o2);
  s3.set(new Uint8Array(t2));
  const i2 = g.dracoDecompressPointCloudData(n5, s3.byteLength);
  if (g._free(n5), i2.error.length > 0)
    throw new Error(`i3s.wasm: ${i2.error}`);
  const a3 = ((_a = i2.featureIds) == null ? void 0 : _a.length) > 0 ? i2.featureIds.slice() : null, f2 = i2.positions.slice();
  return a3 && r.push(a3.buffer), r.push(f2.buffer), { result: { positions: f2, featureIds: a3 }, transferList: r };
}
async function u(e3) {
  await j(), L(e3);
  const r = { buffer: e3.buffer };
  return { result: r, transferList: [r.buffer] };
}
async function m3(e3) {
  await j(), E(e3);
}
async function y2(e3) {
  g = await j(), g.setLegacySchema(e3.context, e3.jsonSchema);
}
async function p(n5) {
  const { localMatrix: s3, origin: i2, positions: a3, vertexSpace: f2, localMode: l2 } = n5, c2 = f.fromJSON(n5.inSpatialReference), u2 = f.fromJSON(n5.outSpatialReference);
  let m4;
  if ("georeferenced" === f2.type) {
    const [{ projectBuffer: e3 }, { initializeProjection: r }] = await Promise.all([import("./projectBuffer-EJ6NKWAX.js"), import("./projection-3JKU4UBH.js")]);
    await r(c2, u2), m4 = new Float64Array(a3.length), e3(a3, c2, 0, m4, u2, 0, m4.length / 3);
  } else {
    const e3 = "georeferencedRelative" === f2.type ? m.fromJSON(f2) : m2.fromJSON(f2), { project: n6 } = await import("./georeference-RBRVXN24.js");
    m4 = y(n6({ positions: a3, transform: s3 ? { localMatrix: s3 } : void 0, vertexSpace: e3, inSpatialReference: c2, outSpatialReference: u2, localMode: l2 }));
  }
  const y3 = m4.length, [p2, d2, b2] = i2;
  for (let e3 = 0; e3 < y3; e3 += 3)
    m4[e3] -= p2, m4[e3 + 1] -= d2, m4[e3 + 2] -= b2;
  return { result: { projected: m4, original: a3 }, transferList: [m4.buffer, a3.buffer] };
}
async function d({ normalMatrix: e3, normals: r }) {
  const t2 = new Float32Array(r.length);
  return n(t2, r, e3), s(t2, t2), { result: { transformed: t2, original: r }, transferList: [t2.buffer, r.buffer] };
}
function b(e3) {
  S(e3);
}
var h;
var g;
function E(e3) {
  if (!g)
    return;
  const r = e3.modifications, t2 = g._malloc(8 * r.length), o2 = new Float64Array(g.HEAPU8.buffer, t2, r.length);
  for (let n5 = 0; n5 < r.length; ++n5)
    o2[n5] = r[n5];
  g.setModifications(e3.context, t2, r.length, e3.isGeodetic), g._free(t2);
}
function w(e3, r, t2) {
  const { context: o2, localOrigin: n5, globalTrafo: s3, mbs: a3, obb: f2, elevationOffset: l2, geometryBuffer: c2, geometryDescriptor: u2, indexToVertexProjector: m4, vertexToRenderProjector: y3 } = r, p2 = e3._malloc(c2.byteLength), d2 = 33, b2 = e3._malloc(d2 * Float64Array.BYTES_PER_ELEMENT), h2 = new Uint8Array(e3.HEAPU8.buffer, p2, c2.byteLength);
  h2.set(new Uint8Array(c2));
  const g2 = new Float64Array(e3.HEAPU8.buffer, b2, d2);
  _(g2, n5);
  let E2 = g2.byteOffset + 3 * g2.BYTES_PER_ELEMENT, w2 = new Float64Array(g2.buffer, E2);
  _(w2, s3), E2 += 16 * g2.BYTES_PER_ELEMENT, w2 = new Float64Array(g2.buffer, E2), _(w2, a3), E2 += 4 * g2.BYTES_PER_ELEMENT, null != f2 && (w2 = new Float64Array(g2.buffer, E2), _(w2, f2.center), E2 += 3 * g2.BYTES_PER_ELEMENT, w2 = new Float64Array(g2.buffer, E2), _(w2, f2.halfSize), E2 += 3 * g2.BYTES_PER_ELEMENT, w2 = new Float64Array(g2.buffer, E2), _(w2, f2.quaternion));
  const A2 = u2, L2 = { isDraco: false, isLegacy: false, color: r.layouts.some((e4) => e4.some((e5) => "color" === e5.name)), normal: r.needNormals && r.layouts.some((e4) => e4.some((e5) => "normalCompressed" === e5.name)), uv0: r.layouts.some((e4) => e4.some((e5) => "uv0" === e5.name)), uvRegion: r.layouts.some((e4) => e4.some((e5) => "uvRegion" === e5.name)), featureIndex: A2.featureIndex }, S2 = e3.process(o2, !!r.obb, p2, h2.byteLength, A2, L2, b2, l2, m4, y3, r.normalReferenceFrame);
  if (e3._free(b2), e3._free(p2), S2.error.length > 0)
    throw new Error(`i3s.wasm: ${S2.error}`);
  if (S2.discarded)
    return null;
  const I2 = S2.componentOffsets.length > 0 ? S2.componentOffsets.slice() : null, j2 = S2.featureIds.length > 0 ? S2.featureIds.slice() : null, M2 = S2.anchorIds.length > 0 ? Array.from(S2.anchorIds) : null, P = S2.anchors.length > 0 ? Array.from(S2.anchors) : null, T = S2.interleavedVertedData.slice().buffer, x = S2.indicesType === n2.Int16 ? new Uint16Array(S2.indices.buffer, S2.indices.byteOffset, S2.indices.byteLength / 2).slice() : new Uint32Array(S2.indices.buffer, S2.indices.byteOffset, S2.indices.byteLength / 4).slice(), R = S2.positions.slice(), U = S2.positionIndicesType === n2.Int16 ? new Uint16Array(S2.positionIndices.buffer, S2.positionIndices.byteOffset, S2.positionIndices.byteLength / 2).slice() : new Uint32Array(S2.positionIndices.buffer, S2.positionIndices.byteOffset, S2.positionIndices.byteLength / 4).slice(), v = { layout: r.layouts[0], interleavedVertexData: T, indices: x, hasColors: S2.hasColors, hasModifications: S2.hasModifications, positionData: { data: R, indices: U } };
  return j2 && t2.push(j2.buffer), I2 && t2.push(I2.buffer), t2.push(T), t2.push(x.buffer), t2.push(R.buffer), t2.push(U.buffer), { componentOffsets: I2, featureIds: j2, anchorIds: M2, anchors: P, transformedGeometry: v, obb: S2.obb };
}
function A(e3) {
  return 0 === e3 ? n4.Unmodified : 1 === e3 ? n4.PotentiallyModified : 2 === e3 ? n4.Culled : n4.Unknown;
}
function L(e3) {
  if (!g)
    return;
  const { context: r, buffer: t2 } = e3, o2 = g._malloc(t2.byteLength), n5 = t2.byteLength / Float64Array.BYTES_PER_ELEMENT, s3 = new Float64Array(g.HEAPU8.buffer, o2, n5), i2 = new Float64Array(t2);
  s3.set(i2), g.filterOBBs(r, o2, n5), i2.set(s3), g._free(o2);
}
function S(e3) {
  g && 0 === g.destroy(e3) && (g = null);
}
function _(e3, r) {
  for (let t2 = 0; t2 < r.length; ++t2)
    e3[t2] = r[t2];
}
async function I() {
  g || await j();
}
function j() {
  return g ? Promise.resolve(g) : (h || (h = e2().then((e3) => (g = e3, h = null, g))), h);
}
var M = { transform: (e3, r) => g && w(g, e3, r), destroy: S };
export {
  b as destroyContext,
  c as dracoDecompressPointCloudData,
  u as filterObbsForModifications,
  L as filterObbsForModificationsSync,
  I as initialize,
  A as interpretObbModificationResults,
  l as process,
  p as project,
  y2 as setLegacySchema,
  m3 as setModifications,
  E as setModificationsSync,
  M as test,
  d as transformNormals
};
//# sourceMappingURL=SceneLayerWorker-XLUPF3MI.js.map
