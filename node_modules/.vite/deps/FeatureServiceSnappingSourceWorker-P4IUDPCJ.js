import {
  S,
  c as c5,
  f as f3,
  x
} from "./chunk-MKRPXDII.js";
import {
  E as E2
} from "./chunk-ED5W63C6.js";
import "./chunk-S6CVQWN7.js";
import {
  a as a3
} from "./chunk-JWPJ4Y6I.js";
import "./chunk-OYPRFNII.js";
import {
  m
} from "./chunk-A427XTHR.js";
import {
  o as o4
} from "./chunk-QAQNFI3S.js";
import {
  W as W2
} from "./chunk-7KUR2TMU.js";
import "./chunk-3ON6HO7Q.js";
import "./chunk-KMTPMPRR.js";
import "./chunk-K4NVR6KM.js";
import "./chunk-57KRYRCY.js";
import {
  ft,
  it,
  yt
} from "./chunk-747B2TEO.js";
import "./chunk-4NEWABLH.js";
import "./chunk-FW2Y26A2.js";
import "./chunk-5WG7GACT.js";
import "./chunk-AZHRWST4.js";
import "./chunk-PFFV4MXI.js";
import "./chunk-NYTJIWNN.js";
import "./chunk-7Y57Y6IH.js";
import "./chunk-WND35VNG.js";
import "./chunk-PUYNEESA.js";
import "./chunk-GXVWD6F2.js";
import "./chunk-W4QVNWBV.js";
import {
  h as h2
} from "./chunk-XUD6H4VO.js";
import {
  j
} from "./chunk-CQMEHG4P.js";
import {
  t as t3
} from "./chunk-GZTU5O23.js";
import "./chunk-LOGPPZUD.js";
import "./chunk-HYU6N3H3.js";
import "./chunk-EC5POYCL.js";
import "./chunk-X5VYGREB.js";
import {
  h as h3,
  r as r2
} from "./chunk-HU7QYAVQ.js";
import {
  b as b2
} from "./chunk-45OAWGCA.js";
import "./chunk-R4LYFMZX.js";
import "./chunk-X2TA76Q5.js";
import "./chunk-T3Y5GTKO.js";
import "./chunk-XN6LAULS.js";
import "./chunk-M7OEQQRX.js";
import {
  e as e4
} from "./chunk-CSWPLQ7Q.js";
import "./chunk-KWSMYM7P.js";
import "./chunk-RP5SAUAF.js";
import "./chunk-6BFXMZEZ.js";
import "./chunk-AMSVADDY.js";
import "./chunk-GAJBN4TM.js";
import "./chunk-2AXFVQBN.js";
import "./chunk-WOGT6UK2.js";
import "./chunk-RHT6WWRD.js";
import "./chunk-EUGXS5RE.js";
import "./chunk-IRNKV32L.js";
import "./chunk-HLM2UN42.js";
import "./chunk-5WWPLX36.js";
import "./chunk-UNONG753.js";
import "./chunk-OFRZSMZB.js";
import "./chunk-IATM3RCE.js";
import "./chunk-BEALJUHO.js";
import "./chunk-GRHSIT57.js";
import "./chunk-PJQIAD5D.js";
import "./chunk-Z6KIMOUA.js";
import "./chunk-SZAJDZCO.js";
import "./chunk-M7R7REMB.js";
import "./chunk-ZZYUEH57.js";
import "./chunk-VTWXDFFD.js";
import {
  p as p2
} from "./chunk-IPCIO3PX.js";
import "./chunk-EIY2DYTV.js";
import "./chunk-WJ4LS3YG.js";
import "./chunk-F6MD5VOH.js";
import "./chunk-V2RPSCV3.js";
import {
  w as w2
} from "./chunk-AOJ6OCPK.js";
import "./chunk-LMT5JII2.js";
import "./chunk-A43TI6AT.js";
import "./chunk-BHJVWW2P.js";
import "./chunk-4HKQSEUR.js";
import "./chunk-V3U4F2NL.js";
import "./chunk-ZB6PGKG5.js";
import "./chunk-OIIDE5GZ.js";
import {
  E,
  c as c4,
  l,
  o as o3,
  u as u2
} from "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import {
  C as C2,
  d as d2,
  p,
  w
} from "./chunk-TBSVVR6M.js";
import {
  b,
  d
} from "./chunk-6TJWLWLO.js";
import "./chunk-H7BKONNV.js";
import "./chunk-K6C6RVSV.js";
import "./chunk-KBJ5Z4R2.js";
import "./chunk-JUZJCTW2.js";
import {
  o as o2
} from "./chunk-423VNHLR.js";
import "./chunk-FN47E7YK.js";
import "./chunk-XZS3Q5K4.js";
import "./chunk-XXFXRXFH.js";
import "./chunk-CCXEAKIM.js";
import {
  M
} from "./chunk-Y5D433JZ.js";
import "./chunk-QNOCEWCR.js";
import "./chunk-WURET5CW.js";
import {
  f as f2
} from "./chunk-QWPLZ3QH.js";
import {
  W2 as W
} from "./chunk-HLGIRLYQ.js";
import "./chunk-N2K4VRZH.js";
import "./chunk-WL4VPODY.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import {
  e3,
  f,
  g,
  o4 as o,
  t5 as t2,
  u3 as u,
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c as c3,
  r2 as r
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  C,
  a as a2,
  e as e2,
  s as s2
} from "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  a,
  c as c2,
  s2 as s
} from "./chunk-WJ3HJKNC.js";
import {
  c,
  h,
  t3 as t
} from "./chunk-4V6374PV.js";
import "./chunk-A34O4XB5.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/snappingCandidateElevationAlignment.js
function i(e6 = false, t6) {
  if (e6) {
    const { elevationInfo: e7, alignPointsInFeatures: s4 } = t6;
    return new c6(e7, s4);
  }
  return new a4();
}
var a4 = class {
  async alignCandidates(e6, t6, s4) {
    return e6;
  }
  notifyElevationSourceChange() {
  }
};
var r3 = 1024;
var c6 = class {
  constructor(t6, s4) {
    this._elevationInfo = t6, this._alignPointsInFeatures = s4, this._alignmentsCache = new e4(r3), this._cacheVersion = 0;
  }
  async alignCandidates(e6, t6, s4) {
    const n3 = this._elevationInfo;
    return null == n3 || "absolute-height" !== n3.mode || n3.featureExpressionInfo ? this._alignComputedElevationCandidates(e6, t6, s4) : (this._alignAbsoluteElevationCandidates(e6, t6, n3), e6);
  }
  notifyElevationSourceChange() {
    this._alignmentsCache.clear(), this._cacheVersion++;
  }
  _alignAbsoluteElevationCandidates(e6, t6, s4) {
    const { offset: i4, unit: a7 } = s4;
    if (null == i4)
      return;
    const r8 = W(t6), c9 = i4 * (r2(a7 ?? "meters") / r8);
    for (const n3 of e6)
      switch (n3.type) {
        case "edge":
          n3.start.z += c9, n3.end.z += c9;
          continue;
        case "vertex":
          n3.target.z += c9;
          continue;
      }
  }
  async _alignComputedElevationCandidates(e6, n3, o6) {
    const i4 = /* @__PURE__ */ new Map();
    for (const s4 of e6)
      r(i4, s4.objectId, d3).push(s4);
    const [a7, r8, c9] = this._prepareQuery(i4, n3), l3 = await this._alignPointsInFeatures(a7, o6);
    s2(o6);
    if (c9 !== this._cacheVersion)
      return this._alignComputedElevationCandidates(e6, n3, o6);
    this._applyCacheAndResponse(a7, l3, r8);
    const { drapedObjectIds: h5, failedObjectIds: u4 } = l3, p3 = [];
    for (const t6 of e6) {
      const { objectId: e7 } = t6;
      h5.has(e7) && "edge" === t6.type && (t6.draped = true), u4.has(e7) || p3.push(t6);
    }
    return p3;
  }
  _prepareQuery(e6, t6) {
    const s4 = [], n3 = [];
    for (const [o6, i4] of e6) {
      const e7 = [];
      for (const t7 of i4)
        this._addToQueriesOrCachedResult(o6, t7.target, e7, n3), "edge" === t7.type && (this._addToQueriesOrCachedResult(o6, t7.start, e7, n3), this._addToQueriesOrCachedResult(o6, t7.end, e7, n3));
      0 !== e7.length && s4.push({ objectId: o6, points: e7 });
    }
    return [{ spatialReference: t6.toJSON(), pointsInFeatures: s4 }, n3, this._cacheVersion];
  }
  _addToQueriesOrCachedResult(e6, t6, s4, n3) {
    const o6 = h4(e6, t6), i4 = this._alignmentsCache.get(o6);
    null == i4 ? s4.push(t6) : n3.push(new l2(t6, i4));
  }
  _applyCacheAndResponse(e6, { elevations: t6, drapedObjectIds: s4, failedObjectIds: n3 }, o6) {
    for (const r8 of o6)
      r8.apply();
    let i4 = 0;
    const a7 = this._alignmentsCache;
    for (const { objectId: r8, points: c9 } of e6.pointsInFeatures) {
      if (n3.has(r8)) {
        i4 += c9.length;
        continue;
      }
      const e7 = !s4.has(r8);
      for (const s5 of c9) {
        const n4 = h4(r8, s5), o7 = t6[i4++];
        s5.z = o7, e7 && a7.put(n4, o7, 1);
      }
    }
  }
};
var l2 = class {
  constructor(e6, t6) {
    this.point = e6, this.z = t6;
  }
  apply() {
    this.point.z = this.z;
  }
};
function h4(e6, { x: t6, y: s4, z: n3, spatialReference: o6 }) {
  return `${e6}-${t6}-${s4}-${n3 ?? 0}}-wkid:${o6 == null ? void 0 : o6.wkid}`;
}
function d3() {
  return [];
}

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/snappingCandidateElevationFilter.js
var t4 = class {
  filter(t6, n3) {
    return n3;
  }
  notifyElevationSourceChange() {
  }
};
var n = class {
  filter(t6, n3) {
    const { point: r8, distance: c9 } = t6, { z: i4 } = r8;
    if (!(null != i4))
      return n3;
    if (0 === n3.length)
      return n3;
    const o6 = s3(c9), u4 = this._updateCandidatesTo3D(n3, r8, o6).filter(e5);
    return u4.sort(a5), u4;
  }
  _updateCandidatesTo3D(t6, n3, e6) {
    for (const r8 of t6)
      switch (r8.type) {
        case "edge":
          c7(r8, n3, e6);
          continue;
        case "vertex":
          o5(r8, n3, e6);
          continue;
      }
    return t6;
  }
};
function e5(t6) {
  return t6.distance <= 1;
}
function r4(e6 = false) {
  return e6 ? new n() : new t4();
}
function c7(t6, n3, { x: e6, y: r8, z: c9 }) {
  const { start: o6, end: s4, target: a7 } = t6;
  t6.draped || i2(a7, n3, o6, s4);
  const u4 = (n3.x - a7.x) / e6, d4 = (n3.y - a7.y) / r8, f4 = (n3.z - a7.z) / c9;
  t6.distance = Math.sqrt(u4 * u4 + d4 * d4 + f4 * f4);
}
function i2(t6, n3, e6, r8) {
  const c9 = r8.x - e6.x, i4 = r8.y - e6.y, o6 = r8.z - e6.z, s4 = c9 * c9 + i4 * i4 + o6 * o6, a7 = (n3.x - e6.x) * c9 + (n3.y - e6.y) * i4 + o6 * (n3.z - e6.z), u4 = Math.min(1, Math.max(0, a7 / s4)), d4 = e6.x + c9 * u4, f4 = e6.y + i4 * u4, x3 = e6.z + o6 * u4;
  t6.x = d4, t6.y = f4, t6.z = x3;
}
function o5(t6, n3, { x: e6, y: r8, z: c9 }) {
  const { target: i4 } = t6, o6 = (n3.x - i4.x) / e6, s4 = (n3.y - i4.y) / r8, a7 = (n3.z - i4.z) / c9, u4 = Math.sqrt(o6 * o6 + s4 * s4 + a7 * a7);
  t6.distance = u4;
}
function s3(t6) {
  return "number" == typeof t6 ? { x: t6, y: t6, z: t6 } : t6;
}
function a5(t6, n3) {
  return t6.distance - n3.distance;
}

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/symbologySnappingCandidates.js
function n2(t6 = false, e6) {
  return t6 ? new i3(e6) : new c8();
}
var c8 = class {
  async fetch() {
    return [];
  }
  notifySymbologyChange() {
  }
};
var r5 = 1024;
var i3 = class {
  constructor(t6) {
    this._getSymbologyCandidates = t6, this._candidatesCache = new e4(r5), this._cacheVersion = 0;
  }
  async fetch(e6, o6) {
    if (0 === e6.length)
      return [];
    const n3 = [], c9 = [], r8 = this._candidatesCache;
    for (const s4 of e6) {
      const e7 = a6(s4), o7 = r8.get(e7);
      if (o7)
        for (const s5 of o7)
          c9.push(a(s5));
      else
        n3.push(s4), r8.put(e7, [], 1);
    }
    if (0 === n3.length)
      return c9;
    const i4 = this._cacheVersion, { candidates: h5, sourceCandidateIndices: d4 } = await this._getSymbologyCandidates(n3, o6);
    s2(o6);
    if (i4 !== this._cacheVersion)
      return this.fetch(e6, o6);
    const f4 = [], { length: g2 } = h5;
    for (let s4 = 0; s4 < g2; ++s4) {
      const e7 = h5[s4], o7 = a6(n3[d4[s4]]), c10 = r8.get(o7);
      c10.push(e7), r8.put(o7, c10, c10.length), f4.push(a(e7));
    }
    return c9.concat(f4);
  }
  notifySymbologyChange() {
    this._candidatesCache.clear(), this._cacheVersion++;
  }
};
function a6(t6) {
  switch (t6.type) {
    case "vertex": {
      const { objectId: e6, target: s4 } = t6, n3 = `${e6}-vertex-${s4.x}-${s4.y}-${s4.z ?? 0}`;
      return c2(n3).toString();
    }
    case "edge": {
      const { objectId: e6, start: s4, end: n3 } = t6, c9 = `${e6}-edge-${s4.x}-${s4.y}-${s4.z ?? 0}-to-${n3.x}-${n3.y}-${n3.z ?? 0}`;
      return c2(c9).toString();
    }
    default:
      return "";
  }
}

// node_modules/@arcgis/core/core/AsyncSequence.js
var r6 = class extends g {
  constructor() {
    super(...arguments), this.updating = false, this._pending = [];
  }
  push(s4, t6) {
    this._pending.push({ promise: s4, callback: t6 }), 1 === this._pending.length && this._process();
  }
  _process() {
    if (!this._pending.length)
      return void (this.updating = false);
    this.updating = true;
    const s4 = this._pending[0];
    s4.promise.then((t6) => s4.callback(t6)).catch(() => {
    }).then(() => {
      this._pending.shift(), this._process();
    });
  }
};
e([y()], r6.prototype, "updating", void 0), r6 = e([c3("esri.core.AsyncSequence")], r6);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/PendingFeatureTile.js
var r7 = class {
  constructor(t6, e6) {
    this.data = t6, this.resolution = e6, this.state = { type: u3.CREATED }, this.alive = true;
  }
  process(t6) {
    switch (this.state.type) {
      case u3.CREATED:
        return this.state = this._gotoFetchCount(this.state, t6), this.state.task.promise.then(t6.resume, t6.resume);
      case u3.FETCH_COUNT:
        break;
      case u3.FETCHED_COUNT:
        return this.state = this._gotoFetchFeatures(this.state, t6), this.state.task.promise.then(t6.resume, t6.resume);
      case u3.FETCH_FEATURES:
        break;
      case u3.FETCHED_FEATURES:
        this.state = this._goToDone(this.state, t6);
      case u3.DONE:
    }
    return null;
  }
  get debugInfo() {
    return { data: this.data, featureCount: this._featureCount, state: this._stateToString };
  }
  get _featureCount() {
    switch (this.state.type) {
      case u3.CREATED:
      case u3.FETCH_COUNT:
        return 0;
      case u3.FETCHED_COUNT:
        return this.state.featureCount;
      case u3.FETCH_FEATURES:
        return this.state.previous.featureCount;
      case u3.FETCHED_FEATURES:
        return this.state.features.length;
      case u3.DONE:
        return this.state.previous.features.length;
    }
  }
  get _stateToString() {
    switch (this.state.type) {
      case u3.CREATED:
        return "created";
      case u3.FETCH_COUNT:
        return "fetch-count";
      case u3.FETCHED_COUNT:
        return "fetched-count";
      case u3.FETCH_FEATURES:
        return "fetch-features";
      case u3.FETCHED_FEATURES:
        return "fetched-features";
      case u3.DONE:
        return "done";
    }
  }
  _gotoFetchCount(s4, a7) {
    return { type: u3.FETCH_COUNT, previous: s4, task: d(async (t6) => {
      const s5 = await b(a7.fetchCount(this, t6));
      this.state.type === u3.FETCH_COUNT && (this.state = this._gotoFetchedCount(this.state, s5.ok ? s5.value : 1 / 0));
    }) };
  }
  _gotoFetchedCount(t6, e6) {
    return { type: u3.FETCHED_COUNT, featureCount: e6, previous: t6 };
  }
  _gotoFetchFeatures(s4, a7) {
    return { type: u3.FETCH_FEATURES, previous: s4, task: d(async (t6) => {
      const E4 = await b(a7.fetchFeatures(this, s4.featureCount, t6));
      this.state.type === u3.FETCH_FEATURES && (this.state = this._gotoFetchedFeatures(this.state, E4.ok ? E4.value : []));
    }) };
  }
  _gotoFetchedFeatures(t6, e6) {
    return { type: u3.FETCHED_FEATURES, previous: t6, features: e6 };
  }
  _goToDone(t6, e6) {
    return e6.finish(this, t6.features), { type: u3.DONE, previous: t6 };
  }
  reset() {
    const t6 = this.state;
    switch (this.state = { type: u3.CREATED }, t6.type) {
      case u3.CREATED:
      case u3.FETCHED_COUNT:
      case u3.FETCHED_FEATURES:
      case u3.DONE:
        break;
      case u3.FETCH_COUNT:
      case u3.FETCH_FEATURES:
        t6.task.abort();
    }
  }
  intersects(t6) {
    return null == t6 || !this.data.extent || (o3(t6, T), E(this.data.extent, T));
  }
};
var u3;
!function(t6) {
  t6[t6.CREATED = 0] = "CREATED", t6[t6.FETCH_COUNT = 1] = "FETCH_COUNT", t6[t6.FETCHED_COUNT = 2] = "FETCHED_COUNT", t6[t6.FETCH_FEATURES = 3] = "FETCH_FEATURES", t6[t6.FETCHED_FEATURES = 4] = "FETCHED_FEATURES", t6[t6.DONE = 5] = "DONE";
}(u3 || (u3 = {}));
var T = u2();

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiledFetcher.js
var j2 = class extends g {
  get _minimumVerticesPerFeature() {
    var _a;
    switch ((_a = this.store) == null ? void 0 : _a.featureStore.geometryType) {
      case "esriGeometryPoint":
      case "esriGeometryMultipoint":
        return 1;
      case "esriGeometryPolygon":
        return 4;
      case "esriGeometryPolyline":
        return 2;
    }
  }
  get _mandatoryOutFields() {
    const e6 = /* @__PURE__ */ new Set();
    return this.objectIdField && e6.add(this.objectIdField), this.globalIdField && e6.add(this.globalIdField), e6;
  }
  set outFields(e6) {
    const t6 = this._get("outFields"), i4 = t2(e6, this._mandatoryOutFields);
    f(i4, t6) || (this._set("outFields", i4), e3(i4, t6) || this.refresh());
  }
  get outFields() {
    return this._get("outFields") ?? this._mandatoryOutFields;
  }
  set filter(e6) {
    const t6 = this._get("filter"), i4 = this._filterProperties(e6);
    JSON.stringify(t6) !== JSON.stringify(i4) && this._set("filter", i4);
  }
  set customParameters(e6) {
    const t6 = this._get("customParameters");
    JSON.stringify(t6) !== JSON.stringify(e6) && this._set("customParameters", e6);
  }
  get _configuration() {
    return { filter: this.filter, customParameters: this.customParameters, tileInfo: this.tileInfo, tileSize: this.tileSize };
  }
  set tileInfo(e6) {
    const t6 = this._get("tileInfo");
    t6 !== e6 && (null != e6 && null != t6 && JSON.stringify(e6) === JSON.stringify(t6) || (this._set("tileInfo", e6), this.store.tileInfo = e6));
  }
  set tileSize(e6) {
    this._get("tileSize") !== e6 && this._set("tileSize", e6);
  }
  get updating() {
    return this.updatingExcludingEdits || this._pendingEdits.updating;
  }
  get updatingExcludingEdits() {
    return this._updatingHandles.updating;
  }
  get hasZ() {
    return this.store.featureStore.hasZ;
  }
  constructor(e6) {
    super(e6), this.suspended = true, this.tilesOfInterest = [], this.availability = 0, this._pendingTiles = /* @__PURE__ */ new Map(), this._updatingHandles = new h2(), this._pendingEdits = new r6(), this._pendingEditsAbortController = new AbortController();
  }
  initialize() {
    this._initializeFetchExtent(), this._updatingHandles.add(() => this._configuration, () => this.refresh()), this._updatingHandles.add(() => this.tilesOfInterest, (e6, t6) => {
      h(e6, t6, ({ id: e7 }, { id: t7 }) => e7 === t7) || this._process();
    }, C2), this.addHandles(p(() => !this.suspended, () => this._process()));
  }
  destroy() {
    this._pendingTiles.forEach((e6) => this._deletePendingTile(e6)), this._pendingTiles.clear(), this.store.destroy(), this.tilesOfInterest.length = 0, this._pendingEditsAbortController.abort(), this._pendingEditsAbortController = null, this._updatingHandles.destroy();
  }
  refresh() {
    this.store.refresh(), this._pendingTiles.forEach((e6) => this._deletePendingTile(e6)), this._process();
  }
  applyEdits(e6) {
    this._pendingEdits.push(e6, async (e7) => {
      if (0 === e7.addedFeatures.length && 0 === e7.updatedFeatures.length && 0 === e7.deletedFeatures.length)
        return;
      for (const [, i4] of this._pendingTiles)
        i4.reset();
      const t6 = { ...e7, deletedFeatures: e7.deletedFeatures.map(({ objectId: e8, globalId: t7 }) => e8 && -1 !== e8 ? e8 : this._lookupObjectIdByGlobalId(t7)) };
      await this._updatingHandles.addPromise(this.store.processEdits(t6, (e8, t7) => this._queryFeaturesById(e8, t7), this._pendingEditsAbortController.signal)), this._processPendingTiles();
    });
  }
  _initializeFetchExtent() {
    if (!this.capabilities.query.supportsExtent || !w2(this.url))
      return;
    const e6 = d(async (e7) => {
      var _a;
      try {
        const t6 = await x(this.url, new b2({ where: "1=1", outSpatialReference: this.spatialReference, cacheHint: this.capabilities.query.supportsCacheHint ?? void 0 }), { query: this._configuration.customParameters, signal: e7 });
        this.store.extent = M.fromJSON((_a = t6.data) == null ? void 0 : _a.extent);
      } catch (t6) {
        a2(t6), s.getLogger(this).warn("Failed to fetch data extent", t6);
      }
    });
    this._updatingHandles.addPromise(e6.promise.then(() => this._process())), this.addHandles(e2(() => e6.abort()));
  }
  get debugInfo() {
    return { numberOfFeatures: this.store.featureStore.numFeatures, tilesOfInterest: this.tilesOfInterest, pendingTiles: Array.from(this._pendingTiles.values()).map((e6) => e6.debugInfo), storedTiles: this.store.debugInfo };
  }
  _process() {
    this._markTilesNotAlive(), this._createPendingTiles(), this._deletePendingTiles(), this._processPendingTiles();
  }
  _markTilesNotAlive() {
    for (const [, e6] of this._pendingTiles)
      e6.alive = false;
  }
  _createPendingTiles() {
    if (this.suspended)
      return;
    const e6 = this._collectMissingTilesInfo();
    if (this._setAvailability(null == e6 ? 1 : e6.coveredArea / e6.fullArea), null != e6)
      for (const { data: t6, resolution: i4 } of e6.missingTiles) {
        const e7 = this._pendingTiles.get(t6.id);
        e7 ? (e7.resolution = i4, e7.alive = true) : this._createPendingTile(t6, i4);
      }
  }
  _collectMissingTilesInfo() {
    let e6 = null;
    for (let t6 = this.tilesOfInterest.length - 1; t6 >= 0; t6--) {
      const i4 = this.tilesOfInterest[t6], s4 = this.store.process(i4, (e7, t7) => this._verifyTileComplexity(e7, t7), this.outFields);
      null == e6 ? e6 = s4 : e6.prepend(s4);
    }
    return e6;
  }
  _deletePendingTiles() {
    for (const [, e6] of this._pendingTiles)
      e6.alive || this._deletePendingTile(e6);
  }
  _processPendingTiles() {
    const e6 = { fetchCount: (e7, t6) => this._fetchCount(e7, t6), fetchFeatures: (e7, t6, i4) => this._fetchFeatures(e7, t6, i4), finish: (e7, t6) => this._finishPendingTile(e7, t6), resume: () => this._processPendingTiles() };
    if (this._ensureFetchAllCounts(e6))
      for (const [, t6] of this._pendingTiles)
        this._verifyTileComplexity(this.store.getFeatureCount(t6.data), t6.resolution) && this._updatingHandles.addPromise(t6.process(e6));
  }
  _verifyTileComplexity(e6, t6) {
    return this._verifyVertexComplexity(e6) && this._verifyFeatureDensity(e6, t6);
  }
  _verifyVertexComplexity(e6) {
    return e6 * this._minimumVerticesPerFeature < q;
  }
  _verifyFeatureDensity(e6, t6) {
    if (null == this.tileInfo)
      return false;
    const i4 = this.tileSize * t6;
    return e6 * (A / (i4 * i4)) < H;
  }
  _ensureFetchAllCounts(e6) {
    let t6 = true;
    for (const [, i4] of this._pendingTiles)
      i4.state.type < u3.FETCHED_COUNT && this._updatingHandles.addPromise(i4.process(e6)), i4.state.type <= u3.FETCH_COUNT && (t6 = false);
    return t6;
  }
  _finishPendingTile(e6, t6) {
    this.store.add(e6.data, t6), this._deletePendingTile(e6), this._updateAvailability();
  }
  _updateAvailability() {
    const e6 = this._collectMissingTilesInfo();
    this._setAvailability(null == e6 ? 1 : e6.coveredArea / e6.fullArea);
  }
  _setAvailability(e6) {
    this._set("availability", e6);
  }
  _createPendingTile(e6, t6) {
    const i4 = new r7(e6, t6);
    return this._pendingTiles.set(e6.id, i4), i4;
  }
  _deletePendingTile(e6) {
    e6.reset(), this._pendingTiles.delete(e6.data.id);
  }
  async _fetchCount(e6, t6) {
    return this.store.fetchCount(e6.data, this.url, this._createCountQuery(e6), { query: this.customParameters, timeout: w3, signal: t6 });
  }
  async _fetchFeatures(e6, t6, i4) {
    let s4 = 0;
    const r8 = [];
    let o6 = 0, n3 = t6;
    for (; ; ) {
      const a7 = this._createFeaturesQuery(e6), l3 = this._setPagingParameters(a7, s4, n3), { features: u4, exceededTransferLimit: d4 } = await this._queryFeatures(a7, i4);
      l3 && (s4 += a7.num), o6 += u4.length;
      for (const e7 of u4)
        r8.push(e7);
      if (n3 = t6 - o6, !l3 || !d4 || n3 <= 0)
        return r8;
    }
  }
  _filterProperties(e6) {
    return null == e6 ? { where: "1=1", gdbVersion: void 0, timeExtent: void 0 } : { where: e6.where || "1=1", timeExtent: e6.timeExtent, gdbVersion: e6.gdbVersion };
  }
  _lookupObjectIdByGlobalId(e6) {
    const t6 = this.globalIdField, i4 = this.objectIdField;
    if (null == t6)
      throw new Error("Expected globalIdField to be defined");
    let s4 = null;
    if (this.store.featureStore.forEach((r8) => {
      e6 === r8.attributes[t6] && (s4 = r8.objectId ?? r8.attributes[i4]);
    }), null == s4)
      throw new Error(`Expected to find a feature with globalId ${e6}`);
    return s4;
  }
  _queryFeaturesById(e6, t6) {
    const i4 = this._createFeaturesQuery();
    return i4.objectIds = e6, this._queryFeatures(i4, t6);
  }
  _queryFeatures(e6, t6) {
    return this.capabilities.query.supportsFormatPBF ? this._queryFeaturesPBF(e6, t6) : this._queryFeaturesJSON(e6, t6);
  }
  async _queryFeaturesPBF(e6, t6) {
    const { sourceSpatialReference: i4 } = this, { data: s4 } = await f3(this.url, e6, new a3({ sourceSpatialReference: i4 }), { query: this._configuration.customParameters, timeout: w3, signal: t6 });
    return ft(s4);
  }
  async _queryFeaturesJSON(e6, t6) {
    const { sourceSpatialReference: i4 } = this, { data: s4 } = await c5(this.url, e6, i4, { query: this._configuration.customParameters, timeout: w3, signal: t6 });
    return it(s4, this.objectIdField);
  }
  _createCountQuery(e6) {
    const t6 = this._createBaseQuery(e6);
    return this.capabilities.query.supportsCacheHint && (t6.cacheHint = true), t6;
  }
  _createFeaturesQuery(e6 = null) {
    var _a;
    const t6 = this._createBaseQuery(e6), i4 = null != (e6 == null ? void 0 : e6.data) ? this.store.getAttributesForTile((_a = e6 == null ? void 0 : e6.data) == null ? void 0 : _a.id) : null, s4 = t2(u(this.outFields, i4 ?? /* @__PURE__ */ new Set()), this._mandatoryOutFields);
    return t6.outFields = Array.from(s4), t6.returnGeometry = true, null != e6 && (this.capabilities.query.supportsResultType ? t6.resultType = "tile" : this.capabilities.query.supportsCacheHint && (t6.cacheHint = true)), t6;
  }
  _createBaseQuery(e6) {
    const t6 = new b2({ returnZ: this.hasZ, returnM: false, geometry: null != this.tileInfo && null != e6 ? c4(e6.data.extent, this.tileInfo.spatialReference) : void 0 }), i4 = this._configuration.filter;
    return null != i4 && (t6.where = i4.where, t6.gdbVersion = i4.gdbVersion, t6.timeExtent = i4.timeExtent), t6.outSpatialReference = this.spatialReference, t6;
  }
  _setPagingParameters(e6, t6, i4) {
    if (!this.capabilities.query.supportsPagination)
      return false;
    const { supportsMaxRecordCountFactor: s4, supportsCacheHint: r8, tileMaxRecordCount: o6, maxRecordCount: n3, supportsResultType: a7 } = this.capabilities.query, l3 = s4 ? b2.MAX_MAX_RECORD_COUNT_FACTOR : 1, u4 = l3 * ((a7 || r8) && o6 ? o6 : n3 || x2);
    return e6.start = t6, s4 ? (e6.maxRecordCountFactor = Math.min(l3, Math.ceil(i4 / u4)), e6.num = Math.min(i4, e6.maxRecordCountFactor * u4)) : e6.num = Math.min(i4, u4), true;
  }
};
e([y({ constructOnly: true })], j2.prototype, "url", void 0), e([y({ constructOnly: true })], j2.prototype, "objectIdField", void 0), e([y({ constructOnly: true })], j2.prototype, "globalIdField", void 0), e([y({ constructOnly: true })], j2.prototype, "capabilities", void 0), e([y({ constructOnly: true })], j2.prototype, "sourceSpatialReference", void 0), e([y({ constructOnly: true })], j2.prototype, "spatialReference", void 0), e([y({ constructOnly: true })], j2.prototype, "store", void 0), e([y({ readOnly: true })], j2.prototype, "_minimumVerticesPerFeature", null), e([y()], j2.prototype, "_mandatoryOutFields", null), e([y()], j2.prototype, "outFields", null), e([y()], j2.prototype, "suspended", void 0), e([y()], j2.prototype, "filter", null), e([y()], j2.prototype, "customParameters", null), e([y({ readOnly: true })], j2.prototype, "_configuration", null), e([y()], j2.prototype, "tileInfo", null), e([y()], j2.prototype, "tileSize", null), e([y()], j2.prototype, "tilesOfInterest", void 0), e([y({ readOnly: true })], j2.prototype, "updating", null), e([y({ readOnly: true })], j2.prototype, "updatingExcludingEdits", null), e([y({ readOnly: true })], j2.prototype, "availability", void 0), e([y()], j2.prototype, "hasZ", null), j2 = e([c3("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiledFetcher")], j2);
var x2 = 2e3;
var w3 = 6e5;
var q = 1e6;
var A = 25;
var H = 1;

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTileCache.js
var t5 = class {
  constructor() {
    this._store = /* @__PURE__ */ new Map(), this._byteSize = 0;
  }
  set(t6, e6) {
    this.delete(t6), this._store.set(t6, e6), this._byteSize += e6.byteSize;
  }
  delete(t6) {
    const e6 = this._store.get(t6);
    return !!this._store.delete(t6) && (null != e6 && (this._byteSize -= e6.byteSize), true);
  }
  get(t6) {
    return this._used(t6), this._store.get(t6);
  }
  has(t6) {
    return this._used(t6), this._store.has(t6);
  }
  clear() {
    this._store.clear();
  }
  applyByteSizeLimit(t6, e6) {
    for (const [s4, r8] of this._store) {
      if (this._byteSize <= t6)
        break;
      this.delete(s4), e6(r8);
    }
  }
  values() {
    return this._store.values();
  }
  [Symbol.iterator]() {
    return this._store[Symbol.iterator]();
  }
  _used(t6) {
    const e6 = this._store.get(t6);
    e6 && (this._store.delete(t6), this._store.set(t6, e6));
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTileStore.js
var v = class extends g {
  constructor(e6) {
    super(e6), this.tileInfo = null, this.extent = null, this.maximumByteSize = 10 * E2.MEGABYTES, this._tileBounds = new o4(), this._tiles = new t5(), this._refCounts = /* @__PURE__ */ new Map(), this._tileFeatureCounts = /* @__PURE__ */ new Map(), this._tmpBoundingRect = u2();
  }
  add(e6, t6) {
    var _a;
    for (const r8 of t6)
      this._referenceFeature(r8.objectId);
    const s4 = this.featureStore.upsertMany(t6), i4 = s4.map((e7) => new Set(Object.keys(e7.attributes))).reduce((e7, t7) => o(e7, t7), new Set(Object.keys(((_a = s4[0]) == null ? void 0 : _a.attributes) ?? [])));
    this._addTileStorage(e6, new Set(s4.map((e7) => e7.objectId)), C3(s4), i4), this._tiles.applyByteSizeLimit(this.maximumByteSize, (e7) => this._removeTileStorage(e7));
  }
  getAttributesForTile(e6) {
    var _a;
    return e6 ? (_a = this._tiles.get(e6)) == null ? void 0 : _a.attributeKeys : null;
  }
  destroy() {
    this.clear(), this._tileFeatureCounts.clear();
  }
  clear() {
    this.featureStore.clear(), this._tileBounds.clear(), this._tiles.clear(), this._refCounts.clear();
  }
  refresh() {
    this.clear(), this._tileFeatureCounts.clear();
  }
  processEdits(e6, t6, s4) {
    return this._processEditsDelete(e6.deletedFeatures.concat(e6.updatedFeatures)), this._processEditsRefetch(e6.addedFeatures.concat(e6.updatedFeatures), t6, s4);
  }
  _addTileStorage(e6, t6, s4, i4) {
    const r8 = e6.id;
    this._tiles.set(r8, new E3(e6, t6, s4, i4)), this._tileBounds.set(r8, e6.extent), this._tileFeatureCounts.set(r8, t6.size);
  }
  _remove({ id: e6 }) {
    const t6 = this._tiles.get(e6);
    t6 && this._removeTileStorage(t6);
  }
  _removeTileStorage(e6) {
    const t6 = [];
    for (const i4 of e6.objectIds)
      this._unreferenceFeature(i4) === A2.REMOVED && t6.push(i4);
    this.featureStore.removeManyById(t6);
    const s4 = e6.data.id;
    this._tiles.delete(s4), this._tileBounds.delete(s4);
  }
  _processEditsDelete(e6) {
    this.featureStore.removeManyById(e6);
    for (const [, t6] of this._tiles) {
      for (const s4 of e6)
        t6.objectIds.delete(s4);
      this._tileFeatureCounts.set(t6.data.id, t6.objectIds.size);
    }
    for (const t6 of e6)
      this._refCounts.delete(t6);
  }
  async _processEditsRefetch(e6, t6, s4) {
    const i4 = (await t6(e6, s4)).features, { hasZ: r8, hasM: o6 } = this.featureStore;
    for (const n3 of i4) {
      const e7 = yt(this._tmpBoundingRect, n3.geometry, r8, o6);
      null != e7 && this._tileBounds.forEachInBounds(e7, (e8) => {
        const t7 = this._tiles.get(e8);
        this.featureStore.add(n3);
        const s5 = n3.objectId;
        t7.objectIds.has(s5) || (t7.objectIds.add(s5), this._referenceFeature(s5), this._tileFeatureCounts.set(t7.data.id, t7.objectIds.size));
      });
    }
  }
  process(e6, t6 = () => true, s4) {
    if (null == this.tileInfo || !e6.extent || null != this.extent && !E(o3(this.extent, this._tmpBoundingRect), e6.extent))
      return new F(e6);
    const i4 = this.getAttributesForTile(e6.id);
    if (e3(s4, i4))
      return new F(e6);
    const r8 = this._createTileTree(e6, this.tileInfo);
    return this._simplify(r8, t6, null, 0, 1), this._collectMissingTiles(e6, r8, this.tileInfo, s4);
  }
  get debugInfo() {
    return Array.from(this._tiles.values()).map(({ data: e6 }) => ({ data: e6, featureCount: this._tileFeatureCounts.get(e6.id) || 0 }));
  }
  getFeatureCount(e6) {
    return this._tileFeatureCounts.get(e6.id) ?? 0;
  }
  async fetchCount(e6, t6, s4, i4) {
    const r8 = this._tileFeatureCounts.get(e6.id);
    if (null != r8)
      return r8;
    const o6 = await S(t6, s4, i4);
    return this._tileFeatureCounts.set(e6.id, o6.data.count), o6.data.count;
  }
  _createTileTree(e6, t6) {
    const s4 = new w4(e6.level, e6.row, e6.col);
    return t6.updateTileInfo(s4, j.ExtrapolateOptions.POWER_OF_TWO), this._tileBounds.forEachInBounds(e6.extent, (i4) => {
      var _a;
      const r8 = (_a = this._tiles.get(i4)) == null ? void 0 : _a.data;
      r8 && this._tilesAreRelated(e6, r8) && this._populateChildren(s4, r8, t6, this._tileFeatureCounts.get(r8.id) || 0);
    }), s4;
  }
  _tilesAreRelated(e6, t6) {
    if (!e6 || !t6)
      return false;
    if (e6.level === t6.level)
      return e6.row === t6.row && e6.col === t6.col;
    const s4 = e6.level < t6.level, i4 = s4 ? e6 : t6, r8 = s4 ? t6 : e6, o6 = 1 << r8.level - i4.level;
    return Math.floor(r8.row / o6) === i4.row && Math.floor(r8.col / o6) === i4.col;
  }
  _populateChildren(e6, t6, s4, i4) {
    const r8 = t6.level - e6.level - 1;
    if (r8 < 0)
      return void (e6.isLeaf = true);
    const o6 = t6.row >> r8, n3 = t6.col >> r8, l3 = e6.row << 1, u4 = n3 - (e6.col << 1) + (o6 - l3 << 1), a7 = e6.children[u4];
    if (null != a7)
      this._populateChildren(a7, t6, s4, i4);
    else {
      const r9 = new w4(e6.level + 1, o6, n3);
      s4.updateTileInfo(r9, j.ExtrapolateOptions.POWER_OF_TWO), e6.children[u4] = r9, this._populateChildren(r9, t6, s4, i4);
    }
  }
  _simplify(e6, t6, s4, i4, r8) {
    const o6 = r8 * r8;
    if (e6.isLeaf)
      return t6(this.getFeatureCount(e6), r8) ? 0 : (this._remove(e6), null != s4 && (s4.children[i4] = null), o6);
    const n3 = r8 / 2, l3 = n3 * n3;
    let u4 = 0;
    for (let a7 = 0; a7 < e6.children.length; a7++) {
      const s5 = e6.children[a7];
      u4 += null != s5 ? this._simplify(s5, t6, e6, a7, n3) : l3;
    }
    return 0 === u4 ? this._mergeChildren(e6) : 1 - u4 / o6 < b3 && (this._purge(e6), null != s4 && (s4.children[i4] = null), u4 = o6), u4;
  }
  _mergeChildren(e6) {
    const t6 = /* @__PURE__ */ new Set();
    let s4, i4 = 0;
    this._forEachLeaf(e6, (e7) => {
      const r8 = this._tiles.get(e7.id);
      if (r8) {
        s4 = s4 ? o(s4, r8.attributeKeys) : new Set(r8.attributeKeys), i4 += r8.byteSize;
        for (const e8 of r8.objectIds)
          t6.has(e8) || (t6.add(e8), this._referenceFeature(e8));
        this._remove(e7);
      }
    }), this._addTileStorage(e6, t6, i4, s4 ?? /* @__PURE__ */ new Set()), e6.isLeaf = true, e6.children[0] = e6.children[1] = e6.children[2] = e6.children[3] = null, this._tileFeatureCounts.set(e6.id, t6.size);
  }
  _forEachLeaf(e6, t6) {
    for (const s4 of e6.children)
      null != s4 && (s4.isLeaf ? t6(s4) : this._forEachLeaf(s4, t6));
  }
  _purge(e6) {
    if (null != e6)
      if (e6.isLeaf)
        this._remove(e6);
      else
        for (let t6 = 0; t6 < e6.children.length; t6++) {
          const s4 = e6.children[t6];
          this._purge(s4), e6.children[t6] = null;
        }
  }
  _collectMissingTiles(e6, t6, s4, i4) {
    const r8 = new j3(s4, e6, this.extent);
    return this._collectMissingTilesRecurse(t6, r8, 1, i4), r8.info;
  }
  _collectMissingTilesRecurse(e6, t6, s4, i4) {
    const r8 = this.getAttributesForTile(e6.id), o6 = r8 && !e3(i4, r8);
    if (o6 && t6.addMissing(e6.level, e6.row, e6.col, s4), e6.isLeaf)
      return;
    if (!e6.hasChildren)
      return void (o6 || t6.addMissing(e6.level, e6.row, e6.col, s4));
    const l3 = s4 / 2;
    for (let n3 = 0; n3 < e6.children.length; n3++) {
      const s5 = e6.children[n3];
      null == s5 ? t6.addMissing(e6.level + 1, (e6.row << 1) + ((2 & n3) >> 1), (e6.col << 1) + (1 & n3), l3) : this._collectMissingTilesRecurse(s5, t6, l3, i4);
    }
  }
  _referenceFeature(e6) {
    const t6 = (this._refCounts.get(e6) || 0) + 1;
    return this._refCounts.set(e6, t6), 1 === t6 ? A2.ADDED : A2.UNCHANGED;
  }
  _unreferenceFeature(e6) {
    const t6 = (this._refCounts.get(e6) || 0) - 1;
    return 0 === t6 ? (this._refCounts.delete(e6), A2.REMOVED) : (t6 > 0 && this._refCounts.set(e6, t6), A2.UNCHANGED);
  }
  get test() {
    return { tiles: Array.from(this._tiles.values()).map((e6) => `${e6.data.id}:[${Array.from(e6.objectIds)}]`), featureReferences: Array.from(this._refCounts.keys()).map((e6) => `${e6}:${this._refCounts.get(e6)}`) };
  }
};
function C3(e6) {
  return e6.reduce((e7, t6) => e7 + S2(t6), 0);
}
function S2(e6) {
  return 32 + T2(e6.geometry) + t(e6.attributes);
}
function T2(e6) {
  if (null == e6)
    return 0;
  const t6 = c(e6.lengths, 4);
  return 32 + c(e6.coords, 8) + t6;
}
e([y({ constructOnly: true })], v.prototype, "featureStore", void 0), e([y()], v.prototype, "tileInfo", void 0), e([y()], v.prototype, "extent", void 0), e([y()], v.prototype, "maximumByteSize", void 0), v = e([c3("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTileStore")], v);
var E3 = class {
  constructor(e6, t6, s4, i4) {
    this.data = e6, this.objectIds = t6, this.byteSize = s4, this.attributeKeys = i4;
  }
};
var w4 = class {
  constructor(e6, t6, s4) {
    this.level = e6, this.row = t6, this.col = s4, this.isLeaf = false, this.extent = null, this.children = [null, null, null, null];
  }
  get hasChildren() {
    return !this.isLeaf && (null != this.children[0] || null != this.children[1] || null != this.children[2] || null != this.children[3]);
  }
};
var F = class {
  constructor(e6, t6 = []) {
    this.missingTiles = t6, this.fullArea = 0, this.coveredArea = 0, this.fullArea = l(e6.extent), this.coveredArea = this.fullArea;
  }
  prepend(e6) {
    this.missingTiles = e6.missingTiles.concat(this.missingTiles), this.coveredArea += e6.coveredArea, this.fullArea += e6.fullArea;
  }
};
var j3 = class {
  constructor(e6, t6, s4) {
    this._tileInfo = e6, this._extent = null, this.info = new F(t6), null != s4 && (this._extent = o3(s4));
  }
  addMissing(e6, t6, s4, i4) {
    const r8 = new t3(null, e6, t6, s4);
    this._tileInfo.updateTileInfo(r8, j.ExtrapolateOptions.POWER_OF_TWO), null == r8.extent || null != this._extent && !E(this._extent, r8.extent) || (this.info.missingTiles.push({ data: r8, resolution: i4 }), this.info.coveredArea -= l(r8.extent));
  }
};
var b3 = 0.18751;
var A2;
!function(e6) {
  e6[e6.ADDED = 0] = "ADDED", e6[e6.REMOVED = 1] = "REMOVED", e6[e6.UNCHANGED = 2] = "UNCHANGED";
}(A2 || (A2 = {}));

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceSnappingSourceWorker.js
var w5 = class extends o2.EventedAccessor {
  constructor() {
    super(...arguments), this._isInitializing = true, this.remoteClient = null, this._whenSetup = C(), this._elevationAligner = i(), this._elevationFilter = r4(), this._symbologyCandidatesFetcher = n2(), this._updatingHandles = new h2(), this._editsUpdatingHandles = new h2(), this._pendingApplyEdits = /* @__PURE__ */ new Map(), this._alignPointsInFeatures = async (e6, t6) => {
      const i4 = { query: e6 }, r8 = await this.remoteClient.invoke("alignElevation", i4, { signal: t6 });
      return s2(t6), r8;
    }, this._getSymbologyCandidates = async (e6, t6) => {
      const i4 = { candidates: e6, spatialReference: this._spatialReference.toJSON() }, r8 = await this.remoteClient.invoke("getSymbologyCandidates", i4, { signal: t6 });
      return s2(t6), r8;
    };
  }
  get updating() {
    return this.updatingExcludingEdits || this._editsUpdatingHandles.updating || this._featureFetcher.updating;
  }
  get updatingExcludingEdits() {
    return this._featureFetcher.updatingExcludingEdits || this._isInitializing || this._updatingHandles.updating;
  }
  destroy() {
    var _a, _b, _c;
    (_a = this._featureFetcher) == null ? void 0 : _a.destroy(), (_b = this._queryEngine) == null ? void 0 : _b.destroy(), (_c = this._featureStore) == null ? void 0 : _c.clear();
  }
  async setup(e6) {
    if (this.destroyed)
      return { result: {} };
    const { geometryType: t6, objectIdField: i4, timeInfo: s4, fieldsIndex: n3 } = e6.serviceInfo, { hasZ: o6 } = e6, l3 = f2.fromJSON(e6.spatialReference);
    this._spatialReference = l3, this._featureStore = new m({ ...e6.serviceInfo, hasZ: o6, hasM: false }), this._queryEngine = new W2({ spatialReference: e6.spatialReference, featureStore: this._featureStore, geometryType: t6, fieldsIndex: n3, hasZ: o6, hasM: false, objectIdField: i4, timeInfo: s4 }), this._featureFetcher = new j2({ store: new v({ featureStore: this._featureStore }), url: e6.serviceInfo.url, objectIdField: e6.serviceInfo.objectIdField, globalIdField: e6.serviceInfo.globalIdField, capabilities: e6.serviceInfo.capabilities, spatialReference: l3, sourceSpatialReference: f2.fromJSON(e6.serviceInfo.spatialReference) });
    const d4 = "3d" === e6.configuration.viewType;
    return this._elevationAligner = i(d4, { elevationInfo: null != e6.elevationInfo ? h3.fromJSON(e6.elevationInfo) : null, alignPointsInFeatures: this._alignPointsInFeatures }), this._elevationFilter = r4(d4), this.addHandles([d2(() => this._featureFetcher.availability, (e7) => this.emit("notify-availability", { availability: e7 }), C2), d2(() => this.updating, () => this._notifyUpdating())]), this._whenSetup.resolve(), this._isInitializing = false, this.configure(e6.configuration);
  }
  async configure(e6) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), this._updateFeatureFetcherConfiguration(e6), j4;
  }
  async setSuspended(e6, t6) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s2(t6), this._featureFetcher.suspended = e6, j4;
  }
  async updateOutFields(e6, t6) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s2(t6), this._featureFetcher.outFields = new Set(e6 ?? []), j4;
  }
  async fetchCandidates(e6, t6) {
    await this._whenSetup.promise, s2(t6);
    const i4 = b4(e6), r8 = t6 == null ? void 0 : t6.signal, n3 = await this._queryEngine.executeQueryForSnapping(i4, r8);
    s2(r8);
    const a7 = await this._elevationAligner.alignCandidates(n3.candidates, f2.fromJSON(e6.point.spatialReference) ?? f2.WGS84, r8);
    s2(r8);
    const o6 = await this._symbologyCandidatesFetcher.fetch(a7, r8);
    s2(r8);
    const l3 = 0 === o6.length ? a7 : a7.concat(o6);
    return { result: { candidates: this._elevationFilter.filter(i4, l3) } };
  }
  async updateTiles(e6, t6) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s2(t6), this._featureFetcher.tileSize = e6.tileSize, this._featureFetcher.tilesOfInterest = e6.tiles, this._featureFetcher.tileInfo = null != e6.tileInfo ? j.fromJSON(e6.tileInfo) : null, j4;
  }
  async refresh(e6, t6) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s2(t6), this._featureFetcher.refresh(), j4;
  }
  async whenNotUpdating(e6, t6) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s2(t6), await w(() => !this.updatingExcludingEdits, t6), s2(t6), j4;
  }
  async getDebugInfo(e6, t6) {
    return s2(t6), { result: this._featureFetcher.debugInfo };
  }
  async beginApplyEdits(e6, t6) {
    this._updatingHandles.addPromise(this._whenSetup.promise), s2(t6);
    const r8 = C();
    return this._pendingApplyEdits.set(e6.id, r8), this._featureFetcher.applyEdits(r8.promise), this._editsUpdatingHandles.addPromise(r8.promise), j4;
  }
  async endApplyEdits(e6, t6) {
    const i4 = this._pendingApplyEdits.get(e6.id);
    return i4 && i4.resolve(e6.edits), s2(t6), j4;
  }
  async notifyElevationSourceChange(e6, t6) {
    return this._elevationAligner.notifyElevationSourceChange(), j4;
  }
  async notifySymbologyChange(e6, t6) {
    return this._symbologyCandidatesFetcher.notifySymbologyChange(), j4;
  }
  async setSymbologySnappingSupported(e6) {
    return this._symbologyCandidatesFetcher = n2(e6, this._getSymbologyCandidates), j4;
  }
  _updateFeatureFetcherConfiguration(e6) {
    this._featureFetcher.filter = null != e6.filter ? b2.fromJSON(e6.filter) : null, this._featureFetcher.customParameters = e6.customParameters;
  }
  _notifyUpdating() {
    this.emit("notify-updating", { updating: this.updating });
  }
};
e([y({ readOnly: true })], w5.prototype, "updating", null), e([y({ readOnly: true })], w5.prototype, "updatingExcludingEdits", null), e([y()], w5.prototype, "_isInitializing", void 0), w5 = e([c3("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorker")], w5);
var I = w5;
function b4(e6) {
  if (!e6.filter)
    return { ...e6, query: { where: "1=1" } };
  const { distance: t6, units: i4, spatialRel: s4, where: r8, timeExtent: n3, objectIds: a7 } = e6.filter, o6 = { geometry: e6.filter.geometry ? p2(e6.filter.geometry) : void 0, distance: t6, units: i4, spatialRel: s4, timeExtent: n3, objectIds: a7, where: r8 ?? "1=1" };
  return { ...e6, query: o6 };
}
var j4 = { result: {} };
export {
  I as default
};
//# sourceMappingURL=FeatureServiceSnappingSourceWorker-P4IUDPCJ.js.map
