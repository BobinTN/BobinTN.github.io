import {
  r
} from "./chunk-VKTTTBW2.js";
import {
  Z
} from "./chunk-M7OEQQRX.js";
import {
  e
} from "./chunk-CSWPLQ7Q.js";
import {
  d
} from "./chunk-4TSAC52K.js";
import {
  u
} from "./chunk-G557TGXY.js";
import {
  i,
  l
} from "./chunk-M7R7REMB.js";
import {
  j
} from "./chunk-R5DM4YAB.js";
import {
  b
} from "./chunk-RFPH3ZTZ.js";
import {
  c,
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";

// node_modules/@arcgis/core/renderers/support/DictionaryLoader.js
var h = "esri.renderers.support.DictionaryLoader";
var u2 = { type: "CIMSimpleLineCallout", lineSymbol: { type: "CIMLineSymbol", symbolLayers: [{ type: "CIMSolidStroke", width: 0.5, color: [0, 0, 0, 255] }] } };
var y = class {
  constructor(e2, t, s3) {
    this.config = null, this.fieldMap = null, this.url = null, this._ongoingRequests = /* @__PURE__ */ new Map(), this._symbolCache = new e(100), this._dictionaryVersion = null, this._fieldIndex = null, this._dictionaryPromise = null, this.url = e2, this.config = t, this.fieldMap = s3;
  }
  getSymbolFields() {
    return this._symbolFields;
  }
  async getSymbolAsync(t, s3) {
    let i2;
    this._dictionaryPromise || (this._dictionaryPromise = this.fetchResources(s3));
    try {
      i2 = await this._dictionaryPromise;
    } catch (d3) {
      if (b(d3))
        return this._dictionaryPromise = null, null;
    }
    const o = this._dictionaryVersion && this._dictionaryVersion.since(4, 0), l2 = {};
    if (this.fieldMap)
      for (const e2 of this._symbolFields) {
        const s4 = this._getFieldName(this.fieldMap[e2]);
        if (s4) {
          const i3 = t.attributes[s4];
          l2[e2] = o ? i3 : null != i3 ? "" + t.attributes[s4] : "";
        } else
          l2[e2] = "";
      }
    let a = null;
    try {
      a = i2 == null ? void 0 : i2(l2, s3);
    } catch (g) {
      return null;
    }
    if (!a || "string" != typeof a)
      return null;
    const c2 = c(a).toString(), m = this._symbolCache.get(c2);
    if (m)
      return m.catch(() => {
        this._symbolCache.pop(c2);
      }), m;
    const f = a.split(";"), h2 = [], u3 = [];
    for (const r2 of f)
      if (r2)
        if (r2.includes("po:")) {
          const t2 = r2.substr(3).split("|");
          if (3 === t2.length) {
            const s4 = t2[0], i3 = t2[1];
            let o2 = t2[2];
            if ("DashTemplate" === i3)
              o2 = o2.split(" ").map((e2) => Number(e2));
            else if ("Color" === i3) {
              const t3 = new u(o2).toRgba();
              o2 = [t3[0], t3[1], t3[2], 255 * t3[3]];
            } else
              o2 = Number(o2);
            u3.push({ primitiveName: s4, propertyName: i3, value: o2 });
          }
        } else if (r2.includes("|")) {
          for (const e2 of r2.split("|"))
            if (this._itemNames.has(e2)) {
              h2.push(e2);
              break;
            }
        } else
          this._itemNames.has(r2) && h2.push(r2);
    const y2 = null == t.geometry || !t.geometry.hasZ && "point" === t.geometry.type, p2 = this._cimPartsToCIMSymbol(h2, u3, y2, s3);
    return this._symbolCache.put(c2, p2, 1), p2;
  }
  async fetchResources(e2) {
    if (this._dictionaryPromise)
      return this._dictionaryPromise;
    if (!this.url)
      return void s.getLogger(h).error("no valid URL!");
    const o = j(this.url + "/resources/styles/dictionary-info.json", { responseType: "json", query: { f: "json" }, signal: null != e2 ? e2.signal : null }), [{ data: r2 }] = await Promise.all([o, i()]);
    if (!r2)
      throw this._dictionaryPromise = null, new s2("esri.renderers.DictionaryRenderer", "Bad dictionary data!");
    const { authoringInfo: n, dictionary_version: f, expression: u3, itemsNames: y2 } = r2, p2 = u3;
    let d3 = false;
    f && (this._dictionaryVersion = r.parse(f), d3 = this._dictionaryVersion.since(4, 0)), this._refSymbolUrlTemplate = this.url + "/" + r2.cimRefTemplateUrl, this._itemNames = new Set(y2), this._symbolFields = n.symbol;
    const g = {};
    if (this.config) {
      const e3 = this.config;
      for (const t in e3)
        g[t] = e3[t];
    }
    if (n.configuration)
      for (const t of n.configuration)
        g.hasOwnProperty(t.name) || (g[t.name] = t.value);
    const b2 = [];
    if ((e2 == null ? void 0 : e2.fields) && this.fieldMap)
      for (const t of this._symbolFields) {
        const s3 = this.fieldMap[t], i2 = e2.fields.filter((e3) => e3.name.toLowerCase() === (s3 == null ? void 0 : s3.toLowerCase()));
        i2.length > 0 && b2.push({ ...i2[0], type: d3 ? i2[0].type : "esriFieldTypeString" });
      }
    b2.length > 0 && (this._fieldIndex = new Z(b2));
    const _ = l(p2, null != e2 ? e2.spatialReference : null, b2, g).then((e3) => {
      const t = { scale: 0 };
      return (s3, i2) => {
        if (null == e3)
          return null;
        const o2 = e3.repurposeFeature({ geometry: null, attributes: s3 });
        return t.scale = null != i2 ? i2.scale ?? void 0 : void 0, e3.evaluate({ $feature: o2, $view: t }, e3.services);
      };
    }).catch((e3) => (s.getLogger(h).error("Creating dictinoary expression failed:", e3), null));
    return this._dictionaryPromise = _, _;
  }
  async _cimPartsToCIMSymbol(e2, t, s3, i2) {
    const o = new Array(e2.length);
    for (let l2 = 0; l2 < e2.length; l2++)
      o[l2] = this._getSymbolPart(e2[l2], i2);
    const r2 = await Promise.all(o), n = this.fieldMap;
    if (n)
      for (const l2 of r2)
        p(l2, n);
    return new d({ data: this._combineSymbolParts(r2, t, s3) });
  }
  async _getSymbolPart(e2, s3) {
    if (this._ongoingRequests.has(e2))
      return this._ongoingRequests.get(e2).then((e3) => e3.data);
    const i2 = this._refSymbolUrlTemplate.replaceAll(/\{itemName\}/gi, e2), o = j(i2, { responseType: "json", query: { f: "json" }, ...s3 });
    this._ongoingRequests.set(e2, o);
    try {
      return (await o).data;
    } catch (r2) {
      throw this._ongoingRequests.delete(e2), r2;
    }
  }
  _combineSymbolParts(e2, t, s3) {
    if (!e2 || 0 === e2.length)
      return null;
    const i2 = { ...e2[0] };
    if (e2.length > 1) {
      i2.symbolLayers = [];
      for (const t2 of e2) {
        const e3 = t2;
        i2.symbolLayers.unshift(...e3.symbolLayers);
      }
    }
    return s3 && (i2.callout = u2), { type: "CIMSymbolReference", symbol: i2, primitiveOverrides: t };
  }
  _getFieldName(e2) {
    if (null !== this._fieldIndex) {
      const t = this._fieldIndex.get(e2);
      return t ? t.name : e2;
    }
    return e2;
  }
};
function p(e2, t) {
  if (!e2)
    return;
  const s3 = e2.symbolLayers;
  if (!s3)
    return;
  let i2 = s3.length;
  for (; i2--; ) {
    const e3 = s3[i2];
    if (e3 && false !== e3.enable && "CIMVectorMarker" === e3.type)
      d2(e3, t);
  }
}
function d2(e2, t) {
  const s3 = e2.markerGraphics;
  if (s3)
    for (const i2 of s3) {
      if (!i2)
        continue;
      const e3 = i2.symbol;
      if (e3)
        switch (e3.type) {
          case "CIMPointSymbol":
          case "CIMLineSymbol":
          case "CIMPolygonSymbol":
            p(e3, t);
            break;
          case "CIMTextSymbol":
            e3.fieldMap = t;
        }
    }
}

export {
  y
};
//# sourceMappingURL=chunk-7VNZ6V2N.js.map
