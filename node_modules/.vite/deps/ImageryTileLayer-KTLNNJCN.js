import {
  h as h4,
  i as i4,
  m as m6,
  s as s4,
  x as x2
} from "./chunk-LRNGG7EZ.js";
import {
  B as B2,
  E,
  K,
  N as N2,
  S,
  V as V2,
  a as a4,
  c as c3,
  c2 as c4,
  d as d4,
  h as h3,
  l as l3,
  m as m5,
  p as p4,
  t as t2
} from "./chunk-QYCDYE3Z.js";
import {
  D as D3,
  a as a5,
  d as d5,
  f as f6,
  g as g2,
  h as h2,
  i as i3,
  o as o4,
  p as p3
} from "./chunk-RS353LH2.js";
import "./chunk-6JCSK7BN.js";
import {
  T as T4
} from "./chunk-RURX4WVF.js";
import {
  C,
  R as R3,
  f as f5,
  i as i2,
  n as n5,
  y as y4
} from "./chunk-LOFJKPMO.js";
import {
  C as C2,
  D as D2,
  J,
  T as T3,
  U as U3,
  V,
  Z,
  ee,
  j as j5,
  oe,
  re
} from "./chunk-OQKR5TK4.js";
import {
  B,
  D,
  F,
  L,
  L2,
  N,
  P,
  R,
  U,
  g,
  h2 as h,
  j as j4,
  m as m3,
  m3 as m4,
  n as n3,
  n2 as n4,
  r,
  r2
} from "./chunk-OEIWJN32.js";
import {
  I as I2,
  R as R2,
  T as T2,
  U as U2,
  W,
  f2 as f4,
  l2,
  s3,
  u as u2,
  u2 as u3,
  u4
} from "./chunk-ABKJC2RS.js";
import "./chunk-XZLDDXLF.js";
import "./chunk-XI27PUTI.js";
import "./chunk-ED5W63C6.js";
import "./chunk-NYTJIWNN.js";
import {
  j as j2,
  p
} from "./chunk-CQMEHG4P.js";
import "./chunk-GZTU5O23.js";
import "./chunk-LOGPPZUD.js";
import "./chunk-HYU6N3H3.js";
import {
  l
} from "./chunk-36R5EC6A.js";
import {
  o as o3
} from "./chunk-5DLICG33.js";
import {
  a as a3
} from "./chunk-ZILXWPAR.js";
import {
  p as p2
} from "./chunk-HPFRYEGX.js";
import "./chunk-4LDWKTSM.js";
import {
  A
} from "./chunk-U4ONWLTG.js";
import {
  j as j3
} from "./chunk-POSLR7O2.js";
import {
  f as f3
} from "./chunk-VOYU5TTK.js";
import {
  a as a2
} from "./chunk-P5VIVFJT.js";
import "./chunk-SA3C7GIT.js";
import "./chunk-P3R45ANF.js";
import {
  t
} from "./chunk-PIEUUBJ5.js";
import {
  u as u5
} from "./chunk-YIAYIZOZ.js";
import {
  m as m2
} from "./chunk-P5GW5DPX.js";
import {
  c as c2,
  d as d3
} from "./chunk-VIOPOI6P.js";
import "./chunk-GDKL26HH.js";
import "./chunk-2CL4LRYG.js";
import "./chunk-64EQFPYJ.js";
import "./chunk-HKYMYCLL.js";
import "./chunk-ICVVQFO6.js";
import {
  d as d2
} from "./chunk-BYK6DXRK.js";
import "./chunk-OCLKX5SY.js";
import "./chunk-SEKLTVY5.js";
import "./chunk-HX5GOVNX.js";
import "./chunk-2Q2Q2Z4U.js";
import "./chunk-HU7QYAVQ.js";
import "./chunk-T3Y5GTKO.js";
import {
  y as y3
} from "./chunk-XN6LAULS.js";
import "./chunk-CSWPLQ7Q.js";
import "./chunk-KWSMYM7P.js";
import "./chunk-RP5SAUAF.js";
import "./chunk-AMSVADDY.js";
import "./chunk-6B7VJB6C.js";
import {
  b
} from "./chunk-YXRSJYLG.js";
import "./chunk-KBKTS574.js";
import "./chunk-6ABSX3YY.js";
import "./chunk-24NOAXOQ.js";
import "./chunk-FWR4JURK.js";
import {
  k as k3
} from "./chunk-BELGAUAK.js";
import "./chunk-JHJVOI7Q.js";
import "./chunk-TWNBDJHC.js";
import "./chunk-HITXLR5N.js";
import "./chunk-WYZCKLOR.js";
import "./chunk-S6NERLXF.js";
import "./chunk-4TSAC52K.js";
import "./chunk-H4ZZ5S37.js";
import "./chunk-G557TGXY.js";
import "./chunk-WOGT6UK2.js";
import "./chunk-RHT6WWRD.js";
import "./chunk-EUGXS5RE.js";
import "./chunk-IRNKV32L.js";
import "./chunk-IATM3RCE.js";
import "./chunk-BEALJUHO.js";
import "./chunk-GRHSIT57.js";
import "./chunk-PJQIAD5D.js";
import "./chunk-Z6KIMOUA.js";
import "./chunk-SZAJDZCO.js";
import "./chunk-M7R7REMB.js";
import "./chunk-ZZYUEH57.js";
import "./chunk-VTWXDFFD.js";
import "./chunk-IPCIO3PX.js";
import "./chunk-EIY2DYTV.js";
import {
  i
} from "./chunk-WJ4LS3YG.js";
import "./chunk-F6MD5VOH.js";
import {
  o as o2
} from "./chunk-V2RPSCV3.js";
import {
  y as y2
} from "./chunk-AOJ6OCPK.js";
import "./chunk-LMT5JII2.js";
import "./chunk-A43TI6AT.js";
import "./chunk-BHJVWW2P.js";
import "./chunk-4HKQSEUR.js";
import "./chunk-V3U4F2NL.js";
import "./chunk-ZB6PGKG5.js";
import "./chunk-OIIDE5GZ.js";
import "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import {
  d
} from "./chunk-TBSVVR6M.js";
import "./chunk-6TJWLWLO.js";
import "./chunk-H7BKONNV.js";
import "./chunk-K6C6RVSV.js";
import "./chunk-KBJ5Z4R2.js";
import "./chunk-JUZJCTW2.js";
import "./chunk-423VNHLR.js";
import "./chunk-FN47E7YK.js";
import "./chunk-XZS3Q5K4.js";
import "./chunk-XXFXRXFH.js";
import "./chunk-CCXEAKIM.js";
import {
  M
} from "./chunk-Y5D433JZ.js";
import {
  x2 as x
} from "./chunk-QNOCEWCR.js";
import {
  o
} from "./chunk-WURET5CW.js";
import {
  f as f2
} from "./chunk-QWPLZ3QH.js";
import {
  G,
  w,
  z
} from "./chunk-HLGIRLYQ.js";
import {
  n as n2
} from "./chunk-N2K4VRZH.js";
import "./chunk-WL4VPODY.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import {
  I,
  j
} from "./chunk-R5DM4YAB.js";
import {
  f
} from "./chunk-NSRXJNTS.js";
import {
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  T,
  c,
  v as v2
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  a,
  k as k2,
  m,
  u,
  v
} from "./chunk-RFPH3ZTZ.js";
import {
  n
} from "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import {
  has,
  k
} from "./chunk-4V6374PV.js";
import "./chunk-A34O4XB5.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/support/rasterDatasets/BaseRaster.js
var J2 = 8;
var N3 = 256;
var V3 = class extends n2(f) {
  constructor() {
    super(...arguments), this.datasetName = null, this.datasetFormat = null, this.hasUniqueSourceStorageInfo = true, this.rasterInfo = null, this.ioConfig = { sampling: "closest" };
  }
  async init() {
    const e3 = T3();
    this.addResolvingPromise(e3), await this.when();
  }
  normalizeCtorArgs(e3) {
    return (e3 == null ? void 0 : e3.ioConfig) && (e3 = { ...e3, ioConfig: { resolution: null, bandIds: null, sampling: "closest", tileInfo: j2.create(), ...e3.ioConfig } }), e3;
  }
  get _isGlobalWrappableSource() {
    const { rasterInfo: e3 } = this, t5 = D2(e3.spatialReference);
    return null != t5 && e3.extent.width >= t5 / 2;
  }
  get _hasNoneOrGCSShiftTransform() {
    const { transform: e3 } = this.rasterInfo;
    return null == e3 || "gcs-shift" === e3.type;
  }
  set rasterJobHandler(e3) {
    var _a, _b;
    this._set("rasterJobHandler", e3), "Function" === this.datasetFormat && ((_b = (_a = this.primaryRasters) == null ? void 0 : _a.rasters) == null ? void 0 : _b.forEach((t5) => t5.rasterJobHandler = e3));
  }
  set url(e3) {
    this._set("url", y2(e3, s.getLogger(this)));
  }
  async open(e3) {
    throw new s2("BaseRaster:open-not-implemented", "open() is not implemented");
  }
  async fetchTile(e3, t5, i6, o7 = {}) {
    const r5 = o7.tileInfo || this.rasterInfo.storageInfo.tileInfo, n10 = this.getTileExtentFromTileInfo(e3, t5, i6, r5);
    return this.fetchPixels(n10, r5.size[0], r5.size[1], o7);
  }
  async identify(e3, t5 = {}) {
    var _a;
    e3 = v2(x, e3).clone().normalize();
    const { multidimensionalDefinition: i6, timeExtent: o7 } = t5, { rasterInfo: r5 } = this, { hasMultidimensionalTranspose: n10, multidimensionalInfo: s5 } = r5;
    let { transposedVariableName: l5 } = t5;
    const c9 = null != s5 && n10 && (null != o7 || h2(i6));
    if (c9 && !l5) {
      l5 = null != i6 && i6.length > 0 ? i6[0].variableName ?? void 0 : s5.variables[0].name, t5 = { ...t5, transposedVariableName: l5 };
    }
    t5 = this._getRequestOptionsWithSliceId(t5);
    const { spatialReference: m8, extent: f7 } = r5, { datumTransformation: u8 } = t5;
    let h8 = j5(e3, m8, u8);
    if (!f7.intersects(h8))
      return { location: h8, value: null };
    if (null != r5.transform) {
      const e4 = r5.transform.inverseTransform(h8);
      if (!r5.nativeExtent.intersects(e4))
        return { location: e4, value: null };
      h8 = e4;
    }
    let p6 = 0;
    const d8 = null != l5 && null != s5 && r5.hasMultidimensionalTranspose;
    if ("Function" === this.datasetFormat) {
      const e4 = this.primaryRasters.rasters[0];
      if (d8)
        return e4.identify(h8, t5);
      const { pixelSize: i7 } = r5, o8 = 3, n11 = i7.x * o8 / 2, s6 = i7.y * o8 / 2, l6 = new M({ xmin: h8.x - n11, xmax: h8.x + n11, ymin: h8.y - s6, ymax: h8.y + s6, spatialReference: m8 }), a7 = { interpolation: "nearest" }, { pixelBlock: c10 } = await e4.fetchPixels(l6, o8, o8, a7), { pixelBlock: f8 } = await this.fetchPixels(l6, o8, o8, a7);
      if (null == c10)
        return { location: h8, value: null };
      const u9 = Math.floor(o8 * o8 * 0.5), p7 = !c10.mask || c10.mask[u9] ? c10.pixels.map((e5) => e5[u9]) : null;
      let x6;
      return null != f8 && (x6 = !f8.mask || f8.mask[u9] ? f8.pixels.map((e5) => e5[u9]) : void 0), { location: h8, value: p7, processedValue: x6, pyramidLevel: 0 };
    }
    if (!d8) {
      if (t5.srcResolution) {
        p6 = re(t5.srcResolution, r5, this.ioConfig.sampling).pyramidLevel;
      } else if (p6 = await this.computeBestPyramidLevelForLocation(e3, t5), null == p6)
        return { location: h8, value: null };
    }
    const y7 = this.identifyPixelLocation(h8, p6, null, d8);
    if (null === y7)
      return { location: h8, value: null };
    const { row: g5, col: I4, rowOffset: k4, colOffset: T5, blockWidth: b2 } = y7, v5 = l5 ?? t5.sliceId, P3 = i4(this.url, v5), B4 = `${p6}/${g5}/${I4}`;
    let M2 = m6(P3, null, B4);
    null == M2 && (M2 = this.fetchRawTile(p6, g5, I4, t5), x2(P3, null, B4, M2));
    const _ = await M2;
    if (!((_a = _ == null ? void 0 : _.pixels) == null ? void 0 : _a.length))
      return { location: h8, value: null };
    const W2 = k4 * b2 + T5;
    return this._processIdentifyResult(_, { srcLocation: h8, position: W2, pyramidLevel: p6, useTransposedTile: !!d8, requestSomeSlices: c9, identifyOptions: t5 });
  }
  async fetchPixels(e3, t5, i6, o7 = {}) {
    e3 = oe(e3), o7 = this._getRequestOptionsWithSliceId(o7);
    const { _hasNoneOrGCSShiftTransform: r5 } = this;
    if (o7.requestRawData && r5)
      return this._fetchPixels(e3, t5, i6, o7);
    const n10 = D2(e3.spatialReference), s5 = V(e3);
    if (null == n10 || 0 === s5 || 1 === s5 && this._isGlobalWrappableSource && r5)
      return this._fetchPixels(e3, t5, i6, o7);
    if (s5 >= 3)
      return { extent: e3, pixelBlock: null };
    const l5 = [], { xmin: a7, xmax: c9 } = e3, m8 = Math.round(n10 / (c9 - a7) * t5), f7 = m8 - Math.round((n10 / 2 - a7) / (c9 - a7) * t5);
    let u8 = 0;
    const h8 = [];
    for (let y7 = 0; y7 <= s5; y7++) {
      const r6 = new M({ xmin: 0 === y7 ? a7 : -n10 / 2, xmax: y7 === s5 ? c9 - n10 * y7 : n10 / 2, ymin: e3.ymin, ymax: e3.ymax, spatialReference: e3.spatialReference }), p7 = 0 === y7 ? m8 - f7 : y7 === s5 ? t5 - u8 : m8;
      u8 += p7, h8.push(p7);
      const d9 = o7.disableWrapAround && y7 > 0 ? null : this._fetchPixels(r6, p7, i6, o7);
      l5.push(d9);
    }
    const p6 = (await Promise.all(l5)).map((e4) => e4 == null ? void 0 : e4.pixelBlock);
    let d8 = null;
    const x6 = { width: t5, height: i6 };
    if (this.rasterJobHandler) {
      d8 = (await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: p6, srcMosaicSize: x6, destDimension: null, coefs: null, sampleSpacing: null, interpolation: "nearest", alignmentInfo: null, blockWidths: h8 }, o7)).pixelBlock;
    } else
      d8 = U2(p6, x6, { blockWidths: h8 });
    return { extent: e3, srcExtent: J(e3, this.rasterInfo.spatialReference, o7.datumTransformation), pixelBlock: d8 };
  }
  async fetchRawPixels(e3, t5, i6, o7 = {}) {
    t5 = { x: Math.floor(t5.x), y: Math.floor(t5.y) };
    const r5 = await this._fetchRawTiles(e3, t5, i6, o7), { nativeExtent: n10, nativePixelSize: s5, storageInfo: l5 } = this.rasterInfo, a7 = 2 ** e3, c9 = s5.x * a7, m8 = s5.y * a7, f7 = new M({ xmin: n10.xmin + c9 * t5.x, xmax: n10.xmin + c9 * (t5.x + i6.width - 1), ymin: n10.ymax - m8 * (t5.y + i6.height - 1), ymax: n10.ymax - m8 * t5.y, spatialReference: n10.spatialReference });
    if (!r5)
      return { extent: f7, srcExtent: f7, pixelBlock: null };
    const { pixelBlocks: u8, mosaicSize: h8 } = r5;
    if (1 === u8.length && null != u8[0] && u8[0].width === i6.width && u8[0].height === i6.height)
      return { extent: f7, srcExtent: f7, pixelBlock: r5.pixelBlocks[0] };
    const p6 = e3 > 0 ? l5.pyramidBlockWidth : l5.blockWidth, d8 = e3 > 0 ? l5.pyramidBlockHeight : l5.blockHeight, x6 = { x: t5.x % p6, y: t5.y % d8 };
    let y7;
    if (this.rasterJobHandler) {
      y7 = (await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: u8, srcMosaicSize: h8, destDimension: i6, clipOffset: x6, clipSize: i6, coefs: null, sampleSpacing: null, interpolation: o7.interpolation, alignmentInfo: null, blockWidths: null }, o7)).pixelBlock;
    } else
      y7 = U2(u8, h8, { clipOffset: x6, clipSize: i6 });
    return { extent: f7, srcExtent: f7, pixelBlock: y7 };
  }
  fetchRawTile(e3, t5, o7, r5) {
    throw new s2("BaseRaster:read-not-implemented", "fetchRawTile() is not implemented");
  }
  computeExtent(e3) {
    return J(this.rasterInfo.extent, e3);
  }
  decodePixelBlock(e3, t5) {
    return !this.rasterJobHandler || t5.useCanvas ? j4(e3, t5) : this.rasterJobHandler.decode({ data: e3, options: t5 });
  }
  async request(e3, i6, o7 = 0) {
    const { customFetchParameters: r5 } = this.ioConfig, { range: n10, query: s5, headers: l5 } = i6;
    o7 = o7 ?? i6.retryCount ?? this.ioConfig.retryCount;
    const a7 = n10 ? { Range: `bytes=${n10.from}-${n10.to}` } : null;
    try {
      return await j(e3, { ...i6, query: { ...s5, ...r5 }, headers: { ...l5, ...a7 } });
    } catch (c9) {
      if (o7 > 0)
        return o7--, this.request(e3, i6, o7);
      throw c9;
    }
  }
  getSliceIndex(e3) {
    const { multidimensionalInfo: t5 } = this.rasterInfo;
    return null == t5 || null == e3 || 0 === e3.length ? null : D3(e3, t5);
  }
  getTileExtentFromTileInfo(e3, t5, i6, o7) {
    const r5 = o7.lodAt(e3);
    return this.getTileExtent({ x: r5.resolution, y: r5.resolution }, t5, i6, o7.origin, o7.spatialReference, o7.size);
  }
  updateTileInfo() {
    const { storageInfo: e3, spatialReference: t5, extent: i6, pixelSize: o7 } = this.rasterInfo;
    if (!e3.tileInfo) {
      const r5 = [], n10 = e3.maximumPyramidLevel || 0;
      let s5 = Math.max(o7.x, o7.y), l5 = 1 / 0.0254 * 96 * s5;
      for (let e4 = 0; e4 <= n10; e4++)
        r5.unshift(new p({ level: n10 - e4, resolution: s5, scale: l5 })), s5 *= 2, l5 *= 2;
      const a7 = new x({ x: i6.xmin, y: i6.ymax, spatialReference: t5 });
      e3.tileInfo = new j2({ origin: a7, size: [e3.blockWidth, e3.blockHeight], spatialReference: t5, lods: r5 }), e3.isVirtualTileInfo = true;
    }
  }
  createRemoteDatasetStorageInfo(e3, t5 = 512, i6 = 512, o7) {
    const { width: r5, height: n10, nativeExtent: s5, pixelSize: l5, spatialReference: a7 } = e3, c9 = new x({ x: s5.xmin, y: s5.ymax, spatialReference: a7 });
    null == o7 && (o7 = Math.max(0, Math.round(Math.log(Math.max(r5, n10)) / Math.LN2 - 8)));
    const m8 = this.computeBlockBoundary(s5, 512, 512, { x: s5.xmin, y: s5.ymax }, [l5], o7);
    e3.storageInfo = new n4({ blockWidth: t5, blockHeight: i6, pyramidBlockWidth: t5, pyramidBlockHeight: i6, origin: c9, firstPyramidLevel: 1, maximumPyramidLevel: o7, blockBoundary: m8 });
  }
  async computeBestPyramidLevelForLocation(e3, t5 = {}) {
    return 0;
  }
  computeBlockBoundary(e3, t5, i6, o7, r5, n10 = 0, s5 = 2) {
    if (1 === r5.length && n10 > 0) {
      r5 = [...r5];
      let { x: e4, y: t6 } = r5[0];
      for (let i7 = 0; i7 < n10; i7++)
        e4 *= s5, t6 *= s5, r5.push({ x: e4, y: t6 });
    }
    const l5 = [], { x: a7, y: c9 } = o7;
    for (let m8 = 0; m8 < r5.length; m8++) {
      const { x: o8, y: n11 } = r5[m8];
      l5.push({ minCol: Math.floor((e3.xmin - a7 + 0.1 * o8) / t5 / o8), maxCol: Math.floor((e3.xmax - a7 - 0.1 * o8) / t5 / o8), minRow: Math.floor((c9 - e3.ymax + 0.1 * n11) / i6 / n11), maxRow: Math.floor((c9 - e3.ymin - 0.1 * n11) / i6 / n11) });
    }
    return l5;
  }
  getPyramidPixelSize(e3) {
    const { nativePixelSize: t5 } = this.rasterInfo, { pyramidResolutions: i6, pyramidScalingFactor: o7 } = this.rasterInfo.storageInfo;
    if (0 === e3)
      return t5;
    if (null != i6 && i6.length)
      return i6[e3 - 1];
    const r5 = o7 ** e3;
    return { x: t5.x * r5, y: t5.y * r5 };
  }
  identifyPixelLocation(e3, t5, i6, o7) {
    const { spatialReference: r5, nativeExtent: n10, storageInfo: s5 } = this.rasterInfo, { maximumPyramidLevel: l5, origin: a7, transposeInfo: c9 } = s5, m8 = o7 && null != c9 ? c9.tileSize[0] : s5.blockWidth, f7 = o7 && null != c9 ? c9.tileSize[1] : s5.blockHeight, u8 = j5(e3, r5, i6);
    if (!n10.intersects(u8))
      return null;
    if (t5 < 0 || t5 > l5)
      return null;
    const h8 = this.getPyramidPixelSize(t5), { x: p6, y: d8 } = h8, x6 = (a7.y - u8.y) / d8 / f7, y7 = (u8.x - a7.x) / p6 / m8, g5 = Math.min(f7 - 1, Math.floor((x6 - Math.floor(x6)) * f7)), I4 = Math.min(m8 - 1, Math.floor((y7 - Math.floor(y7)) * m8));
    return { pyramidLevel: t5, row: Math.floor(x6), col: Math.floor(y7), rowOffset: g5, colOffset: I4, blockWidth: m8, srcLocation: u8 };
  }
  getTileExtent(e3, t5, i6, o7, r5, n10) {
    const [s5, l5] = n10, a7 = o7.x + i6 * s5 * e3.x, c9 = a7 + s5 * e3.x, m8 = o7.y - t5 * l5 * e3.y, f7 = m8 - l5 * e3.y;
    return new M({ xmin: a7, xmax: c9, ymin: f7, ymax: m8, spatialReference: r5 });
  }
  getBlockWidthHeight(e3) {
    return { blockWidth: e3 > 0 ? this.rasterInfo.storageInfo.pyramidBlockWidth : this.rasterInfo.storageInfo.blockWidth, blockHeight: e3 > 0 ? this.rasterInfo.storageInfo.pyramidBlockHeight : this.rasterInfo.storageInfo.blockHeight };
  }
  isBlockOutside(e3, t5, i6) {
    const o7 = this.rasterInfo.storageInfo.blockBoundary[e3];
    return !o7 || o7.maxRow < t5 || o7.maxCol < i6 || o7.minRow > t5 || o7.minCol > i6;
  }
  async _fetchPixels(e3, t5, i6, o7 = {}) {
    let r5 = V(e3);
    if (r5 >= 2)
      return { extent: e3, pixelBlock: null };
    const n10 = this._getSourceDataInfo(e3, t5, i6, o7), { pyramidLevel: s5, srcResolution: l5, srcExtent: a7, srcWidth: c9, srcHeight: m8, ul: f7 } = n10;
    if (0 === c9 || 0 === m8)
      return { extent: e3, srcExtent: a7, pixelBlock: null };
    const { rasterInfo: u8 } = this, h8 = u8.transform, p6 = "gcs-shift" === (h8 == null ? void 0 : h8.type), d8 = null != D2(e3.spatialReference);
    !p6 && d8 || (r5 = V(n10.srcExtent, p6));
    const x6 = await this._fetchRawTiles(s5, f7, { width: c9, height: m8, wrapCount: r5 }, o7);
    if (!x6)
      return { extent: e3, srcExtent: a7, pixelBlock: null };
    const y7 = u8.storageInfo, g5 = s5 > 0 ? y7.pyramidBlockWidth : y7.blockWidth, I4 = s5 > 0 ? y7.pyramidBlockHeight : y7.blockHeight;
    let { x: R4, y: w3 } = u8.pixelSize;
    if (s5 > 0) {
      const { pyramidResolutions: e4, pyramidScalingFactor: t6 } = y7;
      if (null != e4 && e4[s5 - 1])
        ({ x: R4, y: w3 } = e4[s5 - 1]);
      else {
        const e5 = t6 ** s5;
        R4 *= e5, w3 *= e5;
      }
    }
    const S6 = u8.spatialReference, k4 = new x({ x: R4, y: w3, spatialReference: S6 }), T5 = g5 === c9 && I4 === m8 && f7.x % g5 == 0 && f7.y % I4 == 0, b2 = new x({ x: (e3.xmax - e3.xmin) / t5, y: (e3.ymax - e3.ymin) / i6, spatialReference: e3.spatialReference }), v5 = !e3.spatialReference.equals(S6), C3 = S6.isGeographic ? 1e-9 : 1e-4, { datumTransformation: j6 } = o7;
    if (!v5 && T5 && 1 === x6.pixelBlocks.length && g5 === t5 && I4 === i6 && this._isSameResolution(l5, b2, C3))
      return { extent: e3, srcExtent: a7, srcTilePixelSize: k4, pixelBlock: x6.pixelBlocks[0] };
    const H = d8 && null != D2(a7.spatialReference) && this._hasNoneOrGCSShiftTransform, L3 = o7.requestProjectedLocalDirections && this.rasterInfo.dataType.startsWith("vector");
    L3 && !this.rasterJobHandler && await T3();
    const D4 = this.rasterJobHandler ? await this.rasterJobHandler.getProjectionOffsetGrid({ projectedExtent: e3, srcBufferExtent: x6.extent, pixelSize: b2.toJSON(), datumTransformation: j6, rasterTransform: h8, hasWrapAround: r5 > 0 || H, isAdaptive: false !== this.ioConfig.optimizeProjectionAccuracy, includeGCSGrid: L3 }, o7) : ee({ projectedExtent: e3, srcBufferExtent: x6.extent, pixelSize: b2, datumTransformation: j6, rasterTransform: h8, hasWrapAround: r5 > 0 || H, isAdaptive: false, includeGCSGrid: L3 });
    let F3;
    const A3 = !o7.requestRawData, G2 = { rows: D4.spacing[0], cols: D4.spacing[1] }, J3 = this._hasNoneOrGCSShiftTransform ? this._getRasterTileAlignmentInfo(s5, x6.extent.xmin) : void 0, { pixelBlocks: N4, mosaicSize: V5, isPartiallyFilled: U5 } = x6;
    let $ = null;
    if (this.rasterJobHandler) {
      const e4 = await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: N4, srcMosaicSize: V5, destDimension: A3 ? { width: t5, height: i6 } : null, coefs: A3 ? D4.coefficients : null, sampleSpacing: A3 ? G2 : null, projectDirections: L3, gcsGrid: L3 ? D4.gcsGrid : null, isUV: "vector-uv" === this.rasterInfo.dataType, interpolation: o7.interpolation, alignmentInfo: J3, blockWidths: null }, o7);
      ({ pixelBlock: F3, localNorthDirections: $ } = e4);
    } else {
      const e4 = U2(N4, V5, { alignmentInfo: J3 });
      F3 = A3 ? R2(e4, { width: t5, height: i6 }, D4.coefficients, G2, o7.interpolation) : e4, L3 && D4.gcsGrid && ($ = I2({ width: t5, height: i6 }, D4.gcsGrid), F3 = u4(F3, this.rasterInfo.dataType, $));
    }
    return o7.requestRawData || L3 ? { extent: e3, srcExtent: a7, srcTilePixelSize: k4, pixelBlock: F3, transformGrid: D4, localNorthDirections: $, isPartiallyFilled: U5 } : { extent: e3, srcExtent: a7, srcTilePixelSize: k4, pixelBlock: F3 };
  }
  async _fetchRawTiles(e3, t5, i6, o7) {
    const { origin: r5, blockBoundary: n10 } = this.rasterInfo.storageInfo, { blockWidth: s5, blockHeight: l5 } = this.getBlockWidthHeight(e3);
    let { x: a7, y: c9 } = t5, { width: m8, height: f7, wrapCount: u8 } = i6;
    const h8 = this._getRasterTileAlignmentInfo(e3, 0);
    o7.buffer && (a7 -= o7.buffer.cols, c9 -= o7.buffer.rows, m8 += 2 * o7.buffer.cols, f7 += 2 * o7.buffer.rows);
    let p6 = 0, d8 = 0, x6 = 0;
    if (u8 && null != h8) {
      ({ worldColumnCountFromOrigin: d8, originColumnOffset: x6, rightPadding: p6 } = h8);
      d8 * h8.blockWidth - p6 >= a7 + m8 && (p6 = 0);
    }
    const y7 = Math.floor(a7 / s5), g5 = Math.floor(c9 / l5), I4 = Math.floor((a7 + m8 + p6 - 1) / s5), R4 = Math.floor((c9 + f7 + p6 - 1) / l5), w3 = n10[e3];
    if (!w3)
      return null;
    const { minRow: S6, minCol: k4, maxCol: T5, maxRow: b2 } = w3;
    if (0 === u8 && (R4 < S6 || I4 < k4 || g5 > b2 || y7 > T5))
      return null;
    const v5 = new Array();
    let P3 = false;
    const B4 = null == this.ioConfig.allowPartialFill ? o7.allowPartialFill : this.ioConfig.allowPartialFill;
    for (let z2 = g5; z2 <= R4; z2++)
      for (let t6 = y7; t6 <= I4; t6++) {
        let i7 = t6;
        if (!o7.disableWrapAround && u8 && null != h8 && d8 <= t6 && (i7 = t6 - d8 - x6), z2 >= S6 && i7 >= k4 && b2 >= z2 && T5 >= i7) {
          const t7 = this._fetchRawTile(e3, z2, i7, o7);
          B4 ? v5.push(new Promise((e4) => {
            t7.then((t8) => e4(t8)).catch(() => {
              P3 = true, e4(null);
            });
          })) : v5.push(t7);
        } else
          v5.push(Promise.resolve(null));
      }
    if (0 === v5.length)
      return null;
    const M2 = await Promise.all(v5), _ = { height: (R4 - g5 + 1) * l5, width: (I4 - y7 + 1) * s5 }, { spatialReference: W2 } = this.rasterInfo, C3 = this.getPyramidPixelSize(e3), { x: j6, y: H } = C3;
    return { extent: new M({ xmin: r5.x + y7 * s5 * j6, xmax: r5.x + (I4 + 1) * s5 * j6, ymin: r5.y - (R4 + 1) * l5 * H, ymax: r5.y - g5 * l5 * H, spatialReference: W2 }), pixelBlocks: M2, mosaicSize: _, isPartiallyFilled: P3 };
  }
  _isSameResolution(e3, t5, i6) {
    return Math.abs(e3.x - t5.x) < i6 && Math.abs(e3.y - t5.y) < i6;
  }
  _fetchRawTile(e3, t5, i6, o7) {
    const r5 = this.rasterInfo.storageInfo.blockBoundary[e3];
    if (!r5)
      return Promise.resolve(null);
    const { minRow: n10, minCol: l5, maxCol: a7, maxRow: c9 } = r5;
    if (t5 < n10 || i6 < l5 || t5 > c9 || i6 > a7)
      return Promise.resolve(null);
    const m8 = i4(this.url, o7.sliceId), f7 = `${e3}/${t5}/${i6}`;
    let u8 = m6(m8, o7.registryId, f7);
    if (null == u8) {
      const r6 = new AbortController();
      u8 = this.fetchRawTile(e3, t5, i6, { ...o7, signal: r6.signal }), x2(m8, o7.registryId, f7, u8, r6), u8.catch(() => h4(m8, o7.registryId, f7));
    }
    return o7.signal && m(o7, () => {
      s4(m8, o7.registryId, f7);
    }), u8;
  }
  _computeMagDirValues(e3) {
    var _a;
    const { bandCount: t5, dataType: i6 } = this.rasterInfo;
    if (!(2 === t5 && "vector-magdir" === i6 || "vector-uv" === i6) || 2 !== (e3 == null ? void 0 : e3.length) || !((_a = e3[0]) == null ? void 0 : _a.length))
      return null;
    const o7 = e3[0].length;
    if ("vector-magdir" === i6) {
      const t6 = e3[1].map((e4) => (e4 + 360) % 360);
      return [e3[0], t6];
    }
    const [r5, n10] = e3, s5 = [], l5 = [];
    for (let a7 = 0; a7 < o7; a7++) {
      const [e4, t6] = l2([r5[a7], n10[a7]]);
      s5.push(e4), l5.push(t6);
    }
    return [s5, l5];
  }
  _getRasterTileAlignmentInfo(e3, t5) {
    return null == this._rasterTileAlighmentInfo && (this._rasterTileAlighmentInfo = Z(this.rasterInfo)), null == this._rasterTileAlighmentInfo.pyramidsInfo ? null : { startX: t5, halfWorldWidth: this._rasterTileAlighmentInfo.halfWorldWidth, hasGCSSShiftTransform: this._rasterTileAlighmentInfo.hasGCSSShiftTransform, ...this._rasterTileAlighmentInfo.pyramidsInfo[e3] };
  }
  _getSourceDataInfo(e3, t5, i6, o7 = {}) {
    const r5 = { datumTransformation: o7.datumTransformation, pyramidLevel: 0, pyramidResolution: null, srcExtent: null, srcHeight: 0, srcResolution: null, srcWidth: 0, ul: { x: 0, y: 0 } };
    o7.srcResolution && (r5.srcResolution = o7.srcResolution, this._updateSourceDataInfo(e3, r5));
    const n10 = this.rasterInfo.storageInfo.maximumPyramidLevel || 0, { srcWidth: s5, srcHeight: l5, pyramidLevel: a7 } = r5, c9 = s5 / t5, m8 = l5 / i6, f7 = a7 < n10 && c9 * m8 >= 16, u8 = a7 === n10 && this._requireTooManySrcTiles(s5, l5, t5, i6);
    if (f7 || u8 || (0 === s5 || 0 === l5)) {
      const s6 = new x({ x: (e3.xmax - e3.xmin) / t5, y: (e3.ymax - e3.ymin) / i6, spatialReference: e3.spatialReference });
      let l6 = C2(s6, this.rasterInfo.spatialReference, e3, r5.datumTransformation);
      const u9 = !l6 || o7.srcResolution && l6.x + l6.y < o7.srcResolution.x + o7.srcResolution.y;
      if (f7 && o7.srcResolution && u9) {
        const e4 = Math.round(Math.log(Math.max(c9, m8)) / Math.LN2) - 1;
        if (n10 - a7 + 3 >= e4) {
          const t6 = 2 ** e4;
          l6 = { x: o7.srcResolution.x * t6, y: o7.srcResolution.y * t6 };
        }
      }
      l6 && (r5.srcResolution = l6, this._updateSourceDataInfo(e3, r5));
    }
    return this._requireTooManySrcTiles(r5.srcWidth, r5.srcHeight, t5, i6) && (r5.srcWidth = 0, r5.srcHeight = 0), r5;
  }
  _requireTooManySrcTiles(e3, t5, i6, o7) {
    const { tileInfo: r5 } = this.rasterInfo.storageInfo;
    return Math.ceil(e3 / r5.size[0]) * Math.ceil(t5 / r5.size[1]) >= N3 || e3 / i6 > J2 || t5 / o7 > J2;
  }
  _updateSourceDataInfo(e3, t5) {
    t5.srcWidth = 0, t5.srcHeight = 0;
    const { rasterInfo: i6 } = this, o7 = i6.spatialReference, { srcResolution: r5, datumTransformation: n10 } = t5, { pyramidLevel: s5, pyramidResolution: l5, excessiveReading: a7 } = re(r5, i6, this.ioConfig.sampling);
    if (a7)
      return;
    let c9 = t5.srcExtent || J(e3, o7, n10);
    if (null == c9)
      return;
    const m8 = i6.transform;
    m8 && (c9 = m8.inverseTransform(c9)), t5.srcExtent = c9;
    const { x: f7, y: u8 } = i6.storageInfo.origin, h8 = Math.floor((c9.xmin - f7) / l5.x + 0.1), p6 = Math.floor((u8 - c9.ymax) / l5.y + 0.1), d8 = Math.floor((c9.xmax - f7) / l5.x - 0.1), x6 = Math.floor((u8 - c9.ymin) / l5.y - 0.1), y7 = c9.width < 0.1 * l5.x ? 0 : d8 - h8 + 1, g5 = c9.height < 0.1 * l5.y ? 0 : x6 - p6 + 1;
    t5.pyramidLevel = s5, t5.pyramidResolution = l5, t5.srcWidth = y7, t5.srcHeight = g5, t5.ul = { x: h8, y: p6 };
  }
  _getRequestOptionsWithSliceId(e3) {
    return null != this.rasterInfo.multidimensionalInfo && null == e3.sliceId && (e3 = { ...e3, sliceId: this.getSliceIndex(e3.multidimensionalDefinition) }), e3;
  }
  _processIdentifyResult(e3, t5) {
    const { srcLocation: i6, position: o7, pyramidLevel: r5, useTransposedTile: n10 } = t5, s5 = e3.pixels[0].length / e3.width / e3.height;
    if (!(!e3.mask || e3.mask[o7]))
      return { location: i6, value: null };
    const { multidimensionalInfo: l5 } = this.rasterInfo;
    if (null == l5 || !n10) {
      const t6 = e3.pixels.map((e4) => e4[o7]), n11 = { location: i6, value: t6, pyramidLevel: r5 }, s6 = this._computeMagDirValues(t6.map((e4) => [e4]));
      return (s6 == null ? void 0 : s6.length) && (n11.magdirValue = s6.map((e4) => e4[0])), n11;
    }
    let a7 = e3.pixels.map((e4) => e4.slice(o7 * s5, o7 * s5 + s5)), c9 = this._computeMagDirValues(a7);
    const { requestSomeSlices: m8, identifyOptions: f7 } = t5;
    let h8 = i3(l5, f7.transposedVariableName);
    if (m8) {
      const e4 = a5(h8, f7.multidimensionalDefinition, f7.timeExtent);
      a7 = a7.map((t6) => e4.map((e5) => t6[e5])), c9 = c9 == null ? void 0 : c9.map((t6) => e4.map((e5) => t6[e5])), h8 = e4.map((e5) => h8[e5]);
    }
    const p6 = e3.noDataValues || this.rasterInfo.noDataValue, d8 = { pixels: a7, pixelType: e3.pixelType };
    let x6;
    null != p6 && (u2(d8, p6), x6 = d8.mask);
    return { location: i6, value: null, dataSeries: h8.map((e4, t6) => {
      const i7 = { value: 0 === (x6 == null ? void 0 : x6[t6]) ? null : a7.map((e5) => e5[t6]), multidimensionalDefinition: e4.multidimensionalDefinition.map((e5) => new p3({ ...e5, isSlice: true })) };
      return (c9 == null ? void 0 : c9.length) && (i7.magdirValue = [c9[0][t6], c9[1][t6]]), i7;
    }), pyramidLevel: r5 };
  }
};
e([y()], V3.prototype, "_rasterTileAlighmentInfo", void 0), e([y({ readOnly: true })], V3.prototype, "_isGlobalWrappableSource", null), e([y({ readOnly: true })], V3.prototype, "_hasNoneOrGCSShiftTransform", null), e([y()], V3.prototype, "rasterJobHandler", null), e([y(d3)], V3.prototype, "url", null), e([y({ type: String, json: { write: true } })], V3.prototype, "datasetName", void 0), e([y({ type: String, json: { write: true } })], V3.prototype, "datasetFormat", void 0), e([y()], V3.prototype, "hasUniqueSourceStorageInfo", void 0), e([y()], V3.prototype, "rasterInfo", void 0), e([y()], V3.prototype, "ioConfig", void 0), e([y()], V3.prototype, "sourceJSON", void 0), V3 = e([c("esri.layers.support.rasterDatasets.BaseRaster")], V3);
var U4 = V3;

// node_modules/@arcgis/core/layers/support/rasterDatasets/FunctionRaster.js
var n6 = class extends U4 {
  constructor() {
    super(...arguments), this.datasetFormat = "Function", this.tileType = "Raster", this.rasterFunction = null;
  }
  async open(t5) {
    var _a, _b, _c, _d;
    await this.init();
    const { rasterFunction: r5 } = this;
    ((_b = (_a = this.primaryRasters) == null ? void 0 : _a.rasters) == null ? void 0 : _b.length) ? r5.sourceRasters = this.primaryRasters.rasters : (this.primaryRasters = r5.getPrimaryRasters(), this.rasterJobHandler && ((_c = this.primaryRasters.rasters) == null ? void 0 : _c.forEach((t6) => t6.rasterJobHandler = this.rasterJobHandler)));
    const { rasters: s5, rasterIds: a7 } = this.primaryRasters, i6 = s5.map((e3) => e3.rasterInfo ? void 0 : e3.open(t5));
    await Promise.all(i6);
    const n10 = s5.map(({ rasterInfo: t6 }) => t6), c9 = r5.bind({ rasterInfos: n10, rasterIds: a7 });
    if (!c9.success || 0 === n10.length)
      throw new s2("raster-function:open", `cannot bind the function: ${c9.error ?? ""}`);
    const l5 = "Table" === r5.functionName ? r5 : (_d = r5.functionArguments) == null ? void 0 : _d.raster;
    "Table" === (l5 == null ? void 0 : l5.functionName) && (r5.rasterInfo.attributeTable = d2.fromJSON(l5.functionArguments.attributeTableAsRecordSet)), await this.syncJobHandler();
    const p6 = n10[0];
    this.hasUniqueSourceStorageInfo = 1 === n10.length || n10.slice(1).every((t6) => this._hasSameStorageInfo(t6, p6)), this.set("sourceJSON", s5[0].sourceJSON), this.set("rasterInfo", r5.rasterInfo);
  }
  async syncJobHandler() {
    var _a;
    return (_a = this.rasterJobHandler) == null ? void 0 : _a.updateRasterFunction(this.rasterFunction);
  }
  async fetchPixels(t5, e3, r5, s5 = {}) {
    var _a, _b;
    const { rasters: a7, rasterIds: o7 } = this.primaryRasters;
    let n10 = false;
    const { interpolation: c9 } = s5, l5 = (_a = this.rasterFunction.flatWebGLFunctionChain) == null ? void 0 : _a.hasFocalFunction;
    !s5.requestRawData && "bilinear" !== c9 && l5 && (n10 = 1 === a7.length && !s5.skipRasterFunction, s5 = { ...s5, interpolation: "bilinear", requestRawData: n10 });
    const p6 = a7.map((a8) => a8.fetchPixels(t5, e3, r5, s5)), u8 = await Promise.all(p6), m8 = u8.map((t6) => t6.pixelBlock), h8 = n10 || s5.requestRawData ? u8.map((t6) => t6.srcTilePixelSize) : null;
    if (s5.skipRasterFunction || m8.every((t6) => null == t6))
      return u8[0];
    const d8 = ((_b = u8.find((t6) => null != t6.pixelBlock)) == null ? void 0 : _b.extent) ?? t5, f7 = this.rasterJobHandler ? await this.rasterJobHandler.process({ extent: d8, primaryPixelBlocks: m8, primaryPixelSizes: h8, primaryRasterIds: o7 }) : this.rasterFunction.process({ extent: d8, primaryPixelBlocks: m8, primaryPixelSizes: h8, primaryRasterIds: o7 }), { transformGrid: y7 } = u8[0];
    if (!n10 || null == f7 || null == y7)
      return { ...u8[0], pixelBlock: f7 };
    const x6 = { rows: y7.spacing[0], cols: y7.spacing[1] };
    let b2;
    if (this.rasterJobHandler) {
      b2 = (await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: [f7], srcMosaicSize: { width: f7.width, height: f7.height }, destDimension: { width: e3, height: r5 }, coefs: y7.coefficients, sampleSpacing: x6, projectDirections: false, gcsGrid: null, isUV: false, interpolation: c9, alignmentInfo: void 0, blockWidths: null }, s5)).pixelBlock;
    } else
      b2 = R2(f7, { width: e3, height: r5 }, y7.coefficients, x6, c9);
    return { extent: t5, srcExtent: u8[0].srcExtent, pixelBlock: b2 };
  }
  _hasSameStorageInfo(t5, e3) {
    const { storageInfo: r5, pixelSize: s5, spatialReference: a7, extent: i6 } = t5, { storageInfo: o7, pixelSize: n10, spatialReference: c9, extent: l5 } = e3;
    return s5.x === n10.x && s5.y === n10.y && a7.equals(c9) && i6.equals(l5) && r5.blockHeight === o7.blockHeight && r5.blockWidth === o7.blockWidth && r5.maximumPyramidLevel === o7.maximumPyramidLevel;
  }
};
e([y({ type: String, json: { write: true } })], n6.prototype, "datasetFormat", void 0), e([y()], n6.prototype, "tileType", void 0), e([y()], n6.prototype, "rasterFunction", void 0), e([y()], n6.prototype, "primaryRasters", void 0), n6 = e([c("esri.layers.support.rasterDatasets.FunctionRaster")], n6);
var c5 = n6;

// node_modules/@arcgis/core/layers/support/rasterFunctions/clipUtils.js
function n7(e3, i6) {
  if (e3.spatialReference.equals(i6))
    return e3;
  const n10 = z(e3.spatialReference), a7 = z(i6);
  if (n10 === a7)
    return e3;
  const h8 = n10 / a7;
  return { x: e3.x * h8, y: e3.y * h8 };
}
async function a6(t5, e3, n10) {
  if ("extent" === n10.type)
    return o5(t5, e3, n10);
  const { width: a7, height: x6 } = t5, l5 = new Uint8Array(a7 * x6), { contains: m8, intersects: s5 } = await import("./geometryEngine-X6OFRYLT.js");
  return s5(e3, n10) ? "polyline" === n10.type ? r3(t5, e3, n10) : m8(n10, e3) ? t5 : h5(t5, e3, n10) : new u3({ pixelType: t5.pixelType, width: a7, height: x6, mask: l5, maskIsAlpha: false, pixels: [...t5.pixels] });
}
function h5(t5, e3, n10) {
  if (!t5)
    return t5;
  const { width: a7, height: h8 } = t5, o7 = e3.width / a7, r5 = e3.height / h8, { xmin: x6, ymax: l5 } = e3;
  let m8;
  if ("extent" === n10.type) {
    const t6 = (n10.xmin - x6) / o7, e4 = (n10.xmax - x6) / o7, i6 = (l5 - n10.ymax) / r5, a8 = (l5 - n10.ymin) / r5;
    m8 = [[[t6, i6], [t6, a8], [e4, a8], [e4, i6], [t6, i6]]];
  } else
    m8 = n10.rings.map((t6) => t6.map(([t7, e4]) => [(t7 - x6) / o7, (l5 - e4) / r5]));
  const s5 = document.createElement("canvas");
  s5.width = a7, s5.height = h8;
  const p6 = s5.getContext("2d");
  p6.fillStyle = "#f00", m8.forEach((t6) => {
    p6.beginPath(), p6.moveTo(t6[0][0], t6[0][1]);
    for (let e4 = 0; e4 < t6.length; e4++)
      p6.lineTo(t6[e4][0], t6[e4][1]);
    p6.closePath(), p6.fill();
  });
  const f7 = p6.getImageData(0, 0, a7, h8).data, y7 = t5.mask, c9 = a7 * h8, M2 = new Uint8Array(c9);
  for (let i6 = 0; i6 < c9; i6++)
    y7 && !y7[i6] || (M2[i6] = f7[4 * i6 + 3] > 127 ? 255 : 0);
  return new u3({ pixelType: t5.pixelType, width: a7, height: h8, mask: M2, maskIsAlpha: false, pixels: [...t5.pixels] });
}
function o5(t5, e3, n10) {
  const { width: a7, height: h8 } = t5, o7 = new Uint8Array(a7 * h8), r5 = e3.width / a7, x6 = e3.height / h8;
  if (n10.width / r5 < 0.5 || n10.height / x6 < 0.5)
    return new u3({ pixelType: t5.pixelType, width: a7, height: h8, mask: o7, pixels: [...t5.pixels] });
  const { xmin: l5, xmax: m8, ymin: s5, ymax: p6 } = e3, { xmin: f7, xmax: y7, ymin: c9, ymax: M2 } = n10, u8 = Math.max(l5, f7), w3 = Math.min(m8, y7), d8 = Math.max(s5, c9), g5 = Math.min(p6, M2), T5 = 0.5 * r5, k4 = 0.5 * x6;
  if (w3 - u8 < T5 || g5 - d8 < k4 || w3 < l5 + T5 || u8 > m8 - T5 || d8 > p6 - k4 || g5 < s5 + k4)
    return new u3({ pixelType: t5.pixelType, width: a7, height: h8, mask: o7, pixels: [...t5.pixels] });
  const A3 = Math.max(0, (u8 - l5) / r5), R4 = Math.min(a7, Math.max(0, (w3 - l5) / r5)), U5 = Math.max(0, (p6 - g5) / x6), j6 = Math.min(h8, Math.max(0, (p6 - d8) / x6)), E3 = Math.round(A3), I4 = Math.round(R4) - 1, P3 = Math.round(U5), v5 = Math.round(j6) - 1;
  if (E3 === I4 && A3 % 1 > 0.5 && R4 % 1 < 0.5 || P3 === v5 && U5 % 1 > 0.5 && j6 % 1 < 0.5)
    return new u3({ pixelType: t5.pixelType, width: a7, height: h8, mask: o7, pixels: [...t5.pixels] });
  if (0 === E3 && 0 === P3 && I4 === a7 && v5 === h8)
    return t5;
  const b2 = t5.mask;
  for (let i6 = P3; i6 <= v5; i6++)
    for (let t6 = E3; t6 <= I4; t6++) {
      const e4 = i6 * a7 + t6;
      o7[e4] = b2 ? b2[e4] : 255;
    }
  return new u3({ pixelType: t5.pixelType, width: a7, height: h8, mask: o7, pixels: [...t5.pixels] });
}
function r3(t5, e3, n10) {
  const { width: a7, height: h8 } = t5, o7 = new Uint8Array(a7 * h8), r5 = e3.width / a7, x6 = e3.height / h8, { xmin: l5, ymax: m8 } = e3, { paths: s5 } = n10, p6 = t5.mask;
  for (let i6 = 0; i6 < s5.length; i6++) {
    const t6 = s5[i6];
    for (let e4 = 0; e4 < t6.length - 1; e4++) {
      const [i7, n11] = t6[e4], [s6, f7] = t6[e4 + 1];
      let y7 = Math.floor((m8 - n11) / x6), c9 = Math.floor((m8 - f7) / x6);
      if (c9 < y7) {
        const t7 = y7;
        y7 = c9, c9 = t7;
      }
      y7 = Math.max(0, y7), c9 = Math.min(h8 - 1, c9);
      const M2 = (s6 - i7) / (f7 - n11);
      for (let t7 = y7; t7 <= c9; t7++) {
        const e5 = t7 === y7 ? Math.max(n11, f7) : (h8 + 1 - t7) * x6, m9 = t7 === c9 ? Math.min(n11, f7) : e5 - x6;
        let u8 = f7 === n11 ? Math.floor((i7 - l5) / r5) : Math.floor((M2 * (e5 - n11) + i7 - l5) / r5), w3 = f7 === n11 ? Math.floor((s6 - l5) / r5) : Math.floor((M2 * (m9 - n11) + i7 - l5) / r5);
        if (w3 < u8) {
          const t8 = u8;
          u8 = w3, w3 = t8;
        }
        const d8 = t7 * a7;
        u8 = Math.max(0, u8), w3 = Math.min(a7 - 1, w3);
        for (let t8 = d8 + u8; t8 <= d8 + w3; t8++)
          o7[t8] = p6 ? p6[t8] : 255;
      }
    }
  }
  return new u3({ pixelType: t5.pixelType, width: a7, height: h8, mask: o7, pixels: [...t5.pixels] });
}
function x3(t5, i6, a7, h8 = true) {
  const { spatialReference: o7 } = t5, { x: r5, y: x6 } = n7(a7, o7);
  let l5, m8, s5;
  const p6 = "extent" === i6.type ? i6 : i6.extent;
  let { xmin: f7, xmax: y7, ymax: c9, ymin: M2 } = p6;
  const { xmin: u8, ymax: w3 } = t5.extent;
  return h8 ? (f7 = u8 + (f7 > u8 ? r5 * Math.round((f7 - u8) / r5) : 0), c9 = w3 - (c9 < w3 ? x6 * Math.round((w3 - c9) / x6) : 0), y7 = u8 + (y7 > u8 ? r5 * Math.round((y7 - u8) / r5) : 0), M2 = w3 - (M2 < w3 ? x6 * Math.round((w3 - M2) / x6) : 0), l5 = new M({ xmin: f7, ymax: c9, xmax: y7, ymin: M2, spatialReference: o7 }), m8 = Math.round(l5.width / r5), s5 = Math.round(l5.height / x6)) : (m8 = Math.floor((y7 - f7) / r5 + 0.8), s5 = Math.floor((c9 - M2) / x6 + 0.8), f7 = u8 + (f7 > u8 ? r5 * Math.floor((f7 - u8) / r5 + 0.1) : 0), c9 = w3 - (c9 < w3 ? x6 * Math.floor((w3 - c9) / x6 + 0.1) : 0), y7 = f7 + m8 * r5, M2 = c9 - s5 * x6, l5 = new M({ xmin: f7, ymax: c9, xmax: y7, ymin: M2, spatialReference: o7 })), { extent: l5, width: m8, height: s5 };
}

// node_modules/@arcgis/core/layers/mixins/ImageryTileMixin.js
var B3 = s.getLogger("esri.layers.mixins.ImageryTileMixin");
var V4 = (o7) => {
  let V5 = class extends o7 {
    constructor(...e3) {
      var _a, _b;
      super(...e3), this._isConstructedFromFunctionRaster = false, this._rasterJobHandler = { instance: null, refCount: 0, connectionPromise: null }, this.bandIds = null, this.copyright = null, this.interpolation = "nearest", this.multidimensionalSubset = null, this.raster = null, this.rasterInfo = null, this.sourceJSON = null, this.spatialReference = null, this.symbolizer = null, this._isConstructedFromFunctionRaster = "Function" === ((_b = (_a = e3[0]) == null ? void 0 : _a.raster) == null ? void 0 : _b.datasetFormat);
    }
    get fullExtent() {
      var _a;
      return (_a = this.rasterInfo) == null ? void 0 : _a.extent;
    }
    set multidimensionalDefinition(e3) {
      this._set("multidimensionalDefinition", e3), this.updateRenderer();
    }
    set rasterFunction(e3) {
      var _a;
      "none" === ((_a = e3 == null ? void 0 : e3.functionName) == null ? void 0 : _a.toLowerCase()) && (e3 = void 0), this._set("rasterFunction", e3), this.updateRasterFunction();
    }
    set url(e3) {
      this._set("url", y2(e3, B3));
    }
    set renderer(e3) {
      null == e3 && null == this.rasterFunction ? this._configDefaultRenderer("override") : (this._set("renderer", e3), this.updateRenderer());
    }
    readRenderer(e3, t5, r5) {
      var _a, _b;
      const n10 = (_b = (_a = t5 == null ? void 0 : t5.layerDefinition) == null ? void 0 : _a.drawingInfo) == null ? void 0 : _b.renderer;
      return c3(n10, r5) || void 0;
    }
    async convertVectorFieldData(e3, t5) {
      if (null == e3 || !this.rasterInfo)
        return null;
      const r5 = this._rasterJobHandler.instance, i6 = this.rasterInfo.dataType;
      return r5 ? r5.convertVectorFieldData({ pixelBlock: e3, dataType: i6 }, t5) : f4(e3, i6);
    }
    async computeStatisticsHistograms(e3, t5) {
      e3 = v2(h3, e3).clone();
      const { rasterInfo: r5 } = this, { geometry: i6 } = e3;
      if (null == i6)
        throw new s2("imagery-tile-mixin:compute-statistics-histograms", "geometry must be specified");
      let n10 = i6;
      const { spatialReference: o8 } = r5;
      i6.spatialReference.equals(o8) || (await T3(), n10 = "extent" === i6.type ? J(i6, o8) : U3(i6, o8));
      const a7 = e3.pixelSize ?? new x({ x: r5.pixelSize.x, y: r5.pixelSize.y, spatialReference: o8 }), { extent: u8, width: c9, height: d8 } = x3(r5, n10, a7), m8 = await this.fetchPixels(u8, c9, d8, { ...t5, interpolation: "nearest" });
      if (null == m8.pixelBlock)
        throw new s2("imagery-tile-mixin:compute-statistics-histograms", "failed to fetch pixels");
      const h8 = await a6(m8.pixelBlock, u8, n10), p6 = this._rasterJobHandler.instance;
      return p6 ? p6.computeStatisticsHistograms({ pixelBlock: h8 }, t5) : m4(h8);
    }
    async createFlowMesh(e3, t5) {
      const r5 = this._rasterJobHandler.instance;
      return r5 ? r5.createFlowMesh(e3, t5) : s3(e3.meshType, e3.simulationSettings, e3.flowData, null != t5.signal ? t5.signal : new AbortController().signal);
    }
    normalizeRasterFetchOptions(e3) {
      var _a, _b;
      const { multidimensionalInfo: t5 } = this.rasterInfo ?? {};
      if (null == t5)
        return e3;
      let r5 = e3.multidimensionalDefinition || this.multidimensionalDefinition;
      (r5 == null ? void 0 : r5.length) || (r5 = d5(this.raster.rasterInfo, { multidimensionalSubset: this.multidimensionalSubset }));
      const i6 = e3.timeExtent || this.timeExtent;
      if (null != r5 && null != i6 && (null != i6.start || null != i6.end)) {
        r5 = r5.map((e4) => e4.clone());
        const n10 = (_b = (_a = t5.variables.find(({ name: e4 }) => e4 === r5[0].variableName)) == null ? void 0 : _a.dimensions) == null ? void 0 : _b.find(({ name: e4 }) => "StdTime" === e4), s5 = r5.find(({ dimensionName: e4 }) => "StdTime" === e4);
        if (!n10 || !s5)
          return { ...e3, multidimensionalDefinition: null };
        const { start: o8, end: a7 } = i6, l5 = null == o8 ? null : o8.getTime(), u8 = null == a7 ? null : a7.getTime(), c9 = l5 ?? u8, d8 = u8 ?? l5;
        if (null != n10.values) {
          const e4 = n10.values.filter((e5) => {
            if (Array.isArray(e5)) {
              if (c9 === d8)
                return e5[0] <= c9 && e5[1] >= c9;
              const t6 = e5[0] <= c9 && e5[1] > c9 || e5[0] < d8 && e5[1] >= d8, r6 = e5[0] >= c9 && e5[1] <= d8 || e5[0] < c9 && e5[1] > d8;
              return t6 || r6;
            }
            return c9 === d8 ? e5 === c9 : e5 >= c9 && e5 <= d8;
          });
          if (e4.length) {
            const t6 = e4.sort((e5, t7) => {
              const r6 = Array.isArray(e5) ? e5[0] : e5, i7 = Array.isArray(e5) ? e5[1] : e5, n11 = Array.isArray(t7) ? t7[0] : t7, s6 = Array.isArray(t7) ? t7[1] : t7;
              if (c9 === d8)
                return r6 - n11;
              return Math.abs(i7 - d8) - Math.abs(s6 - d8);
            })[0];
            s5.values = [t6];
          } else
            r5 = null;
        } else if (n10.hasRegularIntervals && n10.extent) {
          const [e4, t6] = n10.extent;
          c9 > t6 || d8 < e4 ? r5 = null : s5.values = c9 === d8 ? [c9] : [Math.max(e4, c9), Math.min(t6, d8)];
        }
      }
      return null != r5 && o4(r5, this.multidimensionalSubset) ? { ...e3, multidimensionalDefinition: null } : { ...e3, multidimensionalDefinition: r5 };
    }
    async updateRasterFunction() {
      var _a, _b, _c;
      if (!this.loaded || "imagery-tile" !== this.type || !this.rasterFunction && !this._cachedRasterFunctionJson || JSON.stringify(this.rasterFunction) === JSON.stringify(this._cachedRasterFunctionJson))
        return;
      if (this._isConstructedFromFunctionRaster && "Function" === this.raster.datasetFormat) {
        const e4 = this.raster.rasterFunction.toJSON();
        return !this.rasterFunction && e4 && this._set("rasterFunction", N2.fromJSON(e4)), void (this._cachedRasterFunctionJson = (_a = this.rasterFunction) == null ? void 0 : _a.toJSON());
      }
      let e3, t5 = this.raster, r5 = false;
      "Function" === t5.datasetFormat ? (e3 = t5.primaryRasters.rasters, t5 = e3[0], r5 = true) : e3 = [t5];
      const { rasterFunction: i6 } = this;
      if (i6) {
        const r6 = { raster: t5 };
        e3.length > 1 && e3.forEach((e4) => r6[e4.url] = e4);
        const n11 = R3(((_b = i6.functionDefinition) == null ? void 0 : _b.toJSON()) ?? i6.toJSON(), r6), s6 = new c5({ rasterFunction: n11 });
        s6.rasterJobHandler = this._rasterJobHandler.instance, await s6.open(), this._cachedRasterFunctionJson = (_c = this.rasterFunction) == null ? void 0 : _c.toJSON(), this.raster = s6;
      } else
        this.raster = t5, this._cachedRasterFunctionJson = null, await t5.when();
      if (this._cachedRendererJson = null, !r5 && !i6)
        return;
      const { bandIds: n10 } = this, { bandCount: s5 } = this.raster.rasterInfo, o8 = (n10 == null ? void 0 : n10.length) ? n10.some((e4) => e4 >= s5) : s5 >= 3;
      n10 && (o8 || this.renderer && "raster-stretch" !== this.renderer.type) && this._set("bandIds", null), this._configDefaultRenderer("auto");
    }
    async updateRenderer() {
      const { loaded: e3, symbolizer: t5 } = this;
      if (!e3 || !t5 || !this.renderer)
        return;
      const { rasterInfo: r5 } = this.raster, i6 = f6(r5, { multidimensionalDefinition: this.multidimensionalDefinition, multidimensionalSubset: this.multidimensionalSubset }), n10 = i6 == null ? void 0 : i6.name, s5 = K({ ...this.renderer.toJSON(), variableName: n10 });
      if (JSON.stringify(this._cachedRendererJson) === JSON.stringify(s5))
        return;
      const o8 = this._rasterJobHandler.instance;
      o8 && (t5.rasterInfo = B2(r5, n10), t5.rendererJSON = s5, t5.bind(), await o8.updateSymbolizer(t5), this._cachedRendererJson = s5);
    }
    async applyRenderer(e3, t5) {
      const r5 = e3 == null ? void 0 : e3.pixelBlock;
      if (!(null != r5 && r5.pixels && r5.pixels.length > 0))
        return null;
      let i6;
      await this.updateRenderer();
      const n10 = this._rasterJobHandler.instance, s5 = this.bandIds ?? [];
      return i6 = n10 ? await n10.symbolize({ ...e3, simpleStretchParams: t5, bandIds: s5 }) : this.symbolizer.symbolize({ ...e3, simpleStretchParams: t5, bandIds: s5 }), i6;
    }
    getTileUrl(e3, t5, r5) {
      return "RasterTileServer" === this.raster.datasetFormat ? `${this.url}/tile/${e3}/${t5}/${r5}` : "";
    }
    getCompatibleTileInfo(e3, t5, r5 = false) {
      if (!this.loaded || null == t5)
        return null;
      if (r5 && e3.equals(this.spatialReference))
        return this.tileInfo;
      const i6 = G(e3);
      return j2.create({ size: 256, spatialReference: e3, origin: i6 ? { x: i6.origin[0], y: i6.origin[1] } : { x: t5.xmin, y: t5.ymax } });
    }
    getCompatibleFullExtent(e3) {
      return this.loaded ? (this._compatibleFullExtent && this._compatibleFullExtent.spatialReference.equals(e3) || (this._compatibleFullExtent = this.raster.computeExtent(e3)), this._compatibleFullExtent) : null;
    }
    async fetchTile(e3, t5, r5, i6 = {}) {
      var _a;
      if (L3(this), i6.requestAsImageElement) {
        const s6 = this.getTileUrl(e3, t5, r5);
        return j(s6, { responseType: "image", query: { ...this.refreshParameters, ...this.raster.ioConfig.customFetchParameters }, signal: i6.signal }).then((e4) => e4.data);
      }
      const { rasterInfo: s5 } = this;
      if (null != s5.multidimensionalInfo && null == (i6 = this.normalizeRasterFetchOptions(i6)).multidimensionalDefinition) {
        const n10 = i6.tileInfo || s5.storageInfo.tileInfo;
        return { extent: this.raster.getTileExtentFromTileInfo(e3, t5, r5, n10), pixelBlock: null };
      }
      return await this._initJobHandler(), await this.updateRasterFunction(), "raster-shaded-relief" === ((_a = this.renderer) == null ? void 0 : _a.type) && (i6 = { ...i6, buffer: { cols: 1, rows: 1 } }), this.raster.fetchTile(e3, t5, r5, i6);
    }
    async fetchPixels(e3, t5, r5, i6 = {}) {
      return null != this.rasterInfo.multidimensionalInfo && null == (i6 = this.normalizeRasterFetchOptions(i6)).multidimensionalDefinition ? { extent: e3, pixelBlock: null } : (await this._initJobHandler(), await this.updateRasterFunction(), t5 = Math.round(t5), r5 = Math.round(r5), this.raster.fetchPixels(e3, t5, r5, i6));
    }
    async identify(e3, t5 = {}) {
      var _a;
      const { raster: r5, rasterInfo: i6 } = this;
      if (null != i6.multidimensionalInfo) {
        if (!(i6.hasMultidimensionalTranspose && !!(h2(t5.multidimensionalDefinition) || t5.transposedVariableName || t5.timeExtent)) && null == (t5 = this.normalizeRasterFetchOptions(t5)).multidimensionalDefinition)
          return { location: e3, value: null };
      }
      const n10 = (_a = this.multidimensionalSubset) == null ? void 0 : _a.areaOfInterest;
      if (n10 && !n10.contains(e3))
        throw new s2("imagery-tile-mixin:identify", "the request cannot be fulfilled when falling outside of the multidimensional subset");
      return r5.identify(e3, t5);
    }
    increaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount++;
    }
    decreaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount--, this._rasterJobHandler.refCount <= 0 && this._shutdownJobHandler();
    }
    hasStandardTime() {
      var _a, _b, _c;
      const e3 = (_a = this.rasterInfo) == null ? void 0 : _a.multidimensionalInfo;
      if (null == e3 || "standard-time" !== ((_b = this.rasterInfo) == null ? void 0 : _b.dataType))
        return false;
      const t5 = this.multidimensionalDefinition, r5 = (_c = t5 == null ? void 0 : t5[0]) == null ? void 0 : _c.variableName;
      return e3.variables.some((e4) => e4.name === r5 && (!(t5 == null ? void 0 : t5[0].dimensionName) || e4.dimensions.some((e5) => "StdTime" === e5.name)));
    }
    getStandardTimeValue(e3) {
      return new Date(24 * (e3 - 25569) * 3600 * 1e3).toString();
    }
    getMultidimensionalSubsetVariables(e3) {
      var _a;
      const t5 = e3 ?? ((_a = this.rasterInfo) == null ? void 0 : _a.multidimensionalInfo);
      return g2(this.multidimensionalSubset, t5);
    }
    _configDefaultSettings() {
      this._configDefaultInterpolation(), this.multidimensionalDefinition || (this.multidimensionalDefinition = d5(this.raster.rasterInfo, { multidimensionalSubset: this.multidimensionalSubset })), this.rasterFunction && "Function" === this.raster.datasetFormat && (this._cachedRasterFunctionJson = this.rasterFunction.toJSON()), this._configDefaultRenderer();
    }
    _initJobHandler() {
      if (null != this._rasterJobHandler.connectionPromise)
        return this._rasterJobHandler.connectionPromise;
      const e3 = new t2();
      return this._rasterJobHandler.connectionPromise = e3.initialize().then(async () => {
        L3(this), this._rasterJobHandler.instance = e3, this.raster.rasterJobHandler = e3, "Function" === this.raster.datasetFormat && this.raster.syncJobHandler(), this.rasterFunction && await this.updateRasterFunction().catch(() => {
        }), this.renderer && this.updateRenderer();
      }).catch(() => {
      }), this._rasterJobHandler.connectionPromise;
    }
    _shutdownJobHandler() {
      this._rasterJobHandler.instance && this._rasterJobHandler.instance.destroy(), this._rasterJobHandler.instance = null, this._rasterJobHandler.connectionPromise = null, this._rasterJobHandler.refCount = 0, this._cachedRendererJson = null, this.raster && (this.raster.rasterJobHandler = null);
    }
    _configDefaultInterpolation() {
      var _a;
      if (null == this.interpolation) {
        L3(this);
        const { raster: e3 } = this, t5 = S(e3.rasterInfo, e3.tileType, (_a = this.sourceJSON) == null ? void 0 : _a.defaultResamplingMethod);
        this._set("interpolation", t5);
      }
    }
    _configDefaultRenderer(e3 = "no") {
      var _a, _b;
      L3(this);
      const { rasterInfo: t5 } = this.raster;
      !this.bandIds && t5.bandCount > 1 && (this.bandIds = E(t5));
      const r5 = f6(t5, { multidimensionalDefinition: this.multidimensionalDefinition, multidimensionalSubset: this.multidimensionalSubset }), i6 = r5 == null ? void 0 : r5.name;
      if (!this.renderer || "override" === e3) {
        const e4 = V2(t5, { bandIds: this.bandIds, variableName: i6 }), r6 = t5.statistics, n11 = r6 && r6.length > 0 ? r6[0] : null, s6 = (n11 == null ? void 0 : n11.max) ?? 0, o9 = (n11 == null ? void 0 : n11.min) ?? 0;
        "WCSServer" === this.raster.datasetFormat && "raster-stretch" === e4.type && (s6 > 1e24 || o9 < -1e24) && (e4.dynamicRangeAdjustment = true, e4.statistics = null, "none" === e4.stretchType && (e4.stretchType = "min-max")), this.renderer = e4;
      }
      const n10 = K({ ...this.renderer.toJSON(), variableName: i6 }), s5 = B2(t5, i6);
      this.symbolizer ? (this.symbolizer.rendererJSON = n10, this.symbolizer.rasterInfo = s5) : this.symbolizer = new L2({ rendererJSON: n10, rasterInfo: s5 });
      const o8 = this.symbolizer.bind();
      if (o8.success) {
        if ("auto" === e3) {
          const { colormap: e4 } = this.raster.rasterInfo, t6 = this.renderer;
          if (null != e4 && "raster-colormap" === t6.type) {
            const e5 = V2(this.raster.rasterInfo);
            JSON.stringify(e5) !== JSON.stringify(t6) && this._configDefaultRenderer("override");
          } else if ("raster-stretch" === t6.type) {
            const e5 = (_a = this.bandIds) == null ? void 0 : _a.length, r6 = (_b = t6.statistics) == null ? void 0 : _b.length;
            !t6.dynamicRangeAdjustment && r6 && e5 && r6 !== e5 && this._configDefaultRenderer("override");
          }
        }
      } else
        B3.warn("imagery-tile-mixin", o8.error || "The given renderer is not supported by the layer."), "auto" === e3 && this._configDefaultRenderer("override");
    }
  };
  function L3(e3) {
    if (!e3.raster || !e3.rasterInfo)
      throw new s2("imagery-tile", "no raster");
  }
  return e([y({ clonable: false })], V5.prototype, "_cachedRendererJson", void 0), e([y({ clonable: false })], V5.prototype, "_cachedRasterFunctionJson", void 0), e([y({ clonable: false })], V5.prototype, "_compatibleFullExtent", void 0), e([y({ clonable: false })], V5.prototype, "_isConstructedFromFunctionRaster", void 0), e([y({ clonable: false })], V5.prototype, "_rasterJobHandler", void 0), e([y()], V5.prototype, "bandIds", void 0), e([y({ json: { origins: { service: { read: { source: "copyrightText" } } } } })], V5.prototype, "copyright", void 0), e([y({ json: { read: false } })], V5.prototype, "fullExtent", null), e([y()], V5.prototype, "interpolation", void 0), e([y()], V5.prototype, "ioConfig", void 0), e([y({ type: [p3], json: { write: true } })], V5.prototype, "multidimensionalDefinition", null), e([y({ type: c4, json: { write: true } })], V5.prototype, "multidimensionalSubset", void 0), e([y()], V5.prototype, "raster", void 0), e([y({ type: N2, json: { name: "renderingRule", write: true } })], V5.prototype, "rasterFunction", null), e([y()], V5.prototype, "rasterInfo", void 0), e([y()], V5.prototype, "sourceJSON", void 0), e([y({ readOnly: true, type: f2, json: { read: false } })], V5.prototype, "spatialReference", void 0), e([y({ type: j2 })], V5.prototype, "tileInfo", void 0), e([y(d3)], V5.prototype, "url", null), e([y({ types: l3, json: { name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy() {
    var _a;
    const e3 = "raster-stretch" === ((_a = this.renderer) == null ? void 0 : _a.type) && "none" === this.renderer.stretchType && !this.renderer.useGamma;
    return { enabled: !this.loaded || "Raster" === this.raster.tileType || !e3 };
  } }, origins: { "web-scene": { types: d4, name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: (e3) => ({ enabled: e3 && "vector-field" !== e3.type && "flow" !== e3.type }) } } } } })], V5.prototype, "renderer", null), e([o("renderer")], V5.prototype, "readRenderer", null), e([y({ clonable: false })], V5.prototype, "symbolizer", void 0), V5 = e([c("esri.layers.ImageryTileMixin")], V5), V5;
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/DBFParser.js
function t3(e3) {
  const t5 = e3.fields, r5 = e3.records, n10 = t5.some((e4) => "oid" === e4.name.toLowerCase()) ? "OBJECTID" : "OID", i6 = [{ name: n10, type: "esriFieldTypeOID", alias: "OID" }].concat(t5.map((e4) => ({ name: e4.name, type: "esriFieldType" + e4.typeName, alias: e4.name }))), s5 = i6.map((e4) => e4.name), a7 = [];
  let o7 = 0, l5 = 0;
  return r5.forEach((e4) => {
    const t6 = {};
    for (t6[n10] = o7++, l5 = 1; l5 < s5.length; l5++)
      t6[s5[l5]] = e4[l5 - 1];
    a7.push({ attributes: t6 });
  }), { displayFieldName: "", fields: i6, features: a7 };
}
var r4 = class {
  static get supportedVersions() {
    return [5];
  }
  static parse(r5) {
    const n10 = new DataView(r5), i6 = 3 & n10.getUint8(0);
    if (3 !== i6)
      return { header: { version: i6 }, recordSet: null };
    const s5 = n10.getUint32(4, true), a7 = n10.getUint16(8, true), o7 = n10.getUint16(10, true), l5 = { version: i6, recordCount: s5, headerByteCount: a7, recordByteCount: o7 };
    let p6 = 32;
    const g5 = [], u8 = [];
    let d8;
    if (3 === i6) {
      for (; 13 !== n10.getUint8(p6); )
        d8 = String.fromCharCode(n10.getUint8(p6 + 11)).trim(), g5.push({ name: r(new Uint8Array(r5, p6, 11)), type: d8, typeName: ["String", "Date", "Double", "Boolean", "String", "Integer"][["C", "D", "F", "L", "M", "N"].indexOf(d8)], length: n10.getUint8(p6 + 16) }), p6 += 32;
      if (p6 += 1, g5.length > 0)
        for (; u8.length < s5 && r5.byteLength - p6 > o7; ) {
          const t5 = [];
          32 === n10.getUint8(p6) ? (p6 += 1, g5.forEach((n11) => {
            if ("C" === n11.type)
              t5.push(r(new Uint8Array(r5, p6, n11.length)).trim());
            else if ("N" === n11.type)
              t5.push(parseInt(String.fromCharCode.apply(null, new Uint8Array(r5, p6, n11.length)).trim(), 10));
            else if ("F" === n11.type)
              t5.push(parseFloat(String.fromCharCode.apply(null, new Uint8Array(r5, p6, n11.length)).trim()));
            else if ("D" === n11.type) {
              const e3 = String.fromCharCode.apply(null, new Uint8Array(r5, p6, n11.length)).trim();
              t5.push(new Date(parseInt(e3.substring(0, 4), 10), parseInt(e3.substring(4, 6), 10) - 1, parseInt(e3.substring(6, 8), 10)));
            }
            p6 += n11.length;
          }), u8.push(t5)) : p6 += o7;
        }
    }
    return { header: l5, fields: g5, records: u8, recordSet: t3({ fields: g5, records: u8 }) };
  }
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/CloudRaster.js
var g3 = /* @__PURE__ */ new Map();
g3.set("int16", "esriFieldTypeSmallInteger"), g3.set("int32", "esriFieldTypeInteger"), g3.set("int64", "esriFieldTypeInteger"), g3.set("float32", "esriFieldTypeSingle"), g3.set("float64", "esriFieldTypeDouble"), g3.set("text", "esriFieldTypeString");
var y5 = 8;
var x4 = class extends U4 {
  constructor() {
    super(...arguments), this.storageInfo = null, this.datasetFormat = "CRF";
  }
  async open(e3) {
    await this.init();
    const { data: r5 } = await this.request(this.url + "/conf.json", { signal: e3 == null ? void 0 : e3.signal });
    if (!this._validateHeader(r5))
      throw new s2("cloudraster:open", "Invalid or unsupported conf.json.");
    this.datasetName = this.url.slice(this.url.lastIndexOf("/") + 1);
    const { storageInfo: o7, rasterInfo: i6 } = this._parseHeader(r5);
    if ("thematic" === i6.dataType) {
      const e4 = await this._fetchAuxiliaryInformation();
      i6.attributeTable = e4;
    }
    this._set("storageInfo", o7), this._set("rasterInfo", i6), this.ioConfig.retryCount = this.ioConfig.retryCount || 0;
  }
  async fetchRawTile(e3, t5, r5, o7 = {}) {
    const { transposeInfo: i6 } = this.rasterInfo.storageInfo, { transposedVariableName: s5 } = o7, a7 = !(!i6 || !s5), n10 = a7 ? 0 : this.rasterInfo.storageInfo.maximumPyramidLevel - e3;
    if (n10 < 0)
      return null;
    const l5 = this._buildCacheFilePath(n10, t5, r5, o7.multidimensionalDefinition, s5), f7 = this._getIndexRecordFromBundle(t5, r5, a7), m8 = await this.request(l5, { range: { from: 0, to: this.storageInfo.headerSize - 1 }, responseType: "array-buffer", signal: o7.signal });
    if (!m8)
      return null;
    const c9 = new Uint8Array(m8.data), p6 = this._getTileEndAndContentType(c9, f7);
    if (0 === p6.recordSize)
      return null;
    const d8 = await this.request(l5, { range: { from: p6.position, to: p6.position + p6.recordSize }, responseType: "array-buffer", signal: o7.signal });
    if (!d8)
      return null;
    const [u8, h8] = this._getTileSize(a7);
    return this.decodePixelBlock(d8.data, { width: u8, height: h8, planes: null, pixelType: null, returnInterleaved: a7 });
  }
  _validateHeader(e3) {
    const t5 = ["origin", "extent", "geodataXform", "LODInfos", "blockWidth", "blockHeight", "bandCount", "pixelType", "pixelSizeX", "pixelSizeY", "format", "packetSize"];
    return e3 && "RasterInfo" === e3.type && !t5.some((t6) => !e3[t6]);
  }
  _parseHeader(e3) {
    var _a, _b, _c, _d, _e;
    const t5 = ["u1", "u2", "u4", "u8", "s8", "u16", "s16", "u32", "s32", "f32", "f64"][e3.pixelType], { bandCount: r5, colormap: o7, blockWidth: l5, blockHeight: f7, firstPyramidLevel: m8, maximumPyramidLevel: c9 } = e3, p6 = (_a = e3.statistics) == null ? void 0 : _a.map((e4) => ({ min: e4.min, max: e4.max, avg: e4.mean, stddev: e4.standardDeviation, median: e4.median, mode: e4.mode })), g5 = ((_d = (_c = (_b = e3.histograms) == null ? void 0 : _b[0]) == null ? void 0 : _c.counts) == null ? void 0 : _d.length) ? e3.histograms : null, x6 = e3.extent.spatialReference, S6 = (_e = e3.geodataXform) == null ? void 0 : _e.spatialReference, I4 = new f2((x6 == null ? void 0 : x6.wkid) || (x6 == null ? void 0 : x6.wkt) || (x6 == null ? void 0 : x6.wkt2) ? x6 : S6);
    let w3 = new M({ xmin: e3.extent.xmin, ymin: e3.extent.ymin, xmax: e3.extent.xmax, ymax: e3.extent.ymax, spatialReference: I4 });
    const _ = new x({ x: e3.pixelSizeX, y: e3.pixelSizeY, spatialReference: I4 }), v5 = Math.round((w3.xmax - w3.xmin) / _.x), b2 = Math.round((w3.ymax - w3.ymin) / _.y), z2 = this._parseTransform(e3.geodataXform), T5 = z2 ? w3 : null;
    z2 && (w3 = z2.forwardTransform(w3), _.x = (w3.xmax - w3.xmin) / v5, _.y = (w3.ymax - w3.ymin) / b2);
    const k4 = e3.properties ?? {}, j6 = e3.format.toLowerCase().replace("cache/", ""), C3 = new x(e3.origin.x, e3.origin.y, I4);
    let R4, F3, P3, H;
    if (o7 == null ? void 0 : o7.colors)
      for (R4 = [], F3 = 0; F3 < o7.colors.length; F3++)
        P3 = o7.colors[F3], H = o7.values ? o7.values[F3] : F3, R4.push([H, 255 & P3, P3 << 16 >>> 24, P3 << 8 >>> 24, P3 >>> 24]);
    const D4 = e3.LODInfos, L3 = [];
    for (F3 = 0; F3 < D4.levels.length; F3++)
      L3.push(new p({ level: D4.levels[F3], resolution: D4.resolutions[F3], scale: 96 / 0.0254 * D4.resolutions[F3] }));
    const M2 = new j2({ dpi: 96, lods: L3, format: j6, origin: C3, size: [l5, f7], spatialReference: I4 }), O = { recordSize: y5, packetSize: e3.packetSize, headerSize: e3.packetSize * e3.packetSize * y5 + 64 }, B4 = [{ maxCol: Math.ceil(v5 / l5) - 1, maxRow: Math.ceil(b2 / f7) - 1, minCol: 0, minRow: 0 }];
    let $ = 2;
    if (c9 > 0)
      for (F3 = 0; F3 < c9; F3++)
        B4.push({ maxCol: Math.ceil(v5 / $ / l5) - 1, maxRow: Math.ceil(b2 / $ / f7) - 1, minCol: 0, minRow: 0 }), $ *= 2;
    const N4 = e3.mdInfo;
    let q = null;
    if (N4 && k4._yxs) {
      const e4 = k4._yxs;
      q = { packetSize: e4.PacketSize, tileSize: [e4.TileXSize, e4.TileYSize] };
    }
    return { storageInfo: O, rasterInfo: new m3({ width: v5, height: b2, pixelType: t5, bandCount: r5, extent: w3, nativeExtent: T5, transform: z2, spatialReference: I4, pixelSize: _, keyProperties: k4, statistics: p6, histograms: g5, multidimensionalInfo: N4, colormap: R4, storageInfo: new n4({ blockWidth: l5, blockHeight: f7, pyramidBlockWidth: l5, pyramidBlockHeight: f7, origin: C3, tileInfo: M2, transposeInfo: q, firstPyramidLevel: m8, maximumPyramidLevel: c9, blockBoundary: B4 }) }) };
  }
  _parseTransform(e3) {
    var _a, _b;
    if (!f5(e3))
      throw new s2("cloudraster:open", "the data contains unsupported geodata transform types");
    const r5 = i2(e3);
    if ("identity" === r5.type)
      return null;
    if ("polynomial" !== r5.type || !((_a = r5.forwardCoefficients) == null ? void 0 : _a.length) || !((_b = r5.inverseCoefficients) == null ? void 0 : _b.length))
      throw new s2("cloudraster:open", "the data contains unsupported geodata transforms - both forward and inverse coefficients are required currently");
    return r5;
  }
  async _fetchAuxiliaryInformation(e3) {
    const t5 = this.request(this.url + "/conf.vat.json", { signal: e3 }).then((e4) => e4.data).catch(() => null), r5 = this.request(this.url + "/conf.vat.dbf", { responseType: "array-buffer", signal: e3 }).then((e4) => e4.data).catch(() => null), o7 = await Promise.all([t5, r5]);
    let i6;
    if (o7[0]) {
      let e4 = o7[0].fields;
      const t6 = o7[0].values;
      if (e4 && t6) {
        e4 = e4.map((e5) => ({ type: "OID" === e5.name ? "esriFieldTypeOID" : g3.get(e5.type), name: e5.name, alias: e5.alias || e5.name }));
        const r6 = t6.map((e5) => ({ attributes: e5 }));
        e4 && t6 && (i6 = { fields: e4, features: r6 });
      }
    }
    if (!i6 && o7[1]) {
      i6 = r4.parse(o7[1]).recordSet;
    }
    return d2.fromJSON(i6);
  }
  _buildCacheFilePath(e3, t5, r5, o7, i6) {
    const s5 = this._getPackageSize(!!i6), a7 = Math.floor(t5 / s5) * s5, n10 = Math.floor(r5 / s5) * s5, l5 = "R" + this._toHexString4(a7) + "C" + this._toHexString4(n10);
    let f7 = "L";
    f7 += e3 >= 10 ? e3.toString() : "0" + e3.toString();
    const { multidimensionalInfo: m8 } = this.rasterInfo, c9 = o7 == null ? void 0 : o7[0];
    if (null == m8 || !c9)
      return `${this.url}/_alllayers/${f7}/${l5}.bundle`;
    let p6 = "_yxs";
    if (!i6) {
      p6 = m8.variables.find((e5) => e5.name === c9.variableName).dimensions[0].values.indexOf(c9.values[0]).toString(16);
      const e4 = 4 - p6.length;
      for (let t6 = 0; t6 < e4; t6++)
        p6 = "0" + p6;
      p6 = "S" + p6;
    }
    const d8 = this._getVariableFolderName(i6 || c9.variableName);
    return `${this.url}/_alllayers/${d8}/${p6}/${f7}/${l5}.bundle`;
  }
  _getPackageSize(e3 = false) {
    const { transposeInfo: t5 } = this.rasterInfo.storageInfo;
    return e3 && null != t5 ? t5.packetSize ?? 0 : this.storageInfo.packetSize;
  }
  _getTileSize(e3 = false) {
    const { storageInfo: t5 } = this.rasterInfo, { transposeInfo: r5 } = t5;
    return e3 && null != r5 ? r5.tileSize : t5.tileInfo.size;
  }
  _getVariableFolderName(e3) {
    return "" === (e3 = e3.trim()) ? "_v" : e3.replaceAll(/[\{|\}\-]/g, "_").replace("\\*", "_v");
  }
  _getIndexRecordFromBundle(e3, t5, r5 = false) {
    const o7 = this._getPackageSize(r5), i6 = o7 * (e3 % o7) + t5 % o7;
    if (i6 < 0)
      throw new Error("Invalid level / row / col");
    return 20 + i6 * this.storageInfo.recordSize + 44;
  }
  _getTileEndAndContentType(e3, t5) {
    const r5 = e3.subarray(t5, t5 + 8);
    let o7, i6 = 0;
    for (o7 = 0; o7 < 5; o7++)
      i6 |= (255 & r5[o7]) << 8 * o7;
    const s5 = 1099511627775 & i6;
    for (i6 = 0, o7 = 5; o7 < 8; o7++)
      i6 |= (255 & r5[o7]) << 8 * (o7 - 5);
    return { position: s5, recordSize: 1099511627775 & i6 };
  }
  _toHexString4(e3) {
    let t5 = e3.toString(16);
    if (4 !== t5.length) {
      let e4 = 4 - t5.length;
      for (; e4-- > 0; )
        t5 = "0" + t5;
    }
    return t5;
  }
};
e([y({ readOnly: true })], x4.prototype, "storageInfo", void 0), e([y({ type: String, json: { write: true } })], x4.prototype, "datasetFormat", void 0), x4 = e([c("esri.layers.support.rasterDatasets.CloudRaster")], x4);
var S2 = x4;

// node_modules/@arcgis/core/layers/support/rasterDatasets/InMemoryRaster.js
var c6 = class extends U4 {
  constructor() {
    super(...arguments), this.datasetFormat = "MEMORY", this.data = null;
  }
  async open(t5) {
    await this.init();
    const e3 = this.data, { pixelBlock: s5, statistics: r5, histograms: i6, name: a7, keyProperties: n10, nativeExtent: m8, transform: c9 } = this.data, { width: h8, height: f7, pixelType: u8 } = s5, d8 = e3.extent ?? new M({ xmin: -0.5, ymin: 0.5, xmax: h8 - 0.5, ymax: f7 - 0.5, spatialReference: new f2({ wkid: 3857 }) }), y7 = e3.isPseudoSpatialReference ?? !e3.extent, x6 = { x: d8.width / h8, y: d8.height / f7 }, g5 = new m3({ width: h8, height: f7, pixelType: u8, extent: d8, nativeExtent: m8, transform: c9, pixelSize: x6, spatialReference: d8.spatialReference, bandCount: s5.pixels.length, keyProperties: n10 || {}, statistics: r5, isPseudoSpatialReference: y7, histograms: i6 });
    this.createRemoteDatasetStorageInfo(g5, 512, 512), this._set("rasterInfo", g5), this.updateTileInfo(), await this._buildInMemoryRaster(s5, { width: 512, height: 512 }, t5), this.datasetName = a7, this.url = "/InMemory/" + a7;
  }
  fetchRawTile(t5, e3, s5, r5 = {}) {
    const i6 = this._pixelBlockTiles.get(`${t5}/${e3}/${s5}`);
    return Promise.resolve(i6);
  }
  async _buildInMemoryRaster(t5, r5, i6) {
    var _a, _b;
    const o7 = this.rasterInfo.storageInfo.maximumPyramidLevel, a7 = this.rasterJobHandler ? this.rasterJobHandler.split({ pixelBlock: t5, tileSize: r5, maximumPyramidLevel: o7 }, i6) : Promise.resolve(W(t5, r5, o7)), l5 = null != this.rasterInfo.statistics, p6 = null != this.rasterInfo.histograms, c9 = l5 ? Promise.resolve({ statistics: null, histograms: null }) : this.rasterJobHandler ? this.rasterJobHandler.estimateStatisticsHistograms({ pixelBlock: t5 }, i6) : Promise.resolve(h(t5)), h8 = await v([a7, c9]);
    if (!h8[0].value && h8[1].value)
      throw new s2("inmemory-raster:open", "failed to build in memory raster");
    this._pixelBlockTiles = h8[0].value, l5 || (this.rasterInfo.statistics = (_a = h8[1].value) == null ? void 0 : _a.statistics), p6 || (this.rasterInfo.histograms = (_b = h8[1].value) == null ? void 0 : _b.histograms);
  }
};
e([y({ type: String, json: { write: true } })], c6.prototype, "datasetFormat", void 0), e([y()], c6.prototype, "data", void 0), c6 = e([c("esri.layers.support.rasterDatasets.InMemoryRaster")], c6);
var h6 = c6;

// node_modules/@arcgis/core/layers/support/rasterDatasets/xmlUtilities.js
function n8(e3, t5) {
  if (!e3 || !t5)
    return [];
  let l5 = t5;
  t5.includes("/") ? (l5 = t5.slice(0, t5.indexOf("/")), t5 = t5.slice(t5.indexOf("/") + 1)) : t5 = "";
  const r5 = [];
  if (t5) {
    const u9 = n8(e3, l5);
    for (let e4 = 0; e4 < u9.length; e4++) {
      n8(u9[e4], t5).forEach((n10) => r5.push(n10));
    }
    return r5;
  }
  const u8 = e3.getElementsByTagNameNS("*", l5);
  if (!u8 || 0 === u8.length)
    return [];
  for (let n10 = 0; n10 < u8.length; n10++)
    r5.push(u8[n10] || u8.item(n10));
  return r5;
}
function e2(t5, l5) {
  if (!t5 || !l5)
    return null;
  let r5 = l5;
  l5.includes("/") ? (r5 = l5.slice(0, l5.indexOf("/")), l5 = l5.slice(l5.indexOf("/") + 1)) : l5 = "";
  const u8 = n8(t5, r5);
  return u8.length > 0 ? l5 ? e2(u8[0], l5) : u8[0] : null;
}
function t4(n10, t5 = null) {
  const l5 = t5 ? e2(n10, t5) : n10;
  let r5;
  return l5 ? (r5 = l5.textContent || l5.nodeValue, r5 ? r5.trim() : null) : null;
}
function l4(e3, t5) {
  const l5 = n8(e3, t5), r5 = [];
  let u8;
  for (let n10 = 0; n10 < l5.length; n10++)
    u8 = l5[n10].textContent || l5[n10].nodeValue, u8 && (u8 = u8.trim(), "" !== u8 && r5.push(u8));
  return r5;
}
function u6(n10, e3) {
  return l4(n10, e3).map((n11) => Number(n11));
}
function o6(n10, e3) {
  const l5 = t4(n10, e3);
  return Number(l5);
}
function i5(n10, e3) {
  var _a;
  const t5 = (_a = n10 == null ? void 0 : n10.nodeName) == null ? void 0 : _a.toLowerCase(), l5 = e3.toLowerCase();
  return t5.slice(t5.lastIndexOf(":") + 1) === l5;
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/pamParser.js
function u7(e3, t5) {
  if (!e3 || !t5)
    return null;
  const n10 = [];
  for (let r5 = 0; r5 < e3.length; r5++)
    n10.push(e3[r5]), n10.push(t5[r5]);
  return n10;
}
function c7(e3) {
  const t5 = e2(e3, "GeodataXform"), n10 = d6(o6(t5, "SpatialReference/WKID") || t4(t5, "SpatialReference/WKT"));
  if ("typens:PolynomialXform" !== t5.getAttribute("xsi:type"))
    return { spatialReference: n10, transform: null };
  const s5 = o6(t5, "PolynomialOrder") ?? 1, f7 = u6(t5, "CoeffX/Double"), c9 = u6(t5, "CoeffY/Double"), m8 = u6(t5, "InverseCoeffX/Double"), p6 = u6(t5, "InverseCoeffY/Double"), S6 = u7(f7, c9), C3 = u7(m8, p6);
  return { spatialReference: n10, transform: S6 && C3 && S6.length && C3.length ? new y4({ spatialReference: n10, polynomialOrder: s5, forwardCoefficients: S6, inverseCoefficients: C3 }) : null };
}
function m7(e3) {
  var _a;
  const t5 = o6(e3, "NoDataValue"), n10 = e2(e3, "Histograms/HistItem"), l5 = o6(n10, "HistMin"), o7 = o6(n10, "HistMax"), f7 = o6(n10, "BucketCount"), u8 = (_a = t4(n10, "HistCounts")) == null ? void 0 : _a.split("|").map((e4) => Number(e4));
  let c9, m8, d8, p6;
  n8(e3, "Metadata/MDI").forEach((e4) => {
    const t6 = Number(e4.textContent ?? e4.nodeValue);
    switch (e4.getAttribute("key").toUpperCase()) {
      case "STATISTICS_MINIMUM":
        c9 = t6;
        break;
      case "STATISTICS_MAXIMUM":
        m8 = t6;
        break;
      case "STATISTICS_MEAN":
        d8 = t6;
        break;
      case "STATISTICS_STDDEV":
        p6 = t6;
    }
  });
  const S6 = o6(e3, "Metadata/SourceBandIndex");
  return { noDataValue: t5, histogram: (u8 == null ? void 0 : u8.length) && null != l5 && null != o7 ? { min: l5, max: o7, size: f7 || u8.length, counts: u8 } : null, sourceBandIndex: S6, statistics: null != c9 && null != m8 ? { min: c9, max: m8, avg: d8, stddev: p6 } : null };
}
function d6(e3) {
  if (!e3)
    return null;
  let n10 = Number(e3);
  if (!isNaN(n10) && 0 !== n10)
    return new f2({ wkid: n10 });
  if (e3 = String(e3).trim(), w(e3))
    return new f2({ wkt2: e3 });
  const r5 = e3.toUpperCase();
  if (r5.startsWith("COMPD_CS")) {
    if (!r5.includes("VERTCS") || !r5.includes("GEOGCS") && !r5.startsWith("PROJCS"))
      return null;
    const t5 = r5.indexOf("VERTCS"), s5 = r5.indexOf("PROJCS"), a7 = s5 > -1 ? s5 : r5.indexOf("GEOGCS");
    if (-1 === a7)
      return null;
    const i6 = e3.slice(a7, e3.lastIndexOf("]", t5) + 1).trim(), l5 = e3.slice(t5, e3.lastIndexOf("]")).trim();
    n10 = p5(i6);
    const o7 = new f2(n10 ? { wkid: n10 } : { wkt: i6 }), u8 = p5(l5);
    return u8 && (o7.vcsWkid = u8), o7;
  }
  return r5.startsWith("GEOGCS") || r5.startsWith("PROJCS") ? (n10 = p5(e3), new f2(0 !== n10 ? { wkid: n10 } : { wkt: e3 })) : null;
}
function p5(e3) {
  var _a;
  const t5 = e3.replaceAll("]", "[").replaceAll('"', "").split("[").map((e4) => e4.trim()).filter((e4) => "" !== e4), n10 = t5[t5.length - 1].split(","), r5 = (_a = n10[0]) == null ? void 0 : _a.toLowerCase();
  if (("epsg" === r5 || "esri" === r5) && e3.endsWith('"]]')) {
    const e4 = Number(n10[1]);
    if (!isNaN(e4) && 0 !== e4)
      return e4;
  }
  return 0;
}
function S3(t5) {
  var _a;
  if ("pamdataset" !== ((_a = t5 == null ? void 0 : t5.documentElement.tagName) == null ? void 0 : _a.toLowerCase()))
    return {};
  const a7 = { spatialReference: null, transform: null, metadata: {}, rasterBands: [], statistics: null, histograms: null };
  t5.documentElement.childNodes.forEach((e3) => {
    if (1 === e3.nodeType) {
      if (i5(e3, "SRS")) {
        if (!a7.spatialReference) {
          const t6 = t4(e3);
          a7.spatialReference = d6(t6);
        }
      } else if (i5(e3, "Metadata"))
        if ("xml:ESRI" === e3.getAttribute("domain")) {
          const { spatialReference: t6, transform: n10 } = c7(e3);
          a7.transform = n10, a7.spatialReference || (a7.spatialReference = t6);
        } else {
          n8(e3, "MDI").forEach((e4) => a7.metadata[e4.getAttribute("key")] = t4(e4));
        }
      else if (i5(e3, "PAMRasterBand")) {
        const t6 = m7(e3);
        null != t6.sourceBandIndex && null == a7.rasterBands[t6.sourceBandIndex] ? a7.rasterBands[t6.sourceBandIndex] = t6 : a7.rasterBands.push(t6);
      }
    }
  });
  const i6 = a7.rasterBands;
  if (i6.length) {
    const t6 = !!i6[0].statistics;
    a7.statistics = t6 ? i6.map((e3) => e3.statistics).filter(k) : null;
    const n10 = !!i6[0].histogram;
    a7.histograms = n10 ? i6.map((e3) => e3.histogram).filter(k) : null;
  }
  return a7;
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/ImageAuxRaster.js
var h7 = class extends U4 {
  async open(t5) {
    await this.init();
    const e3 = await this._fetchData(t5);
    let { spatialReference: s5, statistics: r5, histograms: a7, transform: o7 } = await this._fetchAuxiliaryData(t5);
    const i6 = !s5;
    i6 && (s5 = new f2({ wkid: 3857 })), (a7 == null ? void 0 : a7.length) && null == r5 && (r5 = g(a7));
    const { width: l5, height: m8 } = e3;
    let c9 = new M({ xmin: -0.5, ymin: 0.5 - m8, xmax: l5 - 0.5, ymax: 0.5, spatialReference: s5 });
    const h8 = o7 ? o7.forwardTransform(c9) : c9;
    let d8 = true;
    if (o7) {
      const t6 = o7.forwardCoefficients;
      d8 = t6 && 0 === t6[1] && 0 === t6[2], d8 && (o7 = null, c9 = h8);
    }
    const w3 = new h6({ data: { extent: h8, nativeExtent: c9, transform: o7, pixelBlock: e3, statistics: r5, histograms: a7, keyProperties: { DateType: "Processed" }, isPseudoSpatialReference: i6 } });
    await w3.open(), w3.data = null, this._set("rasterInfo", w3.rasterInfo), this._inMemoryRaster = w3;
  }
  fetchRawTile(t5, e3, s5, r5 = {}) {
    return this._inMemoryRaster.fetchRawTile(t5, e3, s5, r5);
  }
  async _fetchData(t5) {
    const { data: s5 } = await this.request(this.url, { responseType: "array-buffer", signal: t5 == null ? void 0 : t5.signal }), r5 = P(s5).toUpperCase();
    if ("JPG" !== r5 && "PNG" !== r5 && "GIF" !== r5 && "BMP" !== r5)
      throw new s2("image-aux-raster:open", "the data is not a supported format");
    this._set("datasetFormat", r5);
    const a7 = r5.toLowerCase(), o7 = "gif" === a7 || "bmp" === a7 || !has("ios"), i6 = await this.decodePixelBlock(s5, { format: a7, useCanvas: o7, hasNoZlibMask: true });
    if (null == i6)
      throw new s2("image-aux-raster:open", "the data cannot be decoded");
    return i6;
  }
  async _fetchAuxiliaryData(t5) {
    var _a;
    const e3 = t5 == null ? void 0 : t5.signal, a7 = this.ioConfig.skipExtensions ?? [], o7 = a7.includes("aux.xml") ? null : this.request(this.url + ".aux.xml", { responseType: "xml", signal: e3 }), i6 = this.datasetFormat, n10 = "JPG" === i6 ? "jgw" : "PNG" === i6 ? "pgw" : "BMP" === i6 ? "bpw" : null, m8 = n10 && a7.includes(n10) ? null : this.request(this.url.slice(0, this.url.lastIndexOf(".")) + "." + n10, { responseType: "text", signal: e3 }), p6 = await v([o7, m8]);
    if (e3 == null ? void 0 : e3.aborted)
      throw u();
    const f7 = S3((_a = p6[0].value) == null ? void 0 : _a.data);
    if (!f7.transform) {
      const t6 = p6[1].value ? p6[1].value.data.split("\n").slice(0, 6).map((t7) => Number(t7)) : null;
      f7.transform = 6 === (t6 == null ? void 0 : t6.length) ? new y4({ forwardCoefficients: [t6[4], t6[5], t6[0], -t6[1], t6[2], -t6[3]] }) : null;
    }
    return f7;
  }
};
e([y({ type: String, json: { write: true } })], h7.prototype, "datasetFormat", void 0), h7 = e([c("esri.layers.support.rasterDatasets.ImageAuxRaster")], h7);
var d7 = h7;

// node_modules/@arcgis/core/layers/support/rasterDatasets/ImageServerRaster.js
var g4 = class extends U4 {
  constructor() {
    super(...arguments), this._levelOffset = 0, this._tilemapCache = null, this._slices = null, this.datasetFormat = "RasterTileServer", this.tileType = null;
  }
  async open(e3) {
    var _a, _b;
    await this.init();
    const r5 = e3 == null ? void 0 : e3.signal, a7 = this.sourceJSON ? { data: this.sourceJSON } : await this.request(this.url, { query: { f: "json" }, signal: r5 });
    a7.ssl && (this.url = this.url.replace(/^http:/i, "https:"));
    const l5 = a7.data;
    if (this.sourceJSON = l5, !l5)
      throw new s2("imageserverraster:open", "cannot initialize tiled image service, missing service info");
    if (!l5.tileInfo)
      throw new s2("imageserverraster:open", "use ImageryLayer to open non-tiled image services");
    this._fixScaleInServiceInfo();
    const m8 = ["jpg", "jpeg", "png", "png8", "png24", "png32", "mixed"];
    this.tileType = l5.cacheType, null == this.tileType && (m8.includes(l5.tileInfo.format.toLowerCase()) ? this.tileType = "Map" : "lerc" === l5.tileInfo.format.toLowerCase() ? this.tileType = "Elevation" : this.tileType = "Raster"), this.datasetName = ((_a = l5.name) == null ? void 0 : _a.slice(l5.name.indexOf("/") + 1)) ?? "";
    const u8 = await this._fetchRasterInfo({ signal: r5 });
    if (null == u8)
      throw new s2("image-server-raster:open", "cannot initialize image service");
    p4(u8, l5);
    const h8 = "Map" === this.tileType ? v3(l5.tileInfo, l5) : j2.fromJSON(l5.tileInfo);
    n(h8);
    const [p6, d8] = this._computeMinMaxLOD(u8, h8), { extent: y7, pixelSize: x6 } = u8, g5 = 0.5 / u8.width * x6.x, S6 = Math.max(x6.x, x6.y), { lods: I4 } = h8;
    ("Map" !== this.tileType && 0 !== l5.maxScale || Math.abs(x6.x - x6.y) > g5 || !I4.some((e4) => Math.abs(e4.resolution - S6) < g5)) && (x6.x = x6.y = p6.resolution, u8.width = Math.ceil((y7.xmax - y7.xmin) / x6.x - 0.1), u8.height = Math.ceil((y7.ymax - y7.ymin) / x6.y - 0.1));
    const w3 = p6.level - d8.level, [j6, M2] = h8.size, b2 = [], T5 = [];
    I4.forEach((e4, t5) => {
      e4.level >= d8.level && e4.level <= p6.level && b2.push({ x: e4.resolution, y: e4.resolution }), t5 < I4.length - 1 && T5.push(Math.round(10 * e4.resolution / I4[t5 + 1].resolution) / 10);
    }), b2.sort((e4, t5) => e4.x - t5.x);
    const _ = this.computeBlockBoundary(y7, j6, M2, h8.origin, b2, w3), O = b2.length > 1 ? b2.slice(1) : null;
    let R4;
    l5.transposeInfo && (R4 = { tileSize: [l5.transposeInfo.rows, l5.transposeInfo.cols], packetSize: ((_b = u8.keyProperties) == null ? void 0 : _b._yxs.PacketSize) ?? 0 });
    const z2 = T5.length <= 1 || T5.length >= 3 && T5.slice(0, -1).every((e4) => e4 === T5[0]) ? T5[0] ?? 2 : Math.round(10 / (d8.resolution / p6.resolution) ** (-1 / w3)) / 10;
    if (u8.storageInfo = new n4({ blockWidth: h8.size[0], blockHeight: h8.size[1], pyramidBlockWidth: h8.size[0], pyramidBlockHeight: h8.size[1], pyramidResolutions: O, pyramidScalingFactor: z2, compression: h8.format, origin: h8.origin, firstPyramidLevel: 1, maximumPyramidLevel: w3, tileInfo: h8, transposeInfo: R4, blockBoundary: _ }), this._fixGCSShift(u8), this._set("rasterInfo", u8), l5.capabilities.toLowerCase().includes("tilemap")) {
      const e4 = { tileInfo: u8.storageInfo.tileInfo, parsedUrl: I(this.url), url: this.url, tileServers: [] };
      this._tilemapCache = new T4({ layer: e4 });
    }
  }
  async fetchRawTile(e3, t5, i6, s5 = {}) {
    const { storageInfo: r5, extent: a7 } = this.rasterInfo, { transposeInfo: l5 } = r5, o7 = null != l5 && !!s5.transposedVariableName;
    if (this._slices && !o7 && null == s5.sliceId)
      return null;
    const n10 = o7 ? 0 : r5.maximumPyramidLevel - e3 + this._levelOffset, c9 = `${this.url}/tile/${n10}/${t5}/${i6}`, m8 = this._slices ? o7 ? { variable: s5.transposedVariableName } : { sliceId: s5.sliceId || 0 } : null, { data: h8 } = await this.request(c9, { query: m8, responseType: "array-buffer", signal: s5.signal });
    if (!h8)
      return null;
    const f7 = o7 ? l5.tileSize : r5.tileInfo.size, p6 = await this.decodePixelBlock(h8, { width: f7[0], height: f7[1], planes: null, pixelType: null, isPoint: "Elevation" === this.tileType, returnInterleaved: o7, noDataValue: this.rasterInfo.noDataValue });
    if (null == p6)
      return null;
    const d8 = r5.blockBoundary[e3];
    if ("jpg" !== r5.compression || i6 > d8.minCol && i6 < d8.maxCol && t5 > d8.minRow && t5 < d8.maxRow)
      return p6;
    const { origin: y7, blockWidth: x6, blockHeight: g5 } = r5, { x: v5, y: S6 } = this.getPyramidPixelSize(e3), I4 = Math.round((a7.xmin - y7.x) / v5) % x6, w3 = Math.round((a7.xmax - y7.x) / v5) % x6 || x6, j6 = Math.round((y7.y - a7.ymax) / S6) % g5, M2 = Math.round((y7.y - a7.ymin) / S6) % g5 || g5, b2 = i6 === d8.minCol ? I4 : 0, T5 = t5 === d8.minRow ? j6 : 0, _ = i6 === d8.maxCol ? w3 : x6, O = t5 === d8.maxRow ? M2 : g5;
    return T2(p6, { x: b2, y: T5 }, { width: _ - b2, height: O - T5 }), p6;
  }
  getSliceIndex(e3) {
    if (!this._slices || null == e3 || 0 === e3.length)
      return null;
    const t5 = e3;
    for (let i6 = 0; i6 < this._slices.length; i6++) {
      const e4 = this._slices[i6].multidimensionalDefinition;
      if (e4.length === t5.length && !e4.some((e5) => {
        const i7 = t5.find((t6) => e5.variableName === t6.variableName && t6.dimensionName === e5.dimensionName);
        if (!i7)
          return true;
        return (Array.isArray(e5.values[0]) ? `${e5.values[0][0]}-${e5.values[0][1]}` : e5.values[0]) !== (Array.isArray(i7.values[0]) ? `${i7.values[0][0]}-${i7.values[0][1]}` : i7.values[0]);
      }))
        return i6;
    }
    return null;
  }
  async fetchVariableStatisticsHistograms(e3, t5) {
    var _a, _b, _c;
    const i6 = this.request(this.url + "/statistics", { query: { variable: e3, f: "json" }, signal: t5 }).then((e4) => {
      var _a2;
      return (_a2 = e4.data) == null ? void 0 : _a2.statistics;
    }), s5 = this.request(this.url + "/histograms", { query: { variable: e3, f: "json" }, signal: t5 }).then((e4) => {
      var _a2;
      return (_a2 = e4.data) == null ? void 0 : _a2.histograms;
    }), r5 = await Promise.all([i6, s5]);
    return r5[0] && r5[0].forEach((e4) => {
      e4.avg = e4.mean, e4.stddev = e4.standardDeviation;
    }), ((_c = (_b = (_a = r5[1]) == null ? void 0 : _a[0]) == null ? void 0 : _b.counts) == null ? void 0 : _c.length) || (r5[1] = null), { statistics: r5[0] || null, histograms: r5[1] || null };
  }
  async computeBestPyramidLevelForLocation(e3, t5 = {}) {
    if (!this._tilemapCache)
      return 0;
    let i6 = this.identifyPixelLocation(e3, 0, t5.datumTransformation);
    if (null === i6)
      return null;
    let s5 = 0;
    const { maximumPyramidLevel: r5 } = this.rasterInfo.storageInfo;
    let a7 = r5 - s5 + this._levelOffset;
    const l5 = i6.srcLocation;
    for (; a7 >= 0; ) {
      try {
        if ("available" === await this._tilemapCache.fetchAvailability(a7, i6.row, i6.col, t5))
          break;
      } catch {
      }
      if (a7--, s5++, i6 = this.identifyPixelLocation(l5, s5, t5.datumTransformation), null === i6)
        return null;
    }
    return -1 === a7 || null == i6 ? null : s5;
  }
  async _fetchRasterInfo(e3) {
    const t5 = this.sourceJSON;
    if ("Map" === this.tileType) {
      const e4 = t5.fullExtent || t5.extent, i7 = Math.ceil((e4.xmax - e4.xmin) / t5.pixelSizeX - 0.1), s6 = Math.ceil((e4.ymax - e4.ymin) / t5.pixelSizeY - 0.1), r6 = f2.fromJSON(t5.spatialReference || e4.spatialReference), a8 = new x({ x: t5.pixelSizeX, y: t5.pixelSizeY, spatialReference: r6 });
      return new m3({ width: i7, height: s6, bandCount: 3, extent: M.fromJSON(e4), spatialReference: r6, pixelSize: a8, pixelType: "u8", statistics: null, keyProperties: { DataType: "processed" } });
    }
    const { signal: i6 } = e3, s5 = m5(this.url, this.sourceJSON, { signal: i6, query: this.ioConfig.customFetchParameters }), r5 = t5.hasMultidimensions ? this.request(`${this.url}/slices`, { query: { f: "json" }, signal: i6 }).then((e4) => {
      var _a;
      return (_a = e4.data) == null ? void 0 : _a.slices;
    }).catch(() => null) : null, a7 = await Promise.all([s5, r5]);
    return this._slices = a7[1], a7[0];
  }
  _fixScaleInServiceInfo() {
    const { sourceJSON: e3 } = this;
    e3.minScale && e3.minScale < 0 && (e3.minScale = 0), e3.maxScale && e3.maxScale < 0 && (e3.maxScale = 0);
  }
  _fixGCSShift(e3) {
    const { extent: t5, spatialReference: i6 } = e3;
    t5.xmin > -1 && t5.xmax > 181 && (i6 == null ? void 0 : i6.wkid) && i6.isGeographic && (e3.nativeExtent = e3.extent, e3.transform = new n5(), e3.extent = e3.transform.forwardTransform(t5));
  }
  _computeMinMaxLOD(e3, t5) {
    const { pixelSize: i6 } = e3, s5 = 0.5 / e3.width * i6.x, { lods: r5 } = t5, a7 = t5.lodAt(Math.max.apply(null, r5.map((e4) => e4.level))), l5 = t5.lodAt(Math.min.apply(null, r5.map((e4) => e4.level))), { tileType: o7 } = this;
    if ("Map" === o7)
      return this._levelOffset = r5[0].level, [a7, l5];
    if ("Raster" === o7) {
      return [r5.find((e4) => e4.resolution === i6.x) ?? a7, l5];
    }
    const { minScale: n10, maxScale: c9 } = this.sourceJSON;
    let m8 = a7;
    c9 > 0 && (m8 = r5.find((e4) => Math.abs(e4.scale - c9) < s5), m8 || (m8 = r5.filter((e4) => e4.scale > c9).sort((e4, t6) => e4.scale > t6.scale ? 1 : -1)[0] ?? a7));
    let u8 = l5;
    return n10 > 0 && (u8 = r5.find((e4) => Math.abs(e4.scale - n10) < s5) ?? l5, this._levelOffset = u8.level - l5.level), [m8, u8];
  }
};
function v3(e3, t5) {
  if (!e3)
    return null;
  const { minScale: i6, maxScale: s5, minLOD: r5, maxLOD: a7 } = t5;
  if (null != r5 && null != a7)
    return j2.fromJSON({ ...e3, lods: e3.lods.filter(({ level: e4 }) => null != e4 && e4 >= r5 && e4 <= a7) });
  if (0 !== i6 && 0 !== s5) {
    const t6 = (e4) => Math.round(1e4 * e4) / 1e4, r6 = i6 ? t6(i6) : 1 / 0, a8 = s5 ? t6(s5) : -1 / 0;
    return j2.fromJSON({ ...e3, lods: e3.lods.filter((e4) => {
      const i7 = t6(e4.scale);
      return i7 <= r6 && i7 >= a8;
    }) });
  }
  return j2.fromJSON(e3);
}
e([y({ type: String, json: { write: true } })], g4.prototype, "datasetFormat", void 0), e([y()], g4.prototype, "tileType", void 0), g4 = e([c("esri.layers.support.rasterDatasets.ImageServerRaster")], g4);
var S4 = g4;

// node_modules/@arcgis/core/layers/support/rasterDatasets/MRFRaster.js
var y6 = /* @__PURE__ */ new Map();
y6.set("Int8", "s8"), y6.set("UInt8", "u8"), y6.set("Int16", "s16"), y6.set("UInt16", "u16"), y6.set("Int32", "s32"), y6.set("UInt32", "u32"), y6.set("Float32", "f32"), y6.set("Float64", "f32"), y6.set("Double64", "f32");
var x5 = /* @__PURE__ */ new Map();
x5.set("none", { blobExtension: ".til", isOneSegment: true, decoderFormat: "bip" }), x5.set("lerc", { blobExtension: ".lrc", isOneSegment: false, decoderFormat: "lerc" }), x5.set("deflate", { blobExtension: ".pzp", isOneSegment: true, decoderFormat: "deflate" }), x5.set("jpeg", { blobExtension: ".pjg", isOneSegment: true, decoderFormat: "jpg" });
var w2 = class extends U4 {
  constructor() {
    super(...arguments), this._files = null, this._storageIndex = null, this.datasetFormat = "MRF";
  }
  async open(t5) {
    var _a;
    await this.init(), this.datasetName = this.url.slice(this.url.lastIndexOf("/") + 1);
    const e3 = t5 ? t5.signal : null, r5 = await this.request(this.url, { responseType: "xml", signal: e3 }), { rasterInfo: s5, files: o7 } = this._parseHeader(r5.data);
    if (-1 === ((_a = this.ioConfig.skipExtensions) == null ? void 0 : _a.indexOf("aux.xml"))) {
      const e4 = await this._fetchAuxiliaryData(t5);
      null != e4 && (s5.statistics = e4.statistics ?? s5.statistics, s5.histograms = e4.histograms, e4.histograms && null == s5.statistics && (s5.statistics = g(e4.histograms)));
    }
    this._set("rasterInfo", s5), this._files = o7;
    const i6 = await this.request(o7.index, { responseType: "array-buffer", signal: e3 });
    this._storageIndex = this._parseIndex(i6.data);
    const { blockWidth: a7, blockHeight: n10 } = this.rasterInfo.storageInfo, l5 = this.rasterInfo.storageInfo.pyramidScalingFactor, { width: f7, height: c9 } = this.rasterInfo, p6 = [], m8 = this._getBandSegmentCount();
    let u8 = 0, g5 = -1;
    for (; u8 < this._storageIndex.length; ) {
      g5++;
      const t6 = Math.ceil(f7 / a7 / l5 ** g5) - 1, e4 = Math.ceil(c9 / n10 / l5 ** g5) - 1;
      u8 += (t6 + 1) * (e4 + 1) * m8 * 4, p6.push({ maxRow: e4, maxCol: t6, minCol: 0, minRow: 0 });
    }
    this.rasterInfo.storageInfo.blockBoundary = p6, g5 > 0 && (this.rasterInfo.storageInfo.firstPyramidLevel = 1, this.rasterInfo.storageInfo.maximumPyramidLevel = g5), this.updateTileInfo();
  }
  async fetchRawTile(t5, e3, r5, s5 = {}) {
    const { blockWidth: i6, blockHeight: a7, blockBoundary: n10 } = this.rasterInfo.storageInfo, l5 = n10[t5];
    if (!l5 || l5.maxRow < e3 || l5.maxCol < r5 || l5.minRow > e3 || l5.minCol > r5)
      return null;
    const { bandCount: f7, pixelType: c9 } = this.rasterInfo, { ranges: p6, actualTileWidth: m8, actualTileHeight: h8 } = this._getTileLocation(t5, e3, r5);
    if (!p6 || 0 === p6.length)
      return null;
    if (0 === p6[0].from && 0 === p6[0].to) {
      const t6 = new Uint8Array(i6 * a7);
      return new u3({ width: i6, height: a7, pixels: null, mask: t6, validPixelCount: 0 });
    }
    const { bandIds: u8 } = this.ioConfig, g5 = this._getBandSegmentCount(), d8 = [];
    let y7 = 0;
    for (y7 = 0; y7 < g5; y7++)
      u8 && !u8.includes(y7) || d8.push(this.request(this._files.data, { range: { from: p6[y7].from, to: p6[y7].to }, responseType: "array-buffer", signal: s5.signal }));
    const w3 = await Promise.all(d8), I4 = w3.map((t6) => t6.data.byteLength).reduce((t6, e4) => t6 + e4), b2 = new Uint8Array(I4);
    let A3 = 0;
    for (y7 = 0; y7 < g5; y7++)
      b2.set(new Uint8Array(w3[y7].data), A3), A3 += w3[y7].data.byteLength;
    const F3 = x5.get(this.rasterInfo.storageInfo.compression).decoderFormat, _ = await this.decodePixelBlock(b2.buffer, { width: i6, height: a7, format: F3, planes: (u8 == null ? void 0 : u8.length) || f7, pixelType: c9 });
    if (null == _)
      return null;
    let { noDataValue: R4 } = this.rasterInfo;
    if (null != R4 && "lerc" !== F3 && !_.mask && (R4 = R4[0], null != R4)) {
      const t6 = _.width * _.height, e4 = new Uint8Array(t6);
      if (Math.abs(R4) > 1e24)
        for (y7 = 0; y7 < t6; y7++)
          Math.abs((_.pixels[0][y7] - R4) / R4) > 1e-6 && (e4[y7] = 1);
      else
        for (y7 = 0; y7 < t6; y7++)
          _.pixels[0][y7] !== R4 && (e4[y7] = 1);
      _.mask = e4;
    }
    let S6 = 0, j6 = 0;
    if (m8 !== i6 || h8 !== a7) {
      let t6 = _.mask;
      if (t6)
        for (y7 = 0; y7 < a7; y7++)
          if (j6 = y7 * i6, y7 < h8)
            for (S6 = m8; S6 < i6; S6++)
              t6[j6 + S6] = 0;
          else
            for (S6 = 0; S6 < i6; S6++)
              t6[j6 + S6] = 0;
      else
        for (t6 = new Uint8Array(i6 * a7), _.mask = t6, y7 = 0; y7 < h8; y7++)
          for (j6 = y7 * i6, S6 = 0; S6 < m8; S6++)
            t6[j6 + S6] = 1;
    }
    return _;
  }
  _parseIndex(t5) {
    if (t5.byteLength % 16 > 0)
      throw new Error("invalid array buffer must be multiples of 16");
    let e3, r5, s5, o7, i6, a7;
    if (r2) {
      for (r5 = new Uint8Array(t5), o7 = new ArrayBuffer(t5.byteLength), s5 = new Uint8Array(o7), i6 = 0; i6 < t5.byteLength / 4; i6++)
        for (a7 = 0; a7 < 4; a7++)
          s5[4 * i6 + a7] = r5[4 * i6 + 3 - a7];
      e3 = new Uint32Array(o7);
    } else
      e3 = new Uint32Array(t5);
    return e3;
  }
  _getBandSegmentCount() {
    return x5.get(this.rasterInfo.storageInfo.compression).isOneSegment ? 1 : this.rasterInfo.bandCount;
  }
  _getTileLocation(t5, e3, r5) {
    const { blockWidth: s5, blockHeight: o7, pyramidScalingFactor: i6 } = this.rasterInfo.storageInfo, { width: a7, height: n10 } = this.rasterInfo, l5 = this._getBandSegmentCount();
    let f7, c9, p6, m8 = 0, h8 = 0;
    for (p6 = 0; p6 < t5; p6++)
      h8 = i6 ** p6, f7 = Math.ceil(a7 / s5 / h8), c9 = Math.ceil(n10 / o7 / h8), m8 += f7 * c9;
    h8 = i6 ** t5, f7 = Math.ceil(a7 / s5 / h8), c9 = Math.ceil(n10 / o7 / h8), m8 += e3 * f7 + r5, m8 *= 4 * l5;
    const u8 = this._storageIndex.subarray(m8, m8 + 4 * l5);
    let g5 = 0, d8 = 0;
    const y7 = [];
    for (let x6 = 0; x6 < l5; x6++)
      g5 = u8[4 * x6] * 2 ** 32 + u8[4 * x6 + 1], d8 = g5 + u8[4 * x6 + 2] * 2 ** 32 + u8[4 * x6 + 3], y7.push({ from: g5, to: d8 });
    return { ranges: y7, actualTileWidth: r5 < f7 - 1 ? s5 : Math.ceil(a7 / h8) - s5 * (f7 - 1), actualTileHeight: e3 < c9 - 1 ? o7 : Math.ceil(n10 / h8) - o7 * (c9 - 1) };
  }
  _parseHeader(t5) {
    const r5 = e2(t5, "MRF_META/Raster");
    if (!r5)
      throw new s2("mrf:open", "not a valid MRF format");
    const s5 = e2(r5, "Size"), o7 = parseInt(s5.getAttribute("x"), 10), n10 = parseInt(s5.getAttribute("y"), 10), f7 = parseInt(s5.getAttribute("c"), 10), m8 = (t4(r5, "Compression") || "none").toLowerCase();
    if (!x5.has(m8))
      throw new s2("mrf:open", "currently does not support compression " + m8);
    const h8 = t4(r5, "DataType") || "UInt8", w3 = y6.get(h8);
    if (null == w3)
      throw new s2("mrf:open", "currently does not support pixel type " + h8);
    const I4 = e2(r5, "PageSize"), b2 = parseInt(I4.getAttribute("x"), 10), A3 = parseInt(I4.getAttribute("y"), 10), F3 = e2(r5, "DataValues");
    let _, R4;
    F3 && (R4 = F3.getAttribute("NoData"), null != R4 && (_ = R4.trim().split(" ").map((t6) => parseFloat(t6))));
    if (e2(t5, "MRF_META/CachedSource"))
      throw new s2("mrf:open", "currently does not support MRF referencing other data files");
    const S6 = e2(t5, "MRF_META/GeoTags"), j6 = e2(S6, "BoundingBox");
    let k4, M2 = false;
    if (null != j6) {
      const t6 = parseFloat(j6.getAttribute("minx")), e3 = parseFloat(j6.getAttribute("miny")), r6 = parseFloat(j6.getAttribute("maxx")), s6 = parseFloat(j6.getAttribute("maxy")), o8 = t4(S6, "Projection") || "";
      let i6 = f2.WGS84;
      if ("LOCAL_CS[]" !== o8)
        if (o8.toLowerCase().startsWith("epsg:")) {
          const t7 = Number(o8.slice(5));
          isNaN(t7) || 0 === t7 || (i6 = new f2({ wkid: t7 }));
        } else
          i6 = d6(o8) ?? f2.WGS84;
      else
        M2 = true, i6 = new f2({ wkid: 3857 });
      k4 = new M(t6, e3, r6, s6), k4.spatialReference = i6;
    } else
      M2 = true, k4 = new M({ xmin: -0.5, ymin: 0.5 - n10, xmax: o7 - 0.5, ymax: 0.5, spatialReference: new f2({ wkid: 3857 }) });
    const T5 = e2(t5, "MRF_META/Rsets"), C3 = parseInt((T5 == null ? void 0 : T5.getAttribute("scale")) || "2", 10), U5 = k4.spatialReference, B4 = new n4({ origin: new x({ x: k4.xmin, y: k4.ymax, spatialReference: U5 }), blockWidth: b2, blockHeight: A3, pyramidBlockWidth: b2, pyramidBlockHeight: A3, compression: m8, pyramidScalingFactor: C3 }), E3 = new x({ x: k4.width / o7, y: k4.height / n10, spatialReference: U5 }), L3 = new m3({ width: o7, height: n10, extent: k4, isPseudoSpatialReference: M2, spatialReference: U5, bandCount: f7, pixelType: w3, pixelSize: E3, noDataValue: _, storageInfo: B4 }), P3 = t4(t5, "datafile"), W2 = t4(t5, "IndexFile");
    return { rasterInfo: L3, files: { mrf: this.url, index: W2 || this.url.replace(".mrf", ".idx"), data: P3 || this.url.replace(".mrf", x5.get(m8).blobExtension) } };
  }
  async _fetchAuxiliaryData(t5) {
    try {
      const { data: e3 } = await this.request(this.url + ".aux.xml", { responseType: "xml", signal: t5 == null ? void 0 : t5.signal });
      return S3(e3);
    } catch {
      return null;
    }
  }
};
e([y()], w2.prototype, "_files", void 0), e([y()], w2.prototype, "_storageIndex", void 0), e([y({ type: String, json: { write: true } })], w2.prototype, "datasetFormat", void 0), w2 = e([c("esri.layers.support.rasterIO.MRFRaster")], w2);
var I3 = w2;

// node_modules/@arcgis/core/layers/support/rasterDatasets/TIFFRaster.js
var S5 = (e3, t5) => {
  var _a;
  return (_a = e3.get(t5)) == null ? void 0 : _a.values;
};
var F2 = (e3, t5) => {
  var _a, _b;
  return (_b = (_a = e3.get(t5)) == null ? void 0 : _a.values) == null ? void 0 : _b[0];
};
var P2 = class extends U4 {
  constructor() {
    super(...arguments), this._files = null, this._headerInfo = null, this._bufferSize = 1048576, this.datasetFormat = "TIFF";
  }
  async open(e3) {
    var _a, _b, _c, _d;
    await this.init();
    const t5 = e3 ? e3.signal : null, { data: s5 } = await this.request(this.url, { range: { from: 0, to: this._bufferSize }, responseType: "array-buffer", signal: t5 });
    if (!s5)
      throw new s2("tiffraster:open", "failed to open url " + this.url);
    this.datasetName = this.url.slice(this.url.lastIndexOf("/") + 1, this.url.lastIndexOf("."));
    const { littleEndian: a7, firstIFDPos: n10, isBigTiff: o7 } = F(s5), f7 = [];
    await this._readIFDs(f7, s5, a7, n10, 0, o7 ? 8 : 4, t5);
    const { imageInfo: l5, rasterInfo: u8 } = this._parseIFDs(f7), p6 = U(f7), d8 = N(f7);
    if (this._headerInfo = { littleEndian: a7, isBigTiff: o7, ifds: f7, pyramidIFDs: p6, maskIFDs: d8, ...l5 }, this._set("rasterInfo", u8), !l5.isSupported)
      throw new s2("tiffraster:open", "this tiff is not supported: " + l5.message);
    if (!l5.tileWidth)
      throw new s2("tiffraster:open", "none-tiled tiff is not optimized for access, convert to COG and retry.");
    u8.isPseudoSpatialReference && s.getLogger(this).warn("The spatial reference for this tiff is unsupported. Only EPSG spatial reference codes and Esri WKTs are supported.");
    const y7 = (_b = (_a = f7[0].get("PREDICTOR")) == null ? void 0 : _a.values) == null ? void 0 : _b[0], g5 = (_d = (_c = f7[0].get("SAMPLEFORMAT")) == null ? void 0 : _c.values) == null ? void 0 : _d[0];
    if (3 === g5 && 2 === y7)
      throw new s2("tiffraster:open", "unsupported horizontal difference encoding. Predictor=3 is supported for floatting point data");
    const { skipExtensions: T5 = [] } = this.ioConfig;
    if (!T5.includes("aux.xml")) {
      const t6 = await this._fetchAuxiliaryMetaData(e3);
      null != t6 && this._processPAMInfo(t6, u8);
    }
    T5.includes("vat.dbf") || 1 !== u8.bandCount || "u8" !== u8.pixelType || (u8.attributeTable = await this._fetchAuxiliaryTable(e3), null != u8.attributeTable && (u8.keyProperties.DataType = "thematic")), this.updateTileInfo();
  }
  async fetchRawTile(e3, t5, r5, i6 = {}) {
    var _a;
    if (!((_a = this._headerInfo) == null ? void 0 : _a.isSupported) || this.isBlockOutside(e3, t5, r5))
      return null;
    const s5 = await this._fetchRawTiffTile(e3, t5, r5, false, i6);
    if (null != s5 && this._headerInfo.hasMaskBand) {
      const a7 = await this._fetchRawTiffTile(e3, t5, r5, true, i6);
      null != a7 && a7.pixels[0] instanceof Uint8Array && (s5.mask = a7.pixels[0]);
    }
    return s5;
  }
  _parseIFDs(e3) {
    var _a, _b;
    const t5 = R(e3), { width: r5, height: i6, tileWidth: s5, tileHeight: a7, planes: f7, pixelType: l5, compression: p6, firstPyramidLevel: c9, maximumPyramidLevel: h8, pyramidBlockWidth: m8, pyramidBlockHeight: y7, tileBoundary: g5, affine: T5, metadata: x6 } = t5, I4 = ((_a = t5.extent.spatialReference) == null ? void 0 : _a.wkt) || ((_b = t5.extent.spatialReference) == null ? void 0 : _b.wkid);
    let R4 = d6(I4), P3 = !!t5.isPseudoGeographic;
    null == R4 && (P3 = true, R4 = new f2({ wkid: 3857 }));
    const v5 = new M({ ...t5.extent, spatialReference: R4 }), D4 = new x(v5 ? { x: v5.xmin, y: v5.ymax, spatialReference: R4 } : { x: 0, y: 0 }), k4 = new n4({ blockWidth: s5, blockHeight: a7, pyramidBlockWidth: m8, pyramidBlockHeight: y7, compression: p6, origin: D4, firstPyramidLevel: c9, maximumPyramidLevel: h8, blockBoundary: g5 }), O = new x({ x: (v5.xmax - v5.xmin) / r5, y: (v5.ymax - v5.ymin) / i6, spatialReference: R4 }), j6 = x6 ? { BandProperties: x6.bandProperties, DataType: x6.dataType } : {};
    let L3 = null;
    const B4 = F2(e3[0], "PHOTOMETRICINTERPRETATION"), z2 = S5(e3[0], "COLORMAP");
    if (B4 <= 3 && (z2 == null ? void 0 : z2.length) > 3 && z2.length % 3 == 0) {
      L3 = [];
      const e4 = z2.length / 3;
      for (let t6 = 0; t6 < e4; t6++)
        L3.push([t6, z2[t6] >>> 8, z2[t6 + e4] >>> 8, z2[t6 + 2 * e4] >>> 8]);
    }
    const A3 = new m3({ width: r5, height: i6, bandCount: f7, pixelType: l5, pixelSize: O, storageInfo: k4, spatialReference: R4, isPseudoSpatialReference: P3, keyProperties: j6, extent: v5, colormap: L3, statistics: x6 ? x6.statistics : null });
    return (T5 == null ? void 0 : T5.length) && (A3.nativeExtent = new M({ xmin: -0.5, ymin: 0.5 - i6, xmax: r5 - 0.5, ymax: 0.5, spatialReference: R4 }), A3.transform = new y4({ polynomialOrder: 1, forwardCoefficients: [T5[2] + T5[0] / 2, T5[5] - T5[3] / 2, T5[0], T5[3], -T5[1], -T5[4]] }), A3.extent = A3.transform.forwardTransform(A3.nativeExtent), A3.pixelSize = new x({ x: (v5.xmax - v5.xmin) / r5, y: (v5.ymax - v5.ymin) / i6, spatialReference: R4 }), k4.origin.x = -0.5, k4.origin.y = 0.5), { imageInfo: t5, rasterInfo: A3 };
  }
  _processPAMInfo(e3, t5) {
    if (t5.statistics = e3.statistics ?? t5.statistics, t5.histograms = e3.histograms, e3.histograms && null == t5.statistics && (t5.statistics = g(e3.histograms)), e3.transform && null == t5.transform) {
      t5.transform = e3.transform, t5.nativeExtent = t5.extent;
      const r5 = t5.transform.forwardTransform(t5.nativeExtent);
      t5.pixelSize = new x({ x: (r5.xmax - r5.xmin) / t5.width, y: (r5.ymax - r5.ymin) / t5.height, spatialReference: t5.spatialReference }), t5.extent = r5;
    }
    t5.isPseudoSpatialReference && e3.spatialReference && (t5.spatialReference = e3.spatialReference, t5.extent.spatialReference = t5.nativeExtent.spatialReference = t5.storageInfo.origin.spatialReference = t5.spatialReference);
  }
  async _readIFDs(e3, t5, r5, i6, s5, a7 = 4, n10) {
    if (!i6)
      return null;
    if (i6 >= t5.byteLength || i6 < 0) {
      t5 = (await this.request(this.url, { range: { from: i6 + s5, to: i6 + s5 + this._bufferSize }, responseType: "array-buffer", signal: n10 })).data, s5 = i6 + s5, i6 = 0;
    }
    const o7 = await this._readIFD(t5, r5, i6, s5, n3.tiffTags, a7, n10);
    if (e3.push(o7.ifd), !o7.nextIFD)
      return null;
    await this._readIFDs(e3, t5, r5, o7.nextIFD - s5, s5, a7, n10);
  }
  async _readIFD(e3, r5, i6, s5, a7 = n3.tiffTags, n10 = 4, o7) {
    var _a, _b;
    if (!e3)
      return null;
    const f7 = B(e3, r5, i6, s5, a7, n10);
    if (f7.success) {
      const i7 = [];
      if ((_a = f7.ifd) == null ? void 0 : _a.forEach((e4) => {
        e4.values || i7.push(e4);
      }), i7.length > 0) {
        const a8 = i7.map((e4) => e4.offlineOffsetSize).filter(k), n11 = Math.min.apply(null, a8.map((e4) => e4[0]));
        if (Math.min.apply(null, a8.map((e4) => e4[0] + e4[1])) - n11 <= this._bufferSize) {
          const { data: t5 } = await this.request(this.url, { range: { from: n11, to: n11 + this._bufferSize }, responseType: "array-buffer", signal: o7 });
          e3 = t5, s5 = n11, i7.forEach((t6) => L(e3, r5, t6, s5));
        }
      }
      if ((_b = f7.ifd) == null ? void 0 : _b.has("GEOKEYDIRECTORY")) {
        const t5 = f7.ifd.get("GEOKEYDIRECTORY"), i8 = t5 == null ? void 0 : t5.values;
        if (i8 && i8.length > 4) {
          const a8 = i8[0] + "." + i8[1] + "." + i8[2], n11 = await this._readIFD(e3, r5, t5.valueOffset + 6 - s5, s5, n3.geoKeys, 2, o7);
          t5.data = n11.ifd, t5.data && t5.data.set("GEOTIFFVersion", { id: 0, type: 2, valueCount: 1, valueOffset: null, values: [a8] });
        }
      }
      return f7;
    }
    if (f7.requiredBufferSize && f7.requiredBufferSize !== e3.byteLength) {
      const t5 = await this.request(this.url, { range: { from: s5, to: s5 + f7.requiredBufferSize + 4 }, responseType: "array-buffer", signal: o7 });
      return (e3 = t5.data).byteLength < f7.requiredBufferSize ? null : this._readIFD(e3, r5, 0, s5, n3.tiffTags, 4, o7);
    }
  }
  async _fetchRawTiffTile(e3, t5, r5, i6, s5 = {}) {
    const a7 = this._getTileLocation(e3, t5, r5, i6);
    if (!a7)
      return null;
    const { ranges: n10, actualTileWidth: o7, actualTileHeight: f7, ifd: l5 } = a7, u8 = n10.map((e4) => this.request(this.url, { range: e4, responseType: "array-buffer", signal: s5.signal })), p6 = await Promise.all(u8), c9 = p6.map((e4) => e4.data.byteLength).reduce((e4, t6) => e4 + t6), h8 = 1 === p6.length ? p6[0].data : new ArrayBuffer(c9), m8 = [0], d8 = [0];
    if (p6.length > 1) {
      const e4 = new Uint8Array(h8);
      for (let t6 = 0, r6 = 0; t6 < p6.length; t6++) {
        const i7 = p6[t6].data;
        e4.set(new Uint8Array(i7), r6), m8[t6] = r6, r6 += i7.byteLength, d8[t6] = i7.byteLength;
      }
    }
    const { blockWidth: y7, blockHeight: g5 } = this.getBlockWidthHeight(e3), T5 = await this.decodePixelBlock(h8, { format: "tiff", customOptions: { headerInfo: this._headerInfo, ifd: l5, offsets: m8, sizes: d8 }, width: y7, height: g5, planes: null, pixelType: null });
    if (null == T5)
      return null;
    let x6, I4, w3;
    if (o7 !== y7 || f7 !== g5) {
      let e4 = T5.mask;
      if (e4)
        for (x6 = 0; x6 < g5; x6++)
          if (w3 = x6 * y7, x6 < f7)
            for (I4 = o7; I4 < y7; I4++)
              e4[w3 + I4] = 0;
          else
            for (I4 = 0; I4 < y7; I4++)
              e4[w3 + I4] = 0;
      else
        for (e4 = new Uint8Array(y7 * g5), T5.mask = e4, x6 = 0; x6 < f7; x6++)
          for (w3 = x6 * y7, I4 = 0; I4 < o7; I4++)
            e4[w3 + I4] = 1;
    }
    return T5;
  }
  _getTileLocation(e3, t5, r5, i6 = false) {
    const { firstPyramidLevel: s5, blockBoundary: a7 } = this.rasterInfo.storageInfo, n10 = 0 === e3 ? 0 : e3 - (s5 - 1), { _headerInfo: o7 } = this;
    if (!o7)
      return null;
    const f7 = i6 ? o7.maskIFDs[n10] : 0 === n10 ? o7 == null ? void 0 : o7.ifds[0] : o7 == null ? void 0 : o7.pyramidIFDs[n10 - 1];
    if (!f7)
      return null;
    const l5 = D(f7, o7), u8 = S5(f7, "TILEOFFSETS");
    if (void 0 === u8)
      return null;
    const p6 = S5(f7, "TILEBYTECOUNTS"), { minRow: c9, minCol: h8, maxRow: m8, maxCol: d8 } = a7[n10];
    if (t5 > m8 || r5 > d8 || t5 < c9 || r5 < h8)
      return null;
    const y7 = F2(f7, "IMAGEWIDTH"), g5 = F2(f7, "IMAGELENGTH"), x6 = F2(f7, "TILEWIDTH"), I4 = F2(f7, "TILELENGTH"), w3 = [];
    if (l5) {
      const { bandCount: e4 } = this.rasterInfo;
      for (let i7 = 0; i7 < e4; i7++) {
        const e5 = i7 * (m8 + 1) * (d8 + 1) + t5 * (d8 + 1) + r5;
        w3[i7] = { from: u8[e5], to: u8[e5] + p6[e5] - 1 };
      }
    } else {
      const e4 = t5 * (d8 + 1) + r5;
      w3.push({ from: u8[e4], to: u8[e4] + p6[e4] - 1 });
    }
    for (let T5 = 0; T5 < w3.length; T5++)
      if (null == w3[T5].from || !w3[T5].to || w3[T5].to < 0)
        return null;
    return { ranges: w3, ifd: f7, actualTileWidth: r5 === d8 && y7 % x6 || x6, actualTileHeight: t5 === m8 && g5 % I4 || I4 };
  }
  async _fetchAuxiliaryMetaData(e3) {
    try {
      const { data: t5 } = await this.request(this.url + ".aux.xml", { responseType: "xml", signal: e3 == null ? void 0 : e3.signal });
      return S3(t5);
    } catch {
      return null;
    }
  }
  async _fetchAuxiliaryTable(e3) {
    try {
      const { data: t5 } = await this.request(this.url + ".vat.dbf", { responseType: "array-buffer", signal: e3 == null ? void 0 : e3.signal }), r5 = r4.parse(t5);
      return (r5 == null ? void 0 : r5.recordSet) ? d2.fromJSON(r5.recordSet) : null;
    } catch {
      return null;
    }
  }
};
e([y()], P2.prototype, "_files", void 0), e([y()], P2.prototype, "_headerInfo", void 0), e([y()], P2.prototype, "_bufferSize", void 0), e([y({ type: String, json: { write: true } })], P2.prototype, "datasetFormat", void 0), P2 = e([c("esri.layers.support.rasterDatasets.TIFFRaster")], P2);
var v4 = P2;

// node_modules/@arcgis/core/layers/support/rasterDatasets/RasterFactory.js
var c8 = /* @__PURE__ */ new Map();
c8.set("CRF", { desc: "Cloud Raster Format", constructor: S2 }), c8.set("MRF", { desc: "Meta Raster Format", constructor: I3 }), c8.set("TIFF", { desc: "GeoTIFF", constructor: v4 }), c8.set("RasterTileServer", { desc: "Raster Tile Server", constructor: S4 }), c8.set("JPG", { desc: "JPG Raster Format", constructor: d7 }), c8.set("PNG", { desc: "PNG Raster Format", constructor: d7 }), c8.set("GIF", { desc: "GIF Raster Format", constructor: d7 }), c8.set("BMP", { desc: "BMP Raster Format", constructor: d7 });
var n9 = class {
  static get supportedFormats() {
    const t5 = /* @__PURE__ */ new Set();
    return c8.forEach((e3, r5) => t5.add(r5)), t5;
  }
  static async open(e3) {
    const { url: r5, ioConfig: s5, sourceJSON: o7 } = e3;
    let a7 = e3.datasetFormat;
    null == a7 && r5.lastIndexOf(".") && (a7 = r5.slice(r5.lastIndexOf(".") + 1).toUpperCase()), "OVR" === a7 || "TIF" === a7 ? a7 = "TIFF" : "JPG" !== a7 && "JPEG" !== a7 && "JFIF" !== a7 || (a7 = "JPG"), r5.toLowerCase().includes("/imageserver") && !r5.toLowerCase().includes("/wcsserver") && (a7 = "RasterTileServer");
    const n10 = { url: r5, sourceJSON: o7, datasetFormat: a7, ioConfig: s5 ?? { bandIds: null, sampling: null } };
    let l5, i6;
    if (a7 && this.supportedFormats.has(a7)) {
      if ("CRF" === a7 && !(s5 == null ? void 0 : s5.enableCRF))
        throw new s2("rasterfactory:open", `cannot open raster: ${r5}`);
      return l5 = c8.get(a7).constructor, i6 = new l5(n10), await i6.open({ signal: e3.signal }), i6;
    }
    if (a7)
      throw new s2("rasterfactory:open", "not a supported format " + a7);
    const u8 = Array.from(c8.keys());
    let F3 = 0;
    const m8 = () => (a7 = u8[F3++], a7 && ("CRF" !== a7 || (s5 == null ? void 0 : s5.enableCRF)) ? (l5 = c8.get(a7).constructor, i6 = new l5(n10), i6.open({ signal: e3.signal }).then(() => i6).catch(() => m8())) : null);
    return m8();
  }
  static register(t5, e3, r5) {
    c8.has(t5.toUpperCase()) || c8.set(t5.toUpperCase(), { desc: e3, constructor: r5 });
  }
};

// node_modules/@arcgis/core/layers/ImageryTileLayer.js
var E2 = class extends a2(t(u5(j3(o3(V4(a3(l(f3(m2(i(b))))))))))) {
  constructor(...e3) {
    super(...e3), this._primaryRasters = [], this.bandIds = null, this.interpolation = null, this.legendEnabled = true, this.isReference = null, this.listMode = "show", this.sourceJSON = null, this.version = null, this.type = "imagery-tile", this.operationalLayerType = "ArcGISTiledImageServiceLayer", this.popupEnabled = true, this.popupTemplate = null, this.fields = null, this._debouncedSaveOperations = k2(async (e4, r5, t5) => {
      const { save: s5, saveAs: i6 } = await import("./imageryUtils-3G72LB27.js");
      switch (e4) {
        case A.SAVE:
          return s5(this, r5);
        case A.SAVE_AS:
          return i6(this, t5, r5);
      }
    });
  }
  normalizeCtorArgs(e3, r5) {
    return "string" == typeof e3 ? { url: e3, ...r5 } : e3;
  }
  load(e3) {
    const r5 = null != e3 ? e3.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"] }, e3).catch(a).then(() => this._openRaster(r5))), Promise.resolve(this);
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get rasterFields() {
    var _a;
    const e3 = [new y3({ name: "Raster.ServicePixelValue", alias: "Pixel Value", domain: null, editable: false, length: 50, type: "string" }), new y3({ name: "Raster.ServicePixelValue.Raw", alias: "Raw Pixel Value", domain: null, editable: false, length: 50, type: "string" })], { rasterInfo: r5 } = this, t5 = r5 == null ? void 0 : r5.attributeTable, s5 = null != t5 ? t5.fields : null, i6 = "Raster.";
    if (s5) {
      const r6 = s5.filter((e4) => "oid" !== e4.type && "value" !== e4.name.toLowerCase()).map((e4) => {
        const r7 = e4.clone();
        return r7.name = i6 + e4.name, r7;
      });
      e3.push(...r6);
    }
    const o7 = r5 == null ? void 0 : r5.dataType, a7 = r5 == null ? void 0 : r5.multidimensionalInfo;
    if (("vector-magdir" === o7 || "vector-uv" === o7) && null != a7) {
      const r6 = (_a = a7.variables[0].unit) == null ? void 0 : _a.trim(), t6 = "Magnitude" + (r6 ? ` (${r6})` : "");
      e3.push(new y3({ name: "Raster.Magnitude", alias: t6, domain: null, editable: false, type: "double" })), e3.push(new y3({ name: "Raster.Direction", alias: "Direction (°)", domain: null, editable: false, type: "double" }));
    }
    return e3;
  }
  createPopupTemplate(e3) {
    const { rasterFields: r5 } = this, t5 = new Set(r5.map(({ name: e4 }) => e4).filter((e4) => "raster.servicepixelvalue.raw" !== e4.toLowerCase()));
    return p2({ fields: r5, title: this.title }, { ...e3, visibleFieldNames: t5 });
  }
  async generateRasterInfo(e3, r5) {
    var _a;
    if (!(e3 = v2(N2, e3)))
      return this.rasterInfo;
    try {
      const t5 = { raster: this._primaryRasters[0] };
      this._primaryRasters.length > 1 && this._primaryRasters.forEach((e4) => t5[e4.url] = e4);
      const s5 = R3(((_a = e3.functionDefinition) == null ? void 0 : _a.toJSON()) ?? e3.toJSON(), t5), i6 = new c5({ rasterFunction: s5 });
      return await i6.open(r5), i6.rasterInfo;
    } catch (t5) {
      if (t5 instanceof s2)
        throw t5;
      throw new s2("imagery-tile-layer", "the given raster function is not supported");
    }
  }
  async save(e3) {
    return this._debouncedSaveOperations(A.SAVE, e3);
  }
  async saveAs(e3, r5) {
    return this._debouncedSaveOperations(A.SAVE_AS, r5, e3);
  }
  write(e3, r5) {
    const t5 = this._primaryRasters[0] ?? this.raster;
    if (this.loaded ? "RasterTileServer" === t5.datasetFormat && ("Raster" === t5.tileType || "Map" === t5.tileType) : this.url && /\/ImageServer(\/|\/?$)/i.test(this.url))
      return super.write(e3, r5);
    if (r5 == null ? void 0 : r5.messages) {
      const e4 = `${r5.origin}/${r5.layerContainerType || "operational-layers"}`;
      r5.messages.push(new s2("layer:unsupported", `Layers (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${e4}'`, { layer: this }));
    }
    return null;
  }
  async _openRaster(e3) {
    var _a;
    let r5 = false;
    if (this.raster)
      this.raster.rasterInfo || await this.raster.open(), "Function" === this.raster.datasetFormat ? (r5 = true, this._primaryRasters = this.raster.primaryRasters.rasters) : this._primaryRasters = [this.raster], this.url = this.raster.url;
    else {
      const { rasterFunction: r6 } = this, t6 = [this.url];
      r6 && C(r6.toJSON(), t6);
      const a7 = await Promise.all(t6.map((r7) => n9.open({ url: r7, sourceJSON: this.sourceJSON, ioConfig: { sampling: "closest", ...this.ioConfig, customFetchParameters: this.customParameters }, signal: e3 }))), n10 = a7.findIndex((e4) => null == e4);
      if (n10 > -1)
        throw new s2("imagery-tile-layer:open", `cannot open raster: ${t6[n10]}`);
      if (this._primaryRasters = a7, r6) {
        const e4 = { raster: this._primaryRasters[0] };
        this._primaryRasters.length > 1 && this._primaryRasters.forEach((r7) => e4[r7.url] = r7);
        const t7 = R3(((_a = r6.functionDefinition) == null ? void 0 : _a.toJSON()) ?? r6.toJSON(), e4), n11 = new c5({ rasterFunction: t7 });
        try {
          await n11.open(), this.raster = n11;
        } catch (o7) {
          const e5 = s.getLogger(this);
          o7 instanceof s2 && e5.error("imagery-tile-layer:open", o7.message), e5.warn("imagery-tile-layer:open", "the raster function cannot be applied and is removed"), this._set("rasterFunction", null), this.raster = a7[0];
        }
      } else
        this.raster = a7[0];
    }
    const t5 = this.raster.rasterInfo;
    if (!t5)
      throw new s2("imagery-tile-layer:load", "cannot load resources on " + this.url);
    if (this._set("rasterInfo", r5 ? t5 : this._primaryRasters[0].rasterInfo), this._set("spatialReference", t5.spatialReference), this.sourceJSON = this.sourceJSON || this.raster.sourceJSON, null != this.sourceJSON) {
      const e4 = "Map" === this.raster.tileType && null != this.sourceJSON.minLOD && null != this.sourceJSON.maxLOD ? this.sourceJSON : { ...this.sourceJSON, minScale: 0, maxScale: 0 };
      this.read(e4, { origin: "service" });
    } else
      this.read({ tileInfo: this.rasterInfo.storageInfo.tileInfo.toJSON() }, { origin: "service" });
    this.title || (this.title = this.raster.datasetName), "Map" === this.raster.tileType && (this.popupEnabled = false), this._configDefaultSettings(), this.addHandles(d(() => this.customParameters, (e4) => {
      this.raster && (this.raster.ioConfig.customFetchParameters = e4);
    }));
  }
};
e([y({ clonable: false })], E2.prototype, "_primaryRasters", void 0), e([y({ type: [T], json: { write: { overridePolicy() {
  var _a;
  return { enabled: !this.loaded || "Raster" === this.raster.tileType || "0,1,2" !== ((_a = this.bandIds) == null ? void 0 : _a.join(",")) };
} } } })], E2.prototype, "bandIds", void 0), e([y({ json: { write: { overridePolicy() {
  return { enabled: !this.loaded || "Raster" === this.raster.tileType || "bilinear" !== this.interpolation };
} } } }), o2(a4)], E2.prototype, "interpolation", void 0), e([y(c2)], E2.prototype, "legendEnabled", void 0), e([y({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], E2.prototype, "isReference", void 0), e([y({ type: ["show", "hide"] })], E2.prototype, "listMode", void 0), e([y({ json: { read: true, write: true } })], E2.prototype, "blendMode", void 0), e([y()], E2.prototype, "sourceJSON", void 0), e([y({ readOnly: true, json: { origins: { service: { read: { source: "currentVersion" } } } } })], E2.prototype, "version", void 0), e([y({ readOnly: true, json: { read: false } })], E2.prototype, "type", void 0), e([y({ type: ["ArcGISTiledImageServiceLayer"] })], E2.prototype, "operationalLayerType", void 0), e([y({ type: Boolean, value: true, json: { read: { source: "disablePopup", reader: (e3, r5) => !r5.disablePopup }, write: { target: "disablePopup", overridePolicy() {
  return { enabled: !this.loaded || "Raster" === this.raster.tileType };
}, writer(e3, r5, t5) {
  r5[t5] = !e3;
} } } })], E2.prototype, "popupEnabled", void 0), e([y({ type: k3, json: { read: { source: "popupInfo" }, write: { target: "popupInfo", overridePolicy() {
  return { enabled: !this.loaded || "Raster" === this.raster.tileType };
} } } })], E2.prototype, "popupTemplate", void 0), e([y({ readOnly: true })], E2.prototype, "defaultPopupTemplate", null), e([y({ readOnly: true, type: [y3] })], E2.prototype, "fields", void 0), e([y({ readOnly: true, type: [y3] })], E2.prototype, "rasterFields", null), E2 = e([c("esri.layers.ImageryTileLayer")], E2);
var A2 = E2;
export {
  A2 as default
};
//# sourceMappingURL=ImageryTileLayer-KTLNNJCN.js.map
