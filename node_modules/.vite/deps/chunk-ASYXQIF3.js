import {
  e as e4,
  r as r3
} from "./chunk-V76ETMKA.js";
import {
  v
} from "./chunk-Q7LVMEOD.js";
import {
  s as s3
} from "./chunk-TJ5AKOA7.js";
import {
  t as t3
} from "./chunk-NB4VIBDC.js";
import {
  s as s2
} from "./chunk-YNB3DCUM.js";
import {
  e as e3
} from "./chunk-GLBAW5CR.js";
import {
  l as l2,
  t as t2
} from "./chunk-VHDTZ7JB.js";
import {
  o as o2,
  r as r2
} from "./chunk-4OLZTDWK.js";
import {
  A,
  O2 as O,
  U as U2,
  _2 as _,
  e2,
  g,
  n,
  o,
  p,
  r,
  s,
  t,
  u2 as u
} from "./chunk-YTH6VA7N.js";
import {
  e4 as e
} from "./chunk-LXXF7K7W.js";
import {
  l
} from "./chunk-SBW6NNVI.js";
import {
  U,
  i,
  y2 as y
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/AttributeArray.js
function o3(o6) {
  if (o6.length < U)
    return Array.from(o6);
  if (y(o6))
    return Float64Array.from(o6);
  if (!("BYTES_PER_ELEMENT" in o6))
    return Array.from(o6);
  switch (o6.BYTES_PER_ELEMENT) {
    case 1:
      return Uint8Array.from(o6);
    case 2:
      return i(o6) ? Uint16Array.from(o6) : Int16Array.from(o6);
    case 4:
      return Float32Array.from(o6);
    default:
      return Float64Array.from(o6);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/BoundingInfo.js
var o4 = class _o {
  constructor(i3, e5, o6) {
    this.primitiveIndices = i3, this._numIndexPerPrimitive = e5, this.position = o6, this._children = void 0, s2(i3.length >= 1), s2(3 === o6.size || 4 === o6.size);
    const { data: c3, size: l5, indices: m2 } = o6;
    s2(m2.length % this._numIndexPerPrimitive == 0), s2(m2.length >= i3.length * this._numIndexPerPrimitive);
    const d = i3.length;
    let u3 = l5 * m2[this._numIndexPerPrimitive * i3[0]];
    a.clear(), a.push(u3);
    const f2 = r(c3[u3], c3[u3 + 1], c3[u3 + 2]), x2 = t(f2);
    for (let t5 = 0; t5 < d; ++t5) {
      const e6 = this._numIndexPerPrimitive * i3[t5];
      for (let i4 = 0; i4 < this._numIndexPerPrimitive; ++i4) {
        u3 = l5 * m2[e6 + i4], a.push(u3);
        let t6 = c3[u3];
        f2[0] = Math.min(t6, f2[0]), x2[0] = Math.max(t6, x2[0]), t6 = c3[u3 + 1], f2[1] = Math.min(t6, f2[1]), x2[1] = Math.max(t6, x2[1]), t6 = c3[u3 + 2], f2[2] = Math.min(t6, f2[2]), x2[2] = Math.max(t6, x2[2]);
      }
    }
    this.bbMin = f2, this.bbMax = x2;
    const P2 = A(n(), this.bbMin, this.bbMax, 0.5);
    this.radius = 0.5 * Math.max(Math.max(x2[0] - f2[0], x2[1] - f2[1]), x2[2] - f2[2]);
    let p2 = this.radius * this.radius;
    for (let t5 = 0; t5 < a.length; ++t5) {
      u3 = a.at(t5);
      const i4 = c3[u3] - P2[0], e6 = c3[u3 + 1] - P2[1], s4 = c3[u3 + 2] - P2[2], r7 = i4 * i4 + e6 * e6 + s4 * s4;
      if (r7 <= p2)
        continue;
      const n3 = Math.sqrt(r7), h2 = 0.5 * (n3 - this.radius);
      this.radius = this.radius + h2, p2 = this.radius * this.radius;
      const o7 = h2 / n3;
      P2[0] += i4 * o7, P2[1] += e6 * o7, P2[2] += s4 * o7;
    }
    this.center = P2, a.clear();
  }
  getChildren() {
    if (this._children || p(this.bbMin, this.bbMax) <= 1)
      return this._children;
    const i3 = A(n(), this.bbMin, this.bbMax, 0.5), s4 = this.primitiveIndices.length, r7 = new Uint8Array(s4), h2 = new Array(8);
    for (let t5 = 0; t5 < 8; ++t5)
      h2[t5] = 0;
    const { data: a3, size: c3, indices: l5 } = this.position;
    for (let t5 = 0; t5 < s4; ++t5) {
      let e5 = 0;
      const s5 = this._numIndexPerPrimitive * this.primitiveIndices[t5];
      let n3 = c3 * l5[s5], o6 = a3[n3], m3 = a3[n3 + 1], d2 = a3[n3 + 2];
      for (let i4 = 1; i4 < this._numIndexPerPrimitive; ++i4) {
        n3 = c3 * l5[s5 + i4];
        const t6 = a3[n3], e6 = a3[n3 + 1], r8 = a3[n3 + 2];
        t6 < o6 && (o6 = t6), e6 < m3 && (m3 = e6), r8 < d2 && (d2 = r8);
      }
      o6 < i3[0] && (e5 |= 1), m3 < i3[1] && (e5 |= 2), d2 < i3[2] && (e5 |= 4), r7[t5] = e5, ++h2[e5];
    }
    let m2 = 0;
    for (let t5 = 0; t5 < 8; ++t5)
      h2[t5] > 0 && ++m2;
    if (m2 < 2)
      return;
    const d = new Array(8);
    for (let t5 = 0; t5 < 8; ++t5)
      d[t5] = h2[t5] > 0 ? new Uint32Array(h2[t5]) : void 0;
    for (let t5 = 0; t5 < 8; ++t5)
      h2[t5] = 0;
    for (let t5 = 0; t5 < s4; ++t5) {
      const i4 = r7[t5];
      d[i4][h2[i4]++] = this.primitiveIndices[t5];
    }
    this._children = new Array();
    for (let t5 = 0; t5 < 8; ++t5)
      void 0 !== d[t5] && this._children.push(new _o(d[t5], this._numIndexPerPrimitive, this.position));
    return this._children;
  }
  static prune() {
    a.prune();
  }
};
var a = new l({ deallocator: null });

// node_modules/@arcgis/core/geometry/support/triangle.js
function j(t5) {
  return t5 ? { p0: t(t5.p0), p1: t(t5.p1), p2: t(t5.p2) } : { p0: n(), p1: n(), p2: n() };
}
function w(t5, n3, o6) {
  return e2(O2, n3, t5), e2(V, o6, t5), s(_(O2, O2, V)) / 2;
}
var M2 = new s3(v);
var x = new s3(() => j());
var O2 = n();
var V = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/geometryDataUtils.js
function c2(s4, r7) {
  if (!s4)
    return false;
  const { size: c3, data: i3, indices: f2 } = s4;
  o(r7, 0, 0, 0), o(m, 0, 0, 0);
  let d = 0, g2 = 0;
  for (let p2 = 0; p2 < f2.length - 2; p2 += 3) {
    const s5 = f2[p2] * c3, h2 = f2[p2 + 1] * c3, j2 = f2[p2 + 2] * c3;
    o(a2, i3[s5], i3[s5 + 1], i3[s5 + 2]), o(u2, i3[h2], i3[h2 + 1], i3[h2 + 2]), o(l3, i3[j2], i3[j2 + 1], i3[j2 + 2]);
    const z = w(a2, u2, l3);
    z ? (u(a2, a2, u2), u(a2, a2, l3), g(a2, a2, 1 / 3 * z), u(r7, r7, a2), d += z) : (u(m, m, a2), u(m, m, u2), u(m, m, l3), g2 += 3);
  }
  return (0 !== g2 || 0 !== d) && (0 !== d ? (g(r7, r7, 1 / d), true) : 0 !== g2 && (g(r7, m, 1 / g2), true));
}
function i2(n3, s4) {
  if (!n3)
    return false;
  const { size: r7, data: o6, indices: c3 } = n3;
  o(s4, 0, 0, 0);
  let i3 = -1, f2 = 0;
  for (let t5 = 0; t5 < c3.length; t5++) {
    const n4 = c3[t5] * r7;
    i3 !== n4 && (s4[0] += o6[n4], s4[1] += o6[n4 + 1], s4[2] += o6[n4 + 2], f2++), i3 = n4;
  }
  return f2 > 1 && g(s4, s4, 1 / f2), f2 > 0;
}
function f(r7, o6, c3) {
  if (!r7)
    return false;
  o(c3, 0, 0, 0), o(m, 0, 0, 0);
  let i3 = 0, f2 = 0;
  const { size: l5, data: d, indices: g2 } = r7, p2 = g2.length - 1, h2 = p2 + (o6 ? 2 : 0);
  for (let t5 = 0; t5 < h2; t5 += 2) {
    const r8 = t5 < p2 ? t5 + 1 : 0, o7 = g2[t5 < p2 ? t5 : p2] * l5, h3 = g2[r8] * l5;
    a2[0] = d[o7], a2[1] = d[o7 + 1], a2[2] = d[o7 + 2], u2[0] = d[h3], u2[1] = d[h3 + 1], u2[2] = d[h3 + 2], g(a2, u(a2, a2, u2), 0.5);
    const j2 = U2(a2, u2);
    j2 > 0 ? (u(c3, c3, g(a2, a2, j2)), i3 += j2) : 0 === i3 && (u(m, m, a2), f2++);
  }
  return 0 !== i3 ? (g(c3, c3, 1 / i3), true) : 0 !== f2 && (g(c3, m, 1 / f2), true);
}
var a2 = n();
var u2 = n();
var l3 = n();
var m = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Object3DStateID.js
var r5 = class {
  constructor(r7) {
    this.channel = r7, this.id = e();
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/renderers/utils.js
function n2(t5, e5) {
  return null == t5 && (t5 = []), t5.push(e5), t5;
}
function r6(t5, e5) {
  if (null == t5)
    return null;
  const n3 = t5.filter((t6) => t6 !== e5);
  return 0 === n3.length ? null : n3;
}
var l4 = n();
var o5 = new Float32Array(6);

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Geometry.js
var I = class _I extends r3 {
  constructor(t5, i3, e5 = null, s4 = e4.Mesh, r7 = null, o6 = -1) {
    super(), this.material = t5, this.mapPositions = e5, this.type = s4, this.objectAndLayerIdColor = r7, this.edgeIndicesLength = o6, this.visible = true, this._attributes = /* @__PURE__ */ new Map(), this._boundingInfo = null;
    for (const [h2, a3] of i3)
      this._attributes.set(h2, { ...a3, indices: t2(a3.indices) }), h2 === e3.POSITION && (this.edgeIndicesLength = this.edgeIndicesLength < 0 ? this._attributes.get(h2).indices.length : this.edgeIndicesLength);
  }
  instantiate(t5 = {}) {
    const i3 = new _I(t5.material || this.material, [], this.mapPositions, this.type, this.objectAndLayerIdColor, this.edgeIndicesLength);
    return this._attributes.forEach((t6, e5) => {
      t6.exclusive = false, i3._attributes.set(e5, t6);
    }), i3._boundingInfo = this._boundingInfo, i3.transformation = t5.transformation || this.transformation, i3;
  }
  get attributes() {
    return this._attributes;
  }
  getMutableAttribute(t5) {
    let i3 = this._attributes.get(t5);
    return i3 && !i3.exclusive && (i3 = { ...i3, exclusive: true, data: o3(i3.data) }, this._attributes.set(t5, i3)), i3;
  }
  setAttributeData(t5, i3) {
    const e5 = this._attributes.get(t5);
    e5 && this._attributes.set(t5, { ...e5, exclusive: true, data: i3 });
  }
  get indexCount() {
    const t5 = this._attributes.values().next().value.indices;
    return (t5 == null ? void 0 : t5.length) ?? 0;
  }
  get faceCount() {
    return this.indexCount / 3;
  }
  get boundingInfo() {
    return null == this._boundingInfo && (this._boundingInfo = this._calculateBoundingInfo()), this._boundingInfo;
  }
  computeAttachmentOrigin(t5) {
    return !!(this.type === e4.Mesh ? this._computeAttachmentOriginTriangles(t5) : this.type === e4.Line ? this._computeAttachmentOriginLines(t5) : this._computeAttachmentOriginPoints(t5)) && (null != this._transformation && O(t5, t5, this._transformation), true);
  }
  _computeAttachmentOriginTriangles(t5) {
    const i3 = this.attributes.get(e3.POSITION);
    return c2(i3, t5);
  }
  _computeAttachmentOriginLines(t5) {
    const i3 = this.attributes.get(e3.POSITION);
    return f(i3, _2(this.material.parameters, i3), t5);
  }
  _computeAttachmentOriginPoints(t5) {
    const i3 = this.attributes.get(e3.POSITION);
    return i2(i3, t5);
  }
  invalidateBoundingInfo() {
    this._boundingInfo = null;
  }
  _calculateBoundingInfo() {
    const t5 = this.attributes.get(e3.POSITION);
    if (!t5 || 0 === t5.indices.length)
      return null;
    const i3 = this.type === e4.Mesh ? 3 : 1;
    s2(t5.indices.length % i3 == 0, "Indexing error: " + t5.indices.length + " not divisible by " + i3);
    const e5 = l2(t5.indices.length / i3);
    return new o4(e5, i3, t5);
  }
  get transformation() {
    return this._transformation ?? o2;
  }
  set transformation(e5) {
    this._transformation = e5 && e5 !== o2 ? r2(e5) : null;
  }
  addHighlight() {
    const t5 = new r5(t3.Highlight);
    return this.highlights = n2(this.highlights, t5), t5;
  }
  removeHighlight(t5) {
    this.highlights = r6(this.highlights, t5);
  }
};
function _2(t5, i3) {
  return !(!("isClosed" in t5) || !t5.isClosed) && i3.indices.length > 2;
}

export {
  I
};
//# sourceMappingURL=chunk-ASYXQIF3.js.map
