import {
  m
} from "./chunk-MKW4ORPJ.js";
import {
  G
} from "./chunk-Y5D433JZ.js";
import {
  x2 as x
} from "./chunk-QNOCEWCR.js";

// node_modules/@arcgis/core/arcade/functions/centroid.js
function r(t, n, e) {
  return Math.sqrt((t[0] - n[0]) ** 2 + (t[1] - n[1]) ** 2 + (void 0 !== t[2] && void 0 !== n[2] ? (t[2] * e - n[2] * e) ** 2 : 0));
}
var o = [];
for (const R of [[9002, 56146130, 6131, 6132, 8050, 8051, 8228], [9003, 5702, 6358, 6359, 6360, 8052, 8053], [9095, 5754]]) {
  const t = R[0];
  for (let n = 1; n < R.length; n++)
    o[R[n]] = t;
}
var s = [];
function i(t) {
  return t.vcsWkid && void 0 !== o[t.vcsWkid] ? s[o[t.vcsWkid]] : t.latestVcsWkid && void 0 !== o[t.latestVcsWkid] ? s[o[t.latestVcsWkid]] : 1;
}
function c(t, n, e) {
  const r2 = { x: 0, y: 0 };
  n && (r2.z = 0), e && (r2.m = 0);
  let o2 = 0, s2 = t[0];
  for (let i2 = 0; i2 < t.length; i2++) {
    const c2 = t[i2];
    if (false === l(c2, s2)) {
      const t2 = h(s2, c2, n), i3 = a(s2, c2, n, e);
      i3.x *= t2, i3.y *= t2, r2.x += i3.x, r2.y += i3.y, n && (i3.z *= t2, r2.z += i3.z), e && (i3.m *= t2, r2.m += i3.m), o2 += t2, s2 = c2;
    }
  }
  return o2 > 0 ? (r2.x /= o2, r2.y /= o2, n && (r2.z /= o2), e && (r2.m /= o2)) : (r2.x = t[0][0], r2.y = t[0][1], n && (r2.z = t[0][2]), e && n ? r2.m = t[0][3] : e && (r2.m = t[0][2])), r2;
}
function a(t, n, e, r2) {
  const o2 = { x: (t[0] + n[0]) / 2, y: (t[1] + n[1]) / 2 };
  return e && (o2.z = (t[2] + n[2]) / 2), e && r2 ? o2.m = (t[3] + n[3]) / 2 : r2 && (o2.m = (t[2] + n[2]) / 2), o2;
}
function f(t, n) {
  if (t.length <= 1)
    return 0;
  let e = 0;
  for (let r2 = 1; r2 < t.length; r2++)
    e += h(t[r2 - 1], t[r2], n);
  return e;
}
function h(t, n, e) {
  const r2 = n[0] - t[0], o2 = n[1] - t[1];
  if (e) {
    const t2 = n[2] - n[2];
    return Math.sqrt(r2 * r2 + o2 * o2 + t2 * t2);
  }
  return Math.sqrt(r2 * r2 + o2 * o2);
}
function l(t, n) {
  if (t.length !== n.length)
    return false;
  for (let e = 0; e < t.length; e++)
    if (t[e] !== n[e])
      return false;
  return true;
}
function u(t) {
  const e = { x: 0, y: 0, spatialReference: t.spatialReference.toJSON() }, r2 = { x: 0, y: 0, spatialReference: t.spatialReference.toJSON() };
  let o2 = 0, s2 = 0;
  for (let n = 0; n < t.paths.length; n++) {
    if (0 === t.paths[n].length)
      continue;
    const i2 = f(t.paths[n], true === t.hasZ);
    if (0 === i2) {
      const r3 = c(t.paths[n], true === t.hasZ, true === t.hasM);
      e.x += r3.x, e.y += r3.y, true === t.hasZ && (e.z += r3.z), true === t.hasM && (e.m += r3.m), ++o2;
    } else {
      const e2 = c(t.paths[n], true === t.hasZ, true === t.hasM);
      r2.x += e2.x * i2, r2.y += e2.y * i2, true === t.hasZ && (r2.z += e2.z * i2), true === t.hasM && (r2.m += e2.m * i2), s2 += i2;
    }
  }
  return s2 > 0 ? (r2.x /= s2, r2.y /= s2, true === t.hasZ && (r2.z /= s2), true === t.hasM && (r2.m /= s2), new x(r2)) : o2 > 0 ? (e.x /= o2, e.y /= o2, true === t.hasZ && (r2.z /= o2), true === t.hasM && (e.m /= o2), new x(e)) : null;
}
function y(t) {
  if (0 === t.points.length)
    return null;
  let e = 0, r2 = 0, o2 = 0, s2 = 0;
  for (let n = 0; n < t.points.length; n++) {
    const i3 = t.getPoint(n);
    true === i3.hasZ && (o2 += i3.z), true === i3.hasM && (s2 += i3.m), e += i3.x, r2 += i3.y, s2 += i3.m;
  }
  const i2 = { x: e / t.points.length, y: r2 / t.points.length, spatialReference: null };
  return i2.spatialReference = t.spatialReference.toJSON(), true === t.hasZ && (i2.z = o2 / t.points.length), true === t.hasM && (i2.m = s2 / t.points.length), new x(i2);
}
function x2(t, n) {
  return t.x * n.x + t.y * n.y;
}
function m2(t, n) {
  return t.x * n.y - n.x * t.y;
}
function p(t, n, e = 0) {
  for (; t < e; )
    t += n;
  const r2 = e + n;
  for (; t >= r2; )
    t -= n;
  return t;
}
function g(t, n) {
  return Math.atan2(n.y - t.y, n.x - t.x);
}
function M(t, n) {
  return p(g(t, n), 2 * Math.PI) * (180 / Math.PI);
}
function z(t, n) {
  return p(Math.PI / 2 - g(t, n), 2 * Math.PI) * (180 / Math.PI);
}
function d(t, n, e) {
  const r2 = { x: t.x - n.x, y: t.y - n.y }, o2 = { x: e.x - n.x, y: e.y - n.y };
  return Math.atan2(m2(r2, o2), x2(r2, o2));
}
function P(n, e, r2) {
  return m(p(d(n, e, r2), 2 * Math.PI));
}
function Z(n, e, r2) {
  return m(p(-1 * d(n, e, r2), 2 * Math.PI));
}
s[9002] = 0.3048, s[9003] = 0.3048006096012192, s[9095] = 0.3048007491;
var v = [0, 0];
function I(t) {
  for (let n = 0; n < t.length; n++) {
    const r2 = t[n];
    for (let s2 = 0; s2 < r2.length - 1; s2++) {
      const o3 = r2[s2], i2 = r2[s2 + 1];
      for (let r3 = n + 1; r3 < t.length; r3++)
        for (let n2 = 0; n2 < t[r3].length - 1; n2++) {
          const s3 = t[r3][n2], c2 = t[r3][n2 + 1];
          if (G(o3, i2, s3, c2, v) && !(v[0] === o3[0] && v[1] === o3[1] || v[0] === s3[0] && v[1] === s3[1] || v[0] === i2[0] && v[1] === i2[1] || v[0] === c2[0] && v[1] === c2[1]))
            return true;
        }
    }
    const o2 = r2.length;
    if (!(o2 < 3))
      for (let t2 = 0; t2 <= o2 - 2; t2++) {
        const n2 = r2[t2], s2 = r2[t2 + 1];
        for (let i2 = t2 + 2; i2 <= o2 - 2; i2++) {
          const t3 = r2[i2], o3 = r2[i2 + 1];
          if (G(n2, s2, t3, o3, v) && !(v[0] === n2[0] && v[1] === n2[1] || v[0] === t3[0] && v[1] === t3[1] || v[0] === s2[0] && v[1] === s2[1] || v[0] === o3[0] && v[1] === o3[1]))
            return true;
        }
      }
  }
  return false;
}

export {
  r,
  i,
  u,
  y,
  M,
  z,
  P,
  Z,
  I
};
//# sourceMappingURL=chunk-7QTR2TBZ.js.map
