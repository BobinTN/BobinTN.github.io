import "./chunk-ASYXQIF3.js";
import "./chunk-V76ETMKA.js";
import "./chunk-5JIGIHKI.js";
import "./chunk-NQ7SK7XM.js";
import "./chunk-Q7LVMEOD.js";
import {
  X,
  b,
  ot
} from "./chunk-IGVJ7QLR.js";
import "./chunk-TJ5AKOA7.js";
import {
  h as h4,
  i as i2,
  o as o3,
  u as u3,
  y as y2
} from "./chunk-EWVUTXQQ.js";
import {
  g as g4,
  p as p3
} from "./chunk-ZN6Q7TWV.js";
import "./chunk-UTUG5XXJ.js";
import "./chunk-NB4VIBDC.js";
import {
  i
} from "./chunk-W3TATJ3S.js";
import {
  e as e3
} from "./chunk-ERRE3PWK.js";
import "./chunk-YNB3DCUM.js";
import "./chunk-GLBAW5CR.js";
import {
  t
} from "./chunk-VHDTZ7JB.js";
import {
  B,
  D,
  I,
  N,
  O as O2,
  R,
  U,
  U2,
  _,
  g as g3,
  h as h2,
  h2 as h3,
  j as j2,
  l as l2,
  o as o2,
  p as p2,
  r as r3,
  v as v2,
  w
} from "./chunk-5VOKVSCM.js";
import {
  L,
  c as c3
} from "./chunk-SD4PEUIA.js";
import {
  a as a3,
  e as e6,
  m as m3,
  t as t2
} from "./chunk-TOWKJZW4.js";
import {
  m as m2
} from "./chunk-SLEGPWAA.js";
import "./chunk-GLOKOXWD.js";
import {
  e as e5
} from "./chunk-4OLZTDWK.js";
import "./chunk-JYYKU27J.js";
import "./chunk-SKLWU2B3.js";
import {
  e as e4
} from "./chunk-2RN2AAP7.js";
import "./chunk-YHB3DQSV.js";
import "./chunk-ED5W63C6.js";
import "./chunk-SBUFDP7O.js";
import "./chunk-CMGHBCKF.js";
import {
  a as a2
} from "./chunk-YVNEJWNQ.js";
import "./chunk-NDKHIQMD.js";
import {
  d as d2
} from "./chunk-BYK6DXRK.js";
import "./chunk-XN6LAULS.js";
import "./chunk-RP5SAUAF.js";
import "./chunk-AMSVADDY.js";
import {
  r as r4,
  s as s4,
  t as t3
} from "./chunk-OJ65P3EQ.js";
import {
  c as c4
} from "./chunk-FWR4JURK.js";
import "./chunk-BELGAUAK.js";
import "./chunk-JHJVOI7Q.js";
import "./chunk-HITXLR5N.js";
import "./chunk-WYZCKLOR.js";
import "./chunk-S6NERLXF.js";
import "./chunk-4TSAC52K.js";
import "./chunk-H4ZZ5S37.js";
import "./chunk-G557TGXY.js";
import "./chunk-IRNKV32L.js";
import "./chunk-GRHSIT57.js";
import "./chunk-PJQIAD5D.js";
import "./chunk-Z6KIMOUA.js";
import "./chunk-SZAJDZCO.js";
import "./chunk-M7R7REMB.js";
import "./chunk-ZZYUEH57.js";
import "./chunk-VTWXDFFD.js";
import "./chunk-IPCIO3PX.js";
import "./chunk-EIY2DYTV.js";
import {
  l
} from "./chunk-WJ4LS3YG.js";
import {
  g as g2
} from "./chunk-F6MD5VOH.js";
import "./chunk-V2RPSCV3.js";
import "./chunk-LMT5JII2.js";
import "./chunk-4HKQSEUR.js";
import "./chunk-V3U4F2NL.js";
import {
  n as n4
} from "./chunk-ZB6PGKG5.js";
import {
  a,
  j
} from "./chunk-OIIDE5GZ.js";
import "./chunk-3XSRVKBX.js";
import {
  n as n2
} from "./chunk-WYBZLWIA.js";
import {
  M as M2
} from "./chunk-MKW4ORPJ.js";
import {
  O2 as O,
  S,
  e2,
  f as f2,
  g,
  n as n3,
  o,
  r as r2,
  u2,
  z as z2
} from "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import {
  d,
  v
} from "./chunk-TBSVVR6M.js";
import "./chunk-6TJWLWLO.js";
import "./chunk-H7BKONNV.js";
import "./chunk-K6C6RVSV.js";
import "./chunk-KBJ5Z4R2.js";
import {
  V
} from "./chunk-JUZJCTW2.js";
import "./chunk-423VNHLR.js";
import "./chunk-FN47E7YK.js";
import "./chunk-XZS3Q5K4.js";
import "./chunk-XXFXRXFH.js";
import {
  m
} from "./chunk-CCXEAKIM.js";
import {
  M
} from "./chunk-Y5D433JZ.js";
import {
  p,
  x2 as x
} from "./chunk-QNOCEWCR.js";
import "./chunk-WURET5CW.js";
import {
  f
} from "./chunk-QWPLZ3QH.js";
import {
  W2 as W,
  z
} from "./chunk-HLGIRLYQ.js";
import {
  n
} from "./chunk-N2K4VRZH.js";
import "./chunk-WL4VPODY.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import {
  G,
  Rt
} from "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import {
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c as c2,
  r2 as r
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  P,
  c2 as c,
  h,
  s as s3,
  u
} from "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import "./chunk-4V6374PV.js";
import "./chunk-A34O4XB5.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/geometry/support/meshErrors.js
var e7 = class extends s2 {
  constructor() {
    super("mesh-not-loaded", "Mesh must be loaded before applying operations");
  }
};
var t4 = class extends s2 {
  constructor() {
    super("component-not-found", "Provided component is not part of the list of components");
  }
};
var n5 = class extends s2 {
  constructor() {
    super("invalid-polygon", "expected polygon to be a Polygon instance");
  }
};
var s5 = class extends s2 {
  constructor() {
    super("invalid-input:location", "Expected location to be a Point instance");
  }
};
var r5 = class extends s2 {
  constructor() {
    super("invalid-input:no-layer", "A layer is needed to convert the files");
  }
};
var c5 = class extends s2 {
  constructor() {
    super("invalid-input:no-model", "No supported model found");
  }
};
var l3 = class extends s2 {
  constructor() {
    super("invalid-input:multiple-models", "Multiple supported models found");
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/polygonUtils.js
function h5(t8, o4, n6, a7) {
  const s6 = ((t9) => !Array.isArray(t9[0]))(o4) ? (t9, e13) => o4[3 * t9 + e13] : (t9, e13) => o4[t9][e13], c8 = a7 ? z(a7) / W(a7) : 1;
  return X(t8, (t9, e13) => o(t9, s6(e13, 0) * c8, s6(e13, 1) * c8, s6(e13, 2)), n6);
}
function j3(e13, r6, o4) {
  const i4 = h5(y3, e13, r6, o4) ? ot(y3) : [0, 0, 1];
  return Math.abs(i4[2]) > Math.cos(M2(80)) ? n2.Z : Math.abs(i4[1]) > Math.abs(i4[0]) ? n2.Y : n2.X;
}
var y3 = b();

// node_modules/@arcgis/core/geometry/support/triangulationUtils.js
function f3(t8) {
  const e13 = g5(t8.rings, t8.hasZ, u4.CCW_IS_HOLE, t8.spatialReference), s6 = new Array();
  let c8 = 0, f7 = 0;
  for (const r6 of e13.polygons) {
    const t9 = r6.count, l6 = r6.index, h10 = a3(e13.position, 3 * l6, 3 * t9), g9 = r6.holeIndices.map((n6) => n6 - l6), a8 = t(i(h10, g9, 3));
    s6.push({ position: h10, faces: a8 }), c8 += h10.length, f7 += a8.length;
  }
  const a7 = h6(s6, c8, f7), p8 = Array.isArray(a7.position) ? e3(a7.position, 3, { originalIndices: a7.faces }) : e3(a7.position.buffer, 6, { originalIndices: a7.faces });
  return a7.position = e6(new Float64Array(p8.buffer)), a7.faces = p8.indices, a7;
}
function h6(n6, t8, e13) {
  if (1 === n6.length)
    return n6[0];
  const o4 = t2(t8), r6 = new Array(e13);
  let l6 = 0, c8 = 0, f7 = 0;
  for (const s6 of n6) {
    for (let n7 = 0; n7 < s6.position.length; n7++)
      o4[l6++] = s6.position[n7];
    for (const n7 of s6.faces)
      r6[c8++] = n7 + f7;
    f7 = l6 / 3;
  }
  return { position: o4, faces: t(r6) };
}
function g5(n6, t8, e13, o4) {
  const r6 = n6.length, i4 = new Array(r6), l6 = new Array(r6), c8 = new Array(r6);
  let f7 = 0, h10 = 0, g9 = 0, d9 = 0;
  for (let s6 = 0; s6 < r6; ++s6)
    d9 += n6[s6].length;
  const m8 = t2(3 * d9);
  let y9 = 0;
  for (let s6 = r6 - 1; s6 >= 0; s6--) {
    const d10 = n6[s6], A5 = e13 === u4.CCW_IS_HOLE && p4(d10, t8, o4);
    if (A5 && 1 !== r6)
      i4[f7++] = d10;
    else {
      let n7 = d10.length;
      for (let t9 = 0; t9 < f7; ++t9)
        n7 += i4[t9].length;
      const e14 = { index: y9, pathLengths: new Array(f7 + 1), count: n7, holeIndices: new Array(f7) };
      e14.pathLengths[0] = d10.length, d10.length > 0 && (c8[g9++] = { index: y9, count: d10.length }), y9 = A5 ? a4(d10, d10.length - 1, -1, m8, y9, d10.length, t8) : a4(d10, 0, 1, m8, y9, d10.length, t8);
      for (let o5 = 0; o5 < f7; ++o5) {
        const n8 = i4[o5];
        e14.holeIndices[o5] = y9, e14.pathLengths[o5 + 1] = n8.length, n8.length > 0 && (c8[g9++] = { index: y9, count: n8.length }), y9 = a4(n8, 0, 1, m8, y9, n8.length, t8);
      }
      f7 = 0, e14.count > 0 && (l6[h10++] = e14);
    }
  }
  for (let s6 = 0; s6 < f7; ++s6) {
    const n7 = i4[s6];
    n7.length > 0 && (c8[g9++] = { index: y9, count: n7.length }), y9 = a4(n7, 0, 1, m8, y9, n7.length, t8);
  }
  return l6.length = h10, c8.length = g9, { position: m8, polygons: l6, outlines: c8 };
}
function a4(n6, t8, e13, o4, r6, s6, i4) {
  r6 *= 3;
  for (let l6 = 0; l6 < s6; ++l6) {
    const s7 = n6[t8];
    o4[r6++] = s7[0], o4[r6++] = s7[1], o4[r6++] = i4 ? s7[2] : 0, t8 += e13;
  }
  return r6 / 3;
}
function p4(n6, o4, r6) {
  if (o4) {
    const o5 = n6.length - 1, s6 = j3(n6, o5, r6);
    if (s6 === n2.X)
      return !a(n6, n2.Y, n2.Z);
    if (s6 === n2.Y)
      return !a(n6, n2.X, n2.Z);
  }
  return !a(n6, n2.X, n2.Y);
}
var u4;
!function(n6) {
  n6[n6.NONE = 0] = "NONE", n6[n6.CCW_IS_HOLE = 1] = "CCW_IS_HOLE";
}(u4 || (u4 = {}));

// node_modules/@arcgis/core/geometry/support/meshUtils/bounds.js
function e10({ xmin: t8, xmax: e13, ymin: i4, ymax: o4, zmin: r6, zmax: x5 }, s6, c8, f7) {
  r6 ?? (r6 = 0), x5 ?? (x5 = 0), a5 ?? (a5 = new Float64Array(24));
  const l6 = a5;
  return l6[0] = t8, l6[1] = i4, l6[2] = r6, l6[3] = t8, l6[4] = o4, l6[5] = r6, l6[6] = e13, l6[7] = o4, l6[8] = r6, l6[9] = e13, l6[10] = i4, l6[11] = r6, l6[12] = t8, l6[13] = i4, l6[14] = x5, l6[15] = t8, l6[16] = o4, l6[17] = x5, l6[18] = e13, l6[19] = o4, l6[20] = x5, l6[21] = e13, l6[22] = i4, l6[23] = x5, I({ positions: l6, transform: s6, vertexSpace: c8, inSpatialReference: f7, outSpatialReference: f7, outPositions: l6 }), m4(l6, f7);
}
var a5 = null;
function m4(n6, e13) {
  let a7 = 1 / 0, m8 = 1 / 0, i4 = 1 / 0, o4 = -1 / 0, r6 = -1 / 0, x5 = -1 / 0;
  const s6 = n6.length;
  let c8 = 0;
  for (; c8 < s6; ) {
    const t8 = n6[c8++], e14 = n6[c8++], s7 = n6[c8++];
    a7 = Math.min(a7, t8), m8 = Math.min(m8, e14), i4 = Math.min(i4, s7), o4 = Math.max(o4, t8), r6 = Math.max(r6, e14), x5 = Math.max(x5, s7);
  }
  return new M({ xmin: a7, ymin: m8, zmin: i4, xmax: o4, ymax: r6, zmax: x5, spatialReference: e13 });
}

// node_modules/@arcgis/core/geometry/projection/projectPointToVector.js
function e11(o4, e13, c8, f7 = 0) {
  t6[0] = o4.x, t6[1] = o4.y;
  const n6 = o4.z;
  return t6[2] = void 0 !== n6 ? n6 : f7, n4(t6, o4.spatialReference, 0, e13, c8, 0, 1);
}
var t6 = n3();

// node_modules/@arcgis/core/geometry/support/meshUtils/centerAt.js
var p5 = "esri.geometry.support.meshUtils.centerAt";
function l4(e13, t8, i4) {
  var _a;
  if (!((_a = e13.vertexAttributes) == null ? void 0 : _a.position))
    return;
  const { vertexSpace: r6 } = e13, o4 = (i4 == null ? void 0 : i4.origin) ?? e13.origin;
  if (r6.isRelative)
    o2(r6, p5, i4), f4(e13, t8, o4);
  else {
    r3(e13.spatialReference, i4) ? g6(e13, t8, o4) : d3(e13, t8, o4);
  }
}
function f4(n6, s6, a7) {
  const { vertexSpace: c8 } = n6;
  if (!c8.isRelative)
    return;
  const l6 = u5, f7 = j4;
  if (!e11(s6, f7, n6.spatialReference))
    return void s.getLogger(p5).error(`Failed to project centerAt location (wkid:${s6.spatialReference.wkid}) to mesh spatial reference (wkid:${n6.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
  if (!e11(a7, l6, n6.spatialReference)) {
    const t8 = n6.origin;
    l6[0] = t8.x, l6[1] = t8.y, l6[2] = t8.z, s.getLogger(p5).error(`Failed to project specified origin (wkid:${a7.spatialReference.wkid}) to mesh spatial reference (wkid:${n6.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
  }
  const g9 = e2(k, f7, l6), d9 = c8.origin;
  c8.origin = u2(n3(), d9, g9);
}
function g6(e13, t8, i4) {
  const r6 = D(e13.vertexAttributes, i4, { geographic: true }), { position: o4, normal: n6, tangent: s6 } = U2(r6, t8, { geographic: true });
  e13.vertexAttributes.position = o4, e13.vertexAttributes.normal = n6, e13.vertexAttributes.tangent = s6, e13.vertexAttributesChanged();
}
function d3(t8, i4, r6) {
  const n6 = u5, s6 = j4;
  if (e11(i4, s6, t8.spatialReference)) {
    if (!e11(r6, n6, t8.spatialReference)) {
      const i5 = t8.origin;
      n6[0] = i5.x, n6[1] = i5.y, n6[2] = i5.z, s.getLogger(p5).error(`Failed to project specified origin (wkid:${r6.spatialReference.wkid}) to mesh spatial reference (wkid:${t8.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
    }
    m5(t8.vertexAttributes.position, s6, n6), t8.vertexAttributesChanged();
  } else
    s.getLogger(p5).error(`Failed to project centerAt location (wkid:${i4.spatialReference.wkid}) to mesh spatial reference (wkid:${t8.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
}
function m5(e13, t8, i4) {
  if (e13)
    for (let r6 = 0; r6 < e13.length; r6 += 3)
      for (let o4 = 0; o4 < 3; o4++)
        e13[r6 + o4] += t8[o4] - i4[o4];
}
var j4 = n3();
var u5 = n3();
var k = n3();

// node_modules/@arcgis/core/geometry/support/meshUtils/loadExternal.js
async function c6(e13, r6, o4) {
  const { source: n6 } = r6, { loadGLTFMesh: i4 } = await h(import("./loadGLTFMesh-W4ICUUYV.js"), o4), a7 = await m6(n6, o4);
  s3(o4);
  const c8 = i4(new x({ x: 0, y: 0, z: 0, spatialReference: e13.spatialReference }), a7.url, { resolveFile: u6(a7), requestFile: void 0, useTransform: true, signal: o4 == null ? void 0 : o4.signal, expectedType: a7.type });
  c8.then(() => a7.dispose(), () => a7.dispose());
  const { vertexAttributes: f7, components: p8 } = await c8;
  e13.vertexAttributes = f7, e13.components = p8;
}
function u6(e13) {
  const t8 = Rt(e13.url);
  return (s6) => {
    const r6 = G(s6, t8, t8), o4 = r6 ? r6.replace(/^ *\.\//, "") : null;
    return (o4 ? e13.files.get(o4) : null) ?? s6;
  };
}
async function m6(t8, s6) {
  if (Array.isArray(t8)) {
    if (!t8.length)
      throw new s2("mesh-load-external:missing-assets", "There must be at least one file to load");
    return t8[0] instanceof File ? h7(t8) : w2(t8, s6);
  }
  return p6(t8);
}
async function f5(e13, t8) {
  const { parts: r6, assetMimeType: o4, assetName: n6 } = e13;
  if (1 === r6.length)
    return new T(r6[0].partUrl);
  const i4 = await e13.toBlob(t8);
  return s3(t8), T.fromBlob(i4, v3(n6, o4));
}
function p6(e13) {
  return T.fromBlob(e13, v3(e13.name, e13.type));
}
function h7(e13) {
  return j5(e13.map((e14) => ({ name: e14.name, mimeType: e14.type, source: p6(e14) })));
}
async function w2(e13, t8) {
  const i4 = await P(e13.map(async (e14) => {
    const r6 = await f5(e14);
    return s3(t8), { name: e14.assetName, mimeType: e14.assetMimeType, source: r6 };
  }));
  if (c(t8))
    throw i4.forEach((e14) => e14.source.dispose()), u();
  return j5(i4);
}
var y4 = /^model\/gltf\+json$/;
var d4 = /^model\/gltf-binary$/;
var g7 = /\.gltf$/i;
var b2 = /\.glb$/i;
function j5(t8) {
  const s6 = /* @__PURE__ */ new Map();
  let r6, o4 = null;
  for (const { name: e13, mimeType: n6, source: i4 } of t8)
    null === o4 && (y4.test(n6) || g7.test(e13) ? (o4 = i4.url, r6 = "gltf") : (d4.test(n6) || b2.test(e13)) && (o4 = i4.url, r6 = "glb")), s6.set(e13, i4.url), i4.files.forEach((e14, t9) => s6.set(t9, e14));
  if (null == o4)
    throw new s2("mesh-load-external:missing-files", "Missing files to load external mesh source");
  return new T(o4, () => t8.forEach(({ source: e13 }) => e13.dispose()), s6, r6);
}
var T = class _T {
  constructor(e13, t8 = () => {
  }, s6 = /* @__PURE__ */ new Map(), r6) {
    this.url = e13, this.dispose = t8, this.files = s6, this.type = r6;
  }
  static fromBlob(e13, t8) {
    const s6 = URL.createObjectURL(e13);
    return new _T(s6, () => URL.revokeObjectURL(s6), void 0, t8);
  }
};
function v3(e13, t8) {
  return y4.test(t8) || g7.test(e13) ? "gltf" : d4.test(t8) || g7.test(e13) ? "glb" : void 0;
}

// node_modules/@arcgis/core/geometry/support/meshUtils/Metadata.js
var a6 = class extends l {
  constructor() {
    super(), this.externalSources = new V(), this._explicitDisplaySource = null, this.addHandles(v(() => this.externalSources, "after-remove", ({ item: e13 }) => {
      e13 === this._explicitDisplaySource && (this._explicitDisplaySource = null);
    }, { sync: true, onListenerRemove: () => this._explicitDisplaySource = null }));
  }
  get displaySource() {
    return this._explicitDisplaySource ?? this._implicitDisplaySource;
  }
  set displaySource(e13) {
    if (null != e13 && !u3(e13))
      throw new Error("Cannot use this source for display: it is not in a supported format.");
    this._explicitDisplaySource = e13, e13 && this.externalSources.every((r6) => !y2(r6, e13)) && this.externalSources.add(e13);
  }
  clearSources() {
    this.externalSources.removeAll();
  }
  getExternalSourcesOnService(e13) {
    return this.externalSources.items.filter((r6) => h4(r6, e13));
  }
  get _implicitDisplaySource() {
    return this.externalSources.find(u3);
  }
};
e([y()], a6.prototype, "externalSources", void 0), e([y()], a6.prototype, "displaySource", null), e([y()], a6.prototype, "_implicitDisplaySource", null), e([y()], a6.prototype, "_explicitDisplaySource", void 0), a6 = e([c2("esri.geometry.support.meshUtils.Metadata")], a6);

// node_modules/@arcgis/core/geometry/support/meshUtils/offset.js
var j6 = "esri.geometry.support.meshUtils.offset";
function v4(t8, e13, n6) {
  var _a;
  if (!((_a = t8.vertexAttributes) == null ? void 0 : _a.position))
    return;
  const { vertexSpace: r6 } = t8;
  if (r6.isRelative)
    o2(r6, j6, n6), x2(r6, e13);
  else {
    r3(t8.spatialReference, n6) ? A2(t8, e13) : b3(t8, e13);
  }
}
function x2(t8, e13) {
  const n6 = t8.origin;
  t8.origin = u2(n3(), n6, e13);
}
function A2(e13, n6) {
  const r6 = e13.spatialReference, i4 = e13.vertexAttributes.position, a7 = e13.vertexAttributes.normal, u8 = e13.vertexAttributes.tangent, j8 = new Float64Array(i4.length), v6 = null != a7 ? new Float32Array(a7.length) : null, x5 = null != u8 ? new Float32Array(u8.length) : null, A5 = e13.extent.center, b5 = y5;
  L(r6, [A5.x, A5.y, A5.z], R2, c3(r6)), a2(d5, R2), S(b5, n6, d5), h3(i4, r6, j8), null != a7 && null != v6 && j2(a7, i4, j8, r6, v6), null != u8 && null != x5 && R(u8, i4, j8, r6, x5), k2(j8, b5), O2(j8, i4, r6), null != a7 && null != v6 && _(v6, i4, j8, r6, a7), null != u8 && null != x5 && v2(x5, i4, j8, r6, u8), e13.vertexAttributesChanged();
}
function b3(t8, e13) {
  k2(t8.vertexAttributes.position, e13), t8.vertexAttributesChanged();
}
function k2(t8, e13) {
  if (t8)
    for (let n6 = 0; n6 < t8.length; n6 += 3)
      for (let r6 = 0; r6 < 3; r6++)
        t8[n6 + r6] += e13[r6];
}
var y5 = n3();
var R2 = e5();
var d5 = e4();

// node_modules/@arcgis/core/geometry/support/meshUtils/primitives.js
function i3() {
  const { faceDescriptions: t8, faceVertexOffsets: e13, uvScales: n6 } = y6, r6 = 4 * t8.length, o4 = new Float64Array(3 * r6), s6 = new Float32Array(3 * r6), a7 = new Float32Array(2 * r6), i4 = new Uint32Array(2 * t8.length * 3);
  let l6 = 0, c8 = 0, f7 = 0, u8 = 0;
  for (let h10 = 0; h10 < t8.length; h10++) {
    const r7 = t8[h10], p8 = l6 / 3;
    for (const t9 of e13)
      i4[u8++] = p8 + t9;
    const w6 = r7.corners;
    for (let t9 = 0; t9 < 4; t9++) {
      const e14 = w6[t9];
      let i5 = 0;
      a7[f7++] = 0.25 * n6[t9][0] + r7.uvOrigin[0], a7[f7++] = r7.uvOrigin[1] - 0.25 * n6[t9][1];
      for (let t10 = 0; t10 < 3; t10++)
        0 !== r7.axis[t10] ? (o4[l6++] = 0.5 * r7.axis[t10], s6[c8++] = r7.axis[t10]) : (o4[l6++] = 0.5 * e14[i5++], s6[c8++] = 0);
    }
  }
  return { position: o4, normal: s6, uv: a7, faces: i4 };
}
function l5(t8, e13) {
  const n6 = t8.components[0], r6 = n6.faces, s6 = d6[e13], a7 = 6 * s6, i4 = new Array(6), l6 = new Array(r6.length - 6);
  let c8 = 0, f7 = 0;
  for (let o4 = 0; o4 < r6.length; o4++)
    o4 >= a7 && o4 < a7 + 6 ? i4[c8++] = r6[o4] : l6[f7++] = r6[o4];
  if (null != t8.vertexAttributes.uv) {
    const e14 = new Float32Array(t8.vertexAttributes.uv), n7 = 4 * s6 * 2, r7 = [0, 1, 1, 1, 1, 0, 0, 0];
    for (let t9 = 0; t9 < r7.length; t9++)
      e14[n7 + t9] = r7[t9];
    t8.vertexAttributes.uv = e14;
  }
  return t8.components = [new g4({ faces: i4, material: n6.material }), new g4({ faces: l6 })], t8;
}
function c7(t8 = 0) {
  const e13 = Math.round(8 * 2 ** t8), n6 = 2 * e13, r6 = (e13 - 1) * (n6 + 1) + 2 * n6, o4 = new Float64Array(3 * r6), s6 = new Float32Array(3 * r6), a7 = new Float32Array(2 * r6), i4 = new Uint32Array(3 * ((e13 - 1) * n6 * 2));
  let l6 = 0, c8 = 0, f7 = 0, u8 = 0;
  for (let h10 = 0; h10 <= e13; h10++) {
    const t9 = h10 / e13 * Math.PI + 0.5 * Math.PI, r7 = Math.cos(t9), p8 = Math.sin(t9);
    M3[2] = p8;
    const w6 = 0 === h10 || h10 === e13, m8 = w6 ? n6 - 1 : n6;
    for (let v6 = 0; v6 <= m8; v6++) {
      const t10 = v6 / m8 * 2 * Math.PI;
      M3[0] = -Math.sin(t10) * r7, M3[1] = Math.cos(t10) * r7;
      for (let e14 = 0; e14 < 3; e14++)
        o4[l6] = 0.5 * M3[e14], s6[l6] = M3[e14], ++l6;
      a7[c8++] = (v6 + (w6 ? 0.5 : 0)) / n6, a7[c8++] = h10 / e13, 0 !== h10 && v6 !== n6 && (h10 !== e13 && (i4[f7++] = u8, i4[f7++] = u8 + 1, i4[f7++] = u8 - n6), 1 !== h10 && (i4[f7++] = u8, i4[f7++] = u8 - n6, i4[f7++] = u8 - n6 - 1)), u8++;
    }
  }
  return { position: o4, normal: s6, uv: a7, faces: i4 };
}
function f6(t8 = 0) {
  const e13 = 5, n6 = Math.round(16 * 2 ** t8), r6 = (e13 - 1) * (n6 + 1) + 2 * n6, o4 = new Float64Array(3 * r6), s6 = new Float32Array(3 * r6), a7 = new Float32Array(2 * r6), i4 = new Uint32Array(3 * (4 * n6));
  let l6 = 0, c8 = 0, f7 = 0, u8 = 0, h10 = 0;
  for (let p8 = 0; p8 <= e13; p8++) {
    const t9 = 0 === p8 || p8 === e13, r7 = p8 <= 1 || p8 >= e13 - 1, w6 = 2 === p8 || 4 === p8, m8 = t9 ? n6 - 1 : n6;
    for (let v6 = 0; v6 <= m8; v6++) {
      const g9 = v6 / m8 * 2 * Math.PI, A5 = t9 ? 0 : 0.5;
      M3[0] = A5 * Math.sin(g9), M3[1] = A5 * -Math.cos(g9), M3[2] = p8 <= 2 ? 0.5 : -0.5;
      for (let t10 = 0; t10 < 3; t10++)
        o4[l6++] = M3[t10], s6[c8++] = r7 ? 2 === t10 ? p8 <= 1 ? 1 : -1 : 0 : 2 === t10 ? 0 : M3[t10] / A5;
      a7[f7++] = (v6 + (t9 ? 0.5 : 0)) / n6, a7[f7++] = p8 <= 1 ? 1 * p8 / 3 : p8 <= 3 ? 1 * (p8 - 2) / 3 + 1 / 3 : 1 * (p8 - 4) / 3 + 2 / 3, w6 || 0 === p8 || v6 === n6 || (p8 !== e13 && (i4[u8++] = h10, i4[u8++] = h10 + 1, i4[u8++] = h10 - n6), 1 !== p8 && (i4[u8++] = h10, i4[u8++] = h10 - n6, i4[u8++] = h10 - n6 - 1)), h10++;
    }
  }
  return { position: o4, normal: s6, uv: a7, faces: i4 };
}
function u7(t8, e13) {
  const n6 = "number" == typeof e13 ? e13 : null != e13 ? e13.width : 1, r6 = "number" == typeof e13 ? e13 : null != e13 ? e13.height : 1;
  switch (t8) {
    case "up":
    case "down":
      return { width: n6, depth: r6 };
    case "north":
    case "south":
      return { width: n6, height: r6 };
    case "east":
    case "west":
      return { depth: n6, height: r6 };
  }
}
function h8(t8) {
  const e13 = v5.facingAxisOrderSwap[t8], n6 = v5.position, r6 = v5.normal, o4 = new Float64Array(n6.length), s6 = new Float32Array(r6.length);
  let a7 = 0;
  for (let i4 = 0; i4 < 4; i4++) {
    const t9 = a7;
    for (let i5 = 0; i5 < 3; i5++) {
      const l6 = e13[i5], c8 = Math.abs(l6) - 1, f7 = l6 >= 0 ? 1 : -1;
      o4[a7] = n6[t9 + c8] * f7, s6[a7] = r6[t9 + c8] * f7, a7++;
    }
  }
  return { position: o4, normal: s6, uv: new Float32Array(v5.uv), faces: new Uint32Array(v5.faces), isPlane: true };
}
var p7 = 1;
var w3 = 2;
var m7 = 3;
var v5 = { position: [-0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0, -0.5, 0.5, 0], normal: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], uv: [0, 1, 1, 1, 1, 0, 0, 0], faces: [0, 1, 2, 0, 2, 3], facingAxisOrderSwap: { east: [m7, p7, w3], west: [-m7, -p7, w3], north: [-p7, m7, w3], south: [p7, -m7, w3], up: [p7, w3, m7], down: [p7, -w3, -m7] } };
function g8(t8, e13, n6) {
  t8.isPlane || A3(t8), x3(t8, n6 == null ? void 0 : n6.size);
  const { vertexAttributes: r6, vertexSpace: i4, transform: l6 } = B(t8, e13, n6);
  return { vertexAttributes: new p3({ ...r6, uv: t8.uv }), vertexSpace: i4, transform: l6, components: [new g4({ faces: t8.faces, material: (n6 == null ? void 0 : n6.material) || null })], spatialReference: e13.spatialReference };
}
function A3(t8) {
  for (let e13 = 0; e13 < t8.position.length; e13 += 3)
    t8.position[e13 + 2] += 0.5;
}
function x3(t8, r6) {
  if (null == r6)
    return;
  const o4 = "number" == typeof r6 ? [r6, r6, r6] : [null != r6.width ? r6.width : 1, null != r6.depth ? r6.depth : 1, null != r6.height ? r6.height : 1];
  F[0] = o4[0], F[4] = o4[1], F[8] = o4[2];
  for (let n6 = 0; n6 < t8.position.length; n6 += 3) {
    for (let e13 = 0; e13 < 3; e13++)
      M3[e13] = t8.position[n6 + e13];
    S(M3, M3, F);
    for (let e13 = 0; e13 < 3; e13++)
      t8.position[n6 + e13] = M3[e13];
  }
  if (o4[0] !== o4[1] || o4[1] !== o4[2]) {
    F[0] = 1 / o4[0], F[4] = 1 / o4[1], F[8] = 1 / o4[2];
    for (let r7 = 0; r7 < t8.normal.length; r7 += 3) {
      for (let e13 = 0; e13 < 3; e13++)
        M3[e13] = t8.normal[r7 + e13];
      S(M3, M3, F), z2(M3, M3);
      for (let e13 = 0; e13 < 3; e13++)
        t8.normal[r7 + e13] = M3[e13];
    }
  }
}
var y6 = { faceDescriptions: [{ axis: [0, -1, 0], uvOrigin: [0, 0.625], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [1, 0, 0], uvOrigin: [0.25, 0.625], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [0, 1, 0], uvOrigin: [0.5, 0.625], corners: [[1, -1], [-1, -1], [-1, 1], [1, 1]] }, { axis: [-1, 0, 0], uvOrigin: [0.75, 0.625], corners: [[1, -1], [-1, -1], [-1, 1], [1, 1]] }, { axis: [0, 0, 1], uvOrigin: [0, 0.375], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [0, 0, -1], uvOrigin: [0, 0.875], corners: [[-1, 1], [1, 1], [1, -1], [-1, -1]] }], uvScales: [[0, 0], [1, 0], [1, 1], [0, 1]], faceVertexOffsets: [0, 1, 2, 0, 2, 3] };
var d6 = { south: 0, east: 1, north: 2, west: 3, up: 4, down: 5 };
var M3 = n3();
var F = e4();

// node_modules/@arcgis/core/geometry/support/meshUtils/rotate.js
var T2 = "esri.geometry.support.meshUtils.rotate";
function U3(t8, e13, r6) {
  var _a;
  if (!((_a = t8.vertexAttributes) == null ? void 0 : _a.position) || 0 === e13[3])
    return;
  const { spatialReference: o4, vertexSpace: n6 } = t8;
  if (n6.isRelative) {
    o2(n6, T2, r6);
    const o5 = (r6 == null ? void 0 : r6.origin) ?? t8.origin;
    t8.transform ?? (t8.transform = new N()), z3(t8.transform, n6, e13, o5);
  } else {
    const n7 = (r6 == null ? void 0 : r6.origin) ?? t8.origin;
    r3(o4, r6) ? C(t8, e13, n7) : I3(t8, e13, n7);
  }
}
function z3(t8, e13, r6, o4) {
  const n6 = e13.origin, l6 = o($, o4.x, o4.y, o4.z ?? 0), c8 = e2($, l6, n6);
  t8.applyLocalInverse(c8, D2), t8.rotation = U(t8.rotation, r6, h2()), t8.applyLocalInverse(c8, c8), e2(c8, c8, D2), t8.translation = u2(n3(), t8.translation, c8);
}
function C(t8, r6, o4) {
  const n6 = t8.spatialReference, i4 = c3(n6), s6 = S2;
  e11(o4, s6, i4) || e11(t8.origin, s6, i4);
  const a7 = t8.vertexAttributes.position, c8 = t8.vertexAttributes.normal, f7 = t8.vertexAttributes.tangent, p8 = new Float64Array(a7.length), j8 = null != c8 ? new Float32Array(c8.length) : null, h10 = null != f7 ? new Float32Array(f7.length) : null;
  L(i4, s6, M4, i4), a2(O3, M4);
  const x5 = E;
  S(l2(E), l2(r6), O3), x5[3] = r6[3], h3(a7, n6, p8), null != c8 && null != j8 && j2(c8, a7, p8, n6, j8), null != f7 && null != h10 && R(f7, a7, p8, n6, h10), P2(p8, x5, 3, s6), O2(p8, a7, n6), null != c8 && null != j8 && (P2(j8, x5, 3), _(j8, a7, p8, n6, c8)), null != f7 && null != h10 && (P2(h10, x5, 4), v2(h10, a7, p8, n6, f7)), t8.vertexAttributesChanged();
}
function I3(e13, r6, o4) {
  const n6 = S2;
  if (!e11(o4, n6, e13.spatialReference)) {
    const r7 = e13.origin;
    n6[0] = r7.x, n6[1] = r7.y, n6[2] = r7.z, s.getLogger(T2).error(`Failed to project specified origin (wkid:${o4.spatialReference.wkid}) to mesh spatial reference (wkid:${e13.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
  }
  P2(e13.vertexAttributes.position, r6, 3, n6), P2(e13.vertexAttributes.normal, r6, 3), P2(e13.vertexAttributes.tangent, r6, 4), e13.vertexAttributesChanged();
}
function P2(t8, e13, r6, n6 = f2) {
  if (null != t8) {
    g2(M4, w(e13), l2(e13));
    for (let e14 = 0; e14 < t8.length; e14 += r6) {
      for (let r7 = 0; r7 < 3; r7++)
        $[r7] = t8[e14 + r7] - n6[r7];
      O($, $, M4);
      for (let r7 = 0; r7 < 3; r7++)
        t8[e14 + r7] = $[r7] + n6[r7];
    }
  }
}
var $ = n3();
var D2 = n3();
var E = h2();
var M4 = e5();
var O3 = e4();
var S2 = n3();

// node_modules/@arcgis/core/geometry/support/meshUtils/scale.js
var x4 = "esri.geometry.support.meshUtils.scale";
function d7(e13, t8, r6) {
  var _a;
  if (!((_a = e13.vertexAttributes) == null ? void 0 : _a.position))
    return;
  const { spatialReference: o4, vertexSpace: n6 } = e13;
  if (n6.isRelative) {
    o2(n6, x4, r6);
    const o5 = (r6 == null ? void 0 : r6.origin) ?? e13.origin;
    e13.transform ?? (e13.transform = new N()), A4(e13.transform, n6, t8, o5);
  } else {
    const n7 = r3(o4, r6), i4 = (r6 == null ? void 0 : r6.origin) ?? e13.origin;
    n7 ? b4(e13, t8, i4) : y7(e13, t8, i4);
  }
}
function A4(e13, s6, l6, a7) {
  const c8 = s6.origin, p8 = o(R3, a7.x, a7.y, a7.z), f7 = e2(R3, p8, c8);
  e13.applyLocalInverse(f7, k3);
  const u8 = g(n3(), e13.scale, l6);
  e13.scale = u8, e13.applyLocalInverse(f7, f7), e2(f7, f7, k3), e13.translation = u2(n3(), e13.translation, f7);
}
function b4(e13, t8, r6) {
  const o4 = e13.spatialReference, n6 = c3(o4), i4 = F2;
  e11(r6, i4, n6) || e11(e13.origin, i4, n6);
  const s6 = e13.vertexAttributes.position, c8 = e13.vertexAttributes.normal, p8 = e13.vertexAttributes.tangent, f7 = new Float64Array(s6.length), x5 = null != c8 ? new Float32Array(c8.length) : null, d9 = null != p8 ? new Float32Array(p8.length) : null;
  h3(s6, o4, f7), null != c8 && null != x5 && j2(c8, s6, f7, o4, x5), null != p8 && null != d9 && R(p8, s6, f7, o4, d9), w4(f7, t8, i4), O2(f7, s6, o4), null != c8 && null != x5 && _(x5, s6, f7, o4, c8), null != p8 && null != d9 && v2(d9, s6, f7, o4, p8), e13.vertexAttributesChanged();
}
function y7(t8, r6, o4) {
  const n6 = F2;
  if (!e11(o4, n6, t8.spatialReference)) {
    const r7 = t8.origin;
    n6[0] = r7.x, n6[1] = r7.y, n6[2] = r7.z, s.getLogger(x4).error(`Failed to project specified origin (wkid:${o4.spatialReference.wkid}) to mesh spatial reference (wkid:${t8.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
  }
  w4(t8.vertexAttributes.position, r6, n6), t8.vertexAttributesChanged();
}
function w4(e13, t8, r6 = f2) {
  if (e13)
    for (let n6 = 0; n6 < e13.length; n6 += 3) {
      for (let t9 = 0; t9 < 3; t9++)
        R3[t9] = e13[n6 + t9] - r6[t9];
      g(R3, R3, t8);
      for (let t9 = 0; t9 < 3; t9++)
        e13[n6 + t9] = R3[t9] + r6[t9];
    }
}
var R3 = n3();
var k3 = n3();
var F2 = n3();

// node_modules/@arcgis/core/support/zipUtils.js
async function e12(e13) {
  const r6 = [];
  for (const n6 of e13)
    n6.name.toLowerCase().endsWith(".zip") ? r6.push(t7(n6)) : r6.push(Promise.resolve(n6));
  return (await Promise.all(r6)).flat();
}
async function t7(e13) {
  const { BlobReader: t8, ZipReader: r6, BlobWriter: n6 } = await import("./zipjs-wrapper-ISCQIKVP.js"), a7 = [], i4 = new r6(new t8(e13));
  return (await i4.getEntries()).forEach((e14) => {
    var _a;
    if (e14.directory || /^__MACOS/i.test(e14.filename))
      return;
    const t9 = new n6(), r7 = (_a = e14.getData) == null ? void 0 : _a.call(e14, t9).then((t10) => new File([t10], e14.filename));
    r7 && a7.push(r7);
  }), Promise.all(a7);
}

// node_modules/@arcgis/core/geometry/Mesh.js
var J;
var Q = "esri.geometry.Mesh";
var X2 = { base: null, key: "type", defaultKeyValue: "georeferenced", typeMap: { georeferenced: p2, "georeferenced-relative": m2, local: m3 } };
var Y = J = class extends m.LoadableMixin(n(p)) {
  constructor(e13) {
    super(e13), this.components = null, this.vertexSpace = new p2(), this.transform = null, this.metadata = new a6(), this.hasZ = true, this.hasM = false, this.vertexAttributes = new p3(), this.type = "mesh";
  }
  initialize() {
    (0 === this.metadata.externalSources.length || this.vertexAttributes.position.length) && (this.loadStatus = "loaded"), this.when(() => {
      this.addHandles(d(() => {
        var _a;
        return { vertexAttributes: this.vertexAttributes, components: (_a = this.components) == null ? void 0 : _a.map((e13) => e13.clone()) };
      }, () => this._clearSources(), { once: true, sync: true }));
    });
  }
  get hasExtent() {
    var _a;
    return this.loaded ? this.vertexAttributes.position.length > 0 && (!this.components || this.components.length > 0) : null != ((_a = this.metadata.displaySource) == null ? void 0 : _a.extent);
  }
  get _transformedExtent() {
    const { components: e13, spatialReference: t8, vertexAttributes: r6, vertexSpace: s6 } = this, o4 = r6.position;
    if (0 === o4.length || e13 && 0 === e13.length)
      return new M({ xmin: 0, ymin: 0, zmin: 0, xmax: 0, ymax: 0, zmax: 0, spatialReference: t8 });
    if ("local" === s6.type) {
      const { _untransformedExtent: e14, transform: r7 } = this;
      return e10(e14, r7, s6, t8);
    }
    if ("georeferenced-relative" === s6.type) {
      const { transform: e14 } = this, r7 = I({ positions: o4, transform: e14, vertexSpace: s6, inSpatialReference: t8, outSpatialReference: t8 });
      return m4(r7, t8);
    }
    return m4(o4, t8);
  }
  get _untransformedExtent() {
    return m4(this.vertexAttributes.position, this.spatialReference);
  }
  get anchor() {
    const { vertexSpace: e13 } = this;
    if (e13.isRelative)
      return e13.getOriginPoint(this.spatialReference);
    const { center: t8, zmin: r6 } = this._transformedExtent;
    return new x({ x: t8.x, y: t8.y, z: r6, spatialReference: this.spatialReference });
  }
  get origin() {
    const { vertexSpace: e13 } = this;
    return e13.isRelative ? e13.getOriginPoint(this.spatialReference) : this._transformedExtent.center;
  }
  get extent() {
    var _a, _b;
    return this.loaded || null == ((_b = (_a = this.metadata) == null ? void 0 : _a.displaySource) == null ? void 0 : _b.extent) ? this._transformedExtent : this.metadata.displaySource.extent.clone();
  }
  addComponent(e13) {
    if (!this.loaded)
      return s.getLogger(this).error("addComponent()", new e7().message);
    this.components || (this.components = []), this.components.push(g4.from(e13)), this.notifyChange("components");
  }
  removeComponent(e13) {
    if (!this.loaded)
      return s.getLogger(this).error("removeComponent()", new e7().message);
    if (this.components) {
      const t8 = this.components.indexOf(e13);
      if (-1 !== t8)
        return this.components.splice(t8, 1), void this.notifyChange("components");
    }
    s.getLogger(this).error("removeComponent()", new t4().message);
  }
  rotate(e13, t8, r6, s6) {
    return g3(e13, t8, r6, ee), U3(this, ee, s6), this;
  }
  offset(e13, t8, r6, o4) {
    return this.loaded ? ($2[0] = e13, $2[1] = t8, $2[2] = r6, v4(this, $2, o4), this) : (s.getLogger(this).error("offset()", new e7().message), this);
  }
  scale(e13, t8) {
    return this.loaded ? (d7(this, e13, t8), this) : (s.getLogger(this).error("scale()", new e7().message), this);
  }
  centerAt(e13, t8) {
    return this.loaded ? (l4(this, e13, t8), this) : (s.getLogger(this).error("centerAt()", new e7().message), this);
  }
  load(e13) {
    const { metadata: { displaySource: t8 } } = this;
    return t8 && this.addResolvingPromise(c6(this, t8, e13)), Promise.resolve(this);
  }
  addExternalSources(e13) {
    this.metadata.externalSources.addMany(e13);
  }
  updateDisplaySource(e13) {
    this.metadata.displaySource = e13;
  }
  clone() {
    return this.cloneWithVertexSpace(this.vertexSpace.clone());
  }
  cloneWithVertexSpace(e13) {
    var _a;
    let t8 = null;
    if (this.components) {
      const e14 = /* @__PURE__ */ new Map(), r7 = /* @__PURE__ */ new Map();
      t8 = this.components.map((t9) => t9.cloneWithDeduplication(e14, r7));
    }
    const r6 = { components: t8, spatialReference: this.spatialReference, vertexAttributes: this.vertexAttributes.clone(), vertexSpace: e13, transform: ((_a = this.transform) == null ? void 0 : _a.clone()) ?? null, metadata: this.metadata.clone() };
    return new J(r6);
  }
  cloneShallow() {
    return new J({ components: this.components, spatialReference: this.spatialReference, vertexAttributes: this.vertexAttributes, vertexSpace: this.vertexSpace.clone(), transform: this.transform, metadata: this.metadata });
  }
  vertexAttributesChanged() {
    this.notifyChange("vertexAttributes");
  }
  async toBinaryGLTF(e13) {
    const t8 = import("./gltfexport-UGKDI426.js"), r6 = this.load(), s6 = await Promise.all([t8, r6]), { toBinaryGLTF: o4 } = s6[0];
    return o4(this, e13);
  }
  get memoryUsage() {
    let e13 = 0;
    if (e13 += this.vertexAttributes.memoryUsage, null != this.components)
      for (const t8 of this.components)
        e13 += t8.memoryUsage;
    return e13;
  }
  _clearSources() {
    this.metadata.clearSources();
  }
  static createBox(e13, t8) {
    if (!(e13 instanceof x))
      return s.getLogger(Q).error(".createBox()", new s5().message), null;
    const r6 = new J(g8(i3(), e13, t8));
    return (t8 == null ? void 0 : t8.imageFace) && "all" !== t8.imageFace ? l5(r6, t8.imageFace) : r6;
  }
  static createSphere(e13, t8) {
    return e13 instanceof x ? new J(g8(c7((t8 == null ? void 0 : t8.densificationFactor) || 0), e13, t8)) : (s.getLogger(Q).error(".createSphere()", new s5().message), null);
  }
  static createCylinder(e13, t8) {
    return e13 instanceof x ? new J(g8(f6((t8 == null ? void 0 : t8.densificationFactor) || 0), e13, t8)) : (s.getLogger(Q).error(".createCylinder()", new s5().message), null);
  }
  static createPlane(e13, t8) {
    if (!(e13 instanceof x))
      return s.getLogger(Q).error(".createPlane()", new s5().message), null;
    const r6 = (t8 == null ? void 0 : t8.facing) ?? "up", o4 = u7(r6, t8 == null ? void 0 : t8.size);
    return new J(g8(h8(r6), e13, { ...t8, size: o4 }));
  }
  static createFromPolygon(e13, t8) {
    if (!(e13 instanceof j))
      return s.getLogger(Q).error(".createFromPolygon()", new n5().message), null;
    const r6 = f3(e13);
    return new J({ vertexAttributes: new p3({ position: r6.position }), components: [new g4({ faces: r6.faces, shading: "flat", material: (t8 == null ? void 0 : t8.material) ?? null })], spatialReference: e13.spatialReference, vertexSpace: new p2() });
  }
  static async createFromGLTF(e13, t8, r6) {
    if (!(e13 instanceof x)) {
      const e14 = new s5();
      throw s.getLogger(Q).error(".createfromGLTF()", e14.message), e14;
    }
    const { loadGLTFMesh: o4 } = await h(import("./loadGLTFMesh-W4ICUUYV.js"), r6);
    return new J(await o4(e13, t8, r6));
  }
  static async createFromFiles(e13, t8, r6) {
    const o4 = (e14) => s.getLogger(Q).error(".createFromFiles()", e14.message);
    if (!(e13 instanceof x)) {
      const e14 = new s5();
      throw o4(e14), e14;
    }
    const n6 = r6 == null ? void 0 : r6.layer;
    if (!n6) {
      const e14 = new r5();
      throw o4(e14), e14;
    }
    const i4 = await J.extractAndFilterFiles(t8, n6), a7 = i4.reduce((e14, t9) => r4(n6.infoFor3D, t9) ? e14 + 1 : e14, 0);
    if (0 === a7) {
      const e14 = new c5();
      throw o4(e14), e14;
    }
    if (a7 > 1) {
      const e14 = new l3();
      throw o4(e14), e14;
    }
    const c8 = J.createWithExternalSource(e13, i4), [p8] = await n6.uploadAssets([c8], r6);
    return p8;
  }
  static async extractAndFilterFiles(e13, t8) {
    const r6 = t8 == null ? void 0 : t8.infoFor3D;
    if (!r6)
      return e13;
    return (await e12(e13)).filter((e14) => t3(r6, e14));
  }
  static createWithExternalSource(e13, t8, r6) {
    var _a;
    const s6 = (r6 == null ? void 0 : r6.extent) ?? null, { x: o4, y: n6, z: i4, spatialReference: a7 } = e13, c8 = ((_a = r6 == null ? void 0 : r6.transform) == null ? void 0 : _a.clone()) ?? new N(), p8 = (r6 == null ? void 0 : r6.vertexSpace) ?? new m3({ origin: [o4, n6, i4 ?? 0] }), m8 = { source: t8, extent: s6 }, l6 = new a6();
    return l6.externalSources.push(m8), new J({ metadata: l6, transform: c8, vertexSpace: p8, spatialReference: a7 });
  }
  static createIncomplete(e13, r6) {
    var _a;
    const { x: s6, y: o4, z: n6, spatialReference: i4 } = e13, a7 = ((_a = r6 == null ? void 0 : r6.transform) == null ? void 0 : _a.clone()) ?? new N(), c8 = (r6 == null ? void 0 : r6.vertexSpace) ?? new m3({ origin: [s6, o4, n6 ?? 0] }), p8 = new J({ transform: a7, vertexSpace: c8, spatialReference: i4 });
    return p8.addResolvingPromise(Promise.reject(new s2("mesh-incomplete", "Mesh resources are not complete"))), p8;
  }
};
e([y({ type: [g4], json: { write: true } })], Y.prototype, "components", void 0), e([y({ nonNullable: true, types: X2, constructOnly: true, json: { write: true } })], Y.prototype, "vertexSpace", void 0), e([y({ type: N, json: { write: true } })], Y.prototype, "transform", void 0), e([y({ constructOnly: true })], Y.prototype, "metadata", void 0), e([y()], Y.prototype, "hasExtent", null), e([y()], Y.prototype, "_transformedExtent", null), e([y()], Y.prototype, "_untransformedExtent", null), e([y()], Y.prototype, "anchor", null), e([y()], Y.prototype, "origin", null), e([y({ readOnly: true, json: { read: false } })], Y.prototype, "extent", null), e([y({ readOnly: true, json: { read: false, write: true, default: true } })], Y.prototype, "hasZ", void 0), e([y({ readOnly: true, json: { read: false, write: true, default: false } })], Y.prototype, "hasM", void 0), e([y({ type: p3, nonNullable: true, json: { write: true } })], Y.prototype, "vertexAttributes", void 0), Y = J = e([c2(Q)], Y);
var $2 = n3();
var ee = h2();
var te = Y;

// node_modules/@arcgis/core/rest/support/meshFeatureSet.js
var h9 = () => s.getLogger("esri.rest.support.meshFeatureSet");
function y8(t8, r6, o4) {
  const n6 = o4.features;
  o4.features = [], delete o4.geometryType;
  const s6 = d2.fromJSON(o4);
  if (s6.geometryType = "mesh", !o4.assetMaps)
    return s6;
  const i4 = M5(r6, o4.assetMaps), u8 = t8.sourceSpatialReference ?? f.WGS84, c8 = o4.globalIdFieldName, { outFields: f7 } = t8, m8 = null != f7 && f7.length > 0 ? E2(f7.includes("*") ? null : new Set(f7)) : () => ({});
  for (const a7 of n6) {
    const t9 = S3(a7, c8, u8, r6, i4);
    null != t9 && s6.features.push(new c4({ geometry: t9, attributes: m8(a7) }));
  }
  return s6;
}
function E2(e13) {
  return ({ attributes: t8 }) => {
    if (!t8)
      return {};
    if (!e13)
      return t8;
    for (const r6 in t8)
      e13.has(r6) || delete t8[r6];
    return t8;
  };
}
function S3(e13, t8, r6, o4, i4) {
  const a7 = e13.attributes[t8], f7 = i4.get(a7);
  if (null == f7)
    return h9().error("mesh-feature-set:asset-not-found", "Service returned a feature which was not found in the asset map", e13), null;
  if (!e13.geometry)
    return h9().error("mesh-feature-set:no-geometry", "Service returned a feature without geometry", e13), null;
  const { originPoint: m8, originVector: p8 } = d8(e13, r6, o4), l6 = M.fromJSON(e13.geometry);
  l6.spatialReference = r6;
  const g9 = j7(e13.attributes, o4), y9 = f7.projectVertices ? new m2({ origin: p8 }) : new m3({ origin: p8 }), E3 = T3(f7);
  return E3 ? te.createWithExternalSource(m8, E3, { extent: l6, transform: g9, vertexSpace: y9 }) : te.createIncomplete(m8, { extent: l6, transform: g9, vertexSpace: y9 });
}
function d8({ attributes: e13 }, t8, { transformFieldRoles: r6 }) {
  const n6 = e13[r6.originX], s6 = e13[r6.originY], a7 = e13[r6.originZ];
  return { originPoint: new x({ x: n6, y: s6, z: a7, spatialReference: t8 }), originVector: r2(n6, s6, a7) };
}
function j7(e13, { transformFieldRoles: t8 }) {
  return new N({ translation: [e13[t8.translationX], -e13[t8.translationZ], e13[t8.translationY]], rotationAxis: [e13[t8.rotationX], -e13[t8.rotationZ], e13[t8.rotationY]], rotationAngle: e13[t8.rotationDeg], scale: [e13[t8.scaleX], e13[t8.scaleZ], e13[t8.scaleY]] });
}
var w5;
function M5(e13, t8) {
  const o4 = /* @__PURE__ */ new Map();
  for (const n6 of t8) {
    const t9 = n6.parentGlobalId;
    if (null == t9)
      continue;
    const s6 = n6.assetName, i4 = n6.assetType, a7 = n6.assetHash, u8 = n6.assetURL, c8 = n6.conversionStatus, f7 = n6.seqNo, m8 = s4(i4, e13.supportedFormats);
    if (!m8) {
      h9().error("mesh-feature-set:unknown-format", `Service returned an asset of type ${i4}, but it does not list it as a supported type`);
      continue;
    }
    const p8 = r(o4, t9, () => ({ projectVertices: P3(n6.flags).projectVertices, files: /* @__PURE__ */ new Map() }));
    r(p8.files, s6, () => ({ name: s6, type: i4, mimeType: m8, status: D3(c8), parts: [] })).parts[f7] = { hash: a7, url: u8 };
  }
  return o4;
}
function T3(e13) {
  const t8 = Array.from(e13.files.values()), r6 = new Array();
  for (const o4 of t8) {
    if (o4.status !== w5.COMPLETED)
      return null;
    const e14 = new Array();
    for (const t9 of o4.parts) {
      if (!t9)
        return null;
      e14.push(new o3(t9.url, t9.hash));
    }
    r6.push(new i2(o4.name, o4.mimeType, e14));
  }
  return r6;
}
function D3(e13) {
  switch (e13) {
    case "COMPLETED":
    case "SUBMITTED":
      return w5.COMPLETED;
    case "INPROGRESS":
      return w5.PENDING;
    default:
      return w5.FAILED;
  }
}
function P3(e13) {
  return { projectVertices: e13.includes("PROJECT_VERTICES") };
}
!function(e13) {
  e13[e13.FAILED = 0] = "FAILED", e13[e13.PENDING = 1] = "PENDING", e13[e13.COMPLETED = 2] = "COMPLETED";
}(w5 || (w5 = {}));
export {
  M5 as assetMapFromAssetMapsJSON,
  S3 as extractMesh,
  y8 as meshFeatureSetFromJSON
};
//# sourceMappingURL=meshFeatureSet-YL5BDCNS.js.map
