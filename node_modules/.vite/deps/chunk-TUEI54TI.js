import {
  n as n2,
  o,
  r as r4,
  t
} from "./chunk-PRZWMTUS.js";
import {
  i as i3,
  l as l2
} from "./chunk-VHDTZ7JB.js";
import {
  C,
  D,
  E as E2,
  L as L2
} from "./chunk-RCLKRKWR.js";
import {
  e as e3
} from "./chunk-GLOKOXWD.js";
import {
  e,
  r as r2
} from "./chunk-4OLZTDWK.js";
import {
  x as x2
} from "./chunk-JYYKU27J.js";
import {
  e as e2
} from "./chunk-SKLWU2B3.js";
import {
  A,
  B,
  E,
  F,
  L,
  O,
  V,
  c as c2,
  d,
  g,
  i as i2,
  q,
  u as u2,
  w,
  x
} from "./chunk-YHB3DQSV.js";
import {
  r as r3
} from "./chunk-VKTTTBW2.js";
import {
  n
} from "./chunk-TWNBDJHC.js";
import {
  b as b2,
  c,
  f,
  i,
  p
} from "./chunk-F6MD5VOH.js";
import {
  _ as _2
} from "./chunk-6TJWLWLO.js";
import {
  _,
  j,
  nt,
  ot,
  tt
} from "./chunk-R5DM4YAB.js";
import {
  r2 as r
} from "./chunk-SBW6NNVI.js";
import {
  P,
  a,
  s as s3
} from "./chunk-RFPH3ZTZ.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import {
  I,
  b,
  l,
  u,
  y2 as y
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/chunks/vec42.js
function t2(t8, r8, f6) {
  if (t8.count !== r8.count)
    return void e3.error("source and destination buffers need to have the same number of elements");
  const n7 = t8.count, o8 = f6[0], u7 = f6[1], s6 = f6[2], d3 = f6[3], a3 = f6[4], i7 = f6[5], c5 = f6[6], p3 = f6[7], l7 = f6[8], m3 = f6[9], y2 = f6[10], B2 = f6[11], h = f6[12], S = f6[13], b3 = f6[14], g2 = f6[15], M = t8.typedBuffer, v = t8.typedBufferStride, _3 = r8.typedBuffer, j2 = r8.typedBufferStride;
  for (let e7 = 0; e7 < n7; e7++) {
    const t9 = e7 * v, r9 = e7 * j2, f7 = _3[r9], n8 = _3[r9 + 1], w2 = _3[r9 + 2], z2 = _3[r9 + 3];
    M[t9] = o8 * f7 + a3 * n8 + l7 * w2 + h * z2, M[t9 + 1] = u7 * f7 + i7 * n8 + m3 * w2 + S * z2, M[t9 + 2] = s6 * f7 + c5 * n8 + y2 * w2 + b3 * z2, M[t9 + 3] = d3 * f7 + p3 * n8 + B2 * w2 + g2 * z2;
  }
}
function r5(e7, t8, r8) {
  f2(e7.typedBuffer, t8.typedBuffer, r8, e7.typedBufferStride, t8.typedBufferStride);
}
function f2(t8, r8, f6, n7 = 4, o8 = n7) {
  if (t8.length / n7 != r8.length / o8)
    return void e3.error("source and destination buffers need to have the same number of elements");
  const u7 = t8.length / n7, s6 = f6[0], d3 = f6[1], a3 = f6[2], i7 = f6[3], c5 = f6[4], p3 = f6[5], l7 = f6[6], m3 = f6[7], y2 = f6[8];
  let B2 = 0, h = 0;
  for (let e7 = 0; e7 < u7; e7++) {
    const e8 = r8[B2], f7 = r8[B2 + 1], u8 = r8[B2 + 2], S = r8[B2 + 3];
    t8[h] = s6 * e8 + i7 * f7 + l7 * u8, t8[h + 1] = d3 * e8 + c5 * f7 + m3 * u8, t8[h + 2] = a3 * e8 + p3 * f7 + y2 * u8, t8[h + 3] = S, B2 += o8, h += n7;
  }
}
function n3(e7, t8) {
  const r8 = Math.min(e7.count, t8.count), f6 = e7.typedBuffer, n7 = e7.typedBufferStride, o8 = t8.typedBuffer, u7 = t8.typedBufferStride;
  for (let s6 = 0; s6 < r8; s6++) {
    const e8 = s6 * n7, t9 = s6 * u7, r9 = o8[t9], d3 = o8[t9 + 1], a3 = o8[t9 + 2], i7 = r9 * r9 + d3 * d3 + a3 * a3;
    if (i7 > 0) {
      const t10 = 1 / Math.sqrt(i7);
      f6[e8] = t10 * r9, f6[e8 + 1] = t10 * d3, f6[e8 + 2] = t10 * a3;
    }
  }
}
function o2(e7, t8, r8) {
  u3(e7.typedBuffer, t8, r8, e7.typedBufferStride);
}
function u3(e7, t8, r8, f6 = 4) {
  const n7 = Math.min(e7.length / f6, t8.count), o8 = t8.typedBuffer, u7 = t8.typedBufferStride;
  let s6 = 0, d3 = 0;
  for (let a3 = 0; a3 < n7; a3++)
    e7[d3] = r8 * o8[s6], e7[d3 + 1] = r8 * o8[s6 + 1], e7[d3 + 2] = r8 * o8[s6 + 2], e7[d3 + 3] = r8 * o8[s6 + 3], s6 += u7, d3 += f6;
}
var s4 = Object.freeze(Object.defineProperty({ __proto__: null, normalize: n3, scale: u3, scaleView: o2, transformMat3: f2, transformMat3View: r5, transformMat4: t2 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/vec22.js
function o3(e7, t8) {
  n4(e7.typedBuffer, t8.typedBuffer, e7.typedBufferStride, t8.typedBufferStride);
}
function n4(o8, n7, l7 = 2, u7 = l7) {
  const i7 = n7.length / 2;
  let a3 = 0, d3 = 0;
  if (y(n7) || l(n7)) {
    for (let e7 = 0; e7 < i7; ++e7)
      o8[a3] = n7[d3], o8[a3 + 1] = n7[d3 + 1], a3 += l7, d3 += u7;
    return;
  }
  const c5 = I(n7);
  if (b(n7))
    for (let e7 = 0; e7 < i7; ++e7)
      o8[a3] = Math.max(n7[d3] / c5, -1), o8[a3 + 1] = Math.max(n7[d3 + 1] / c5, -1), a3 += l7, d3 += u7;
  else
    for (let e7 = 0; e7 < i7; ++e7)
      o8[a3] = n7[d3] / c5, o8[a3 + 1] = n7[d3 + 1] / c5, a3 += l7, d3 += u7;
}
function l3(e7, t8, r8, f6) {
  const o8 = e7.typedBuffer, n7 = e7.typedBufferStride, l7 = (f6 == null ? void 0 : f6.count) ?? e7.count;
  let u7 = ((f6 == null ? void 0 : f6.dstIndex) ?? 0) * n7;
  for (let i7 = 0; i7 < l7; ++i7)
    o8[u7] = t8, o8[u7 + 1] = r8, u7 += n7;
}
var u4 = Object.freeze(Object.defineProperty({ __proto__: null, fill: l3, normalizeIntegerBuffer: n4, normalizeIntegerBufferView: o3 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/vec33.js
function e4(e7, f6) {
  t3(e7.typedBuffer, f6.typedBuffer, e7.typedBufferStride, f6.typedBufferStride);
}
function t3(e7, t8, f6 = 3, o8 = f6) {
  const r8 = t8.length / o8;
  let n7 = 0, u7 = 0;
  for (let c5 = 0; c5 < r8; ++c5)
    e7[n7] = t8[u7], e7[n7 + 1] = t8[u7 + 1], e7[n7 + 2] = t8[u7 + 2], n7 += f6, u7 += o8;
}
function f3(e7, t8, f6, o8, r8) {
  const n7 = e7.typedBuffer, u7 = e7.typedBufferStride, c5 = (r8 == null ? void 0 : r8.count) ?? e7.count;
  let d3 = ((r8 == null ? void 0 : r8.dstIndex) ?? 0) * u7;
  for (let l7 = 0; l7 < c5; ++l7)
    n7[d3] = t8, n7[d3 + 1] = f6, n7[d3 + 2] = o8, d3 += u7;
}
var o4 = Object.freeze(Object.defineProperty({ __proto__: null, copy: t3, copyView: e4, fill: f3 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/vec43.js
function e5(e7, f6) {
  t4(e7.typedBuffer, f6, e7.typedBufferStride);
}
function t4(e7, t8, f6 = 4) {
  const o8 = t8.typedBuffer, r8 = t8.typedBufferStride, n7 = t8.count;
  let u7 = 0, c5 = 0;
  for (let d3 = 0; d3 < n7; ++d3)
    e7[u7] = o8[c5], e7[u7 + 1] = o8[c5 + 1], e7[u7 + 2] = o8[c5 + 2], e7[u7 + 3] = o8[c5 + 3], u7 += f6, c5 += r8;
}
function f4(e7, t8, f6, o8, r8, n7) {
  const u7 = e7.typedBuffer, c5 = e7.typedBufferStride, d3 = (n7 == null ? void 0 : n7.count) ?? e7.count;
  let l7 = ((n7 == null ? void 0 : n7.dstIndex) ?? 0) * c5;
  for (let p3 = 0; p3 < d3; ++p3)
    u7[l7] = t8, u7[l7 + 1] = f6, u7[l7 + 2] = o8, u7[l7 + 3] = r8, l7 += c5;
}
var o5 = Object.freeze(Object.defineProperty({ __proto__: null, copy: t4, copyView: e5, fill: f4 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/views/3d/glTF/DefaultLoadingContext.js
var n5 = class {
  constructor(r8) {
    this._streamDataRequester = r8;
  }
  async loadJSON(r8, e7) {
    return this._load("json", r8, e7);
  }
  async loadBinary(r8, e7) {
    return tt(r8) ? (s3(e7), nt(r8)) : this._load("binary", r8, e7);
  }
  async loadImage(r8, e7) {
    return this._load("image", r8, e7);
  }
  async _load(a3, o8, i7) {
    if (null == this._streamDataRequester)
      return (await j(o8, { responseType: m[a3] })).data;
    const n7 = await _2(this._streamDataRequester.request(o8, a3, i7));
    if (true === n7.ok)
      return n7.value;
    throw a(n7.error), new s2("", `Request for resource failed: ${n7.error}`);
  }
};
var m = { image: "image", binary: "array-buffer", json: "json", "image+type": void 0 };

// node_modules/@arcgis/core/views/3d/glTF/LoaderResult.js
function r6(e7 = {}) {
  return { color: [1, 1, 1], opacity: 1, alphaMode: "OPAQUE", alphaCutoff: 0.5, doubleSided: false, castShadows: true, receiveShadows: true, receiveAmbientOcclustion: true, textureColor: null, textureNormal: null, textureOcclusion: null, textureEmissive: null, textureMetallicRoughness: null, colorTextureTransform: null, normalTextureTransform: null, occlusionTextureTransform: null, emissiveTextureTransform: null, metallicRoughnessTextureTransform: null, emissiveFactor: [0, 0, 0], metallicFactor: 1, roughnessFactor: 1, colorMixMode: "multiply", ...e7 };
}
function l4(r8, l7 = {}) {
  return { data: r8, parameters: { wrap: { s: D.REPEAT, t: D.REPEAT, ...l7.wrap }, noUnpackFlip: true, mipmap: false, ...l7 } };
}

// node_modules/@arcgis/core/chunks/scalar.js
function e6(e7, t8) {
  const o8 = e7.count;
  t8 || (t8 = new e7.TypedArrayConstructor(o8));
  for (let r8 = 0; r8 < o8; r8++)
    t8[r8] = e7.get(r8);
  return t8;
}
var t5 = Object.freeze(Object.defineProperty({ __proto__: null, makeDense: e6 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/views/3d/glTF/internal/BinaryStreamReader.js
var t6 = class {
  constructor(t8) {
    this._data = t8, this._offset4 = 0, this._dataUint32 = new Uint32Array(this._data, 0, Math.floor(this._data.byteLength / 4));
  }
  readUint32() {
    const t8 = this._offset4;
    return this._offset4 += 1, this._dataUint32[t8];
  }
  readUint8Array(t8) {
    const s6 = 4 * this._offset4;
    return this._offset4 += t8 / 4, new Uint8Array(this._data, s6, t8);
  }
  remainingBytes() {
    return this._data.byteLength - 4 * this._offset4;
  }
};

// node_modules/@arcgis/core/views/3d/glTF/internal/enums.js
var A2;
var E3;
!function(A3) {
  A3.SCALAR = "SCALAR", A3.VEC2 = "VEC2", A3.VEC3 = "VEC3", A3.VEC4 = "VEC4", A3.MAT2 = "MAT2", A3.MAT3 = "MAT3", A3.MAT4 = "MAT4";
}(A2 || (A2 = {})), function(A3) {
  A3[A3.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", A3[A3.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER";
}(E3 || (E3 = {}));

// node_modules/@arcgis/core/views/3d/glTF/internal/fillDefaults.js
var t7 = { baseColorFactor: [1, 1, 1, 1], metallicFactor: 1, roughnessFactor: 1 };
var a2 = { pbrMetallicRoughness: t7, emissiveFactor: [0, 0, 0], alphaMode: "OPAQUE", alphaCutoff: 0.5, doubleSided: false };
var l5 = { ESRI_externalColorMixMode: "tint" };
var i4 = (e7 = {}) => {
  const o8 = { ...t7, ...e7.pbrMetallicRoughness }, r8 = s5({ ...l5, ...e7.extras });
  return { ...a2, ...e7, pbrMetallicRoughness: o8, extras: r8 };
};
function s5(o8) {
  switch (o8.ESRI_externalColorMixMode) {
    case "multiply":
    case "tint":
    case "ignore":
    case "replace":
      break;
    default:
      n(o8.ESRI_externalColorMixMode), o8.ESRI_externalColorMixMode = "tint";
  }
  return o8;
}
var n6 = { magFilter: L2.LINEAR, minFilter: L2.LINEAR_MIPMAP_LINEAR, wrapS: D.REPEAT, wrapT: D.REPEAT };
var c3 = (e7) => ({ ...n6, ...e7 });

// node_modules/@arcgis/core/views/3d/glTF/internal/pathUtils.js
function r7(r8) {
  let e7, t8;
  return r8.replace(/^(.*\/)?([^/]*)$/, (r9, a3, i7) => (e7 = a3 || "", t8 = i7 || "", "")), { dirPart: e7, filePart: t8 };
}

// node_modules/@arcgis/core/views/3d/glTF/internal/Resource.js
var K = { MAGIC: 1179937895, CHUNK_TYPE_JSON: 1313821514, CHUNK_TYPE_BIN: 5130562, MIN_HEADER_LENGTH: 20 };
var Y = class _Y {
  constructor(t8, r8, o8, n7) {
    if (this._context = t8, this.uri = r8, this.json = o8, this._glbBuffer = n7, this._bufferLoaders = /* @__PURE__ */ new Map(), this._textureLoaders = /* @__PURE__ */ new Map(), this._textureCache = /* @__PURE__ */ new Map(), this._materialCache = /* @__PURE__ */ new Map(), this._nodeParentMap = /* @__PURE__ */ new Map(), this._nodeTransformCache = /* @__PURE__ */ new Map(), this._supportedExtensions = ["KHR_texture_basisu"], this._baseUri = r7(this.uri).dirPart, this._checkVersionSupported(), this._checkRequiredExtensionsSupported(), null == o8.scenes)
      throw new s2("gltf-loader-unsupported-feature", "Scenes must be defined.");
    if (null == o8.meshes)
      throw new s2("gltf-loader-unsupported-feature", "Meshes must be defined");
    if (null == o8.nodes)
      throw new s2("gltf-loader-unsupported-feature", "Nodes must be defined.");
    this._computeNodeParents();
  }
  static async load(t8, r8, o8) {
    if (tt(r8)) {
      const e7 = ot(r8);
      if (e7 && "model/gltf-binary" !== e7.mediaType)
        try {
          const o10 = JSON.parse(e7.isBase64 ? atob(e7.data) : e7.data);
          return new _Y(t8, r8, o10);
        } catch {
        }
      const o9 = nt(r8);
      if (_Y._isGLBData(o9))
        return this._fromGLBData(t8, r8, o9);
    }
    if (Q.test(r8) || "gltf" === (o8 == null ? void 0 : o8.expectedType)) {
      const e7 = await t8.loadJSON(r8, o8);
      return new _Y(t8, r8, e7);
    }
    const i7 = await t8.loadBinary(r8, o8);
    if (_Y._isGLBData(i7))
      return this._fromGLBData(t8, r8, i7);
    if (Z.test(r8) || "glb" === (o8 == null ? void 0 : o8.expectedType))
      throw new s2("gltf-loader-invalid-glb", "This is not a valid glb file.");
    const u7 = await t8.loadJSON(r8, o8);
    return new _Y(t8, r8, u7);
  }
  static _isGLBData(e7) {
    if (null == e7)
      return false;
    const t8 = new t6(e7);
    return t8.remainingBytes() >= 4 && t8.readUint32() === K.MAGIC;
  }
  static async _fromGLBData(e7, t8, r8) {
    const o8 = await _Y._parseGLBData(r8);
    return new _Y(e7, t8, o8.json, o8.binaryData);
  }
  static async _parseGLBData(r8) {
    const o8 = new t6(r8);
    if (o8.remainingBytes() < 12)
      throw new s2("gltf-loader-error", "glb binary data is insufficiently large.");
    const n7 = o8.readUint32(), s6 = o8.readUint32(), a3 = o8.readUint32();
    if (n7 !== K.MAGIC)
      throw new s2("gltf-loader-error", "Magic first 4 bytes do not fit to expected glb value.");
    if (r8.byteLength < a3)
      throw new s2("gltf-loader-error", "glb binary data is smaller than header specifies.");
    if (2 !== s6)
      throw new s2("gltf-loader-unsupported-feature", "An unsupported glb container version was detected. Only version 2 is supported.");
    let i7, u7, f6 = 0;
    for (; o8.remainingBytes() >= 8; ) {
      const r9 = o8.readUint32(), n8 = o8.readUint32();
      if (0 === f6) {
        if (n8 !== K.CHUNK_TYPE_JSON)
          throw new s2("gltf-loader-error", "First glb chunk must be JSON.");
        if (r9 < 0)
          throw new s2("gltf-loader-error", "No JSON data found.");
        i7 = await n2(o8.readUint8Array(r9));
      } else if (1 === f6) {
        if (n8 !== K.CHUNK_TYPE_BIN)
          throw new s2("gltf-loader-unsupported-feature", "Second glb chunk expected to be BIN.");
        u7 = o8.readUint8Array(r9);
      } else
        s.getLogger("esri.views.3d.glTF").warn("[Unsupported Feature] More than 2 glb chunks detected. Skipping.");
      f6 += 1;
    }
    if (!i7)
      throw new s2("gltf-loader-error", "No glb JSON chunk detected.");
    return { json: i7, binaryData: u7 };
  }
  async getBuffer(t8, r8) {
    const o8 = this.json.buffers[t8];
    if (null == o8.uri) {
      if (null == this._glbBuffer)
        throw new s2("gltf-loader-error", "glb buffer not present");
      return this._glbBuffer;
    }
    const n7 = await this._getBufferLoader(t8, r8);
    if (n7.byteLength !== o8.byteLength)
      throw new s2("gltf-loader-error", "Buffer byte lengths should match.");
    return n7;
  }
  async _getBufferLoader(e7, t8) {
    const r8 = this._bufferLoaders.get(e7);
    if (r8)
      return r8;
    const o8 = this.json.buffers[e7].uri, n7 = this._context.loadBinary(this._resolveUri(o8), t8).then((e8) => new Uint8Array(e8));
    return this._bufferLoaders.set(e7, n7), n7;
  }
  async getAccessor(t8, r8) {
    if (!this.json.accessors)
      throw new s2("gltf-loader-unsupported-feature", "Accessors missing.");
    const o8 = this.json.accessors[t8];
    if (null == (o8 == null ? void 0 : o8.bufferView))
      throw new s2("gltf-loader-unsupported-feature", "Some accessor does not specify a bufferView.");
    if (o8.type in [A2.MAT2, A2.MAT3, A2.MAT4])
      throw new s2("gltf-loader-unsupported-feature", `AttributeType ${o8.type} is not supported`);
    const n7 = this.json.bufferViews[o8.bufferView], s6 = await this.getBuffer(n7.buffer, r8), a3 = X[o8.type], i7 = $[o8.componentType], u7 = a3 * i7, f6 = n7.byteStride || u7;
    return { raw: s6.buffer, byteStride: f6, byteOffset: s6.byteOffset + (n7.byteOffset || 0) + (o8.byteOffset || 0), entryCount: o8.count, isDenselyPacked: f6 === u7, componentCount: a3, componentByteSize: i7, componentType: o8.componentType, min: o8.min, max: o8.max, normalized: !!o8.normalized };
  }
  async getIndexData(e7, t8) {
    if (null == e7.indices)
      return;
    const r8 = await this.getAccessor(e7.indices, t8);
    if (r8.isDenselyPacked)
      switch (r8.componentType) {
        case C.UNSIGNED_BYTE:
          return new Uint8Array(r8.raw, r8.byteOffset, r8.entryCount);
        case C.UNSIGNED_SHORT:
          return new Uint16Array(r8.raw, r8.byteOffset, r8.entryCount);
        case C.UNSIGNED_INT:
          return new Uint32Array(r8.raw, r8.byteOffset, r8.entryCount);
      }
    else
      switch (r8.componentType) {
        case C.UNSIGNED_BYTE:
          return e6(this._wrapAccessor(d, r8));
        case C.UNSIGNED_SHORT:
          return e6(this._wrapAccessor(g, r8));
        case C.UNSIGNED_INT:
          return e6(this._wrapAccessor(B, r8));
      }
  }
  async getPositionData(t8, r8) {
    if (null == t8.attributes.POSITION)
      throw new s2("gltf-loader-unsupported-feature", "No POSITION vertex data found.");
    const o8 = await this.getAccessor(t8.attributes.POSITION, r8);
    if (o8.componentType !== C.FLOAT)
      throw new s2("gltf-loader-unsupported-feature", "Expected type FLOAT for POSITION vertex attribute, but found " + C[o8.componentType]);
    if (3 !== o8.componentCount)
      throw new s2("gltf-loader-unsupported-feature", "POSITION vertex attribute must have 3 components, but found " + o8.componentCount.toFixed());
    return this._wrapAccessor(i2, o8);
  }
  async getNormalData(t8, r8) {
    if (null == t8.attributes.NORMAL)
      throw new s2("gltf-loader-error", "No NORMAL vertex data found.");
    const o8 = await this.getAccessor(t8.attributes.NORMAL, r8);
    if (o8.componentType !== C.FLOAT)
      throw new s2("gltf-loader-unsupported-feature", "Expected type FLOAT for NORMAL vertex attribute, but found " + C[o8.componentType]);
    if (3 !== o8.componentCount)
      throw new s2("gltf-loader-unsupported-feature", "NORMAL vertex attribute must have 3 components, but found " + o8.componentCount.toFixed());
    return this._wrapAccessor(i2, o8);
  }
  async getTangentData(t8, r8) {
    if (null == t8.attributes.TANGENT)
      throw new s2("gltf-loader-error", "No TANGENT vertex data found.");
    const o8 = await this.getAccessor(t8.attributes.TANGENT, r8);
    if (o8.componentType !== C.FLOAT)
      throw new s2("gltf-loader-unsupported-feature", "Expected type FLOAT for TANGENT vertex attribute, but found " + C[o8.componentType]);
    if (4 !== o8.componentCount)
      throw new s2("gltf-loader-unsupported-feature", "TANGENT vertex attribute must have 4 components, but found " + o8.componentCount.toFixed());
    return new c2(o8.raw, o8.byteOffset, o8.byteStride, o8.byteOffset + o8.byteStride * o8.entryCount);
  }
  async getTextureCoordinates(t8, r8) {
    if (null == t8.attributes.TEXCOORD_0)
      throw new s2("gltf-loader-error", "No TEXCOORD_0 vertex data found.");
    const o8 = await this.getAccessor(t8.attributes.TEXCOORD_0, r8);
    if (2 !== o8.componentCount)
      throw new s2("gltf-loader-unsupported-feature", "TEXCOORD_0 vertex attribute must have 2 components, but found " + o8.componentCount.toFixed());
    if (o8.componentType === C.FLOAT)
      return this._wrapAccessor(u2, o8);
    if (!o8.normalized)
      throw new s2("gltf-loader-unsupported-feature", "Integer component types are only supported for a normalized accessor for TEXCOORD_0.");
    return W(o8);
  }
  async getVertexColors(t8, r8) {
    if (null == t8.attributes.COLOR_0)
      throw new s2("gltf-loader-error", "No COLOR_0 vertex data found.");
    const o8 = await this.getAccessor(t8.attributes.COLOR_0, r8);
    if (4 !== o8.componentCount && 3 !== o8.componentCount)
      throw new s2("gltf-loader-unsupported-feature", "COLOR_0 attribute must have 3 or 4 components, but found " + o8.componentCount.toFixed());
    if (4 === o8.componentCount) {
      if (o8.componentType === C.FLOAT)
        return this._wrapAccessor(c2, o8);
      if (o8.componentType === C.UNSIGNED_BYTE)
        return this._wrapAccessor(x, o8);
      if (o8.componentType === C.UNSIGNED_SHORT)
        return this._wrapAccessor(L, o8);
    } else if (3 === o8.componentCount) {
      if (o8.componentType === C.FLOAT)
        return this._wrapAccessor(i2, o8);
      if (o8.componentType === C.UNSIGNED_BYTE)
        return this._wrapAccessor(O, o8);
      if (o8.componentType === C.UNSIGNED_SHORT)
        return this._wrapAccessor(E, o8);
    }
    throw new s2("gltf-loader-unsupported-feature", "Unsupported component type for COLOR_0 attribute: " + C[o8.componentType]);
  }
  hasPositions(e7) {
    return void 0 !== e7.attributes.POSITION;
  }
  hasNormals(e7) {
    return void 0 !== e7.attributes.NORMAL;
  }
  hasVertexColors(e7) {
    return void 0 !== e7.attributes.COLOR_0;
  }
  hasTextureCoordinates(e7) {
    return void 0 !== e7.attributes.TEXCOORD_0;
  }
  hasTangents(e7) {
    return void 0 !== e7.attributes.TANGENT;
  }
  async getMaterial(e7, t8, r8) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    let o8 = e7.material ? this._materialCache.get(e7.material) : void 0;
    if (!o8) {
      const n7 = null != e7.material ? i4(this.json.materials[e7.material]) : i4(), s6 = n7.pbrMetallicRoughness, a3 = this.hasVertexColors(e7), i7 = this.getTexture(s6.baseColorTexture, t8), u7 = this.getTexture(n7.normalTexture, t8), f6 = r8 ? this.getTexture(n7.occlusionTexture, t8) : void 0, c5 = r8 ? this.getTexture(n7.emissiveTexture, t8) : void 0, d3 = r8 ? this.getTexture(s6.metallicRoughnessTexture, t8) : void 0, l7 = null != e7.material ? e7.material : -1;
      o8 = { alphaMode: n7.alphaMode, alphaCutoff: n7.alphaCutoff, color: s6.baseColorFactor, doubleSided: !!n7.doubleSided, colorTexture: await i7, normalTexture: await u7, name: n7.name, id: l7, occlusionTexture: await f6, emissiveTexture: await c5, emissiveFactor: n7.emissiveFactor, metallicFactor: s6.metallicFactor, roughnessFactor: s6.roughnessFactor, metallicRoughnessTexture: await d3, hasVertexColors: a3, ESRI_externalColorMixMode: n7.extras.ESRI_externalColorMixMode, colorTextureTransform: (_b = (_a = s6 == null ? void 0 : s6.baseColorTexture) == null ? void 0 : _a.extensions) == null ? void 0 : _b.KHR_texture_transform, normalTextureTransform: (_d = (_c = n7.normalTexture) == null ? void 0 : _c.extensions) == null ? void 0 : _d.KHR_texture_transform, occlusionTextureTransform: (_f = (_e = n7.occlusionTexture) == null ? void 0 : _e.extensions) == null ? void 0 : _f.KHR_texture_transform, emissiveTextureTransform: (_h = (_g = n7.emissiveTexture) == null ? void 0 : _g.extensions) == null ? void 0 : _h.KHR_texture_transform, metallicRoughnessTextureTransform: (_j = (_i = s6 == null ? void 0 : s6.metallicRoughnessTexture) == null ? void 0 : _i.extensions) == null ? void 0 : _j.KHR_texture_transform };
    }
    return o8;
  }
  async getTexture(t8, o8) {
    if (!t8)
      return;
    if (0 !== (t8.texCoord || 0))
      throw new s2("gltf-loader-unsupported-feature", "Only TEXCOORD with index 0 is supported.");
    const n7 = t8.index, s6 = this.json.textures[n7], a3 = c3(null != s6.sampler ? this.json.samplers[s6.sampler] : {}), i7 = this._getTextureSourceId(s6), u7 = this.json.images[i7], f6 = await this._loadTextureImageData(n7, s6, o8);
    return r(this._textureCache, n7, () => {
      const t9 = (e7) => 33071 === e7 || 33648 === e7 || 10497 === e7, r8 = (t10) => {
        throw new s2("gltf-loader-error", `Unexpected TextureSampler WrapMode: ${t10}`);
      };
      return { data: f6, wrapS: t9(a3.wrapS) ? a3.wrapS : r8(a3.wrapS), wrapT: t9(a3.wrapT) ? a3.wrapT : r8(a3.wrapT), minFilter: a3.minFilter, name: u7.name, id: n7 };
    });
  }
  getNodeTransform(e7) {
    if (void 0 === e7)
      return q2;
    let t8 = this._nodeTransformCache.get(e7);
    if (!t8) {
      const r8 = this.getNodeTransform(this._getNodeParent(e7)), o8 = this.json.nodes[e7];
      o8.matrix ? t8 = c(e(), r8, o8.matrix) : o8.translation || o8.rotation || o8.scale ? (t8 = r2(r8), o8.translation && i(t8, t8, o8.translation), o8.rotation && (z[3] = x2(z, o8.rotation), b2(t8, t8, z[3], z)), o8.scale && f(t8, t8, o8.scale)) : t8 = r2(r8), this._nodeTransformCache.set(e7, t8);
    }
    return t8;
  }
  _wrapAccessor(e7, t8) {
    return new e7(t8.raw, t8.byteOffset, t8.byteStride, t8.byteOffset + t8.byteStride * (t8.entryCount - 1) + t8.componentByteSize * t8.componentCount);
  }
  _resolveUri(e7) {
    return _(e7, this._baseUri);
  }
  _getNodeParent(e7) {
    return this._nodeParentMap.get(e7);
  }
  _checkVersionSupported() {
    const e7 = r3.parse(this.json.asset.version, "glTF");
    J.validate(e7);
  }
  _checkRequiredExtensionsSupported() {
    const t8 = this.json;
    if (t8.extensionsRequired) {
      if (!t8.extensionsRequired.every((e7) => this._supportedExtensions.includes(e7)))
        throw new s2("gltf-loader-unsupported-feature", "gltf loader was not able to load unsupported feature. Required extensions: " + t8.extensionsRequired.join(", "));
    }
  }
  _computeNodeParents() {
    this.json.nodes.forEach((e7, t8) => {
      e7.children && e7.children.forEach((e8) => {
        this._nodeParentMap.set(e8, t8);
      });
    });
  }
  async _loadTextureImageData(e7, t8, r8) {
    const o8 = this._textureLoaders.get(e7);
    if (o8)
      return o8;
    const n7 = this._createTextureLoader(t8, r8);
    return this._textureLoaders.set(e7, n7), n7;
  }
  _getTextureSourceId(t8) {
    if (void 0 !== t8.extensions && null !== t8.extensions.KHR_texture_basisu)
      return t8.extensions.KHR_texture_basisu.source;
    if (null !== t8.source)
      return t8.source;
    throw new s2("gltf-loader-unsupported-feature", "Source is expected to be defined for a texture. It can also be omitted in favour of an KHR_texture_basisu extension tag.");
  }
  async _createTextureLoader(t8, r8) {
    const o8 = this._getTextureSourceId(t8), n7 = this.json.images[o8];
    if (n7.uri) {
      if (n7.uri.endsWith(".ktx2")) {
        const e7 = await this._context.loadBinary(this._resolveUri(n7.uri), r8);
        return new t(new Uint8Array(e7));
      }
      return this._context.loadImage(this._resolveUri(n7.uri), r8);
    }
    if (null == n7.bufferView)
      throw new s2("gltf-loader-unsupported-feature", "Image bufferView must be defined.");
    if (null == n7.mimeType)
      throw new s2("gltf-loader-unsupported-feature", "Image mimeType must be defined.");
    const s6 = this.json.bufferViews[n7.bufferView], a3 = await this.getBuffer(s6.buffer, r8);
    if (null != s6.byteStride)
      throw new s2("gltf-loader-unsupported-feature", "byteStride not supported for image buffer");
    const i7 = a3.byteOffset + (s6.byteOffset || 0);
    return o(new Uint8Array(a3.buffer, i7, s6.byteLength), n7.mimeType);
  }
  async getLoadedBuffersSize() {
    if (this._glbBuffer)
      return this._glbBuffer.byteLength;
    const e7 = await P(Array.from(this._bufferLoaders.values())), t8 = await P(Array.from(this._textureLoaders.values()));
    return e7.reduce((e8, t9) => e8 + ((t9 == null ? void 0 : t9.byteLength) ?? 0), 0) + t8.reduce((e8, t9) => e8 + (t9 ? r4(t9) ? t9.data.byteLength : t9.width * t9.height * 4 : 0), 0);
  }
};
var q2 = p(e(), Math.PI / 2);
var J = new r3(2, 0, "glTF");
var z = e2();
var X = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
var $ = { [C.BYTE]: 1, [C.UNSIGNED_BYTE]: 1, [C.SHORT]: 2, [C.UNSIGNED_SHORT]: 2, [C.FLOAT]: 4, [C.INT]: 4, [C.UNSIGNED_INT]: 4 };
function W(e7) {
  switch (e7.componentType) {
    case C.BYTE:
      return new V(e7.raw, e7.byteOffset, e7.byteStride, e7.byteOffset + e7.byteStride * e7.entryCount);
    case C.UNSIGNED_BYTE:
      return new A(e7.raw, e7.byteOffset, e7.byteStride, e7.byteOffset + e7.byteStride * e7.entryCount);
    case C.SHORT:
      return new q(e7.raw, e7.byteOffset, e7.byteStride, e7.byteOffset + e7.byteStride * e7.entryCount);
    case C.UNSIGNED_SHORT:
      return new w(e7.raw, e7.byteOffset, e7.byteStride, e7.byteOffset + e7.byteStride * e7.entryCount);
    case C.UNSIGNED_INT:
      return new F(e7.raw, e7.byteOffset, e7.byteStride, e7.byteOffset + e7.byteStride * e7.entryCount);
    case C.FLOAT:
      return new u2(e7.raw, e7.byteOffset, e7.byteStride, e7.byteOffset + e7.byteStride * e7.entryCount);
  }
}
var Q = /\.gltf$/i;
var Z = /\.glb$/i;

// node_modules/@arcgis/core/views/3d/glTF/loader.js
var i5 = 0;
async function l6(t8, r8, a3 = {}, l7 = true) {
  const m3 = await Y.load(t8, r8, a3), p3 = "gltf_" + i5++, T = { lods: [], materials: /* @__PURE__ */ new Map(), textures: /* @__PURE__ */ new Map(), meta: u5(m3) }, f6 = !(!m3.json.asset.extras || "symbolResource" !== m3.json.asset.extras.ESRI_type), x3 = /* @__PURE__ */ new Map();
  await c4(m3, async (t9, r9, s6, i7) => {
    var _a;
    const u7 = x3.get(s6) ?? 0;
    x3.set(s6, u7 + 1);
    const c5 = void 0 !== t9.mode ? t9.mode : E2.TRIANGLES, f7 = c5 === E2.TRIANGLES || c5 === E2.TRIANGLE_STRIP || c5 === E2.TRIANGLE_FAN ? c5 : null;
    if (null == f7)
      return void s.getLogger("esri.views.3d.glTF").warn("[Unsupported Feature] Unsupported primitive mode (" + E2[c5] + "). Skipping primitive.");
    if (!m3.hasPositions(t9))
      return void s.getLogger("esri.views.3d.glTF").warn("Skipping primitive without POSITION vertex attribute.");
    const g3 = m3.getPositionData(t9, a3), h = m3.getMaterial(t9, a3, l7), w2 = m3.hasNormals(t9) ? m3.getNormalData(t9, a3) : null, v = m3.hasTangents(t9) ? m3.getTangentData(t9, a3) : null, R = m3.hasTextureCoordinates(t9) ? m3.getTextureCoordinates(t9, a3) : null, S = m3.hasVertexColors(t9) ? m3.getVertexColors(t9, a3) : null, _3 = m3.getIndexData(t9, a3), E4 = { name: i7, transform: r2(r9), attributes: { position: await g3, normal: w2 ? await w2 : null, texCoord0: R ? await R : null, color: S ? await S : null, tangent: v ? await v : null }, indices: await _3, primitiveType: f7, material: d2(T, await h, p3) };
    let I2 = null;
    null != ((_a = T.meta) == null ? void 0 : _a.ESRI_lod) && "screenSpaceRadius" === T.meta.ESRI_lod.metric && (I2 = T.meta.ESRI_lod.thresholds[s6]), T.lods[s6] = T.lods[s6] || { parts: [], name: i7, lodThreshold: I2 }, T.lods[s6].parts[u7] = E4;
  });
  for (const e7 of T.lods)
    e7.parts = e7.parts.filter((e8) => !!e8);
  const g2 = await m3.getLoadedBuffersSize();
  return { model: T, meta: { isEsriSymbolResource: f6, uri: m3.uri }, customMeta: {}, size: g2 };
}
function u5(e7) {
  const o8 = e7.json;
  let t8 = null;
  return o8.nodes.forEach((e8) => {
    const o9 = e8.extras;
    null != o9 && (o9.ESRI_proxyEllipsoid || o9.ESRI_lod) && (t8 = o9);
  }), t8;
}
async function c4(o8, t8) {
  const r8 = o8.json, s6 = r8.scenes[r8.scene || 0].nodes, a3 = s6.length > 1, n7 = [];
  for (const e7 of s6) {
    const o9 = r8.nodes[e7];
    if (n7.push(i7(e7, 0)), m2(o9) && !a3) {
      o9.extensions.MSFT_lod.ids.forEach((e8, o10) => i7(e8, o10 + 1));
    }
  }
  async function i7(s7, a4) {
    const l7 = r8.nodes[s7], u7 = o8.getNodeTransform(s7);
    if (null != l7.weights && s.getLogger("esri.views.3d.glTF").warn("[Unsupported Feature] Morph targets are not supported."), null != l7.mesh) {
      const e7 = r8.meshes[l7.mesh];
      for (const o9 of e7.primitives)
        n7.push(t8(o9, u7, a4, e7.name));
    }
    for (const e7 of l7.children || [])
      n7.push(i7(e7, a4));
  }
  await Promise.all(n7);
}
function m2(e7) {
  var _a;
  return ((_a = e7.extensions) == null ? void 0 : _a.MSFT_lod) && Array.isArray(e7.extensions.MSFT_lod.ids);
}
function d2(e7, o8, s6) {
  const a3 = (o9) => {
    const t8 = `${s6}_tex_${o9 && o9.id}${(o9 == null ? void 0 : o9.name) ? "_" + o9.name : ""}`;
    if (o9 && !e7.textures.has(t8)) {
      const s7 = l4(o9.data, { wrap: { s: o9.wrapS, t: o9.wrapT }, mipmap: p2.has(o9.minFilter), noUnpackFlip: true });
      e7.textures.set(t8, s7);
    }
    return t8;
  }, n7 = `${s6}_mat_${o8.id}_${o8.name}`;
  if (!e7.materials.has(n7)) {
    const r8 = r6({ color: [o8.color[0], o8.color[1], o8.color[2]], opacity: o8.color[3], alphaMode: o8.alphaMode, alphaCutoff: o8.alphaCutoff, doubleSided: o8.doubleSided, colorMixMode: o8.ESRI_externalColorMixMode, textureColor: o8.colorTexture ? a3(o8.colorTexture) : void 0, textureNormal: o8.normalTexture ? a3(o8.normalTexture) : void 0, textureOcclusion: o8.occlusionTexture ? a3(o8.occlusionTexture) : void 0, textureEmissive: o8.emissiveTexture ? a3(o8.emissiveTexture) : void 0, textureMetallicRoughness: o8.metallicRoughnessTexture ? a3(o8.metallicRoughnessTexture) : void 0, emissiveFactor: [o8.emissiveFactor[0], o8.emissiveFactor[1], o8.emissiveFactor[2]], colorTextureTransform: o8.colorTextureTransform, normalTextureTransform: o8.normalTextureTransform, occlusionTextureTransform: o8.occlusionTextureTransform, emissiveTextureTransform: o8.emissiveTextureTransform, metallicRoughnessTextureTransform: o8.metallicRoughnessTextureTransform, metallicFactor: o8.metallicFactor, roughnessFactor: o8.roughnessFactor });
    e7.materials.set(n7, r8);
  }
  return n7;
}
var p2 = /* @__PURE__ */ new Set([L2.LINEAR_MIPMAP_LINEAR, L2.LINEAR_MIPMAP_NEAREST]);

// node_modules/@arcgis/core/views/3d/glTF/internal/indexUtils.js
function o6(r8, t8) {
  switch (t8) {
    case E2.TRIANGLES:
      return f5(r8);
    case E2.TRIANGLE_STRIP:
      return u6(r8);
    case E2.TRIANGLE_FAN:
      return i6(r8);
  }
}
function f5(e7) {
  return "number" == typeof e7 ? l2(e7) : u(e7) ? new Uint16Array(e7) : e7;
}
function u6(r8) {
  const t8 = "number" == typeof r8 ? r8 : r8.length;
  if (t8 < 3)
    return [];
  const n7 = t8 - 2, o8 = i3(3 * n7);
  if ("number" == typeof r8) {
    let r9 = 0;
    for (let t9 = 0; t9 < n7; t9 += 1)
      t9 % 2 == 0 ? (o8[r9++] = t9, o8[r9++] = t9 + 1, o8[r9++] = t9 + 2) : (o8[r9++] = t9 + 1, o8[r9++] = t9, o8[r9++] = t9 + 2);
  } else {
    let t9 = 0;
    for (let e7 = 0; e7 < n7; e7 += 1)
      e7 % 2 == 0 ? (o8[t9++] = r8[e7], o8[t9++] = r8[e7 + 1], o8[t9++] = r8[e7 + 2]) : (o8[t9++] = r8[e7 + 1], o8[t9++] = r8[e7], o8[t9++] = r8[e7 + 2]);
  }
  return o8;
}
function i6(r8) {
  const t8 = "number" == typeof r8 ? r8 : r8.length;
  if (t8 < 3)
    return new Uint16Array(0);
  const e7 = t8 - 2, n7 = e7 <= 65536 ? new Uint16Array(3 * e7) : new Uint32Array(3 * e7);
  if ("number" == typeof r8) {
    let r9 = 0;
    for (let t9 = 0; t9 < e7; ++t9)
      n7[r9++] = 0, n7[r9++] = t9 + 1, n7[r9++] = t9 + 2;
    return n7;
  }
  const o8 = r8[0];
  let f6 = r8[1], u7 = 0;
  for (let i7 = 0; i7 < e7; ++i7) {
    const t9 = r8[i7 + 2];
    n7[u7++] = o8, n7[u7++] = f6, n7[u7++] = t9, f6 = t9;
  }
  return n7;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/DefaultMaterial_COLOR_GAMMA.js
var o7 = 2.1;

export {
  r5 as r,
  f2 as f,
  n3 as n,
  o2 as o,
  u3 as u,
  o3 as o2,
  n4 as n2,
  l3 as l,
  e4 as e,
  t3 as t,
  f3 as f2,
  e5 as e2,
  t4 as t2,
  f4 as f3,
  n5 as n3,
  l6 as l2,
  o6 as o3,
  o7 as o4
};
//# sourceMappingURL=chunk-TUEI54TI.js.map
