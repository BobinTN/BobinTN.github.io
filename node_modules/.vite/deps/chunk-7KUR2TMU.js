import {
  I as I2
} from "./chunk-3ON6HO7Q.js";
import {
  t
} from "./chunk-KMTPMPRR.js";
import {
  I,
  P as P3,
  S as S3,
  a as a5,
  g as g2,
  h,
  j as j2,
  n as n2,
  t as t2,
  v as v4,
  y as y2
} from "./chunk-K4NVR6KM.js";
import {
  b,
  j,
  x as x2
} from "./chunk-57KRYRCY.js";
import {
  rt
} from "./chunk-747B2TEO.js";
import {
  $,
  B,
  C as C2,
  E as E2,
  P as P2,
  T,
  U,
  c as c3,
  d as d3,
  f as f2,
  k,
  p as p3,
  v as v3,
  w
} from "./chunk-AZHRWST4.js";
import {
  m as m2
} from "./chunk-7Y57Y6IH.js";
import {
  x
} from "./chunk-GXVWD6F2.js";
import {
  R
} from "./chunk-LOGPPZUD.js";
import {
  r as r3
} from "./chunk-EC5POYCL.js";
import {
  Z
} from "./chunk-M7OEQQRX.js";
import {
  e as e3
} from "./chunk-CSWPLQ7Q.js";
import {
  i as i3,
  r as r2
} from "./chunk-KWSMYM7P.js";
import {
  i
} from "./chunk-RP5SAUAF.js";
import {
  C,
  O,
  i as i2,
  o
} from "./chunk-IRNKV32L.js";
import {
  Fe,
  Ie,
  be,
  ge,
  ye
} from "./chunk-Z6KIMOUA.js";
import {
  i as i4
} from "./chunk-M7R7REMB.js";
import {
  f,
  m,
  p as p2
} from "./chunk-IPCIO3PX.js";
import {
  K
} from "./chunk-4HKQSEUR.js";
import {
  a2 as a4,
  l as l3,
  l2 as l4,
  r,
  v as v2
} from "./chunk-OIIDE5GZ.js";
import {
  a as a3,
  u as u3
} from "./chunk-3XSRVKBX.js";
import {
  P,
  d,
  p
} from "./chunk-TBSVVR6M.js";
import {
  W,
  d2,
  z
} from "./chunk-HLGIRLYQ.js";
import {
  a as a2
} from "./chunk-NSRXJNTS.js";
import {
  e as e2,
  g,
  s3,
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c as c2,
  l as l2
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  E,
  S as S2,
  c2 as c,
  s as s4,
  u as u2
} from "./chunk-RFPH3ZTZ.js";
import {
  l,
  u
} from "./chunk-WGO3VFQP.js";
import {
  n
} from "./chunk-CQS47VN5.js";
import {
  a,
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import {
  S,
  v
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/core/sql/WhereClauseCache.js
var r4 = class {
  constructor(e5, r5) {
    this._cache = new e3(e5), this._invalidCache = new e3(r5);
  }
  get(t6, r5) {
    const i6 = `${r5.uid}:${t6}`, c7 = this._cache.get(i6);
    if (c7)
      return c7;
    if (null != this._invalidCache.get(i6))
      return null;
    try {
      const c8 = x.create(t6, r5);
      return this._cache.put(i6, c8), c8;
    } catch (n5) {
      return this._invalidCache.put(i6, n5), null;
    }
  }
  getError(t6, e5) {
    const r5 = `${e5.uid}:${t6}`;
    return this._invalidCache.get(r5) ?? null;
  }
};

// node_modules/@arcgis/core/layers/graphics/data/attributeSupport.js
var t3 = new r4(50, 500);
var s5 = "unsupported-query";
var n3 = " as ";
var o2 = /* @__PURE__ */ new Set(["esriFieldTypeOID", "esriFieldTypeSmallInteger", "esriFieldTypeBigInteger", "esriFieldTypeInteger", "esriFieldTypeSingle", "esriFieldTypeDouble", "esriFieldTypeLong"]);
var a6 = /* @__PURE__ */ new Set(["esriFieldTypeDate", "esriFieldTypeDateOnly", "esriFieldTypeTimeOnly", "esriFieldTypeTimestampOffset"]);
var l5 = /* @__PURE__ */ new Set(["esriFieldTypeString", "esriFieldTypeGUID", "esriFieldTypeGlobalID", ...o2, ...a6]);
function d4(i6, r5, n5 = {}) {
  const o3 = c4(r5, i6);
  if (!o3) {
    const n6 = t3.getError(r5, i6);
    throw new s2(s5, "invalid SQL expression", { expression: r5, error: n6 });
  }
  const a7 = n5.expressionName || "expression";
  if (n5.validateStandardized && !o3.isStandardized)
    throw new s2(s5, `${a7} is not standard`, { expression: r5 });
  if (n5.validateAggregate && !o3.isAggregate)
    throw new s2(s5, `${a7} does not contain a valid aggregate function`, { expression: r5 });
  return o3.fieldNames;
}
function p4(e5, i6, r5, t6) {
  if (!r5)
    return true;
  const s6 = "where clause";
  return g3(e5, i6, d4(e5, r5, { validateStandardized: true, expressionName: s6 }), { expressionName: s6, query: t6 }), true;
}
function f3(i6, r5, t6, n5, o3) {
  if (!t6)
    return true;
  const a7 = "having clause", l6 = d4(i6, t6, { validateAggregate: true, expressionName: a7 });
  g3(i6, r5, l6, { expressionName: a7, query: o3 });
  const p8 = c4(t6, i6), f6 = p8 == null ? void 0 : p8.getExpressions().every((e5) => {
    var _a;
    const { aggregateType: r6, field: t7 } = e5, s6 = (_a = i6.get(t7)) == null ? void 0 : _a.name;
    return n5.some((e6) => {
      var _a2;
      const { onStatisticField: t8, statisticType: n6 } = e6, o4 = (_a2 = i6.get(t8)) == null ? void 0 : _a2.name;
      return o4 === s6 && n6.toLowerCase().trim() === r6;
    });
  });
  if (!f6)
    throw new s2(s5, "expressions in having clause should also exist in outStatistics", { having: t6 });
  return true;
}
function c4(e5, i6) {
  return e5 ? t3.get(e5, i6) : null;
}
function u4(e5) {
  return /\((.*?)\)/.test(e5) ? e5 : e5.split(n3)[0];
}
function y3(e5) {
  return e5.split(n3)[1];
}
function g3(i6, r5, t6, n5 = {}) {
  const o3 = /* @__PURE__ */ new Map();
  if (m3(o3, i6, r5, n5.allowedFieldTypes ?? l5, t6), o3.size) {
    const i7 = n5.expressionName ?? "expression";
    throw new s2(s5, `${i7} contains invalid or missing fields`, { errors: Array.from(o3.values()), query: n5.query });
  }
}
function m3(e5, i6, r5, t6, s6) {
  for (const o3 of s6) {
    if ("*" === o3)
      continue;
    if (i6.get(o3))
      T2(e5, i6, r5, t6, o3);
    else
      try {
        const s7 = d4(i6, u4(o3), { validateStandardized: true });
        for (const n5 of s7)
          T2(e5, i6, r5, t6, n5);
      } catch (n5) {
        e5.set(o3, { type: "expression-error", expression: o3, error: n5 });
      }
  }
}
function T2(e5, i6, t6, s6, n5) {
  if ("*" === n5)
    return;
  const o3 = i6.get(n5);
  o3 ? t6.has(o3.name) ? false === (s6 == null ? void 0 : s6.has(o3.type)) && e5.set(n5, { type: "invalid-type", fieldName: o3.name, fieldType: i.fromJSON(o3.type), allowedFieldTypes: Array.from(s6, (e6) => i.fromJSON(e6)) }) : e5.set(n5, { type: "missing-field", fieldName: o3.name }) : e5.set(n5, { type: "invalid-field", fieldName: n5 });
}

// node_modules/@arcgis/core/layers/graphics/data/AttributesBuilder.js
var c5 = class {
  constructor(s6, a7, l6) {
    this._fieldDataCache = /* @__PURE__ */ new Map(), this._returnDistinctMap = /* @__PURE__ */ new Map(), this.returnDistinctValues = s6.returnDistinctValues ?? false, this.fieldsIndex = l6, this.featureAdapter = a7;
    const r5 = s6.outFields;
    if (r5 && !r5.includes("*")) {
      this.outFields = r5;
      let s7 = 0;
      for (const a8 of r5) {
        const r6 = u4(a8), n5 = this.fieldsIndex.get(r6), u6 = n5 ? null : c4(r6, l6), o3 = n5 ? n5.name : y3(a8) || "FIELD_EXP_" + s7++;
        this._fieldDataCache.set(a8, { alias: o3, clause: u6 });
      }
    }
  }
  countDistinctValues(t6) {
    return this.returnDistinctValues ? (t6.forEach((t7) => this.getAttributes(t7)), this._returnDistinctMap.size) : t6.length;
  }
  getAttributes(t6) {
    const e5 = this._processAttributesForOutFields(t6);
    return this._processAttributesForDistinctValues(e5);
  }
  getFieldValue(t6, i6, s6) {
    var _a;
    const a7 = s6 ? s6.name : i6;
    let l6 = null;
    return this._fieldDataCache.has(a7) ? l6 = (_a = this._fieldDataCache.get(a7)) == null ? void 0 : _a.clause : s6 || (l6 = c4(i6, this.fieldsIndex), this._fieldDataCache.set(a7, { alias: a7, clause: l6 })), s6 ? this.featureAdapter.getAttribute(t6, a7) : l6 == null ? void 0 : l6.calculateValue(t6, this.featureAdapter);
  }
  getDataValues(t6, e5, i6 = true) {
    const s6 = e5.normalizationType, d6 = e5.normalizationTotal, c7 = this.fieldsIndex.get(e5.field), h3 = Fe(c7) || Ie(c7), f6 = be(c7);
    return t6.map((t7) => {
      let a7 = e5.field && this.getFieldValue(t7, e5.field, this.fieldsIndex.get(e5.field));
      if (e5.field2 ? (a7 = `${c3(a7)}${e5.fieldDelimiter}${c3(this.getFieldValue(t7, e5.field2, this.fieldsIndex.get(e5.field2)))}`, e5.field3 && (a7 = `${a7}${e5.fieldDelimiter}${c3(this.getFieldValue(t7, e5.field3, this.fieldsIndex.get(e5.field3)))}`)) : "string" == typeof a7 && i6 && (h3 ? a7 = a7 ? new Date(a7).getTime() : null : f6 && (a7 = a7 ? w(a7) : null)), s6 && Number.isFinite(a7)) {
        const i7 = "field" === s6 && e5.normalizationField ? this.getFieldValue(t7, e5.normalizationField, this.fieldsIndex.get(e5.normalizationField)) : null;
        a7 = B(a7, s6, i7, d6);
      }
      return a7;
    });
  }
  async getExpressionValues(t6, e5, i6, a7, l6) {
    const { arcadeUtils: r5 } = await i4(), n5 = r5.hasGeometryOperations(e5);
    n5 && await r5.enableGeometryOperations();
    const u6 = r5.createFunction(e5), o3 = r5.getViewInfo(i6), c7 = { fields: this.fieldsIndex.fields };
    return t6.map((t7) => {
      const e6 = { attributes: this.featureAdapter.getAttributes(t7), layer: c7, geometry: n5 ? { ...a5(a7.geometryType, a7.hasZ, a7.hasM, this.featureAdapter.getGeometry(t7)), spatialReference: i6 == null ? void 0 : i6.spatialReference } : null }, d6 = r5.createExecContext(e6, o3, l6);
      return r5.executeFunction(u6, d6);
    });
  }
  validateItem(t6, i6) {
    var _a, _b;
    return this._fieldDataCache.has(i6) || this._fieldDataCache.set(i6, { alias: i6, clause: c4(i6, this.fieldsIndex) }), ((_b = (_a = this._fieldDataCache.get(i6)) == null ? void 0 : _a.clause) == null ? void 0 : _b.testFeature(t6, this.featureAdapter)) ?? false;
  }
  validateItems(t6, i6) {
    var _a, _b;
    return this._fieldDataCache.has(i6) || this._fieldDataCache.set(i6, { alias: i6, clause: c4(i6, this.fieldsIndex) }), ((_b = (_a = this._fieldDataCache.get(i6)) == null ? void 0 : _a.clause) == null ? void 0 : _b.testSet(t6, this.featureAdapter)) ?? false;
  }
  _processAttributesForOutFields(t6) {
    const e5 = this.outFields;
    if (!(e5 == null ? void 0 : e5.length))
      return this.featureAdapter.getAttributes(t6);
    const i6 = {};
    for (const s6 of e5) {
      const { alias: e6, clause: a7 } = this._fieldDataCache.get(s6);
      i6[e6] = a7 ? a7.calculateValue(t6, this.featureAdapter) : this.featureAdapter.getAttribute(t6, e6);
    }
    return i6;
  }
  _processAttributesForDistinctValues(t6) {
    if (null == t6 || !this.returnDistinctValues)
      return t6;
    const e5 = this.outFields, i6 = [];
    if (e5)
      for (const l6 of e5) {
        const { alias: e6 } = this._fieldDataCache.get(l6);
        i6.push(t6[e6]);
      }
    else
      for (const l6 in t6)
        i6.push(t6[l6]);
    const s6 = `${(e5 || ["*"]).join(",")}=${i6.join(",")}`;
    let a7 = this._returnDistinctMap.get(s6) || 0;
    return this._returnDistinctMap.set(s6, ++a7), a7 > 1 ? null : t6;
  }
};

// node_modules/@arcgis/core/layers/graphics/data/SnappingCandidate.js
function t4(t6, e5, r5) {
  return { objectId: t6, target: e5, distance: r5, type: "vertex" };
}
function e4(t6, e5, r5, n5, d6, a7 = false) {
  return { objectId: t6, target: e5, distance: r5, type: "edge", start: n5, end: d6, draped: a7 };
}

// node_modules/@arcgis/core/layers/graphics/data/QueryEngineResult.js
var q = class {
  constructor(e5, t6, s6) {
    this.items = e5, this.query = t6, this.geometryType = s6.geometryType, this.hasM = s6.hasM, this.hasZ = s6.hasZ, this.fieldsIndex = s6.fieldsIndex, this.objectIdField = s6.objectIdField, this.spatialReference = s6.spatialReference, this.featureAdapter = s6.featureAdapter;
  }
  get size() {
    return this.items.length;
  }
  createQueryResponseForCount() {
    const e5 = new c5(this.query, this.featureAdapter, this.fieldsIndex);
    if (!this.query.outStatistics)
      return e5.countDistinctValues(this.items);
    const { groupByFieldsForStatistics: t6, having: s6, outStatistics: i6 } = this.query, a7 = t6 == null ? void 0 : t6.length;
    if (!!!a7)
      return 1;
    const r5 = /* @__PURE__ */ new Map(), n5 = /* @__PURE__ */ new Map(), o3 = /* @__PURE__ */ new Set();
    for (const l6 of i6) {
      const { statisticType: i7 } = l6, a8 = "exceedslimit" !== i7 ? l6.onStatisticField : void 0;
      if (!n5.has(a8)) {
        const s7 = [];
        for (const i8 of t6) {
          const t7 = this._getAttributeValues(e5, i8, r5);
          s7.push(t7);
        }
        n5.set(a8, this._calculateUniqueValues(s7, e5.returnDistinctValues));
      }
      const u6 = n5.get(a8);
      for (const t7 in u6) {
        const { data: i8, items: a9 } = u6[t7], r6 = i8.join(",");
        s6 && !e5.validateItems(a9, s6) || o3.add(r6);
      }
    }
    return o3.size;
  }
  async createQueryResponse() {
    let e5;
    if (this.query.outStatistics) {
      e5 = this.query.outStatistics.some((e6) => "exceedslimit" === e6.statisticType) ? this._createExceedsLimitQueryResponse(this.query) : await this._createStatisticsQueryResponse(this.query);
    } else
      e5 = this._createFeatureQueryResponse(this.query);
    if (this.query.returnQueryGeometry) {
      const t6 = this.query.geometry;
      W(this.query.outSR) && !d2(t6.spatialReference, this.query.outSR) ? e5.queryGeometry = h({ spatialReference: this.query.outSR, ...j(t6, t6.spatialReference, this.query.outSR) }) : e5.queryGeometry = h({ spatialReference: this.query.outSR, ...t6 });
    }
    return e5;
  }
  createSnappingResponse(e5, t6) {
    const s6 = this.featureAdapter, i6 = C3(this.hasZ, this.hasM), { point: a7, mode: r5 } = e5, n5 = "number" == typeof e5.distance ? e5.distance : e5.distance.x, o3 = "number" == typeof e5.distance ? e5.distance : e5.distance.y, l6 = { candidates: [] }, u6 = "esriGeometryPolygon" === this.geometryType, c7 = this._getPointCreator(r5, this.spatialReference, t6), d6 = new D(null, 0), m5 = new D(null, 0), f6 = { x: 0, y: 0, z: 0 };
    for (const p8 of this.items) {
      const t7 = s6.getGeometry(p8);
      if (null == t7)
        continue;
      const { coords: r6, lengths: y5 } = t7;
      if (d6.coords = r6, m5.coords = r6, e5.returnEdge) {
        let e6 = 0;
        for (let t8 = 0; t8 < y5.length; t8++) {
          const r7 = y5[t8];
          for (let t9 = 0; t9 < r7; t9++, e6 += i6) {
            const u7 = d6;
            if (u7.coordsIndex = e6, t9 !== r7 - 1) {
              const t10 = m5;
              t10.coordsIndex = e6 + i6;
              const r8 = f6;
              N(f6, a7, u7, t10);
              const d7 = (a7.x - r8.x) / n5, g5 = (a7.y - r8.y) / o3, y6 = d7 * d7 + g5 * g5;
              y6 <= 1 && l6.candidates.push(e4(s6.getObjectId(p8), c7(r8), Math.sqrt(y6), c7(u7), c7(t10)));
            }
          }
        }
      }
      if ("none" !== e5.vertexMode) {
        const t8 = u6 ? r6.length - i6 : r6.length;
        if ("all" === e5.vertexMode)
          for (let e6 = 0; e6 < t8; e6 += i6) {
            const t9 = d6;
            t9.coordsIndex = e6;
            const i7 = (a7.x - t9.x) / n5, r7 = (a7.y - t9.y) / o3, u7 = i7 * i7 + r7 * r7;
            u7 <= 1 && l6.candidates.push(t4(s6.getObjectId(p8), c7(t9), Math.sqrt(u7)));
          }
        else if ("ends" === e5.vertexMode) {
          const e6 = [0];
          u6 || e6.push(r6.length - i6);
          for (const t9 of e6) {
            const e7 = d6;
            e7.coordsIndex = t9;
            const i7 = (a7.x - e7.x) / n5, r7 = (a7.y - e7.y) / o3, u7 = i7 * i7 + r7 * r7;
            u7 <= 1 && l6.candidates.push(t4(s6.getObjectId(p8), c7(e7), Math.sqrt(u7)));
          }
        }
      }
    }
    return l6.candidates.sort((e6, t7) => e6.distance - t7.distance), l6;
  }
  _getPointCreator(e5, t6, s6) {
    const i6 = null == s6 || d2(t6, s6) ? (e6) => e6 : (e6) => j(e6, t6, s6), { hasZ: a7 } = this, r5 = 0;
    return "3d" === e5 ? a7 ? ({ x: e6, y: t7, z: s7 }) => i6({ x: e6, y: t7, z: s7 }) : ({ x: e6, y: t7 }) => i6({ x: e6, y: t7, z: r5 }) : ({ x: e6, y: t7 }) => i6({ x: e6, y: t7 });
  }
  async createSummaryStatisticsResponse(e5) {
    const { field: t6, valueExpression: s6, normalizationField: i6, normalizationType: a7, normalizationTotal: r5, minValue: n5, maxValue: o3, scale: l6, timeZone: u6 } = e5, c7 = this.fieldsIndex.get(t6), d6 = ge(c7) || Fe(c7) || Ie(c7), m5 = await this._getDataValues({ field: t6, valueExpression: s6, normalizationField: i6, normalizationType: a7, normalizationTotal: r5, scale: l6, timeZone: u6 }), h3 = f2({ normalizationType: a7, normalizationField: i6, minValue: n5, maxValue: o3 }), g5 = { value: 0.5, fieldType: c7 == null ? void 0 : c7.type }, I4 = ye(c7) ? d3({ values: m5, supportsNullCount: h3, percentileParams: g5 }) : p3({ values: m5, minValue: n5, maxValue: o3, useSampleStdDev: !a7, supportsNullCount: h3, percentileParams: g5 });
    return C2(I4, d6);
  }
  async createUniqueValuesResponse(e5) {
    const { field: t6, valueExpression: s6, domains: i6, returnAllCodedValues: a7, scale: r5, timeZone: n5 } = e5, o3 = await this._getDataValues({ field: t6, field2: e5.field2, field3: e5.field3, fieldDelimiter: e5.fieldDelimiter, valueExpression: s6, scale: r5, timeZone: n5 }, false), l6 = k(o3);
    return $(l6, i6, a7, e5.fieldDelimiter);
  }
  async createClassBreaksResponse(e5) {
    const { field: t6, valueExpression: s6, normalizationField: i6, normalizationType: a7, normalizationTotal: r5, classificationMethod: n5, standardDeviationInterval: o3, minValue: l6, maxValue: u6, numClasses: c7, scale: d6, timeZone: m5 } = e5, h3 = await this._getDataValues({ field: t6, valueExpression: s6, normalizationField: i6, normalizationType: a7, normalizationTotal: r5, scale: d6, timeZone: m5 }), g5 = E2(h3, { field: t6, normalizationField: i6, normalizationType: a7, normalizationTotal: r5, classificationMethod: n5, standardDeviationInterval: o3, minValue: l6, maxValue: u6, numClasses: c7 });
    return P2(g5, n5);
  }
  async createHistogramResponse(e5) {
    const { field: t6, valueExpression: s6, normalizationField: i6, normalizationType: a7, normalizationTotal: r5, classificationMethod: n5, standardDeviationInterval: o3, minValue: l6, maxValue: u6, numBins: c7, scale: d6, timeZone: m5 } = e5, h3 = await this._getDataValues({ field: t6, valueExpression: s6, normalizationField: i6, normalizationType: a7, normalizationTotal: r5, scale: d6, timeZone: m5 });
    return U(h3, { field: t6, normalizationField: i6, normalizationType: a7, normalizationTotal: r5, classificationMethod: n5, standardDeviationInterval: o3, minValue: l6, maxValue: u6, numBins: c7 });
  }
  _sortFeatures(e5, t6, s6) {
    if (e5.length > 1 && (t6 == null ? void 0 : t6.length))
      for (const i6 of t6.reverse()) {
        const t7 = i6.split(" "), a7 = t7[0], r5 = this.fieldsIndex.get(a7), n5 = !!t7[1] && "desc" === t7[1].toLowerCase(), o3 = T(r5 == null ? void 0 : r5.type, n5);
        e5.sort((e6, t8) => {
          const i7 = s6(e6, a7, r5), n6 = s6(t8, a7, r5);
          return o3(i7, n6);
        });
      }
  }
  _createFeatureQueryResponse(e5) {
    const t6 = this.items, { geometryType: s6, hasM: i6, hasZ: a7, objectIdField: n5, spatialReference: o3 } = this, { outFields: l6, outSR: c7, quantizationParameters: d6, resultRecordCount: m5, resultOffset: h3, returnZ: g5, returnM: f6 } = e5, p8 = null != m5 && t6.length > (h3 || 0) + m5, y5 = l6 && (l6.includes("*") ? [...this.fieldsIndex.fields] : l6.map((e6) => this.fieldsIndex.get(e6)));
    return { exceededTransferLimit: p8, features: this._createFeatures(e5, t6), fields: y5, geometryType: s6, hasM: i6 && f6, hasZ: a7 && g5, objectIdFieldName: n5, spatialReference: h(c7 || o3), transform: d6 && m2(d6) || null };
  }
  _createFeatures(e5, t6) {
    const s6 = new c5(e5, this.featureAdapter, this.fieldsIndex), { hasM: i6, hasZ: a7 } = this, { orderByFields: n5, quantizationParameters: o3, returnGeometry: u6, returnCentroid: m5, maxAllowableOffset: h3, resultOffset: g5, resultRecordCount: f6, returnZ: p8 = false, returnM: y5 = false } = e5, x3 = a7 && p8, I4 = i6 && y5;
    let T3 = [], V2 = 0;
    const F2 = [...t6];
    if (this._sortFeatures(F2, n5, (e6, t7, i7) => s6.getFieldValue(e6, t7, i7)), this.geometryType && (u6 || m5)) {
      const e6 = m2(o3) ?? void 0;
      if (u6 && !m5)
        for (const t7 of F2)
          T3[V2++] = { attributes: s6.getAttributes(t7), geometry: a5(this.geometryType, this.hasZ, this.hasM, this.featureAdapter.getGeometry(t7), h3, e6, x3, I4) };
      else if (!u6 && m5)
        for (const t7 of F2)
          T3[V2++] = { attributes: s6.getAttributes(t7), centroid: y2(this, this.featureAdapter.getCentroid(t7, this), e6) };
      else
        for (const t7 of F2)
          T3[V2++] = { attributes: s6.getAttributes(t7), centroid: y2(this, this.featureAdapter.getCentroid(t7, this), e6), geometry: a5(this.geometryType, this.hasZ, this.hasM, this.featureAdapter.getGeometry(t7), h3, e6, x3, I4) };
    } else
      for (const r5 of F2) {
        const e6 = s6.getAttributes(r5);
        e6 && (T3[V2++] = { attributes: e6 });
      }
    const S5 = g5 || 0;
    if (null != f6) {
      const e6 = S5 + f6;
      T3 = T3.slice(S5, Math.min(T3.length, e6));
    }
    return T3;
  }
  _createExceedsLimitQueryResponse(e5) {
    let t6 = false, s6 = Number.POSITIVE_INFINITY, i6 = Number.POSITIVE_INFINITY, a7 = Number.POSITIVE_INFINITY;
    for (const r5 of e5.outStatistics ?? [])
      if ("exceedslimit" === r5.statisticType) {
        s6 = null != r5.maxPointCount ? r5.maxPointCount : Number.POSITIVE_INFINITY, i6 = null != r5.maxRecordCount ? r5.maxRecordCount : Number.POSITIVE_INFINITY, a7 = null != r5.maxVertexCount ? r5.maxVertexCount : Number.POSITIVE_INFINITY;
        break;
      }
    if ("esriGeometryPoint" === this.geometryType)
      t6 = this.items.length > s6;
    else if (this.items.length > i6)
      t6 = true;
    else {
      const e6 = C3(this.hasZ, this.hasM), s7 = this.featureAdapter;
      t6 = this.items.reduce((e7, t7) => {
        const i7 = s7.getGeometry(t7);
        return e7 + (null != i7 && i7.coords.length || 0);
      }, 0) / e6 > a7;
    }
    return { fields: [{ name: "exceedslimit", type: "esriFieldTypeInteger", alias: "exceedslimit", sqlType: "sqlTypeInteger", domain: null, defaultValue: null }], features: [{ attributes: { exceedslimit: Number(t6) } }] };
  }
  async _createStatisticsQueryResponse(e5) {
    var _a;
    const t6 = { attributes: {} }, s6 = [], i6 = /* @__PURE__ */ new Map(), a7 = /* @__PURE__ */ new Map(), r5 = /* @__PURE__ */ new Map(), n5 = /* @__PURE__ */ new Map(), o3 = new c5(e5, this.featureAdapter, this.fieldsIndex), u6 = e5.outStatistics, { groupByFieldsForStatistics: c7, having: d6, orderByFields: m5, resultRecordCount: h3 } = e5, g5 = c7 == null ? void 0 : c7.length, f6 = !!g5, p8 = f6 ? c7[0] : null, y5 = f6 && !this.fieldsIndex.get(p8);
    for (const l6 of u6 ?? []) {
      const { outStatisticFieldName: e6, statisticType: u7 } = l6, m6 = l6, h4 = "exceedslimit" !== u7 ? l6.onStatisticField : void 0, I5 = "percentile_disc" === u7 || "percentile_cont" === u7, T3 = "EnvelopeAggregate" === u7 || "CentroidAggregate" === u7 || "ConvexHullAggregate" === u7, V2 = f6 && 1 === g5 && (h4 === p8 || y5) && "count" === u7;
      if (f6) {
        if (!r5.has(h4)) {
          const e7 = [];
          for (const t8 of c7) {
            const s8 = this._getAttributeValues(o3, t8, i6);
            e7.push(s8);
          }
          r5.set(h4, this._calculateUniqueValues(e7, !T3 && o3.returnDistinctValues));
        }
        const t7 = r5.get(h4);
        if (!t7)
          continue;
        const s7 = Object.keys(t7);
        for (const a8 of s7) {
          const { count: s8, data: r6, items: l7, itemPositions: u8 } = t7[a8], g6 = r6.join(",");
          if (!d6 || o3.validateItems(l7, d6)) {
            const t8 = n5.get(g6) || { attributes: {} };
            if (T3) {
              t8.aggregateGeometries || (t8.aggregateGeometries = {});
              const { aggregateGeometries: e7, outStatisticFieldName: s9 } = await this._getAggregateGeometry(m6, l7);
              t8.aggregateGeometries[s9] = e7;
            } else {
              let a10 = null;
              if (V2)
                a10 = s8;
              else {
                const e7 = this._getAttributeValues(o3, h4, i6), t9 = u8.map((t10) => e7[t10]);
                a10 = I5 && "statisticParameters" in m6 ? this._getPercentileValue(m6, t9) : this._getStatisticValue(m6, t9, null, o3.returnDistinctValues);
              }
              t8.attributes[e6] = a10;
            }
            let a9 = 0;
            c7.forEach((e7, s9) => t8.attributes[this.fieldsIndex.get(e7) ? e7 : "EXPR_" + ++a9] = r6[s9]), n5.set(g6, t8);
          }
        }
      } else if (T3) {
        t6.aggregateGeometries || (t6.aggregateGeometries = {});
        const { aggregateGeometries: e7, outStatisticFieldName: s7 } = await this._getAggregateGeometry(m6, this.items);
        t6.aggregateGeometries[s7] = e7;
      } else {
        const s7 = this._getAttributeValues(o3, h4, i6);
        t6.attributes[e6] = I5 && "statisticParameters" in m6 ? this._getPercentileValue(m6, s7) : this._getStatisticValue(m6, s7, a7, o3.returnDistinctValues);
      }
      const F2 = "min" !== u7 && "max" !== u7 || !ye(this.fieldsIndex.get(h4)) && !this._isAnyDateField(h4) ? null : (_a = this.fieldsIndex.get(h4)) == null ? void 0 : _a.type;
      s6.push({ name: e6, alias: e6, type: F2 || "esriFieldTypeDouble" });
    }
    const I4 = f6 ? Array.from(n5.values()) : [t6];
    return this._sortFeatures(I4, m5, (e6, t7) => e6.attributes[t7]), h3 && (I4.length = Math.min(h3, I4.length)), { fields: s6, features: I4 };
  }
  _isAnyDateField(e5) {
    const t6 = this.fieldsIndex.get(e5);
    return ge(t6) || Fe(t6) || Ie(t6) || be(t6);
  }
  async _getAggregateGeometry(e5, r5) {
    const { convexHull: n5, union: o3 } = await import("./geometryEngineJSON-CKCDO7TD.js"), { statisticType: l6, outStatisticFieldName: u6 } = e5, { featureAdapter: d6, spatialReference: m5, geometryType: h3, hasZ: g5, hasM: f6 } = this, p8 = r5.map((e6) => a5(h3, g5, f6, d6.getGeometry(e6))), y5 = n5(m5, p8, true)[0], x3 = { aggregateGeometries: null, outStatisticFieldName: null };
    if ("EnvelopeAggregate" === l6) {
      const e6 = y5 ? v2(y5) : l4(o3(m5, p8));
      x3.aggregateGeometries = { ...e6, spatialReference: m5 }, x3.outStatisticFieldName = u6 || "extent";
    } else if ("CentroidAggregate" === l6) {
      const e6 = y5 ? l3(y5) : r(l4(o3(m5, p8)));
      x3.aggregateGeometries = { x: e6[0], y: e6[1], spatialReference: m5 }, x3.outStatisticFieldName = u6 || "centroid";
    } else
      "ConvexHullAggregate" === l6 && (x3.aggregateGeometries = y5, x3.outStatisticFieldName = u6 || "convexHull");
    return x3;
  }
  _getStatisticValue(e5, t6, s6, i6) {
    const { onStatisticField: a7, statisticType: r5 } = e5;
    let n5 = null;
    n5 = (s6 == null ? void 0 : s6.has(a7)) ? s6.get(a7) : ye(this.fieldsIndex.get(a7)) || this._isAnyDateField(a7) ? d3({ values: t6, returnDistinct: i6 }) : p3({ values: i6 ? [...new Set(t6)] : t6, minValue: null, maxValue: null, useSampleStdDev: true }), s6 && s6.set(a7, n5);
    return n5["var" === r5 ? "variance" : r5];
  }
  _getPercentileValue(e5, t6) {
    const { onStatisticField: s6, statisticParameters: i6, statisticType: a7 } = e5, { value: r5, orderBy: n5 } = i6, o3 = this.fieldsIndex.get(s6);
    return v3(t6, { value: r5, orderBy: n5, fieldType: o3 == null ? void 0 : o3.type, isDiscrete: "percentile_disc" === a7 });
  }
  _getAttributeValues(e5, t6, s6) {
    if (s6.has(t6))
      return s6.get(t6);
    const i6 = this.fieldsIndex.get(t6), a7 = this.items.map((s7) => e5.getFieldValue(s7, t6, i6));
    return s6.set(t6, a7), a7;
  }
  _calculateUniqueValues(e5, t6) {
    const s6 = {}, i6 = this.items, a7 = i6.length;
    for (let r5 = 0; r5 < a7; r5++) {
      const a8 = i6[r5], n5 = [];
      for (const t7 of e5)
        n5.push(t7[r5]);
      const o3 = n5.join(",");
      null == s6[o3] ? s6[o3] = { count: 1, data: n5, items: [a8], itemPositions: [r5] } : (t6 || s6[o3].count++, s6[o3].items.push(a8), s6[o3].itemPositions.push(r5));
    }
    return s6;
  }
  async _getDataValues(t6, s6 = true) {
    const i6 = new c5(this.query, this.featureAdapter, this.fieldsIndex), { valueExpression: a7, scale: r5, timeZone: n5 } = t6;
    return a7 ? i6.getExpressionValues(this.items, a7, { viewingMode: "map", scale: r5, spatialReference: this.query.outSR || this.spatialReference }, { geometryType: this.geometryType, hasZ: this.hasZ, hasM: this.hasM }, n5) : i6.getDataValues(this.items, a(t6), s6);
  }
};
function N(e5, t6, s6, i6) {
  const a7 = i6.x - s6.x, r5 = i6.y - s6.y, n5 = a7 * a7 + r5 * r5, o3 = (t6.x - s6.x) * a7 + (t6.y - s6.y) * r5, l6 = Math.min(1, Math.max(0, o3 / n5));
  e5.x = s6.x + a7 * l6, e5.y = s6.y + r5 * l6;
}
function C3(e5, t6) {
  return e5 ? t6 ? 4 : 3 : t6 ? 3 : 2;
}
var D = class {
  constructor(e5, t6) {
    this.coords = e5, this.coordsIndex = t6;
  }
  get x() {
    return this.coords[this.coordsIndex];
  }
  get y() {
    return this.coords[this.coordsIndex + 1];
  }
  get z() {
    return this.coords[this.coordsIndex + 2];
  }
};

// node_modules/@arcgis/core/layers/graphics/data/queryValidationUtils.js
var u5 = "unsupported-query";
async function c6(t6, { fieldsIndex: i6, geometryType: s6, spatialReference: r5, availableFields: o3 }) {
  if ((t6.distance ?? 0) < 0 || null != t6.geometryPrecision || t6.multipatchOption && "xyFootprint" !== t6.multipatchOption || t6.pixelSize || t6.relationParam || t6.text)
    throw new s2(u5, "Unsupported query options", { query: t6 });
  return p5(i6, o3, t6), f4(i6, o3, t6), Promise.all([P3(t6, s6, r5), x2(r5, t6.outSR)]).then(() => t6);
}
function p5(t6, i6, o3) {
  const { outFields: n5, orderByFields: a7, returnDistinctValues: l6, outStatistics: c7 } = o3, p8 = c7 ? c7.map((e5) => e5.outStatisticFieldName && e5.outStatisticFieldName.toLowerCase()).filter(Boolean) : [];
  if (a7 && a7.length > 0) {
    const e5 = " asc", r5 = " desc", n6 = a7.map((t7) => {
      const i7 = t7.toLowerCase();
      return i7.includes(e5) ? i7.split(e5)[0] : i7.includes(r5) ? i7.split(r5)[0] : t7;
    }).filter((e6) => !p8.includes(e6));
    g3(t6, i6, n6, { expressionName: "orderByFields", query: o3 });
  }
  if (n5 && n5.length > 0)
    g3(t6, i6, n5, { expressionName: "outFields", query: o3 });
  else if (l6)
    throw new s2(u5, "outFields should be specified for returnDistinctValues", { query: o3 });
  p4(t6, i6, o3.where, o3);
}
var d5 = /* @__PURE__ */ new Set([...o2, ...a6]);
function f4(t6, i6, r5) {
  const { outStatistics: n5, groupByFieldsForStatistics: a7, having: l6 } = r5, c7 = a7 == null ? void 0 : a7.length, p8 = n5 == null ? void 0 : n5.length;
  if (l6) {
    if (!c7 || !p8)
      throw new s2(u5, "outStatistics and groupByFieldsForStatistics should be specified with having", { query: r5 });
    f3(t6, i6, l6, n5, r5);
  }
  if (p8) {
    if (!h2(n5))
      return;
    const o3 = n5.map((e5) => e5.onStatisticField).filter(Boolean);
    g3(t6, i6, o3, { expressionName: "onStatisticFields", query: r5 }), c7 && g3(t6, i6, a7, { expressionName: "groupByFieldsForStatistics", query: r5 });
    for (const a8 of n5) {
      const { onStatisticField: o4, statisticType: n6 } = a8;
      if (("percentile_disc" === n6 || "percentile_cont" === n6) && "statisticParameters" in a8) {
        const { statisticParameters: t7 } = a8;
        if (!t7)
          throw new s2(u5, "statisticParameters should be set for percentile type", { definition: a8, query: r5 });
      } else
        t6.get(o4) && "count" !== n6 && "min" !== n6 && "max" !== n6 && g3(t6, i6, [o4], { expressionName: `outStatistics with '${n6}' statistic type`, allowedFieldTypes: d5, query: r5 });
    }
  }
}
async function m4(t6, i6, { fieldsIndex: s6, geometryType: r5, spatialReference: o3, availableFields: l6 }) {
  if ((t6.distance ?? 0) < 0 || null != t6.geometryPrecision || t6.multipatchOption || t6.pixelSize || t6.relationParam || t6.text || t6.outStatistics || t6.groupByFieldsForStatistics || t6.having || t6.orderByFields)
    throw new s2(u5, "Unsupported query options", { query: t6 });
  return p5(s6, l6, t6), Promise.all([y4(s6, l6, i6, t6), P3(t6, r5, o3), x2(o3, t6.outSR)]).then(() => t6);
}
async function y4(t6, i6, r5, o3) {
  let n5 = [];
  if (r5.valueExpression) {
    const { arcadeUtils: e5 } = await i4();
    n5 = e5.extractFieldNames(r5.valueExpression);
  }
  if (r5.field && n5.push(r5.field), r5.field2 && n5.push(r5.field2), r5.field3 && n5.push(r5.field3), r5.normalizationField && n5.push(r5.normalizationField), !n5.length && !r5.valueExpression)
    throw new s2(u5, "field or valueExpression is required", { params: r5 });
  g3(t6, i6, n5, { expressionName: "statistics", query: o3 });
}
function h2(e5) {
  return null != e5 && e5.every((e6) => "exceedslimit" !== e6.statisticType);
}

// node_modules/@arcgis/core/layers/support/PromiseQueue.js
var n4 = class {
  constructor() {
    this._tasks = new Array(), this._running = r3(false);
  }
  get length() {
    return this._tasks.length;
  }
  get running() {
    return this._running.value;
  }
  destroy() {
    this.cancelAll();
  }
  runTask(s6) {
    for (; !s6.done && this._process(s6); )
      s6.madeProgress();
  }
  push(s6, t6, e5) {
    return this._running.value = true, new Promise((r5, n5) => this._tasks.push(new i5(r5, n5, s6, t6, e5)));
  }
  unshift(s6, t6, e5) {
    return this._running.value = true, new Promise((r5, n5) => this._tasks.unshift(new i5(r5, n5, s6, t6, e5)));
  }
  _process(r5) {
    var _a;
    if (0 === this._tasks.length)
      return false;
    const n5 = this._tasks.shift();
    try {
      const i6 = c(n5.signal);
      if (i6 && !n5.abortCallback)
        n5.reject(u2());
      else {
        const s6 = i6 ? (_a = n5.abortCallback) == null ? void 0 : _a.call(n5, u2()) : n5.callback(r5);
        E(s6) ? s6.then(n5.resolve, n5.reject) : n5.resolve(s6);
      }
    } catch (i6) {
      n5.reject(i6);
    }
    return this._running.value = this._tasks.length > 0, true;
  }
  cancelAll() {
    const s6 = u2();
    for (const t6 of this._tasks)
      if (t6.abortCallback) {
        const e5 = t6.abortCallback(s6);
        t6.resolve(e5);
      } else
        t6.reject(s6);
    this._tasks.length = 0, this._running.value = false;
  }
};
var i5 = class {
  constructor(s6, t6, e5, r5 = void 0, n5 = void 0) {
    this.resolve = s6, this.reject = t6, this.callback = e5, this.signal = r5, this.abortCallback = n5;
  }
};

// node_modules/@arcgis/core/views/support/debugFlags.js
var t5 = class extends g {
  constructor() {
    super(...arguments), this.SCHEDULER_LOG_SLOW_TASKS = false, this.FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES = false;
  }
};
e([y()], t5.prototype, "SCHEDULER_LOG_SLOW_TASKS", void 0), e([y()], t5.prototype, "FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES", void 0), t5 = e([c2("esri.views.support.DebugFlags")], t5);
var p6 = new t5();

// node_modules/@arcgis/core/views/support/Scheduler.js
var g4;
var I3;
!function(e5) {
  e5[e5.YIELD = 1] = "YIELD";
}(g4 || (g4 = {})), function(e5) {
  e5.RESOURCE_CONTROLLER_IMMEDIATE = "immediate", e5.RESOURCE_CONTROLLER = "schedule", e5.SLIDE = "slide", e5.STREAM_DATA_LOADER = "stream loader", e5.ELEVATION_QUERY = "elevation query", e5.TERRAIN_SURFACE = "terrain", e5.SURFACE_GEOMETRY_UPDATES = "surface geometry updates", e5.LOD_RENDERER = "LoD renderer", e5.GRAPHICS_CORE = "Graphics3D", e5.I3S_CONTROLLER = "I3S", e5.POINT_CLOUD_LAYER = "point cloud", e5.FEATURE_TILE_FETCHER = "feature fetcher", e5.OVERLAY = "overlay", e5.STAGE = "stage", e5.GRAPHICS_DECONFLICTOR = "graphics deconflictor", e5.FILTER_VISIBILITY = "Graphics3D filter visibility", e5.SCALE_VISIBILITY = "Graphics3D scale visibility", e5.FRUSTUM_VISIBILITY = "Graphics3D frustum visibility", e5.POINT_OF_INTEREST_FREQUENT = "POI frequent", e5.POINT_OF_INTEREST_INFREQUENT = "POI infrequent", e5.LABELER = "labeler", e5.FEATURE_QUERY_ENGINE = "feature query", e5.FEATURE_TILE_TREE = "feature tile tree", e5.FEATURE_TILE_TREE_ACTIVE = "fast feature tile tree", e5.ELEVATION_ALIGNMENT = "elevation alignment", e5.TEXT_TEXTURE_ATLAS = "text texture atlas", e5.TEXTURE_UNLOAD = "texture unload", e5.LINE_OF_SIGHT_TOOL = "line of sight tool", e5.LINE_OF_SIGHT_TOOL_INTERACTIVE = "interactive line of sight tool", e5.ELEVATION_PROFILE = "elevation profile", e5.SNAPPING = "snapping", e5.SHADOW_ACCUMULATOR = "shadow accumulator", e5.CLOUDS_GENERATOR = "clouds generator", e5[e5.NONE = 0] = "NONE", e5[e5.TEST_PRIO = 1] = "TEST_PRIO";
}(I3 || (I3 = {}));
var R2 = 0;
var p7 = /* @__PURE__ */ new Map([[I3.RESOURCE_CONTROLLER_IMMEDIATE, R2], [I3.RESOURCE_CONTROLLER, 4], [I3.SLIDE, R2], [I3.STREAM_DATA_LOADER, R2], [I3.ELEVATION_QUERY, R2], [I3.TERRAIN_SURFACE, 1], [I3.SURFACE_GEOMETRY_UPDATES, 1], [I3.LOD_RENDERER, 2], [I3.GRAPHICS_CORE, 2], [I3.I3S_CONTROLLER, 2], [I3.POINT_CLOUD_LAYER, 2], [I3.FEATURE_TILE_FETCHER, 2], [I3.OVERLAY, 4], [I3.STAGE, 4], [I3.GRAPHICS_DECONFLICTOR, 4], [I3.FILTER_VISIBILITY, 4], [I3.SCALE_VISIBILITY, 4], [I3.FRUSTUM_VISIBILITY, 4], [I3.CLOUDS_GENERATOR, 4], [I3.POINT_OF_INTEREST_FREQUENT, 6], [I3.POINT_OF_INTEREST_INFREQUENT, 30], [I3.LABELER, 8], [I3.FEATURE_QUERY_ENGINE, 8], [I3.FEATURE_TILE_TREE, 16], [I3.FEATURE_TILE_TREE_ACTIVE, R2], [I3.ELEVATION_ALIGNMENT, 12], [I3.TEXT_TEXTURE_ATLAS, 12], [I3.TEXTURE_UNLOAD, 12], [I3.LINE_OF_SIGHT_TOOL, 16], [I3.LINE_OF_SIGHT_TOOL_INTERACTIVE, R2], [I3.SNAPPING, R2], [I3.SHADOW_ACCUMULATOR, 30]]);
function f5(e5) {
  return p7.has(e5) ? p7.get(e5) : "number" == typeof e5 ? e5 : 1;
}
var L = n(6.5);
var A = n(1);
var b2 = n(30);
var S4 = n(1e3 / 30);
var O2 = n(100);
var k2 = 0.9;
var N2;
var U2;
!function(a7) {
  class n5 {
    get updating() {
      return this._updating.value;
    }
    _updatingChanged() {
      this._updating.value = this._tasks.some((e5) => e5.needsUpdate);
    }
    constructor() {
      this._updating = r3(true), this._microTaskQueued = false, this._frameNumber = 0, this.performanceInfo = { total: new s3("total"), tasks: /* @__PURE__ */ new Map() }, this._frameTaskTimes = /* @__PURE__ */ new Map(), this._budget = new c7(), this._state = I2.INTERACTING, this._tasks = new l2(), this._runQueue = new l2(), this._load = 0, this._idleStateCallbacks = new l2(), this._idleUpdatesStartFired = false, this._forceTask = false, this._debug = false, this._debugHandle = d(() => p6.SCHEDULER_LOG_SLOW_TASKS, (e6) => this._debug = e6, P);
      for (const t6 of Object.keys(I3))
        this.performanceInfo.tasks.set(I3[t6], new s3(I3[t6]));
      const e5 = this;
      this._test = { FRAME_SAFETY_BUDGET: L, INTERACTING_BUDGET: S4, IDLE_BUDGET: O2, get availableBudget() {
        return e5._budget.budget;
      }, usedBudget: 0, getBudget: () => e5._budget, setBudget: (t6) => e5._budget = t6, updateTask: (e6) => this._updateTask(e6), getState: (e6) => this._getState(e6), getRuntime: (e6) => this._getRuntime(e6), frameTaskTimes: this._frameTaskTimes, resetRuntimes: () => this._resetRuntimes(), getRunning: () => this._getRunning() };
    }
    destroy() {
      this._tasks.toArray().forEach((e5) => e5.remove()), this._tasks.clear(), l(this._debugHandle), this._microTaskQueued = false, this._updatingChanged();
    }
    taskRunningChanged(e5) {
      this._updatingChanged(), e5 && this._budget.remaining > 0 && !this._microTaskQueued && (this._microTaskQueued = true, queueMicrotask(() => {
        this._microTaskQueued && (this._microTaskQueued = false, this._budget.remaining > 0 && this._schedule() && this.frame());
      }));
    }
    registerTask(e5, t6) {
      const s6 = f5(e5), i6 = new u6(this, e5, t6, s6);
      return this._tasks.push(i6), this._updatingChanged(), this.performanceInfo.tasks.has(e5) || this.performanceInfo.tasks.set(e5, new s3(e5)), i6;
    }
    registerIdleStateCallbacks(e5, t6) {
      const s6 = { idleBegin: e5, idleEnd: t6 };
      this._idleStateCallbacks.push(s6), this.state === I2.IDLE && this._idleUpdatesStartFired && s6.idleBegin();
      const r5 = this;
      return { remove: () => this._removeIdleStateCallbacks(s6), set idleBegin(e6) {
        r5._idleUpdatesStartFired && (s6.idleEnd(), r5._state === I2.IDLE && e6()), s6.idleBegin = e6;
      }, set idleEnd(e6) {
        s6.idleEnd = e6;
      } };
    }
    get load() {
      return this._load;
    }
    set state(e5) {
      this._state !== e5 && (this._state = e5, this.state !== I2.IDLE && this._idleUpdatesStartFired && (this._idleUpdatesStartFired = false, this._idleStateCallbacks.forAll((e6) => e6.idleEnd())));
    }
    get state() {
      return this._state;
    }
    updateBudget(e5) {
      this._test.usedBudget = 0, ++this._frameNumber;
      let t6 = L, s6 = e5.frameDuration, r5 = A;
      switch (this.state) {
        case I2.IDLE:
          t6 = n(0), s6 = n(Math.max(O2, e5.frameDuration)), r5 = b2;
          break;
        case I2.INTERACTING:
          s6 = n(Math.max(S4, e5.frameDuration));
        case I2.ANIMATING:
      }
      return s6 = n(s6 - e5.elapsedFrameTime - t6), this.state !== I2.IDLE && s6 < A && !this._forceTask ? (this._forceTask = true, false) : (s6 = n(Math.max(s6, r5)), this._budget.reset(s6, this.state), this._updateLoad(), this._schedule());
    }
    frame() {
      switch (this._forceTask = false, this._microTaskQueued = false, this.state) {
        case I2.IDLE:
          this._idleUpdatesStartFired || (this._idleUpdatesStartFired = true, this._idleStateCallbacks.forAll((e5) => e5.idleBegin())), this._runIdle();
          break;
        case I2.INTERACTING:
          this._runInteracting();
          break;
        default:
          this._runAnimating();
      }
      this._test.usedBudget = this._budget.elapsed;
    }
    stopFrame() {
      this._budget.reset(n(0), this._state), this._budget.madeProgress();
    }
    _removeIdleStateCallbacks(e5) {
      this._idleUpdatesStartFired && e5.idleEnd(), this._idleStateCallbacks.removeUnordered(e5);
    }
    removeTask(e5) {
      this._tasks.removeUnordered(e5), this._runQueue.removeUnordered(e5), this._updatingChanged();
    }
    _updateTask(e5) {
      this._tasks.forAll((t6) => {
        t6.name === e5 && t6.setPriority(e5);
      });
    }
    _getState(e5) {
      if (this._runQueue.some((t7) => t7.name === e5))
        return U2.SCHEDULED;
      let t6 = U2.IDLE;
      return this._tasks.forAll((s6) => {
        s6.name === e5 && s6.needsUpdate && (s6.schedulePriority <= 1 ? t6 = U2.READY : t6 !== U2.READY && (t6 = U2.WAITING));
      }), t6;
    }
    _getRuntime(e5) {
      let t6 = 0;
      return this._tasks.forAll((s6) => {
        s6.name === e5 && (t6 += s6.runtime);
      }), t6;
    }
    _resetRuntimes() {
      this._tasks.forAll((e5) => e5.runtime = 0);
    }
    _getRunning() {
      const e5 = /* @__PURE__ */ new Map();
      if (this._tasks.forAll((t7) => {
        t7.needsUpdate && e5.set(t7.name, (e5.get(t7.name) || 0) + 1);
      }), 0 === e5.size)
        return null;
      let t6 = "";
      return e5.forEach((e6, s6) => {
        t6 += e6 > 1 ? ` ${e6}x ${s6}` : ` ${s6}`;
      }), t6;
    }
    _runIdle() {
      this._run();
    }
    _runInteracting() {
      this._run();
    }
    _runAnimating() {
      this._run();
    }
    _updateLoad() {
      const e5 = this._tasks.reduce((e6, t6) => t6.needsUpdate ? ++e6 : e6, 0);
      this._load = this._load * k2 + e5 * (1 - k2);
    }
    _schedule() {
      for (this._runQueue.filterInPlace((e5) => !!e5.needsUpdate || (e5.schedulePriority = e5.basePriority, false)), this._tasks.forAll((e5) => {
        e5.basePriority === R2 && e5.needsUpdate && !this._runQueue.includes(e5) && e5.blockFrame !== this._frameNumber && this._runQueue.unshift(e5);
      }); 0 === this._runQueue.length; ) {
        let e5 = false, t6 = 0;
        if (this._tasks.forAll((s6) => {
          if (s6.needsUpdate && 0 !== s6.schedulePriority && s6.basePriority !== R2 && s6.blockFrame !== this._frameNumber)
            if (e5 = true, t6 = Math.max(t6, s6.basePriority), 1 === s6.schedulePriority)
              s6.schedulePriority = 0, this._runQueue.push(s6);
            else
              --s6.schedulePriority;
        }), !e5)
          return this._updatingChanged(), false;
      }
      return this._updatingChanged(), true;
    }
    _run() {
      const e5 = this._budget.now();
      this._startFrameTaskTimes();
      do {
        for (; this._runQueue.length > 0; ) {
          const r5 = this._budget.now(), i6 = this._runQueue.pop();
          this._budget.resetProgress();
          try {
            i6.task.runTask(this._budget) === g4.YIELD && (i6.blockFrame = this._frameNumber);
          } catch (s6) {
            s.getLogger("esri.views.support.Scheduler").error(`Exception in task "${i6.name}"`, s6), i6.blockFrame = this._frameNumber;
          }
          !this._budget.hasProgressed && i6.blockFrame !== this._frameNumber && i6.needsUpdate && (i6.name, I3.I3S_CONTROLLER, i6.blockFrame = this._frameNumber), i6.schedulePriority = i6.basePriority;
          const a8 = this._budget.now() - r5;
          if (i6.runtime += a8, this._frameTaskTimes.set(i6.priority, this._frameTaskTimes.get(i6.priority) + a8), this._debug && a8 > 2 * this._budget.budget && console.log("Task", i6.name, "used", a8, "of max", this._budget.budget, "ms"), this._budget.remaining <= 0)
            return this._updatingChanged(), void this._recordFrameTaskTimes(this._budget.now() - e5);
        }
      } while (this._schedule());
      this._updatingChanged(), this._recordFrameTaskTimes(this._budget.now() - e5);
    }
    _startFrameTaskTimes() {
      for (const e5 of Object.keys(I3))
        this._frameTaskTimes.set(I3[e5], 0);
    }
    _recordFrameTaskTimes(e5) {
      this._frameTaskTimes.forEach((e6, t6) => this.performanceInfo.tasks.get(t6).record(e6)), this.performanceInfo.total.record(e5);
    }
    get test() {
      return this._test;
    }
  }
  a7.Scheduler = n5;
  class u6 {
    get task() {
      return this._task.value;
    }
    get updating() {
      return this._queue.running;
    }
    constructor(t6, s6, r5, i6) {
      this._scheduler = t6, this.name = s6, this._basePriority = i6, this.blockFrame = 0, this.runtime = 0, this._queue = new n4(), this._handles = new e2(), this.schedulePriority = this._basePriority, this._task = r3(null != r5 ? r5 : this._queue), this._handles.add(p(() => this.task.running, (e5) => t6.taskRunningChanged(e5)));
    }
    remove() {
      this.processQueue(C4), this._scheduler.removeTask(this), this.schedule = F.schedule, this.reschedule = F.reschedule, this._handles.destroy();
    }
    get basePriority() {
      return this._basePriority;
    }
    setPriority(e5) {
      this.name = e5;
      const t6 = f5(e5);
      this._basePriority !== R2 && 0 === this.schedulePriority || (this.schedulePriority = t6), this._basePriority = t6;
    }
    get priority() {
      return this.name;
    }
    set priority(e5) {
      this.setPriority(e5);
    }
    get needsUpdate() {
      return this.updating || this.task.running;
    }
    schedule(e5, t6, s6) {
      return this._queue.push(e5, t6, s6);
    }
    reschedule(e5, t6, s6) {
      return this._queue.unshift(e5, t6, s6);
    }
    processQueue(e5) {
      this._queue.runTask(e5);
    }
  }
  class c7 {
    constructor() {
      this._begin = "undefined" != typeof performance ? performance.now() : 0, this._budget = 0, this._state = I2.IDLE, this._done = false, this._progressed = false, this._enabled = true;
    }
    run(e5) {
      return !this.done && (true === e5() && this.madeProgress(), true);
    }
    get done() {
      return this._done;
    }
    get budget() {
      return this._budget;
    }
    madeProgress() {
      return this._progressed = true, this._done = this.elapsed >= this._budget && this._enabled, this._done;
    }
    get state() {
      return this._state;
    }
    get enabled() {
      return this._enabled;
    }
    set enabled(e5) {
      this._enabled = e5;
    }
    reset(e5, t6) {
      this._begin = this.now(), this._budget = e5, this._state = t6, this.resetProgress();
    }
    get remaining() {
      return Math.max(this._budget - this.elapsed, 0);
    }
    now() {
      return performance.now();
    }
    get elapsed() {
      return performance.now() - this._begin;
    }
    resetProgress() {
      this._progressed = false, this._done = false;
    }
    get hasProgressed() {
      return this._progressed;
    }
  }
  a7.Budget = c7;
}(N2 || (N2 = {})), function(e5) {
  e5.SCHEDULED = "s", e5.READY = "r", e5.WAITING = "w", e5.IDLE = "i";
}(U2 || (U2 = {}));
var C4 = (() => {
  const e5 = new N2.Budget();
  return e5.enabled = false, e5;
})();
var P4 = class {
  remove() {
  }
  processQueue() {
  }
  schedule(e5, t6, s6) {
    try {
      if (c(t6)) {
        const e6 = u2();
        return s6 ? Promise.resolve(s6(e6)) : Promise.reject(e6);
      }
      return S2(e5(C4));
    } catch (r5) {
      return Promise.reject(r5);
    }
  }
  reschedule(e5, t6, s6) {
    return this.schedule(e5, t6, s6);
  }
};
var F = new P4();

// node_modules/@arcgis/core/layers/graphics/data/QueryEngine.js
var N3 = "unsupported-query";
var V = new r2(2e6);
var D2 = 0;
var W2 = class {
  constructor(e5) {
    this._geometryQueryCache = null, this._changeHandle = null, this.capabilities = { query: t }, this.geometryType = e5.geometryType, this.hasM = !!e5.hasM, this.hasZ = !!e5.hasZ, this.objectIdField = e5.objectIdField, this.spatialReference = e5.spatialReference, this.definitionExpression = e5.definitionExpression, this.featureStore = e5.featureStore, this.aggregateAdapter = e5.aggregateAdapter, this._changeHandle = this.featureStore.events.on("changed", () => this.clearCache()), this.timeInfo = e5.timeInfo, e5.cacheSpatialQueries && (this._geometryQueryCache = new i3(D2++ + "$$", V)), this.fieldsIndex = a2(e5.fieldsIndex) ? e5.fieldsIndex : Z.fromJSON(e5.fieldsIndex), this.availableFields = null == e5.availableFields ? new Set(this.fieldsIndex.fields.map((e6) => e6.name)) : new Set(e5.availableFields.map((e6) => {
      var _a;
      return (_a = this.fieldsIndex.get(e6)) == null ? void 0 : _a.name;
    }).filter((e6) => null != e6)), e5.scheduler && e5.priority && (this._frameTask = e5.scheduler.registerTask(e5.priority));
  }
  destroy() {
    this._frameTask = l(this._frameTask), this.clearCache(), u(this._geometryQueryCache), this._changeHandle = l(this._changeHandle);
  }
  get featureAdapter() {
    return this.featureStore.featureAdapter;
  }
  clearCache() {
    var _a;
    (_a = this._geometryQueryCache) == null ? void 0 : _a.clear(), this._allFeaturesPromise = null, this._timeExtentPromise = null, this._fullExtentPromise = null;
  }
  async executeQuery(e5, t6) {
    try {
      return (await this._executeQuery(e5, {}, t6)).createQueryResponse();
    } catch (i6) {
      if (i6 !== g2)
        throw i6;
      return new q([], e5, this).createQueryResponse();
    }
  }
  async executeQueryForCount(e5 = {}, t6) {
    try {
      return (await this._executeQuery(e5, { returnGeometry: false, returnCentroid: false, outSR: null }, t6)).createQueryResponseForCount();
    } catch (i6) {
      if (i6 !== g2)
        throw i6;
      return 0;
    }
  }
  async executeQueryForExtent(e5, t6) {
    const i6 = e5.outSR;
    try {
      const s6 = await this._executeQuery(e5, { returnGeometry: true, returnCentroid: false, outSR: null }, t6), r5 = s6.size;
      if (!r5)
        return { count: 0, extent: null };
      return { count: r5, extent: await this._getBounds(s6.items, s6.spatialReference, i6 || this.spatialReference) };
    } catch (s6) {
      if (s6 === g2)
        return { count: 0, extent: null };
      throw s6;
    }
  }
  async executeQueryForIds(e5, t6) {
    return this.executeQueryForIdSet(e5, t6).then((e6) => Array.from(e6));
  }
  async executeQueryForIdSet(e5, t6) {
    try {
      const i6 = await this._executeQuery(e5, { returnGeometry: true, returnCentroid: false, outSR: null }, t6), s6 = i6.items, r5 = /* @__PURE__ */ new Set();
      return await this._reschedule(() => {
        for (const e6 of s6)
          r5.add(i6.featureAdapter.getObjectId(e6));
      }, t6), r5;
    } catch (i6) {
      if (i6 === g2)
        return /* @__PURE__ */ new Set();
      throw i6;
    }
  }
  async executeQueryForSnapping(e5, t6) {
    const { point: i6, distance: s6, returnEdge: a7, vertexMode: n5 } = e5;
    if (!a7 && "none" === n5)
      return { candidates: [] };
    let u6 = a(e5.query);
    u6 = await this._schedule(() => j2(u6, this.definitionExpression, this.spatialReference), t6), u6 = await this._reschedule(() => c6(u6, { availableFields: this.availableFields, fieldsIndex: this.fieldsIndex, geometryType: this.geometryType, spatialReference: this.spatialReference }), t6);
    const l6 = !d2(i6.spatialReference, this.spatialReference);
    l6 && await x2(i6.spatialReference, this.spatialReference);
    const o3 = "number" == typeof s6 ? s6 : s6.x, h3 = "number" == typeof s6 ? s6 : s6.y, c7 = { xmin: i6.x - o3, xmax: i6.x + o3, ymin: i6.y - h3, ymax: i6.y + h3, spatialReference: i6.spatialReference }, m5 = l6 ? j(c7, this.spatialReference) : c7;
    if (!m5)
      return { candidates: [] };
    const y5 = (await R(p2(i6), null, { signal: t6 }))[0], f6 = (await R(p2(m5), null, { signal: t6 }))[0];
    if (null == y5 || null == f6)
      return { candidates: [] };
    const p8 = new q(await this._reschedule(() => this._searchFeatures(this._getQueryBBoxes(f6.toJSON())), t6), u6, this);
    await this._reschedule(() => this._executeObjectIdsQuery(p8), t6), await this._reschedule(() => this._executeTimeQuery(p8), t6), await this._reschedule(() => this._executeAttributesQuery(p8), t6), await this._reschedule(() => this._executeGeometryQueryForSnapping(p8, t6), t6);
    const d6 = y5.toJSON(), g5 = l6 ? j(d6, this.spatialReference) : d6, x3 = l6 ? Math.max(m5.xmax - m5.xmin, m5.ymax - m5.ymin) / 2 : s6;
    return p8.createSnappingResponse({ ...e5, point: g5, distance: x3 }, i6.spatialReference);
  }
  async executeQueryForLatestObservations(e5, t6) {
    var _a;
    if (!((_a = this.timeInfo) == null ? void 0 : _a.trackIdField))
      throw new s2(N3, "Missing timeInfo or timeInfo.trackIdField", { query: e5, timeInfo: this.timeInfo });
    try {
      const i6 = await this._executeQuery(e5, {}, t6);
      return await this._reschedule(() => this._filterLatest(i6), t6), i6.createQueryResponse();
    } catch (s6) {
      if (s6 !== g2)
        throw s6;
      return new q([], e5, this).createQueryResponse();
    }
  }
  async executeQueryForSummaryStatistics(e5 = {}, t6, i6) {
    const { field: s6, normalizationField: r5, valueExpression: a7 } = t6;
    return (await this._executeQueryForStatistics(e5, { field: s6, normalizationField: r5, valueExpression: a7 }, i6)).createSummaryStatisticsResponse(t6);
  }
  async executeQueryForUniqueValues(e5 = {}, t6, i6) {
    const { field: s6, field2: r5, field3: a7, valueExpression: n5 } = t6;
    return (await this._executeQueryForStatistics(e5, { field: s6, field2: r5, field3: a7, valueExpression: n5 }, i6)).createUniqueValuesResponse(t6);
  }
  async executeQueryForClassBreaks(e5 = {}, t6, i6) {
    const { field: s6, normalizationField: r5, valueExpression: a7 } = t6;
    return (await this._executeQueryForStatistics(e5, { field: s6, normalizationField: r5, valueExpression: a7 }, i6)).createClassBreaksResponse(t6);
  }
  async executeQueryForHistogram(e5 = {}, t6, i6) {
    const { field: s6, normalizationField: r5, valueExpression: a7 } = t6;
    return (await this._executeQueryForStatistics(e5, { field: s6, normalizationField: r5, valueExpression: a7 }, i6)).createHistogramResponse(t6);
  }
  async fetchRecomputedExtents(e5) {
    this._timeExtentPromise || (this._timeExtentPromise = n2(this.timeInfo, this.featureStore));
    const [t6, i6] = await Promise.all([this._getFullExtent(), this._timeExtentPromise]);
    return s4(e5), { fullExtent: t6, timeExtent: i6 };
  }
  async _getBounds(e5, t6, i6) {
    const s6 = O(i2(), C);
    await this.featureStore.forEachBounds(e5, (e6) => o(s6, e6));
    const r5 = { xmin: s6[0], ymin: s6[1], xmax: s6[3], ymax: s6[4], spatialReference: h(this.spatialReference) };
    this.hasZ && isFinite(s6[2]) && isFinite(s6[5]) && (r5.zmin = s6[2], r5.zmax = s6[5]);
    const a7 = j(r5, t6, i6);
    if (a7.spatialReference = h(i6), a7.xmax - a7.xmin == 0) {
      const e6 = z(a7.spatialReference);
      a7.xmin -= e6, a7.xmax += e6;
    }
    if (a7.ymax - a7.ymin == 0) {
      const e6 = z(a7.spatialReference);
      a7.ymin -= e6, a7.ymax += e6;
    }
    if (this.hasZ && null != a7.zmin && null != a7.zmax && a7.zmax - a7.zmin == 0) {
      const e6 = z(a7.spatialReference);
      a7.zmin -= e6, a7.zmax += e6;
    }
    return a7;
  }
  _getFullExtent() {
    return this._fullExtentPromise || (this._fullExtentPromise = "getFullExtent" in this.featureStore && this.featureStore.getFullExtent ? Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)) : this._getAllFeatures().then((e5) => this._getBounds(e5, this.spatialReference, this.spatialReference))), this._fullExtentPromise;
  }
  async _schedule(e5, t6) {
    return null != this._frameTask ? this._frameTask.schedule(e5, t6) : e5(C4);
  }
  async _reschedule(e5, t6) {
    return null != this._frameTask ? this._frameTask.reschedule(e5, t6) : e5(C4);
  }
  async _getAllFeaturesQueryEngineResult(e5) {
    return new q(await this._getAllFeatures(), e5, this);
  }
  async _getAllFeatures() {
    if (null == this._allFeaturesPromise) {
      const e6 = [];
      this._allFeaturesPromise = (async () => {
        await this.featureStore.forEach((t7) => e6.push(t7));
      })().then(() => e6);
    }
    const e5 = this._allFeaturesPromise, t6 = await e5;
    return e5 === this._allFeaturesPromise ? t6.slice() : this._getAllFeatures();
  }
  async _executeQuery(e5, t6, i6) {
    e5 = a(e5), e5 = await this._schedule(() => S3(e5, this.definitionExpression, this.spatialReference), i6), e5 = await this._reschedule(() => c6(e5, { availableFields: this.availableFields, fieldsIndex: this.fieldsIndex, geometryType: this.geometryType, spatialReference: this.spatialReference }), i6), e5 = { ...e5, ...t6 };
    const s6 = await this._reschedule(() => this._executeSceneFilterQuery(e5, i6), i6), a7 = await this._reschedule(() => this._executeGeometryQuery(e5, s6, i6), i6);
    return await this._reschedule(() => this._executeAggregateIdsQuery(a7), i6), await this._reschedule(() => this._executeObjectIdsQuery(a7), i6), await this._reschedule(() => this._executeTimeQuery(a7), i6), await this._reschedule(() => this._executeAttributesQuery(a7), i6), a7;
  }
  async _executeSceneFilterQuery(e5, t6) {
    if (null == e5.sceneFilter)
      return null;
    const { outSR: i6, returnGeometry: s6, returnCentroid: r5 } = e5, a7 = this.featureStore.featureSpatialReference, n5 = e5.sceneFilter.geometry, u6 = null == a7 || d2(a7, n5.spatialReference) ? n5 : j(n5, a7);
    if (!u6)
      return null;
    const l6 = s6 || r5, o3 = W(i6) && !d2(this.spatialReference, i6) && l6 ? async (e6) => this._project(e6, i6) : (e6) => e6, h3 = this.featureAdapter, c7 = await this._reschedule(() => this._searchFeatures(this._getQueryBBoxes(u6)), t6);
    if ("disjoint" === e5.sceneFilter.spatialRelationship) {
      if (!c7.length)
        return null;
      const i7 = /* @__PURE__ */ new Set();
      for (const e6 of c7)
        i7.add(h3.getObjectId(e6));
      const s7 = await this._reschedule(() => this._getAllFeatures(), t6), r6 = await this._reschedule(async () => {
        const r7 = await v4("esriSpatialRelDisjoint", u6, this.geometryType, this.hasZ, this.hasM), a8 = (e6) => !i7.has(h3.getObjectId(e6)) || r7(h3.getGeometry(e6)), n6 = await this._runSpatialFilter(s7, a8, t6);
        return new q(n6, e5, this);
      }, t6);
      return o3(r6);
    }
    if (!c7.length)
      return new q([], e5, this);
    if (this._canExecuteSinglePass(u6, e5))
      return o3(new q(c7, e5, this));
    const m5 = await v4("esriSpatialRelContains", u6, this.geometryType, this.hasZ, this.hasM), y5 = await this._runSpatialFilter(c7, (e6) => m5(h3.getGeometry(e6)), t6);
    return o3(new q(y5, e5, this));
  }
  async _executeGeometryQuery(i6, s6, r5) {
    if (null != s6 && 0 === s6.items.length)
      return s6;
    i6 = null != s6 ? s6.query : i6;
    const { geometry: a7, outSR: n5, spatialRel: u6, returnGeometry: l6, returnCentroid: o3 } = i6, h3 = this.featureStore.featureSpatialReference, c7 = !a7 || null == h3 || d2(h3, a7.spatialReference) ? a7 : j(a7, h3), m5 = l6 || o3, y5 = W(n5) && !d2(this.spatialReference, n5), f6 = this._geometryQueryCache && null == s6 ? y5 && m5 ? JSON.stringify({ originalFilterGeometry: a7, spatialRelationship: u6, outSpatialReference: n5 }) : JSON.stringify({ originalFilterGeometry: a7, spatialRelationship: u6 }) : null, p8 = f6 ? this._geometryQueryCache.get(f6) : null;
    if (null != p8)
      return new q(p8, i6, this);
    const d6 = async (e5) => (y5 && m5 && await this._project(e5, n5), f6 && this._geometryQueryCache.put(f6, e5.items, e5.items.length + 1), e5);
    if (!c7)
      return d6(null != s6 ? s6 : await this._getAllFeaturesQueryEngineResult(i6));
    const g5 = this.featureAdapter;
    let x3 = await this._reschedule(() => this._searchFeatures(this._getQueryBBoxes(a7)), r5);
    if ("esriSpatialRelDisjoint" === u6) {
      if (!x3.length)
        return d6(null != s6 ? s6 : await this._getAllFeaturesQueryEngineResult(i6));
      const e5 = /* @__PURE__ */ new Set();
      for (const i7 of x3)
        e5.add(g5.getObjectId(i7));
      const t6 = null != s6 ? s6.items : await this._reschedule(() => this._getAllFeatures(), r5), a8 = await this._reschedule(async () => {
        const s7 = await v4(u6, c7, this.geometryType, this.hasZ, this.hasM), a9 = (t7) => !e5.has(g5.getObjectId(t7)) || s7(g5.getGeometry(t7)), n6 = await this._runSpatialFilter(t6, a9, r5);
        return new q(n6, i6, this);
      }, r5);
      return d6(a8);
    }
    if (null != s6) {
      const i7 = new v();
      x3 = x3.filter((e5) => S(s6.items, e5, s6.items.length, i7) >= 0);
    }
    if (!x3.length) {
      const e5 = new q([], i6, this);
      return f6 && this._geometryQueryCache.put(f6, e5.items, 1), e5;
    }
    if (this._canExecuteSinglePass(c7, i6))
      return d6(new q(x3, i6, this));
    const _ = await v4(u6, c7, this.geometryType, this.hasZ, this.hasM), w2 = await this._runSpatialFilter(x3, (e5) => _(g5.getGeometry(e5)), r5);
    return d6(new q(w2, i6, this));
  }
  async _executeGeometryQueryForSnapping(e5, t6) {
    var _a;
    const { query: i6 } = e5, { spatialRel: s6 } = i6;
    if (!((_a = e5 == null ? void 0 : e5.items) == null ? void 0 : _a.length) || !i6.geometry || !s6)
      return;
    const r5 = await v4(s6, i6.geometry, this.geometryType, this.hasZ, this.hasM), a7 = await this._runSpatialFilter(e5.items, (e6) => r5(e6.geometry), t6);
    e5.items = a7;
  }
  _executeAggregateIdsQuery(e5) {
    var _a;
    if (0 === e5.items.length || !((_a = e5.query.aggregateIds) == null ? void 0 : _a.length) || null == this.aggregateAdapter)
      return;
    const t6 = /* @__PURE__ */ new Set();
    for (const s6 of e5.query.aggregateIds) {
      this.aggregateAdapter.getFeatureObjectIds(s6).forEach((e6) => t6.add(e6));
    }
    const i6 = this.featureAdapter.getObjectId;
    e5.items = e5.items.filter((e6) => t6.has(i6(e6)));
  }
  _executeObjectIdsQuery(e5) {
    var _a;
    if (0 === e5.items.length || !((_a = e5.query.objectIds) == null ? void 0 : _a.length))
      return;
    const t6 = new Set(e5.query.objectIds), i6 = this.featureAdapter.getObjectId;
    e5.items = e5.items.filter((e6) => t6.has(i6(e6)));
  }
  _executeTimeQuery(e5) {
    if (0 === e5.items.length)
      return;
    const t6 = t2(this.timeInfo, e5.query.timeExtent, this.featureAdapter);
    null != t6 && (e5.items = e5.items.filter(t6));
  }
  _executeAttributesQuery(e5) {
    if (0 === e5.items.length)
      return;
    const t6 = c4(e5.query.where, this.fieldsIndex);
    if (t6) {
      if (!t6.isStandardized)
        throw new TypeError("Where clause is not standardized");
      e5.items = e5.items.filter((e6) => t6.testFeature(e6, this.featureAdapter));
    }
  }
  async _runSpatialFilter(e5, t6, i6) {
    if (!t6)
      return e5;
    if (null == this._frameTask)
      return e5.filter((e6) => t6(e6));
    let s6 = 0;
    const r5 = new Array(), a7 = async (n5) => {
      for (; s6 < e5.length; ) {
        const u6 = e5[s6++];
        t6(u6) && (r5.push(u6), n5.madeProgress()), n5.done && await this._reschedule((e6) => a7(e6), i6);
      }
    };
    return this._reschedule((e6) => a7(e6), i6).then(() => r5);
  }
  _filterLatest(e5) {
    const { trackIdField: t6, startTimeField: i6, endTimeField: s6 } = this.timeInfo, r5 = s6 || i6, a7 = /* @__PURE__ */ new Map(), n5 = this.featureAdapter.getAttribute;
    for (const u6 of e5.items) {
      const e6 = n5(u6, t6), i7 = n5(u6, r5), s7 = a7.get(e6);
      (!s7 || i7 > n5(s7, r5)) && a7.set(e6, u6);
    }
    e5.items = Array.from(a7.values());
  }
  _canExecuteSinglePass(e5, t6) {
    const { spatialRel: i6 } = t6;
    return I(e5) && ("esriSpatialRelEnvelopeIntersects" === i6 || "esriGeometryPoint" === this.geometryType && ("esriSpatialRelIntersects" === i6 || "esriSpatialRelContains" === i6));
  }
  async _project(e5, t6) {
    if (!t6 || d2(this.spatialReference, t6))
      return e5;
    const i6 = this.featureAdapter;
    let s6;
    try {
      const e6 = await this._getFullExtent();
      s6 = K(this.spatialReference, t6, e6);
    } catch {
    }
    const r5 = await b(e5.items.map((e6) => a5(this.geometryType, this.hasZ, this.hasM, i6.getGeometry(e6))), this.spatialReference, t6, s6);
    return e5.items = r5.map((t7, s7) => i6.cloneWithGeometry(e5.items[s7], rt(t7, this.hasZ, this.hasM))), e5;
  }
  _getQueryBBoxes(e5) {
    if (I(e5)) {
      if (m(e5))
        return [a3(Math.min(e5.xmin, e5.xmax), Math.min(e5.ymin, e5.ymax), Math.max(e5.xmin, e5.xmax), Math.max(e5.ymin, e5.ymax))];
      if (f(e5))
        return e5.rings.map((e6) => a3(Math.min(e6[0][0], e6[2][0]), Math.min(e6[0][1], e6[2][1]), Math.max(e6[0][0], e6[2][0]), Math.max(e6[0][1], e6[2][1])));
    }
    return [a4(u3(), e5)];
  }
  async _searchFeatures(e5) {
    const t6 = /* @__PURE__ */ new Set();
    await Promise.all(e5.map((e6) => this.featureStore.forEachInBounds(e6, (e7) => t6.add(e7))));
    const i6 = Array.from(t6.values());
    return t6.clear(), i6;
  }
  async _executeQueryForStatistics(e5, t6, i6) {
    e5 = a(e5);
    try {
      e5 = await this._schedule(() => S3(e5, this.definitionExpression, this.spatialReference), i6), e5 = await this._reschedule(() => m4(e5, t6, { availableFields: this.availableFields, fieldsIndex: this.fieldsIndex, geometryType: this.geometryType, spatialReference: this.spatialReference }), i6);
      const s6 = await this._reschedule(() => this._executeSceneFilterQuery(e5, i6), i6), r5 = await this._reschedule(() => this._executeGeometryQuery(e5, s6, i6), i6);
      return await this._reschedule(() => this._executeAggregateIdsQuery(r5), i6), await this._reschedule(() => this._executeObjectIdsQuery(r5), i6), await this._reschedule(() => this._executeTimeQuery(r5), i6), await this._reschedule(() => this._executeAttributesQuery(r5), i6), r5;
    } catch (s6) {
      if (s6 !== g2)
        throw s6;
      return new q([], e5, this);
    }
  }
};

export {
  W2 as W
};
//# sourceMappingURL=chunk-7KUR2TMU.js.map
