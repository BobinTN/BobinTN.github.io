import {
  a
} from "./chunk-IHXVTF6I.js";
import {
  e,
  n
} from "./chunk-7SYCRLSC.js";
import {
  i as i2,
  o
} from "./chunk-UIBKJIZ5.js";
import {
  m
} from "./chunk-A427XTHR.js";
import "./chunk-QAQNFI3S.js";
import {
  W
} from "./chunk-7KUR2TMU.js";
import "./chunk-3ON6HO7Q.js";
import "./chunk-KMTPMPRR.js";
import "./chunk-K4NVR6KM.js";
import {
  x
} from "./chunk-57KRYRCY.js";
import "./chunk-747B2TEO.js";
import "./chunk-4NEWABLH.js";
import {
  t
} from "./chunk-FW2Y26A2.js";
import {
  t as t2
} from "./chunk-5WG7GACT.js";
import "./chunk-AZHRWST4.js";
import "./chunk-PFFV4MXI.js";
import "./chunk-NYTJIWNN.js";
import "./chunk-7Y57Y6IH.js";
import {
  t as t3
} from "./chunk-WND35VNG.js";
import "./chunk-PUYNEESA.js";
import "./chunk-GXVWD6F2.js";
import "./chunk-W4QVNWBV.js";
import "./chunk-LOGPPZUD.js";
import "./chunk-HYU6N3H3.js";
import "./chunk-EC5POYCL.js";
import "./chunk-X5VYGREB.js";
import "./chunk-S6MJEC4A.js";
import {
  Z
} from "./chunk-M7OEQQRX.js";
import "./chunk-CSWPLQ7Q.js";
import "./chunk-KWSMYM7P.js";
import "./chunk-RP5SAUAF.js";
import "./chunk-6BFXMZEZ.js";
import "./chunk-AMSVADDY.js";
import "./chunk-GAJBN4TM.js";
import "./chunk-RHT6WWRD.js";
import "./chunk-EUGXS5RE.js";
import "./chunk-IRNKV32L.js";
import "./chunk-HLM2UN42.js";
import "./chunk-5WWPLX36.js";
import "./chunk-UNONG753.js";
import "./chunk-OFRZSMZB.js";
import "./chunk-IATM3RCE.js";
import "./chunk-BEALJUHO.js";
import "./chunk-GRHSIT57.js";
import "./chunk-PJQIAD5D.js";
import {
  H,
  K,
  d2 as d3
} from "./chunk-Z6KIMOUA.js";
import "./chunk-SZAJDZCO.js";
import "./chunk-M7R7REMB.js";
import "./chunk-ZZYUEH57.js";
import "./chunk-VTWXDFFD.js";
import "./chunk-IPCIO3PX.js";
import "./chunk-EIY2DYTV.js";
import "./chunk-F6MD5VOH.js";
import "./chunk-V2RPSCV3.js";
import "./chunk-A43TI6AT.js";
import "./chunk-BHJVWW2P.js";
import {
  B
} from "./chunk-4HKQSEUR.js";
import "./chunk-V3U4F2NL.js";
import "./chunk-ZB6PGKG5.js";
import "./chunk-OIIDE5GZ.js";
import "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import "./chunk-TBSVVR6M.js";
import {
  d
} from "./chunk-6TJWLWLO.js";
import "./chunk-H7BKONNV.js";
import "./chunk-K6C6RVSV.js";
import {
  i
} from "./chunk-KBJ5Z4R2.js";
import "./chunk-JUZJCTW2.js";
import "./chunk-423VNHLR.js";
import "./chunk-FN47E7YK.js";
import "./chunk-XZS3Q5K4.js";
import "./chunk-XXFXRXFH.js";
import "./chunk-CCXEAKIM.js";
import "./chunk-Y5D433JZ.js";
import {
  M
} from "./chunk-QNOCEWCR.js";
import "./chunk-WURET5CW.js";
import {
  f
} from "./chunk-QWPLZ3QH.js";
import {
  N,
  d2,
  s3
} from "./chunk-HLGIRLYQ.js";
import "./chunk-N2K4VRZH.js";
import "./chunk-WL4VPODY.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import {
  I,
  bt,
  j
} from "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import "./chunk-LXXF7K7W.js";
import "./chunk-SBW6NNVI.js";
import "./chunk-62CXLI6S.js";
import {
  b
} from "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import "./chunk-4V6374PV.js";
import "./chunk-A34O4XB5.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/graphics/sources/csv/csv.js
var r = /^\s*"([\S\s]*)"\s*$/;
var l = /""/g;
var o2 = "\n";
var s4 = [",", " ", ";", "|", "	"];
function* u(e2, t4, n2) {
  let i3 = 0;
  for (; i3 <= e2.length; ) {
    const r2 = e2.indexOf(t4, i3), l2 = e2.substring(i3, r2 > -1 ? r2 : void 0);
    i3 += l2.length + t4.length, n2 && !l2.trim() || (yield l2);
  }
}
function c(e2) {
  const t4 = e2.includes("\r\n") ? "\r\n" : o2;
  return u(e2, t4, true);
}
function d4(e2, t4) {
  return u(e2, t4, false);
}
function f2(e2, t4, n2) {
  e2 = e2.trim(), t4 = t4 == null ? void 0 : t4.trim();
  const i3 = [], r2 = Array.from(/* @__PURE__ */ new Set([n2 == null ? void 0 : n2.delimiter, ...s4])).filter((e3) => null != e3);
  for (const o3 of r2) {
    const n3 = m2(e2, o3).length, r3 = m2(t4, o3).length ?? n3;
    n3 > 1 && i3.push({ weight: Math.min(n3, r3), delimiter: o3 });
  }
  const l2 = i3.sort(({ weight: e3 }, { weight: t5 }) => t5 - e3).map(({ delimiter: e3 }) => e3);
  for (const o3 of l2) {
    const t5 = h(g(e2, o3).names, n2 == null ? void 0 : n2.longitudeField, n2 == null ? void 0 : n2.latitudeField);
    if (t5.longitudeFieldName && t5.latitudeFieldName)
      return { delimiter: o3, locationInfo: t5 };
  }
  return { delimiter: l2[0], locationInfo: null };
}
function* a2(e2, t4, n2, i3 = () => /* @__PURE__ */ Object.create(null)) {
  const s5 = c(e2);
  s5.next();
  let u2 = "", f3 = "", a3 = 0, g2 = i3(), m3 = 0;
  e:
    for (const c2 of s5) {
      const e3 = d4(c2, n2);
      for (const o3 of e3)
        if (u2 += f3 + o3, f3 = "", a3 += p(o3), a3 % 2 == 0) {
          if (a3 > 0) {
            const e4 = r.exec(u2);
            if (!e4) {
              g2 = i3(), m3 = 0, u2 = "", a3 = 0;
              continue e;
            }
            g2[t4[m3]] = e4[1].replaceAll(l, '"'), m3++;
          } else
            g2[t4[m3]] = u2, m3++;
          u2 = "", a3 = 0;
        } else
          f3 = n2;
      0 === a3 ? (yield g2, g2 = i3(), m3 = 0) : f3 = o2;
    }
}
function g(e2, t4) {
  const i3 = m2(e2, t4).filter((e3) => null != e3), r2 = i3.map((e3) => d3(e3));
  for (let n2 = r2.length - 1; n2 >= 0; n2--)
    r2[n2] || (r2.splice(n2, 1), i3.splice(n2, 1));
  return { names: r2, aliases: i3 };
}
function m2(e2, t4) {
  if (!(e2 == null ? void 0 : e2.length))
    return [];
  const n2 = [];
  let i3 = "", o3 = "", s5 = 0;
  const u2 = d4(e2, t4);
  for (const c2 of u2)
    if (i3 += o3 + c2, o3 = "", s5 += p(c2), s5 % 2 == 0) {
      if (s5 > 0) {
        const e3 = r.exec(i3);
        e3 && n2.push(e3[1].replaceAll(l, '"'));
      } else
        n2.push(i3);
      i3 = "", s5 = 0;
    } else
      o3 = t4;
  return n2;
}
function p(e2) {
  let t4 = 0, n2 = 0;
  for (n2 = e2.indexOf('"', n2); n2 >= 0; )
    t4++, n2 = e2.indexOf('"', n2 + 1);
  return t4;
}
function h(e2, t4, i3) {
  var _a, _b;
  t4 = (_a = d3(t4)) == null ? void 0 : _a.toLowerCase(), i3 = (_b = d3(i3)) == null ? void 0 : _b.toLowerCase();
  const r2 = e2.map((e3) => e3.toLowerCase()), l2 = t4 ? e2[r2.indexOf(t4)] : null, o3 = i3 ? e2[r2.indexOf(i3)] : null;
  return { longitudeFieldName: l2 || e2[r2.indexOf(F.find((e3) => r2.includes(e3)))], latitudeFieldName: o3 || e2[r2.indexOf(y.find((e3) => r2.includes(e3)))] };
}
function b2(e2, t4, n2, r2, l2) {
  const o3 = [], s5 = a2(e2, n2, t4), u2 = [];
  for (const i3 of s5) {
    if (10 === u2.length)
      break;
    u2.push(i3);
  }
  for (let c2 = 0; c2 < n2.length; c2++) {
    const e3 = n2[c2], t5 = r2[c2];
    if (e3 === l2.longitudeFieldName || e3 === l2.latitudeFieldName)
      o3.push({ name: e3, type: "esriFieldTypeDouble", alias: t5 });
    else {
      let n3;
      switch (N2(u2.map((t6) => t6[e3]))) {
        case "integer":
          n3 = "esriFieldTypeInteger";
          break;
        case "double":
          n3 = "esriFieldTypeDouble";
          break;
        case "date":
          n3 = "esriFieldTypeDate";
          break;
        default:
          n3 = "esriFieldTypeString";
      }
      o3.push({ name: e3, type: n3, alias: t5, length: K(n3) });
    }
  }
  return o3;
}
function N2(t4) {
  if (!t4.length)
    return "string";
  const n2 = /[^+\-.,0-9]/;
  return t4.map((t5) => {
    if ("" !== t5) {
      if (!n2.test(t5)) {
        let e2 = x2(t5);
        if (!isNaN(e2))
          return /[.,]/.test(t5) || !Number.isInteger(e2) || e2 > 214783647 || e2 < -214783648 ? "double" : "integer";
        if (t5.includes("E")) {
          if (e2 = Number(t5), !Number.isNaN(e2))
            return "double";
          if (t5.includes(",") && (t5 = t5.replace(",", "."), e2 = Number(t5), !Number.isNaN(e2)))
            return "double";
        }
      }
      return e(t5) ? "date" : "string";
    }
  }).reduce((e2, t5) => void 0 === e2 ? t5 : void 0 === t5 ? e2 : e2 === t5 ? t5 : "string" === e2 || "string" === t5 ? "string" : "double" === e2 || "double" === t5 ? "double" : void 0);
}
var x2 = function() {
  const e2 = a(), n2 = new RegExp("^" + e2.regexp + "$"), i3 = new RegExp("[" + e2.group + "\\s\\xa0]", "g"), r2 = e2.factor;
  return (t4) => {
    const l2 = n2.exec(t4);
    if (e2.factor = r2, !l2)
      return NaN;
    let o3 = l2[1];
    if (!l2[1]) {
      if (!l2[2])
        return NaN;
      o3 = l2[2], e2.factor *= -1;
    }
    return o3 = o3.replace(i3, "").replace(e2.decimal, "."), +o3 * e2.factor;
  };
}();
var y = ["lat", "latitude", "latitude83", "latdecdeg", "lat_dd", "y", "ycenter", "point_y"];
var F = ["lon", "lng", "long", "longitude", "longitude83", "longdecdeg", "long_dd", "x", "xcenter", "point_x"];

// node_modules/@arcgis/core/layers/graphics/sources/support/CSVSourceWorker.js
var O = o("esriGeometryPoint");
var v = ["csv"];
var D = [0, 0];
var k = class {
  constructor(e2, t4) {
    this.x = e2, this.y = t4;
  }
};
var P = class {
  constructor() {
    this._queryEngine = null, this._snapshotFeatures = async (e2) => {
      const t4 = await this._fetch(e2);
      return this._createFeatures(t4);
    };
  }
  destroy() {
    var _a;
    (_a = this._queryEngine) == null ? void 0 : _a.destroy(), this._queryEngine = null;
  }
  async load(e2, t4 = {}) {
    var _a;
    this._loadOptions = e2;
    const [i3] = await Promise.all([this._fetch(t4.signal), this._checkProjection((_a = e2 == null ? void 0 : e2.parsingOptions) == null ? void 0 : _a.spatialReference)]), n2 = R(i3, e2);
    this._locationInfo = n2.locationInfo, this._delimiter = n2.delimiter, this._queryEngine = this._createQueryEngine(n2);
    const r2 = await this._createFeatures(i3);
    this._queryEngine.featureStore.addMany(r2);
    const { fullExtent: s5, timeExtent: o3 } = await this._queryEngine.fetchRecomputedExtents();
    if (n2.layerDefinition.extent = s5, o3) {
      const { start: e3, end: t5 } = o3;
      n2.layerDefinition.timeInfo.timeExtent = [e3, t5];
    }
    return n2;
  }
  async applyEdits() {
    throw new s2("csv-layer:editing-not-supported", "applyEdits() is not supported on CSVLayer");
  }
  async queryFeatures(e2 = {}, t4 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQuery(e2, t4.signal);
  }
  async queryFeatureCount(e2 = {}, t4 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e2, t4.signal);
  }
  async queryObjectIds(e2 = {}, t4 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForIds(e2, t4.signal);
  }
  async queryExtent(e2 = {}, t4 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e2, t4.signal);
  }
  async querySnapping(e2, t4 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForSnapping(e2, t4.signal);
  }
  async refresh(e2) {
    var _a;
    this._loadOptions.customParameters = e2, (_a = this._snapshotTask) == null ? void 0 : _a.abort(), this._snapshotTask = d(this._snapshotFeatures), this._snapshotTask.promise.then((e3) => {
      this._queryEngine.featureStore.clear(), e3 && this._queryEngine.featureStore.addMany(e3);
    }, (e3) => {
      this._queryEngine.featureStore.clear(), b(e3) || s.getLogger("esri.layers.CSVLayer").error(new s2("csv-layer:refresh", "An error occurred during refresh", { error: e3 }));
    }), await this._waitSnapshotComplete();
    const { fullExtent: i3, timeExtent: o3 } = await this._queryEngine.fetchRecomputedExtents();
    return { extent: i3, timeExtent: o3 };
  }
  async _waitSnapshotComplete() {
    if (this._snapshotTask && !this._snapshotTask.finished) {
      try {
        await this._snapshotTask.promise;
      } catch {
      }
      return this._waitSnapshotComplete();
    }
  }
  async _fetch(t4) {
    const { url: i3, customParameters: r2 } = this._loadOptions;
    if (!i3)
      throw new s2("csv-layer:invalid-source", "url not defined");
    const s5 = I(i3);
    return (await j(s5.path, { query: { ...s5.query, ...r2 }, responseType: "text", signal: t4 })).data;
  }
  _createQueryEngine(e2) {
    const { objectIdField: t4, fields: i3, extent: n2, timeInfo: r2 } = e2.layerDefinition, s5 = new m({ geometryType: "esriGeometryPoint", hasM: false, hasZ: false });
    return new W({ fieldsIndex: Z.fromLayerJSON({ fields: i3, dateFieldsTimeReference: { timeZoneIANA: i } }), geometryType: "esriGeometryPoint", hasM: false, hasZ: false, timeInfo: r2, objectIdField: t4, spatialReference: n2.spatialReference || { wkid: 4326 }, cacheSpatialQueries: true, featureStore: s5 });
  }
  async _createFeatures(e2) {
    const { latitudeFieldName: t4, longitudeFieldName: n2 } = this._locationInfo, { objectIdField: r2, fieldsIndex: s5, spatialReference: o3 } = this._queryEngine;
    let a3 = [];
    const u2 = [], h2 = s5.fields.filter((e3) => e3.name !== r2).map((e3) => e3.name);
    let g2 = 0;
    const I2 = {};
    for (const i3 of s5.fields)
      if ("esriFieldTypeOID" !== i3.type && "esriFieldTypeGlobalID" !== i3.type) {
        const e3 = H(i3);
        void 0 !== e3 && (I2[i3.name] = e3);
      }
    const w = a2(e2, h2, this._delimiter, i2(I2, r2));
    for (const l2 of w) {
      const e3 = this._parseCoordinateValue(l2[t4]), o4 = this._parseCoordinateValue(l2[n2]);
      if (null != o4 && null != e3 && !isNaN(e3) && !isNaN(o4)) {
        l2[t4] = e3, l2[n2] = o4;
        for (const e4 in l2)
          if (e4 !== t4 && e4 !== n2) {
            if (s5.isDateField(e4))
              l2[e4] = n(l2[e4]);
            else if (s5.isNumericField(e4)) {
              const t5 = x2(l2[e4]);
              isNaN(t5) ? l2[e4] = null : l2[e4] = t5;
            }
          }
        l2[r2] = g2, g2++, a3.push(new k(o4, e3)), u2.push(l2);
      }
    }
    if (!d2({ wkid: 4326 }, o3))
      if (s3(o3))
        for (const i3 of a3)
          [i3.x, i3.y] = M(i3.x, i3.y, D);
      else
        a3 = B(t3, a3, f.WGS84, o3, null, null);
    const E = [];
    for (let i3 = 0; i3 < a3.length; i3++) {
      const { x: e3, y: t5 } = a3[i3], n3 = u2[i3];
      n3[r2] = i3 + 1, E.push(new t(new t2([], [e3, t5]), n3, null, n3[r2]));
    }
    return E;
  }
  _parseCoordinateValue(e2) {
    if (null == e2 || "" === e2)
      return null;
    let t4 = x2(e2);
    return (isNaN(t4) || Math.abs(t4) > 181) && (t4 = parseFloat(e2)), t4;
  }
  async _checkProjection(e2) {
    try {
      await x(N, e2);
    } catch {
      throw new s2("csv-layer:projection-not-supported", "Projection not supported");
    }
  }
};
function R(e2, t4) {
  var _a, _b, _c;
  const i3 = t4.parsingOptions || {}, r2 = { delimiter: i3.delimiter, layerDefinition: null, locationInfo: { latitudeFieldName: i3.latitudeField, longitudeFieldName: i3.longitudeField } }, s5 = r2.layerDefinition = { name: bt(t4.url, v) || "csv", dateFieldsTimeReference: { timeZoneIANA: i }, drawingInfo: O, geometryType: "esriGeometryPoint", objectIdField: null, fields: [], timeInfo: i3.timeInfo, extent: { xmin: Number.POSITIVE_INFINITY, ymin: Number.POSITIVE_INFINITY, xmax: Number.NEGATIVE_INFINITY, ymax: Number.NEGATIVE_INFINITY, spatialReference: i3.spatialReference || { wkid: 4326 } } }, o3 = c(e2), l2 = (_a = o3.next().value) == null ? void 0 : _a.trim(), m3 = (_b = o3.next().value) == null ? void 0 : _b.trim();
  if (!l2)
    throw new s2("csv-layer:empty-csv", "CSV is empty", { csv: e2 });
  const { delimiter: c2, locationInfo: d5 } = f2(l2, m3, i3);
  if (!c2)
    throw new s2("csv-layer:invalid-delimiter", "Unable to detect the delimiter from CSV", { firstLine: l2, secondLine: m3, parsingOptions: i3 });
  if (!d5)
    throw new s2("csv-layer:location-fields-not-found", "Unable to identify latitude and longitude fields from the CSV file", { firstLine: l2, secondLine: m3, parsingOptions: i3 });
  r2.locationInfo = d5, r2.delimiter = c2;
  const { names: u2, aliases: p2 } = g(l2, c2), f3 = b2(e2, r2.delimiter, u2, p2, r2.locationInfo);
  if ((_c = i3.fields) == null ? void 0 : _c.length) {
    const e3 = new Z(i3.fields);
    for (const t5 of f3) {
      const i4 = e3.get(t5.name);
      i4 && Object.assign(t5, i4);
    }
  }
  if (!f3.some((e3) => "esriFieldTypeOID" === e3.type && (s5.objectIdField = e3.name, true))) {
    const e3 = { name: "__OBJECTID", alias: "__OBJECTID", type: "esriFieldTypeOID", editable: false, nullable: false };
    s5.objectIdField = e3.name, f3.unshift(e3);
  }
  s5.fields = f3;
  const y2 = new Z(s5.fields);
  if (r2.locationInfo && (r2.locationInfo.latitudeFieldName = y2.get(r2.locationInfo.latitudeFieldName).name, r2.locationInfo.longitudeFieldName = y2.get(r2.locationInfo.longitudeFieldName).name), s5.timeInfo) {
    const e3 = s5.timeInfo;
    if (e3.startTimeField) {
      const t5 = y2.get(e3.startTimeField);
      t5 ? (e3.startTimeField = t5.name, t5.type = "esriFieldTypeDate") : e3.startTimeField = null;
    }
    if (e3.endTimeField) {
      const t5 = y2.get(e3.endTimeField);
      t5 ? (e3.endTimeField = t5.name, t5.type = "esriFieldTypeDate") : e3.endTimeField = null;
    }
    if (e3.trackIdField) {
      const t5 = y2.get(e3.trackIdField);
      e3.trackIdField = t5 ? t5.name : null;
    }
    e3.startTimeField || e3.endTimeField || (s5.timeInfo = null);
  }
  return r2;
}
export {
  P as default
};
//# sourceMappingURL=CSVSourceWorker-DZKW2FGL.js.map
