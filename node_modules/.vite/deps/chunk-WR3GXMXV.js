import {
  e as e4,
  t as t3
} from "./chunk-NS7I2ZSY.js";
import {
  t as t7
} from "./chunk-3S7E6CPQ.js";
import {
  A as A2,
  F,
  G,
  I,
  L,
  P as P2,
  S,
  b as b2,
  d,
  g,
  h as h2,
  i as i2,
  k as k3,
  l as l5,
  m as m4,
  w as w4,
  x
} from "./chunk-XI27PUTI.js";
import {
  C
} from "./chunk-7REGXRO2.js";
import {
  t as t6
} from "./chunk-L2VCMOKZ.js";
import {
  e as e5,
  n as n4,
  t as t4
} from "./chunk-PHDOV32N.js";
import {
  w as w3
} from "./chunk-Z26DT4RT.js";
import {
  A,
  B,
  C as C2,
  K,
  O,
  P,
  R,
  U as U2,
  X,
  Y,
  Z,
  a as a4,
  ie,
  k as k2,
  l as l3,
  m as m2,
  ne,
  o,
  oe,
  u as u4,
  w as w2,
  y
} from "./chunk-BUMLJETN.js";
import {
  a as a6,
  l as l4
} from "./chunk-OPV4AZKI.js";
import {
  b,
  se,
  w
} from "./chunk-XFC7DZXI.js";
import {
  U,
  k,
  q,
  v
} from "./chunk-7Y57Y6IH.js";
import {
  a as a5,
  n as n2
} from "./chunk-B7TIRUHV.js";
import {
  e as e3,
  h,
  i,
  o as o2
} from "./chunk-EY7PGBJG.js";
import {
  n as n3,
  t as t5
} from "./chunk-6M5DUIJQ.js";
import {
  r,
  z
} from "./chunk-NDKHIQMD.js";
import {
  m2 as m3,
  s as s4
} from "./chunk-H4ZZ5S37.js";
import {
  u as u5
} from "./chunk-G557TGXY.js";
import {
  n as n5
} from "./chunk-M7R7REMB.js";
import {
  f as f4,
  l as l2,
  m,
  s as s3,
  u as u2
} from "./chunk-IPCIO3PX.js";
import {
  e as e2,
  u as u3
} from "./chunk-EIY2DYTV.js";
import {
  a2 as a3,
  c,
  f2,
  l,
  n,
  t as t2
} from "./chunk-OIIDE5GZ.js";
import {
  a as a2,
  f as f3,
  u
} from "./chunk-3XSRVKBX.js";
import {
  f
} from "./chunk-QWPLZ3QH.js";
import {
  e2 as e
} from "./chunk-SBW6NNVI.js";
import {
  a,
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import {
  has,
  t
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/core/BidiText.js
var n6 = new C();
function i3(r16) {
  if (null == r16)
    return ["", false];
  if (!n6.hasBidiChar(r16))
    return [r16, false];
  let i14;
  return i14 = "rtl" === n6.checkContextual(r16) ? "IDNNN" : "ICNNN", [n6.bidiTransform(r16, i14, "VLYSN"), true];
}

// node_modules/@arcgis/core/symbols/cim/CIMPlacements.js
var t8 = class {
  constructor() {
    this.setIdentity();
  }
  getAngle() {
    return (null == this.rz || 0 === this.rz && 1 !== this.rzCos && 0 !== this.rzSin) && (this.rz = Math.atan2(this.rzSin, this.rzCos)), this.rz;
  }
  setIdentity() {
    this.tx = 0, this.ty = 0, this.tz = 0, this.s = 1, this.rx = 0, this.ry = 0, this.rz = 0, this.rzCos = 1, this.rzSin = 0;
  }
  setTranslate(t15, s13) {
    this.tx = t15, this.ty = s13;
  }
  setTranslateZ(t15) {
    this.tz = t15;
  }
  setRotateCS(t15, s13) {
    this.rz = void 0, this.rzCos = t15, this.rzSin = s13;
  }
  setRotate(t15) {
    this.rz = t15, this.rzCos = void 0, this.rzSin = void 0;
  }
  setRotateY(t15) {
    this.ry = t15;
  }
  setScale(t15) {
    this.s = t15;
  }
  setMeasure(t15) {
    this.m = t15;
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMEffects.js
var r2 = 512;
var n7;
var s5 = class {
  constructor(t15) {
    this._geometry = t15;
  }
  next() {
    const t15 = this._geometry;
    return this._geometry = null, t15;
  }
};
function i4(s13, i14) {
  n7 || (n7 = new e5(0, 0, 0, 1));
  const y3 = "esriGeometryPolygon" === s13.geometryType, m7 = y3 ? t4.Polygon : t4.LineString, l9 = y3 ? 3 : 2;
  let c4, p3;
  for (n7.reset(m7), n7.setPixelMargin(i14 + 1), n7.setExtent(r2); s13.nextPath(); )
    if (!(s13.pathSize < l9)) {
      for (s13.nextPoint(), c4 = s13.x, p3 = -s13.y, n7.moveTo(c4, p3); s13.nextPoint(); )
        c4 = s13.x, p3 = -s13.y, n7.lineTo(c4, p3);
      y3 && n7.close();
    }
  const f5 = n7.result(false);
  if (f5) {
    const e14 = a6.createEmptyOptimizedCIM(s13.geometryType);
    for (const t15 of f5) {
      e14.startPath();
      for (const o6 of t15)
        e14.pushXY(o6.x, -o6.y);
    }
    return e14.reset(), e14;
  }
  return null;
}

// node_modules/@arcgis/core/symbols/cim/CIMImageColorSubstitutionHelper.js
var t9 = class {
  applyColorSubstituition(t15, a11) {
    if (!a11)
      return t15;
    this._rasterizationCanvas || (this._rasterizationCanvas = document.createElement("canvas"));
    const { width: e14, height: n19 } = t15, o6 = this._rasterizationCanvas, r16 = o6.getContext("2d", { willReadFrequently: true });
    t15 !== o6 && (o6.width = e14, o6.height = n19, r16.drawImage(t15, 0, 0, e14, n19));
    const i14 = r16.getImageData(0, 0, e14, n19).data;
    if (a11) {
      for (const l9 of a11)
        if (l9 && l9.oldColor && 4 === l9.oldColor.length && l9.newColor && 4 === l9.newColor.length) {
          const [t16, a12, e15, n20] = l9.oldColor, [o7, r17, s14, h8] = l9.newColor;
          if (t16 === o7 && a12 === r17 && e15 === s14 && n20 === h8)
            continue;
          for (let l10 = 0; l10 < i14.length; l10 += 4)
            t16 === i14[l10] && a12 === i14[l10 + 1] && e15 === i14[l10 + 2] && n20 === i14[l10 + 3] && (i14[l10] = o7, i14[l10 + 1] = r17, i14[l10 + 2] = s14, i14[l10 + 3] = h8);
        }
    }
    const s13 = new ImageData(i14, e14, n19);
    return r16.putImageData(s13, 0, 0), o6;
  }
  tintImageData(t15, a11) {
    if (!a11 || a11.length < 4)
      return t15;
    this._rasterizationCanvas || (this._rasterizationCanvas = document.createElement("canvas"));
    const { width: e14, height: n19 } = t15, o6 = this._rasterizationCanvas, r16 = o6.getContext("2d", { willReadFrequently: true });
    t15 !== o6 && (o6.width = e14, o6.height = n19, r16.drawImage(t15, 0, 0, e14, n19));
    const i14 = r16.getImageData(0, 0, e14, n19), s13 = new Uint8Array(i14.data), l9 = [a11[0] / 255, a11[1] / 255, a11[2] / 255, a11[3] / 255];
    for (let g4 = 0; g4 < s13.length; g4 += 4)
      s13[g4] *= l9[0], s13[g4 + 1] *= l9[1], s13[g4 + 2] *= l9[2], s13[g4 + 3] *= l9[3];
    const h8 = new ImageData(new Uint8ClampedArray(s13.buffer), e14, n19);
    return r16.putImageData(h8, 0, 0), o6;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectAddControlPoints.js
var e6 = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(e14, s13, n19, i14, o6) {
    return new t10(e14, s13, n19);
  }
};
e6.instance = null;
var t10 = class {
  constructor(e14, t15, s13) {
    this._inputGeometries = e14, this._angleTolerance = void 0 !== t15.angleTolerance ? t15.angleTolerance : 120, this._maxCosAngle = Math.cos((1 - Math.abs(this._angleTolerance) / 180) * Math.PI);
  }
  next() {
    let e14 = this._inputGeometries.next();
    for (; e14; ) {
      if ("esriGeometryPolygon" === e14.geometryType)
        this._isClosed = true;
      else if ("esriGeometryPolyline" === e14.geometryType)
        this._isClosed = false;
      else {
        if ("esriGeometryEnvelope" !== e14.geometryType) {
          e14 = this._inputGeometries.next();
          continue;
        }
        if (this._maxCosAngle)
          return e14;
        this._isClosed = true;
      }
      for (; e14.nextPath(); )
        this._processPath(e14);
      return e14.reset(), e14;
    }
    return null;
  }
  _processPath(e14) {
    if (e14.nextPoint()) {
      const t15 = e14.x, s13 = e14.y;
      let n19 = t15, i14 = s13, o6 = e14.pathSize, l9 = 0, r16 = 0, a11 = 0, h8 = 0, c4 = 0, _3 = 0;
      this._isClosed && ++o6;
      for (let u9 = 1; e14.nextPoint() || u9 < o6; ++u9) {
        let x3, m7;
        this._isClosed && u9 === o6 - 1 ? (x3 = t15, m7 = s13) : (x3 = e14.x, m7 = e14.y);
        const y3 = x3 - n19, g4 = m7 - i14, C3 = Math.sqrt(y3 * y3 + g4 * g4);
        if (u9 > 1 && C3 > 0 && a11 > 0) {
          (l9 * y3 + r16 * g4) / C3 / a11 <= this._maxCosAngle && e14.setControlPointAt(u9 - 1);
        }
        1 === u9 && (h8 = y3, c4 = g4, _3 = C3), C3 > 0 && (n19 = x3, i14 = m7, l9 = y3, r16 = g4, a11 = C3);
      }
      if (this._isClosed && a11 > 0 && _3 > 0) {
        (l9 * h8 + r16 * c4) / _3 / a11 <= this._maxCosAngle && e14.setControlPointAt(0);
      }
    }
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMCursor.js
function r3(t15, e14) {
  t15[4] = e14;
}
var s6 = class {
  constructor(e14, r16 = true, s13 = true, i14 = 0) {
    this.isClosed = false, this.geometryCursor = null, this.geometryCursor = !r16 && "esriGeometryPolygon" === e14.geometryType || !s13 && "esriGeometryPolyline" === e14.geometryType ? null : e14, this.geomUnitsPerPoint = i14, this.iteratePath = false, this.internalPlacement = new t8();
  }
  next() {
    if (!this.geometryCursor)
      return null;
    for (; this.iteratePath || this.geometryCursor.nextPath(); ) {
      this.geometryCursor.seekPathStart();
      const t15 = this.processPath(this.geometryCursor);
      if (t15)
        return t15;
    }
    return this.geometryCursor = null, null;
  }
};
var i5 = class {
  constructor(t15, e14, r16, s13 = 0) {
    this.isClosed = false, this.inputGeometries = t15, this.acceptPolygon = e14, this.acceptPolyline = r16, this.geomUnitsPerPoint = s13, this.iteratePath = false, this.multiPathCursor = null;
  }
  next() {
    for (; ; ) {
      if (!this.multiPathCursor) {
        let t15 = this.inputGeometries.next();
        for (; t15 && (this.isClosed = this.acceptPolygon && "esriGeometryPolygon" === t15.geometryType || "esriGeometryEnvelope" === t15.geometryType, this.multiPathCursor = t15, !this.multiPathCursor); )
          t15 = this.inputGeometries.next();
        if (!this.multiPathCursor)
          return null;
      }
      for (; this.iteratePath || this.multiPathCursor.nextPath(); ) {
        this.multiPathCursor.seekPathStart();
        const t15 = this.processPath(this.multiPathCursor);
        if (t15)
          return t15;
      }
      this.multiPathCursor = null;
    }
  }
};

// node_modules/@arcgis/core/symbols/cim/CurveHelper.js
var n8 = 0.03;
var s7 = class {
  constructor(t15 = 0, e14 = false) {
  }
  isEmpty(t15) {
    if (!t15.nextPoint())
      return true;
    let e14, n19, s13, r16;
    for (e14 = t15.x, n19 = t15.y; t15.nextPoint(); e14 = n19, n19 = r16)
      if (s13 = t15.x, r16 = t15.y, s13 !== e14 || r16 !== n19)
        return t15.seekPathStart(), false;
    return t15.seekPathStart(), true;
  }
  normalize(t15) {
    const e14 = Math.sqrt(t15[0] * t15[0] + t15[1] * t15[1]);
    0 !== e14 && (t15[0] /= e14, t15[1] /= e14);
  }
  getLength(t15, e14, n19, s13) {
    const r16 = n19 - t15, o6 = s13 - e14;
    return Math.sqrt(r16 * r16 + o6 * o6);
  }
  getSegLength(t15) {
    const [[e14, n19], [s13, r16]] = t15;
    return this.getLength(e14, n19, s13, r16);
  }
  getCoord2D(t15, e14, n19, s13, r16) {
    return [t15 + (n19 - t15) * r16, e14 + (s13 - e14) * r16];
  }
  getSegCoord2D(t15, e14) {
    const [[n19, s13], [r16, o6]] = t15;
    return this.getCoord2D(n19, s13, r16, o6, e14);
  }
  getAngle(t15, e14, n19, s13, r16) {
    const o6 = n19 - t15, i14 = s13 - e14;
    return Math.atan2(i14, o6);
  }
  getAngleCS(t15, e14, n19, s13, r16) {
    const o6 = n19 - t15, i14 = s13 - e14, u9 = Math.sqrt(o6 * o6 + i14 * i14);
    return u9 > 0 ? [o6 / u9, i14 / u9] : [1, 0];
  }
  getSegAngleCS(t15, e14) {
    const [[n19, s13], [r16, o6]] = t15;
    return this.getAngleCS(n19, s13, r16, o6, e14);
  }
  cut(t15, e14, n19, s13, r16, o6) {
    return [r16 <= 0 ? [t15, e14] : this.getCoord2D(t15, e14, n19, s13, r16), o6 >= 1 ? [n19, s13] : this.getCoord2D(t15, e14, n19, s13, o6)];
  }
  getSubCurve(e14, n19, s13) {
    const r16 = a6.createEmptyOptimizedCIM("esriGeometryPolyline");
    return this.appendSubCurve(r16, e14, n19, s13) ? r16 : null;
  }
  appendSubCurve(t15, e14, n19, s13) {
    t15.startPath(), e14.seekPathStart();
    let r16 = 0, o6 = true;
    if (!e14.nextPoint())
      return false;
    let i14 = e14.x, u9 = e14.y;
    for (; e14.nextPoint(); ) {
      const h8 = this.getLength(i14, u9, e14.x, e14.y);
      if (0 !== h8) {
        if (o6) {
          if (r16 + h8 > n19) {
            const l9 = (n19 - r16) / h8;
            let a11 = 1, c4 = false;
            r16 + h8 >= s13 && (a11 = (s13 - r16) / h8, c4 = true);
            const f5 = this.cut(i14, u9, e14.x, e14.y, l9, a11);
            if (f5 && t15.pushPoints(f5), c4)
              break;
            o6 = false;
          }
        } else {
          if (r16 + h8 > s13) {
            const n20 = this.cut(i14, u9, e14.x, e14.y, 0, (s13 - r16) / h8);
            n20 && t15.pushPoint(n20[1]);
            break;
          }
          t15.pushXY(e14.x, e14.y);
        }
        r16 += h8, i14 = e14.x, u9 = e14.y;
      } else
        i14 = e14.x, u9 = e14.y;
    }
    return true;
  }
  getCIMPointAlong(t15, e14) {
    if (!t15.nextPoint())
      return null;
    let n19, s13, r16, o6, i14 = 0;
    for (n19 = t15.x, s13 = t15.y; t15.nextPoint(); n19 = r16, s13 = o6) {
      r16 = t15.x, o6 = t15.y;
      const u9 = this.getLength(n19, s13, r16, o6);
      if (0 !== u9) {
        if (i14 + u9 > e14) {
          const t16 = (e14 - i14) / u9;
          return this.getCoord2D(n19, s13, r16, o6, t16);
        }
        i14 += u9;
      }
    }
    return null;
  }
  offset(t15, n19, s13, r16, o6) {
    if (!t15 || t15.length < 2)
      return null;
    let i14 = 0, u9 = t15[i14++], h8 = i14;
    for (; i14 < t15.length; ) {
      const e14 = t15[i14];
      e14[0] === u9[0] && e14[1] === u9[1] || (i14 !== h8 && (t15[h8] = t15[i14]), u9 = t15[h8++]), i14++;
    }
    const l9 = t15[0][0] === t15[h8 - 1][0] && t15[0][1] === t15[h8 - 1][1];
    if (l9 && --h8, h8 < (l9 ? 3 : 2))
      return null;
    const a11 = [];
    u9 = l9 ? t15[h8 - 1] : null;
    let c4 = t15[0];
    for (let f5 = 0; f5 < h8; f5++) {
      const o7 = f5 === h8 - 1 ? l9 ? t15[0] : null : t15[f5 + 1];
      if (u9)
        if (o7) {
          const t16 = [o7[0] - c4[0], o7[1] - c4[1]];
          this.normalize(t16);
          const i15 = [c4[0] - u9[0], c4[1] - u9[1]];
          this.normalize(i15);
          const h9 = i15[0] * t16[1] - i15[1] * t16[0], l10 = i15[0] * t16[0] + i15[1] * t16[1];
          if (0 === h9 && 1 === l10) {
            c4 = o7;
            continue;
          }
          if (h9 >= 0 == n19 <= 0) {
            if (l10 < 1) {
              const e14 = [t16[0] - i15[0], t16[1] - i15[1]];
              this.normalize(e14);
              const s14 = Math.sqrt((1 + l10) / 2);
              if (s14 > 1 / r16) {
                const t17 = -Math.abs(n19) / s14;
                a11.push([c4[0] - e14[0] * t17, c4[1] - e14[1] * t17]);
              }
            }
          } else
            switch (s13) {
              case O.Mitered: {
                const e14 = Math.sqrt((1 + l10) / 2);
                if (e14 > 0 && 1 / e14 < r16) {
                  const s14 = [t16[0] - i15[0], t16[1] - i15[1]];
                  this.normalize(s14);
                  const r17 = Math.abs(n19) / e14;
                  a11.push([c4[0] - s14[0] * r17, c4[1] - s14[1] * r17]);
                  break;
                }
              }
              case O.Bevelled:
                a11.push([c4[0] + i15[1] * n19, c4[1] - i15[0] * n19]), a11.push([c4[0] + t16[1] * n19, c4[1] - t16[0] * n19]);
                break;
              case O.Rounded:
                if (l10 < 1) {
                  a11.push([c4[0] + i15[1] * n19, c4[1] - i15[0] * n19]);
                  const e14 = Math.floor(2.5 * (1 - l10));
                  if (e14 > 0) {
                    const s14 = 1 / e14;
                    let r17 = s14;
                    for (let o8 = 1; o8 < e14; o8++, r17 += s14) {
                      const e15 = [i15[1] * (1 - r17) + t16[1] * r17, -i15[0] * (1 - r17) - t16[0] * r17];
                      this.normalize(e15), a11.push([c4[0] + e15[0] * n19, c4[1] + e15[1] * n19]);
                    }
                  }
                  a11.push([c4[0] + t16[1] * n19, c4[1] - t16[0] * n19]);
                }
                break;
              case O.Square:
              default:
                if (h9 < 0)
                  a11.push([c4[0] + (i15[1] + i15[0]) * n19, c4[1] + (i15[1] - i15[0]) * n19]), a11.push([c4[0] + (t16[1] - t16[0]) * n19, c4[1] - (t16[0] + t16[1]) * n19]);
                else {
                  const e14 = Math.sqrt((1 + Math.abs(l10)) / 2), s14 = [t16[0] - i15[0], t16[1] - i15[1]];
                  this.normalize(s14);
                  const r17 = n19 / e14;
                  a11.push([c4[0] - s14[0] * r17, c4[1] - s14[1] * r17]);
                }
            }
        } else {
          const t16 = [c4[0] - u9[0], c4[1] - u9[1]];
          this.normalize(t16), a11.push([c4[0] + t16[1] * n19, c4[1] - t16[0] * n19]);
        }
      else {
        const t16 = [o7[0] - c4[0], o7[1] - c4[1]];
        this.normalize(t16), a11.push([c4[0] + t16[1] * n19, c4[1] - t16[0] * n19]);
      }
      u9 = c4, c4 = o7;
    }
    return a11.length < (l9 ? 3 : 2) ? null : (l9 && a11.push([a11[0][0], a11[0][1]]), a11);
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectArrow.js
var c2 = 1.7320508075688772;
var u6 = 5;
var h3 = P.OpenEnded;
var p = class _p {
  static local() {
    return null === _p.instance && (_p.instance = new _p()), _p.instance;
  }
  execute(t15, e14, r16, n19, o6) {
    return new P3(t15, e14, r16);
  }
};
p.instance = null;
var P3 = class extends i5 {
  constructor(t15, e14, r16) {
    super(t15, false, true), this._curveHelper = new s7(), this._width = (void 0 !== e14.width ? e14.width : u6) * r16, this._arrowType = void 0 !== e14.geometricEffectArrowType ? e14.geometricEffectArrowType : void 0 !== e14.arrowType ? e14.arrowType : h3, this._offsetFlattenError = n8 * r16;
  }
  processPath(e14) {
    const r16 = a6.createEmptyOptimizedCIM(e14.geometryType);
    switch (this._arrowType) {
      case P.OpenEnded:
      default:
        this._constructSimpleArrow(r16, e14, true);
        break;
      case P.Block:
        this._constructSimpleArrow(r16, e14, false);
        break;
      case P.Crossed:
        this._constructCrossedArrow(r16, e14);
    }
    return r16;
  }
  _constructSimpleArrow(t15, r16, n19) {
    const o6 = r16.pathLength();
    let s13 = this._width;
    o6 < 2 * s13 && (s13 = o6 / 2);
    const i14 = this._curveHelper.getSubCurve(r16, 0, o6 - s13);
    if (!i14 || !i14.nextPath())
      return;
    i14.seekPathStart();
    const c4 = s13 / 2;
    if (this._curveHelper.isEmpty(i14))
      return;
    const u9 = n(i14), h8 = this._constructOffset(u9, -c4);
    if (!h8)
      return;
    const p3 = this._constructOffset(u9, c4);
    if (!p3)
      return;
    const P4 = this._constructArrowBasePoint(h8, -c4 / 2);
    if (!P4)
      return;
    const l9 = this._constructArrowBasePoint(p3, c4 / 2);
    if (!l9)
      return;
    r16.seekInPath(r16.pathSize - 1);
    const f5 = [r16.x, r16.y];
    t15.pushPath(p3), t15.nextPath(), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(l9), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(f5), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(P4), t15.nextPoint(), t15.setControlPoint(), t15.pushPoints(h8.reverse()), t15.setControlPoint(), n19 || (t15.setControlPointAt(0), t15.setControlPointAt(t15.pathSize - 1), t15.pushPoint(p3[0])), t15.reset();
  }
  _constructCrossedArrow(t15, r16) {
    const n19 = r16.pathLength();
    let o6 = this._width;
    n19 < o6 * (1 + c2 + 1) && (o6 = n19 / (1 + c2 + 1)), r16.seekPathStart();
    const s13 = this._curveHelper.getSubCurve(r16, 0, n19 - o6 * (1 + c2));
    if (!s13)
      return;
    s13.nextPath();
    const i14 = o6 / 2;
    if (this._curveHelper.isEmpty(s13))
      return;
    const u9 = n(s13), h8 = this._constructOffset(u9, i14);
    if (!h8)
      return;
    const p3 = this._constructOffset(u9, -i14);
    if (!p3)
      return;
    const P4 = this._curveHelper.getSubCurve(r16, 0, n19 - o6);
    if (!P4)
      return;
    if (P4.nextPath(), this._curveHelper.isEmpty(P4))
      return;
    const l9 = n(P4), f5 = this._constructOffset(l9, i14);
    if (!f5)
      return;
    const a11 = this._constructOffset(l9, -i14);
    if (!a11)
      return;
    const _3 = f5[f5.length - 1], m7 = this._constructArrowBasePoint(f5, i14 / 2);
    if (!m7)
      return;
    const C3 = a11[a11.length - 1], w6 = this._constructArrowBasePoint(a11, -i14 / 2);
    if (!w6)
      return;
    r16.seekInPath(r16.pathSize - 1);
    const x3 = [r16.x, r16.y];
    t15.pushPath(h8), t15.nextPath(), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(C3), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(w6), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(x3), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(m7), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(_3), t15.nextPoint(), t15.setControlPoint(), t15.pushPoints(p3.reverse()), t15.nextPoint(), t15.setControlPoint(), t15.reset();
  }
  _constructOffset(t15, e14) {
    return this._curveHelper.offset(t15, e14, O.Rounded, 4, this._offsetFlattenError);
  }
  _constructArrowBasePoint(t15, e14) {
    if (!t15 || t15.length < 2)
      return null;
    const r16 = t15[t15.length - 2], n19 = t15[t15.length - 1], o6 = [n19[0] - r16[0], n19[1] - r16[1]];
    return this._curveHelper.normalize(o6), [n19[0] + o6[1] * e14, n19[1] - o6[0] * e14];
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectBuffer.js
var m5 = class _m {
  static local() {
    return null === _m.instance && (_m.instance = new _m()), _m.instance;
  }
  execute(e14, t15, i14, s13, r16, n19) {
    return new l6(e14, t15, i14, s13, r16, n19);
  }
};
m5.instance = null;
var l6 = class {
  constructor(e14, t15, i14, n19, o6, m7) {
    this._inputGeometries = e14, this._tileKey = n19, this._geometryEngine = o6, this._curveHelper = new s7(), this._size = (void 0 !== t15.size ? t15.size : 1) * i14, this._maxInflateSize = m7 * i14, this._offsetFlattenError = n8 * i14;
  }
  next() {
    let s13;
    for (; s13 = this._inputGeometries.next(); ) {
      if (0 === this._size)
        return s13;
      if ("esriGeometryEnvelope" === s13.geometryType) {
        if (this._size > 0) {
          const i14 = a6.createEmptyOptimizedCIM(s13.geometryType), r17 = t2(s13)[0], o6 = this._curveHelper.offset(r17, this._size, O.Rounded, 4, this._offsetFlattenError);
          if (o6)
            return i14.pushPath(o6), i14;
        } else if (this._size < 0) {
          const t15 = s13.asJSON();
          if (Math.min(t15.xmax - t15.xmin, t15.ymax - t15.ymin) + 2 * this._size > 0)
            return a6.fromJSONCIM({ xmin: t15.xmin - this._size, xmax: t15.xmax + this._size, ymin: t15.ymin - this._size, ymax: t15.ymax + this._size });
        }
      }
      const r16 = this._geometryEngine;
      if (null == r16)
        return null;
      const m7 = this._tileKey ? i4(s13, this._maxInflateSize) : s13;
      if (!m7)
        continue;
      const l9 = r16.buffer(f.WebMercator, m7.asJSON(), this._size, 1);
      return l9 ? a6.fromJSONCIM(l9) : null;
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectControlMeasureLine.js
var e7 = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(s13, t15, i14, h8, e14) {
    return new r4(s13, t15, i14);
  }
};
e7.instance = null;
var r4 = class {
  constructor(s13, t15, i14) {
    this._defaultPointSize = 20, this._inputGeometries = s13, this._geomUnitsPerPoint = i14, this._rule = t15.rule ?? R.FullGeometry, this._defaultSize = this._defaultPointSize * i14;
  }
  next() {
    let i14;
    for (; i14 = this._inputGeometries.next(); ) {
      const h8 = this._processGeom(t2(i14));
      if (h8 && h8.length)
        return a6.fromJSONCIM({ paths: h8 });
    }
    return null;
  }
  _clone(s13) {
    return [s13[0], s13[1]];
  }
  _mid(s13, t15) {
    return [(s13[0] + t15[0]) / 2, (s13[1] + t15[1]) / 2];
  }
  _mix(s13, t15, i14, h8) {
    return [s13[0] * t15 + i14[0] * h8, s13[1] * t15 + i14[1] * h8];
  }
  _add(s13, t15) {
    return [s13[0] + t15[0], s13[1] + t15[1]];
  }
  _add2(s13, t15, i14) {
    return [s13[0] + t15, s13[1] + i14];
  }
  _sub(s13, t15) {
    return [s13[0] - t15[0], s13[1] - t15[1]];
  }
  _dist(s13, t15) {
    return Math.sqrt((s13[0] - t15[0]) * (s13[0] - t15[0]) + (s13[1] - t15[1]) * (s13[1] - t15[1]));
  }
  _norm(s13) {
    return Math.sqrt(s13[0] * s13[0] + s13[1] * s13[1]);
  }
  _normalize(s13, t15 = 1) {
    const i14 = t15 / this._norm(s13);
    s13[0] *= i14, s13[1] *= i14;
  }
  _leftPerpendicular(s13) {
    const t15 = -s13[1], i14 = s13[0];
    s13[0] = t15, s13[1] = i14;
  }
  _leftPerp(s13) {
    return [-s13[1], s13[0]];
  }
  _rightPerpendicular(s13) {
    const t15 = s13[1], i14 = -s13[0];
    s13[0] = t15, s13[1] = i14;
  }
  _rightPerp(s13) {
    return [s13[1], -s13[0]];
  }
  _dotProduct(s13, t15) {
    return s13[0] * t15[0] + s13[1] * t15[1];
  }
  _crossProduct(s13, t15) {
    return s13[0] * t15[1] - s13[1] * t15[0];
  }
  _rotateDirect(s13, t15, i14) {
    const h8 = s13[0] * t15 - s13[1] * i14, e14 = s13[0] * i14 + s13[1] * t15;
    s13[0] = h8, s13[1] = e14;
  }
  _makeCtrlPt(s13) {
    const t15 = [s13[0], s13[1]];
    return r3(t15, 1), t15;
  }
  _addAngledTicks(s13, t15, i14, h8) {
    const e14 = this._sub(i14, t15);
    this._normalize(e14);
    const r16 = this._crossProduct(e14, this._sub(h8, t15));
    let _3;
    _3 = r16 > 0 ? this._rightPerp(e14) : this._leftPerp(e14);
    const c4 = Math.abs(r16) / 2, u9 = [];
    u9.push([t15[0] + (_3[0] - e14[0]) * c4, t15[1] + (_3[1] - e14[1]) * c4]), u9.push(t15), u9.push(i14), u9.push([i14[0] + (_3[0] + e14[0]) * c4, i14[1] + (_3[1] + e14[1]) * c4]), s13.push(u9);
  }
  _addBezier2(s13, t15, i14, h8, e14) {
    if (0 == e14--)
      return void s13.push(h8);
    const r16 = this._mid(t15, i14), _3 = this._mid(i14, h8), c4 = this._mid(r16, _3);
    this._addBezier2(s13, t15, r16, c4, e14), this._addBezier2(s13, c4, _3, h8, e14);
  }
  _addBezier3(s13, t15, i14, h8, e14, r16) {
    if (0 == r16--)
      return void s13.push(e14);
    const _3 = this._mid(t15, i14), c4 = this._mid(i14, h8), u9 = this._mid(h8, e14), o6 = this._mid(_3, c4), n19 = this._mid(c4, u9), a11 = this._mid(o6, n19);
    this._addBezier3(s13, t15, _3, o6, a11, r16), this._addBezier3(s13, a11, n19, u9, e14, r16);
  }
  _add90DegArc(s13, t15, i14, h8, e14) {
    const r16 = e14 ?? this._crossProduct(this._sub(i14, t15), this._sub(h8, t15)) > 0, _3 = this._mid(t15, i14), c4 = this._sub(_3, t15);
    r16 ? this._leftPerpendicular(c4) : this._rightPerpendicular(c4), _3[0] += c4[0], _3[1] += c4[1], this._addBezier3(s13, t15, this._mix(t15, 0.33333, _3, 0.66667), this._mix(i14, 0.33333, _3, 0.66667), i14, 4);
  }
  _addArrow(s13, t15, i14) {
    const h8 = t15[0], e14 = t15[1], r16 = t15[t15.length - 1], _3 = this._sub(h8, e14);
    this._normalize(_3);
    const c4 = this._crossProduct(_3, this._sub(r16, e14)), u9 = 0.5 * c4, o6 = this._leftPerp(_3), n19 = [r16[0] - o6[0] * c4, r16[1] - o6[1] * c4], a11 = t15.length - 1, p3 = [];
    p3.push(i14 ? [-o6[0], -o6[1]] : o6);
    let l9 = [-_3[0], -_3[1]];
    for (let d2 = 1; d2 < a11 - 1; d2++) {
      const s14 = this._sub(t15[d2 + 1], t15[d2]);
      this._normalize(s14);
      const i15 = this._dotProduct(s14, l9), h9 = this._crossProduct(s14, l9), e15 = Math.sqrt((1 + i15) / 2), r17 = this._sub(s14, l9);
      this._normalize(r17), r17[0] /= e15, r17[1] /= e15, p3.push(h9 < 0 ? [-r17[0], -r17[1]] : r17), l9 = s14;
    }
    p3.push(this._rightPerp(l9));
    for (let d2 = p3.length - 1; d2 > 0; d2--)
      s13.push([t15[d2][0] + p3[d2][0] * u9, t15[d2][1] + p3[d2][1] * u9]);
    s13.push([n19[0] + p3[0][0] * u9, n19[1] + p3[0][1] * u9]), s13.push([n19[0] + p3[0][0] * c4, n19[1] + p3[0][1] * c4]), s13.push(h8), s13.push([n19[0] - p3[0][0] * c4, n19[1] - p3[0][1] * c4]), s13.push([n19[0] - p3[0][0] * u9, n19[1] - p3[0][1] * u9]);
    for (let d2 = 1; d2 < p3.length; d2++)
      s13.push([t15[d2][0] - p3[d2][0] * u9, t15[d2][1] - p3[d2][1] * u9]);
  }
  _cp2(s13, t15, i14) {
    return s13.length >= 2 ? s13[1] : this._add2(s13[0], t15 * this._defaultSize, i14 * this._defaultSize);
  }
  _cp3(s13, t15, i14, h8) {
    if (s13.length >= 3)
      return s13[2];
    const e14 = this._mix(s13[0], 1 - i14, t15, i14), r16 = this._sub(t15, s13[0]);
    return this._normalize(r16), this._rightPerpendicular(r16), [e14[0] + r16[0] * h8 * this._defaultSize, e14[1] + r16[1] * h8 * this._defaultSize];
  }
  _arrowPath(s13) {
    if (s13.length > 2)
      return s13;
    const t15 = s13[0], i14 = this._cp2(s13, -4, 0), h8 = this._sub(t15, i14);
    this._normalize(h8);
    const e14 = this._rightPerp(h8);
    return [t15, i14, [t15[0] + (e14[0] - h8[0]) * this._defaultSize, t15[1] + (e14[1] - h8[1]) * this._defaultSize]];
  }
  _arrowLastSeg(s13) {
    const t15 = s13[0], i14 = this._cp2(s13, -4, 0);
    let h8;
    if (s13.length >= 3)
      h8 = s13[s13.length - 1];
    else {
      const s14 = this._sub(t15, i14);
      this._normalize(s14);
      const e14 = this._rightPerp(s14);
      h8 = [t15[0] + (e14[0] - s14[0]) * this._defaultSize, t15[1] + (e14[1] - s14[1]) * this._defaultSize];
    }
    return [i14, h8];
  }
  _processGeom(s13) {
    if (!s13)
      return null;
    const t15 = [];
    for (const e14 of s13) {
      if (!e14 || 0 === e14.length)
        continue;
      const s14 = e14.length;
      let r16 = e14[0];
      switch (this._rule) {
        case R.PerpendicularFromFirstSegment: {
          const s15 = this._cp2(e14, 0, -1), i14 = this._cp3(e14, s15, 0.5, 4), h8 = [];
          h8.push(i14), h8.push(this._mid(r16, s15)), t15.push(h8);
          break;
        }
        case R.ReversedFirstSegment: {
          const s15 = this._cp2(e14, 0, -1);
          t15.push([s15, r16]);
          break;
        }
        case R.PerpendicularToSecondSegment: {
          const s15 = this._cp2(e14, -4, 1), i14 = this._cp3(e14, s15, 0.882353, -1.94), h8 = [];
          h8.push(this._mid(s15, i14)), h8.push(r16), t15.push(h8);
          break;
        }
        case R.SecondSegmentWithTicks: {
          const s15 = this._cp2(e14, -4, 1), i14 = this._cp3(e14, s15, 0.882353, -1.94), h8 = this._sub(i14, s15);
          let _3;
          _3 = this._crossProduct(h8, this._sub(r16, s15)) > 0 ? this._rightPerp(_3) : this._leftPerp(h8);
          const c4 = [];
          c4.push([s15[0] + (_3[0] - h8[0]) / 3, s15[1] + (_3[1] - h8[1]) / 3]), c4.push(s15), c4.push(i14), c4.push([i14[0] + (_3[0] + h8[0]) / 3, i14[1] + (_3[1] + h8[1]) / 3]), t15.push(c4);
          break;
        }
        case R.DoublePerpendicular: {
          const s15 = this._cp2(e14, 0, -1), i14 = this._cp3(e14, s15, 0.5, 3), h8 = this._mid(r16, s15), _3 = this._sub(h8, i14);
          this._normalize(_3);
          const c4 = this._crossProduct(_3, this._sub(r16, i14));
          this._leftPerpendicular(_3);
          const u9 = [];
          u9.push(r16), u9.push([i14[0] + _3[0] * c4, i14[1] + _3[1] * c4]), t15.push(u9);
          const o6 = [];
          o6.push([i14[0] - _3[0] * c4, i14[1] - _3[1] * c4]), o6.push(s15), t15.push(o6);
          break;
        }
        case R.OppositeToFirstSegment: {
          const s15 = this._cp2(e14, 0, -1), i14 = this._cp3(e14, s15, 0.5, 3), h8 = this._mid(r16, s15), _3 = this._sub(h8, i14);
          this._normalize(_3);
          const c4 = this._crossProduct(_3, this._sub(r16, i14));
          this._leftPerpendicular(_3);
          const u9 = [];
          u9.push([i14[0] + _3[0] * c4, i14[1] + _3[1] * c4]), u9.push([i14[0] - _3[0] * c4, i14[1] - _3[1] * c4]), t15.push(u9);
          break;
        }
        case R.TriplePerpendicular: {
          const s15 = this._cp2(e14, 0, -1), i14 = this._cp3(e14, s15, 0.5, 4), h8 = this._mid(r16, s15), _3 = this._sub(h8, i14);
          this._normalize(_3);
          const c4 = this._crossProduct(_3, this._sub(r16, i14));
          this._leftPerpendicular(_3);
          const u9 = [];
          u9.push([i14[0] + _3[0] * c4 * 0.8, i14[1] + _3[1] * c4 * 0.8]), u9.push([h8[0] + 0.8 * (r16[0] - h8[0]), h8[1] + 0.8 * (r16[1] - h8[1])]), t15.push(u9), t15.push([i14, h8]);
          const o6 = [];
          o6.push([i14[0] - _3[0] * c4 * 0.8, i14[1] - _3[1] * c4 * 0.8]), o6.push([h8[0] + 0.8 * (s15[0] - h8[0]), h8[1] + 0.8 * (s15[1] - h8[1])]), t15.push(o6);
          break;
        }
        case R.HalfCircleFirstSegment: {
          const s15 = this._cp2(e14, 0, -1), i14 = this._cp3(e14, s15, 0.5, 4), h8 = this._mid(r16, s15);
          let _3 = this._sub(s15, r16);
          const c4 = Math.cos(Math.PI / 18), u9 = Math.sin(Math.PI / 18), o6 = Math.sqrt((1 + c4) / 2), n19 = Math.sqrt((1 - c4) / 2), a11 = [];
          let p3;
          this._crossProduct(_3, this._sub(i14, r16)) > 0 ? (a11.push(r16), _3 = this._sub(r16, h8), p3 = s15) : (a11.push(s15), _3 = this._sub(s15, h8), p3 = r16), this._rotateDirect(_3, o6, n19), _3[0] /= o6, _3[1] /= o6;
          for (let t16 = 1; t16 <= 18; t16++)
            a11.push(this._add(h8, _3)), this._rotateDirect(_3, c4, u9);
          a11.push(p3), t15.push(a11);
          break;
        }
        case R.HalfCircleSecondSegment: {
          const s15 = this._cp2(e14, 0, -1), i14 = this._cp3(e14, s15, 1, -1);
          let h8 = this._sub(r16, s15);
          this._normalize(h8);
          const _3 = this._crossProduct(h8, this._sub(i14, s15)) / 2;
          this._leftPerpendicular(h8);
          const c4 = [s15[0] + h8[0] * _3, s15[1] + h8[1] * _3];
          h8 = this._sub(s15, c4);
          const u9 = Math.cos(Math.PI / 18);
          let o6 = Math.sin(Math.PI / 18);
          _3 > 0 && (o6 = -o6);
          const n19 = [s15];
          for (let t16 = 1; t16 <= 18; t16++)
            this._rotateDirect(h8, u9, o6), n19.push(this._add(c4, h8));
          t15.push(n19);
          break;
        }
        case R.HalfCircleExtended: {
          const i14 = this._cp2(e14, 0, -2), h8 = this._cp3(e14, i14, 1, -1);
          let _3;
          if (s14 >= 4)
            _3 = e14[3];
          else {
            const s15 = this._sub(r16, i14);
            _3 = this._add(h8, s15);
          }
          const c4 = this._dist(i14, h8) / 2 / 0.75, u9 = this._sub(i14, r16);
          this._normalize(u9, c4);
          const o6 = this._sub(h8, _3);
          this._normalize(o6, c4);
          const n19 = [_3, h8];
          t15.push(n19);
          const a11 = [this._clone(h8)];
          this._addBezier3(a11, h8, this._add(h8, o6), this._add(i14, u9), i14, 4), a11.push(r16), t15.push(a11);
          break;
        }
        case R.OpenCircle: {
          const s15 = this._cp2(e14, -2, 0), i14 = this._sub(s15, r16), h8 = Math.cos(Math.PI / 18), _3 = -Math.sin(Math.PI / 18), c4 = [s15];
          for (let t16 = 1; t16 <= 33; t16++)
            this._rotateDirect(i14, h8, _3), c4.push(this._add(r16, i14));
          t15.push(c4);
          break;
        }
        case R.CoverageEdgesWithTicks: {
          const i14 = this._cp2(e14, 0, -1);
          let h8, _3;
          if (s14 >= 3)
            h8 = e14[2];
          else {
            const s15 = this._sub(i14, r16), t16 = this._leftPerp(s15);
            h8 = [r16[0] + t16[0] - 0.25 * s15[0], r16[1] + t16[1] - 0.25 * s15[1]];
          }
          if (s14 >= 4)
            _3 = e14[3];
          else {
            const s15 = this._mid(r16, i14), t16 = this._sub(r16, i14);
            this._normalize(t16), this._leftPerpendicular(t16);
            const e15 = this._crossProduct(t16, this._sub(h8, s15));
            this._rightPerpendicular(t16), _3 = [h8[0] + t16[0] * e15 * 2, h8[1] + t16[1] * e15 * 2];
          }
          const c4 = this._sub(i14, r16);
          let u9, o6;
          u9 = this._crossProduct(c4, this._sub(h8, r16)) > 0 ? this._rightPerp(c4) : this._leftPerp(c4), o6 = [], o6.push(h8), o6.push(r16), o6.push([r16[0] + (u9[0] - c4[0]) / 3, r16[1] + (u9[1] - c4[1]) / 3]), t15.push(o6), u9 = this._crossProduct(c4, this._sub(_3, i14)) > 0 ? this._rightPerp(u9) : this._leftPerp(c4), o6 = [], o6.push([i14[0] + (u9[0] + c4[0]) / 3, i14[1] + (u9[1] + c4[1]) / 3]), o6.push(i14), o6.push(_3), t15.push(o6);
          break;
        }
        case R.GapExtentWithDoubleTicks: {
          const i14 = this._cp2(e14, 0, 2), h8 = this._cp3(e14, i14, 0, 1);
          let _3;
          if (s14 >= 4)
            _3 = e14[3];
          else {
            const s15 = this._sub(i14, r16);
            _3 = this._add(h8, s15);
          }
          this._addAngledTicks(t15, r16, i14, this._mid(h8, _3)), this._addAngledTicks(t15, h8, _3, this._mid(r16, i14));
          break;
        }
        case R.GapExtentMidline: {
          const i14 = this._cp2(e14, 2, 0), h8 = this._cp3(e14, i14, 0, 1);
          let _3;
          if (s14 >= 4)
            _3 = e14[3];
          else {
            const s15 = this._sub(i14, r16);
            _3 = this._add(h8, s15);
          }
          const c4 = [];
          c4.push(this._mid(r16, h8)), c4.push(this._mid(i14, _3)), t15.push(c4);
          break;
        }
        case R.Chevron: {
          const i14 = this._cp2(e14, -1, -1);
          let h8;
          if (s14 >= 3)
            h8 = e14[2];
          else {
            const s15 = this._sub(i14, r16);
            this._leftPerpendicular(s15), h8 = this._add(r16, s15);
          }
          t15.push([i14, this._makeCtrlPt(r16), h8]);
          break;
        }
        case R.PerpendicularWithArc: {
          const s15 = this._cp2(e14, 0, -2), i14 = this._cp3(e14, s15, 0.5, -1);
          let h8 = this._sub(s15, r16);
          const _3 = this._norm(h8);
          h8[0] /= _3, h8[1] /= _3;
          const c4 = this._crossProduct(h8, this._sub(i14, r16));
          let u9 = this._dotProduct(h8, this._sub(i14, r16));
          u9 < 0.05 * _3 ? u9 = 0.05 * _3 : u9 > 0.95 * _3 && (u9 = 0.95 * _3);
          const o6 = [r16[0] + h8[0] * u9, r16[1] + h8[1] * u9];
          this._leftPerpendicular(h8);
          let n19 = [];
          n19.push([o6[0] - h8[0] * c4, o6[1] - h8[1] * c4]), n19.push([o6[0] + h8[0] * c4, o6[1] + h8[1] * c4]), t15.push(n19);
          const a11 = [s15[0] + h8[0] * c4, s15[1] + h8[1] * c4];
          h8 = this._sub(s15, a11);
          const p3 = Math.cos(Math.PI / 18);
          let l9 = Math.sin(Math.PI / 18);
          c4 < 0 && (l9 = -l9), n19 = [r16, s15];
          for (let t16 = 1; t16 <= 9; t16++)
            this._rotateDirect(h8, p3, l9), n19.push(this._add(a11, h8));
          t15.push(n19);
          break;
        }
        case R.ClosedHalfCircle: {
          const s15 = this._cp2(e14, 2, 0), i14 = this._mid(r16, s15), h8 = this._sub(s15, i14), _3 = Math.cos(Math.PI / 18), c4 = Math.sin(Math.PI / 18), u9 = [r16, s15];
          for (let t16 = 1; t16 <= 18; t16++)
            this._rotateDirect(h8, _3, c4), u9.push(this._add(i14, h8));
          t15.push(u9);
          break;
        }
        case R.TripleParallelExtended: {
          const s15 = this._cp2(e14, 0, -2), h8 = this._cp3(e14, s15, 1, -2), _3 = this._mid(r16, s15), c4 = this._sub(h8, s15);
          this._normalize(c4);
          const u9 = Math.abs(this._crossProduct(c4, this._sub(_3, s15))) / 2, o6 = this._dist(s15, h8), n19 = [s15, r16];
          n19.push([r16[0] + c4[0] * o6 * 0.5, r16[1] + c4[1] * o6 * 0.5]), t15.push(n19);
          const a11 = [];
          a11.push([_3[0] - c4[0] * u9, _3[1] - c4[1] * u9]), a11.push([_3[0] + c4[0] * o6 * 0.375, _3[1] + c4[1] * o6 * 0.375]), r3(a11[a11.length - 1], 1), a11.push([_3[0] + c4[0] * o6 * 0.75, _3[1] + c4[1] * o6 * 0.75]), t15.push(a11);
          const p3 = [s15, h8];
          t15.push(p3);
          break;
        }
        case R.ParallelWithTicks: {
          const s15 = this._cp2(e14, 3, 0), i14 = this._cp3(e14, s15, 0.5, -1), h8 = this._sub(i14, s15);
          this._normalize(h8);
          const _3 = this._crossProduct(h8, this._sub(i14, r16));
          this._leftPerpendicular(h8), this._addAngledTicks(t15, r16, s15, i14), this._addAngledTicks(t15, this._mix(r16, 1, h8, _3), this._mix(s15, 1, h8, _3), this._mid(r16, s15));
          break;
        }
        case R.Parallel: {
          const s15 = this._cp2(e14, 3, 0), i14 = this._cp3(e14, s15, 0.5, -1), h8 = this._sub(s15, r16);
          this._normalize(h8);
          const _3 = this._leftPerp(h8), c4 = this._crossProduct(h8, this._sub(i14, r16));
          let u9 = [r16, s15];
          t15.push(u9), u9 = [], u9.push([r16[0] + _3[0] * c4, r16[1] + _3[1] * c4]), u9.push([s15[0] + _3[0] * c4, s15[1] + _3[1] * c4]), t15.push(u9);
          break;
        }
        case R.PerpendicularToFirstSegment: {
          const s15 = this._cp2(e14, 3, 0), i14 = this._cp3(e14, s15, 0.5, -1), h8 = this._mid(r16, s15), _3 = this._sub(s15, r16);
          this._normalize(_3);
          const c4 = this._crossProduct(_3, this._sub(i14, r16));
          this._leftPerpendicular(_3);
          const u9 = [];
          u9.push([h8[0] - _3[0] * c4 * 0.25, h8[1] - _3[1] * c4 * 0.25]), u9.push([h8[0] + _3[0] * c4 * 1.25, h8[1] + _3[1] * c4 * 1.25]), t15.push(u9);
          break;
        }
        case R.ParallelOffset: {
          const s15 = this._cp2(e14, 3, 0), i14 = this._cp3(e14, s15, 0.5, -1), h8 = this._sub(s15, r16);
          this._normalize(h8);
          const _3 = this._crossProduct(h8, this._sub(i14, r16));
          this._leftPerpendicular(h8);
          const c4 = [];
          c4.push([r16[0] - h8[0] * _3, r16[1] - h8[1] * _3]), c4.push([s15[0] - h8[0] * _3, s15[1] - h8[1] * _3]), t15.push(c4);
          const u9 = [];
          u9.push([r16[0] + h8[0] * _3, r16[1] + h8[1] * _3]), u9.push([s15[0] + h8[0] * _3, s15[1] + h8[1] * _3]), t15.push(u9);
          break;
        }
        case R.OffsetOpposite: {
          const s15 = this._cp2(e14, 3, 0), i14 = this._cp3(e14, s15, 0.5, -1), h8 = this._sub(s15, r16);
          this._normalize(h8);
          const _3 = this._crossProduct(h8, this._sub(i14, r16));
          this._leftPerpendicular(h8);
          const c4 = [];
          c4.push([r16[0] - h8[0] * _3, r16[1] - h8[1] * _3]), c4.push([s15[0] - h8[0] * _3, s15[1] - h8[1] * _3]), t15.push(c4);
          break;
        }
        case R.OffsetSame: {
          const s15 = this._cp2(e14, 3, 0), i14 = this._cp3(e14, s15, 0.5, -1), h8 = this._sub(s15, r16);
          this._normalize(h8);
          const _3 = this._crossProduct(h8, this._sub(i14, r16));
          this._leftPerpendicular(h8);
          const c4 = [];
          c4.push([r16[0] + h8[0] * _3, r16[1] + h8[1] * _3]), c4.push([s15[0] + h8[0] * _3, s15[1] + h8[1] * _3]), t15.push(c4);
          break;
        }
        case R.CircleWithArc: {
          let h8 = this._cp2(e14, 3, 0);
          const _3 = this._cp3(e14, h8, 0.5, -1);
          let c4, u9;
          if (s14 >= 4)
            c4 = e14[3], u9 = this._crossProduct(this._sub(c4, h8), this._sub(_3, h8)) > 0;
          else {
            c4 = h8, u9 = this._crossProduct(this._sub(c4, r16), this._sub(_3, r16)) > 0;
            const s15 = 24 * this._geomUnitsPerPoint, t16 = this._sub(c4, r16);
            this._normalize(t16, s15);
            const i14 = Math.sqrt(2) / 2;
            this._rotateDirect(t16, i14, u9 ? i14 : -i14), h8 = this._add(r16, t16);
          }
          const o6 = this._sub(h8, r16), n19 = Math.cos(Math.PI / 18), a11 = Math.sin(Math.PI / 18), p3 = [h8];
          for (let s15 = 1; s15 <= 36; s15++)
            this._rotateDirect(o6, n19, a11), p3.push(this._add(r16, o6));
          this._add90DegArc(p3, h8, c4, _3, u9), r3(p3[p3.length - 8], 1), t15.push(p3);
          break;
        }
        case R.DoubleJog: {
          let i14, h8, _3 = this._cp2(e14, -3, 1);
          if (i14 = s14 >= 3 ? e14[2] : this._add(r16, this._sub(r16, _3)), s14 >= 4)
            h8 = e14[3];
          else {
            const s15 = r16;
            r16 = _3, h8 = i14;
            const t16 = this._dist(r16, s15), e15 = this._dist(h8, s15);
            let c5 = 30 * this._geomUnitsPerPoint;
            0.5 * t16 < c5 && (c5 = 0.5 * t16), 0.5 * e15 < c5 && (c5 = 0.5 * e15), _3 = this._mix(r16, c5 / t16, s15, (t16 - c5) / t16), i14 = this._mix(h8, c5 / e15, s15, (e15 - c5) / e15);
          }
          const c4 = this._mid(r16, _3), u9 = this._mid(h8, i14), o6 = this._dist(r16, _3), n19 = this._dist(i14, h8);
          let a11 = Math.min(o6, n19) / 8;
          a11 = Math.min(a11, 24 * this._geomUnitsPerPoint);
          const p3 = Math.cos(Math.PI / 4);
          let l9 = this._sub(r16, _3);
          this._normalize(l9, a11), this._crossProduct(l9, this._sub(h8, _3)) > 0 ? this._rotateDirect(l9, p3, -p3) : this._rotateDirect(l9, p3, p3);
          let d2 = [];
          d2.push(_3), d2.push(this._add(c4, l9)), d2.push(this._sub(c4, l9)), d2.push(r16), t15.push(d2), l9 = this._sub(h8, i14), this._normalize(l9, a11), this._crossProduct(l9, this._sub(r16, i14)) < 0 ? this._rotateDirect(l9, p3, p3) : this._rotateDirect(l9, p3, -p3), d2 = [], d2.push(i14), d2.push(this._add(u9, l9)), d2.push(this._sub(u9, l9)), d2.push(h8), t15.push(d2);
          break;
        }
        case R.PerpendicularOffset: {
          const s15 = this._cp2(e14, -4, 1), i14 = this._cp3(e14, s15, 0.882353, -1.94), h8 = this._sub(i14, s15);
          this._crossProduct(h8, this._sub(r16, s15)) > 0 ? this._rightPerpendicular(h8) : this._leftPerpendicular(h8);
          const _3 = [h8[0] / 8, h8[1] / 8], c4 = this._sub(this._mid(s15, i14), _3);
          t15.push([c4, r16]);
          break;
        }
        case R.LineExcludingLastSegment: {
          const s15 = this._arrowPath(e14), i14 = [];
          let h8 = s15.length - 2;
          for (; h8--; )
            i14.push(s15[h8]);
          t15.push(i14);
          break;
        }
        case R.MultivertexArrow: {
          const s15 = this._arrowPath(e14), i14 = [];
          this._addArrow(i14, s15, false), t15.push(i14);
          break;
        }
        case R.CrossedArrow: {
          const s15 = this._arrowPath(e14), i14 = [];
          this._addArrow(i14, s15, true), t15.push(i14);
          break;
        }
        case R.ChevronArrow: {
          const [s15, i14] = this._arrowLastSeg(e14), h8 = 10 * this._geomUnitsPerPoint, _3 = this._sub(r16, s15);
          this._normalize(_3);
          const c4 = this._crossProduct(_3, this._sub(i14, s15)), u9 = this._leftPerp(_3), o6 = [i14[0] - u9[0] * c4 * 2, i14[1] - u9[1] * c4 * 2], n19 = [];
          n19.push([i14[0] + _3[0] * h8, i14[1] + _3[1] * h8]), n19.push(r16), n19.push([o6[0] + _3[0] * h8, o6[1] + _3[1] * h8]), t15.push(n19);
          break;
        }
        case R.ChevronArrowOffset: {
          const [s15, i14] = this._arrowLastSeg(e14), h8 = this._sub(r16, s15);
          this._normalize(h8);
          const _3 = this._crossProduct(h8, this._sub(i14, s15));
          this._leftPerpendicular(h8);
          const c4 = [i14[0] - h8[0] * _3, i14[1] - h8[1] * _3], u9 = [];
          u9.push([c4[0] + h8[0] * _3 * 0.5, c4[1] + h8[1] * _3 * 0.5]), u9.push(this._mid(c4, r16)), u9.push([c4[0] - h8[0] * _3 * 0.5, c4[1] - h8[1] * _3 * 0.5]), t15.push(u9);
          break;
        }
        case R.PartialFirstSegment: {
          const [s15, i14] = this._arrowLastSeg(e14), h8 = this._sub(r16, s15);
          this._normalize(h8);
          const _3 = this._crossProduct(h8, this._sub(i14, s15));
          this._leftPerpendicular(h8);
          const c4 = [i14[0] - h8[0] * _3, i14[1] - h8[1] * _3];
          t15.push([s15, c4]);
          break;
        }
        case R.Arch: {
          const s15 = this._cp2(e14, 0, -1), i14 = this._cp3(e14, s15, 0.5, 1), h8 = this._sub(r16, s15), _3 = this._mix(i14, 1, h8, 0.55), c4 = this._mix(i14, 1, h8, -0.55), u9 = [r16];
          this._addBezier2(u9, r16, _3, i14, 4), this._addBezier2(u9, i14, c4, s15, 4), t15.push(u9);
          break;
        }
        case R.CurvedParallelTicks: {
          const s15 = this._cp2(e14, -4, 1), i14 = this._cp3(e14, s15, 0.882353, -1.94), h8 = this._sub(i14, s15);
          this._crossProduct(h8, this._sub(r16, s15)) > 0 ? this._rightPerpendicular(h8) : this._leftPerpendicular(h8);
          const _3 = [h8[0] / 8, h8[1] / 8], c4 = this._sub(this._mid(s15, i14), _3), u9 = this._sub(this._mix(s15, 0.75, i14, 0.25), _3), o6 = this._sub(this._mix(s15, 0.25, i14, 0.75), _3), n19 = [s15];
          this._addBezier2(n19, s15, u9, c4, 3), this._addBezier2(n19, c4, o6, i14, 3), t15.push(n19);
          for (let e15 = 0; e15 < 8; e15++) {
            const s16 = n19[2 * e15 + 1], i15 = [this._clone(s16)];
            i15.push(this._add(s16, [h8[0] / 4, h8[1] / 4])), t15.push(i15);
          }
          break;
        }
        case R.Arc90Degrees: {
          const s15 = this._cp2(e14, 0, -1), i14 = this._cp3(e14, s15, 0.5, 1), h8 = [s15];
          this._add90DegArc(h8, s15, r16, i14), t15.push(h8);
          break;
        }
        case R.FullGeometry:
        default:
          t15.push(e14);
      }
    }
    return t15;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectCut.js
var r5 = class _r {
  static local() {
    return null === _r.instance && (_r.instance = new _r()), _r.instance;
  }
  execute(e14, t15, i14, r16, n19) {
    return new u7(e14, t15, i14);
  }
};
r5.instance = null;
var u7 = class extends i5 {
  constructor(e14, t15, r16) {
    super(e14, true, true), this._curveHelper = new s7(), this._beginCut = (void 0 !== t15.beginCut ? t15.beginCut : 1) * r16, this._endCut = (void 0 !== t15.endCut ? t15.endCut : 1) * r16, this._middleCut = (void 0 !== t15.middleCut ? t15.middleCut : 0) * r16, this._invert = void 0 !== t15.invert && t15.invert, this._beginCut < 0 && (this._beginCut = 0), this._endCut < 0 && (this._endCut = 0), this._middleCut < 0 && (this._middleCut = 0);
  }
  processPath(t15) {
    const { _beginCut: i14, _endCut: r16, _middleCut: u9 } = this, n19 = t15.pathLength(), s13 = a6.createEmptyOptimizedCIM("esriGeometryPolyline");
    if (this._invert) {
      if (0 !== i14 || 0 !== r16 || 0 !== u9)
        if (i14 + r16 + u9 >= n19)
          for (s13.startPath(); t15.nextPoint(); )
            s13.pushXY(t15.x, t15.y);
        else
          this._curveHelper.appendSubCurve(s13, t15, 0, i14), this._curveHelper.appendSubCurve(s13, t15, 0.5 * (n19 - u9), 0.5 * (n19 + u9)), this._curveHelper.appendSubCurve(s13, t15, n19 - r16, r16);
    } else if (0 === i14 && 0 === r16 && 0 === u9)
      for (s13.startPath(); t15.nextPoint(); )
        s13.pushXY(t15.x, t15.y);
    else
      i14 + r16 + u9 < n19 && (0 === u9 ? this._curveHelper.appendSubCurve(s13, t15, i14, n19 - r16) : (this._curveHelper.appendSubCurve(s13, t15, i14, 0.5 * (n19 - u9)), this._curveHelper.appendSubCurve(s13, t15, 0.5 * (n19 + u9), n19 - r16)));
    return 0 === s13.totalSize ? null : s13;
  }
};

// node_modules/@arcgis/core/symbols/cim/GeometryWalker.js
var n9 = 1e-7;
var i6 = class {
  constructor() {
    this._values = [], this.extPtGap = 0, this.ctrlPtGap = 0, this._length = 0, this._currentValue = 0;
  }
  isEmpty() {
    return 0 === this._values.length;
  }
  size() {
    return this._values.length;
  }
  init(t15, e14, s13 = true) {
    if (this._setEmpty(), !t15 || 0 === t15.length)
      return false;
    for (let i14 = 0; i14 < t15.length; i14++) {
      let e15 = Math.abs(t15[i14]);
      s13 && e15 < n9 && (e15 = n9), this._values.push(e15), this._length += e15;
    }
    return e14 && 1 & t15.length && (this._length *= 2), 0 !== this._length && (this.ctrlPtGap = this.extPtGap = 0, this._currentValue = -1, true);
  }
  scale(t15) {
    const e14 = this._values ? this._values.length : 0;
    for (let s13 = 0; s13 < e14; ++s13)
      this._values[s13] *= t15;
    this._length *= t15, this.extPtGap *= t15, this.ctrlPtGap *= t15;
  }
  addValue(t15) {
    this._length += t15, this._values.push(t15);
  }
  firstValue() {
    return this._values[0];
  }
  lastValue() {
    return this._values[this._values.length - 1];
  }
  nextValue() {
    return this._currentValue++, this._currentValue === this._values.length && (this._currentValue = 0), this._values[this._currentValue];
  }
  reset() {
    this._currentValue = -1;
  }
  length() {
    return this._length;
  }
  _setEmpty() {
    this.extPtGap = this.ctrlPtGap = this._length = 0, this._currentValue = -1, this._values.length = 0;
  }
};
var h4 = class {
  constructor() {
    this.pt = null, this.ca = 0, this.sa = 0;
  }
};
var r6;
!function(t15) {
  t15[t15.FAIL = 0] = "FAIL", t15[t15.END = 1] = "END", t15[t15.CONTINUE = 2] = "CONTINUE";
}(r6 || (r6 = {}));
var a7 = class {
  constructor() {
    this.reset();
  }
  reset() {
    this.segment = null, this.segmentLength = 0, this.abscissa = 0, this.isPathEnd = false, this.isPartEnd = false;
  }
  isValid() {
    return null !== this.segment;
  }
  copyTo(t15) {
    t15.segment = this.segment, t15.segmentLength = this.segmentLength, t15.abscissa = this.abscissa, t15.isPathEnd = this.isPathEnd, t15.isPartEnd = this.isPartEnd;
  }
};
var o3 = class extends s7 {
  constructor(t15 = 0, e14 = false) {
    super(t15, e14), this._tolerance = n8, this._currentPosition = new a7();
  }
  updateTolerance(t15) {
    this._tolerance = n8 * t15;
  }
  init(t15, e14, s13 = true) {
    return s13 ? (this._patternLength = e14.length(), this._partExtPtGap = e14.extPtGap, this._partCtrlPtGap = e14.ctrlPtGap) : (this._patternLength = 0, this._partExtPtGap = 0, this._partCtrlPtGap = 0), this._currentPosition.reset(), this._partSegCount = 0, this._pathCursor = t15, this._seg = -1, this._setPosAtNextPart();
  }
  curPositionIsValid() {
    return this._currentPosition.isValid();
  }
  nextPosition(t15, e14 = r6.FAIL) {
    const s13 = new a7();
    return !!this._nextPosition(t15, s13, null, e14) && (s13.copyTo(this._currentPosition), true);
  }
  curPointAndAngle(t15) {
    t15.pt = this._getPoint(this._currentPosition);
    const [e14, s13] = this._getAngleCS(this._currentPosition);
    t15.ca = e14, t15.sa = s13;
  }
  nextPointAndAngle(t15, e14, s13 = r6.FAIL) {
    const n19 = new a7();
    if (!this._nextPosition(t15, n19, null, s13))
      return false;
    n19.copyTo(this._currentPosition), e14.pt = this._getPoint(n19);
    const [i14, h8] = this._getAngleCS(n19);
    return e14.ca = i14, e14.sa = h8, true;
  }
  nextCurve(e14) {
    if (0 === e14)
      return null;
    const s13 = a6.createEmptyOptimizedCIM("esriGeometryPolyline");
    s13.startPath(), s13.nextPath();
    const n19 = new a7();
    return this._nextPosition(e14, n19, s13, r6.END) ? (n19.copyTo(this._currentPosition), s13) : null;
  }
  isPathEnd() {
    return this._currentPosition.isPathEnd;
  }
  getPathEnd() {
    return this._currentPosition.segment[1];
  }
  getPt(t15) {
    return this._pathCursor.seekInPath(t15), [this._pathCursor.x, this._pathCursor.y];
  }
  getSeg(t15) {
    return [this.getPt(t15), this.getPt(t15 + 1)];
  }
  _nextPosition(t15, e14, s13, n19) {
    if (this._currentPosition.isPathEnd)
      return false;
    let i14 = this._currentPosition.abscissa;
    for (this._currentPosition.segmentLength > 0 && (i14 /= this._currentPosition.segmentLength), this._currentPosition.copyTo(e14); e14.abscissa + t15 * this._partLengthRatio > e14.segmentLength + this._tolerance; ) {
      if (s13) {
        if (0 === s13.pathSize)
          if (0 === i14) {
            const t17 = e14.segment[0];
            s13.pushXY(t17[0], t17[1]);
          } else
            s13.pushPoint(this.getSegCoord2D(e14.segment, i14));
        const t16 = e14.segment[1];
        s13.pushXY(t16[0], t16[1]);
      }
      if (i14 = 0, t15 -= (e14.segmentLength - e14.abscissa) / this._partLengthRatio, this._partSegCount)
        e14.segment = this._nextSegment(), e14.segmentLength = this.getSegLength(e14.segment), e14.abscissa = 0, this._partSegCount--;
      else {
        if (!this._setPosAtNextPart())
          return n19 !== r6.FAIL && (e14.segmentLength = this.getSegLength(e14.segment), e14.isPartEnd = true, n19 === r6.END ? (e14.abscissa = e14.segmentLength, e14.isPathEnd = true) : e14.abscissa = e14.segmentLength + t15, true);
        this._currentPosition.copyTo(e14);
      }
    }
    if (e14.abscissa += t15 * this._partLengthRatio, s13) {
      0 === s13.pathSize && (0 === i14 ? s13.pushPoint(e14.segment[0]) : s13.pushPoint(this.getSegCoord2D(e14.segment, i14)));
      const t16 = e14.abscissa / e14.segmentLength;
      1 === t16 ? s13.pushPoint(e14.segment[1]) : s13.pushPoint(this.getSegCoord2D(e14.segment, t16));
    }
    return this._partSegCount || Math.abs(e14.abscissa - e14.segmentLength) < this._tolerance && (e14.isPathEnd = this._partIsLast, e14.isPartEnd = true), true;
  }
  _getPoint(t15) {
    const e14 = t15.segmentLength <= 0 ? 0 : t15.abscissa / t15.segmentLength;
    return this.getSegCoord2D(this._currentPosition.segment, e14);
  }
  _getAngleCS(t15) {
    const e14 = t15.segmentLength <= 0 ? 0 : t15.abscissa / t15.segmentLength;
    return this.getSegAngleCS(this._currentPosition.segment, e14);
  }
  _setPosAtNextPart() {
    for (; this._partSegCount; )
      this._hasNextSegment() && this._nextSegment(), this._partSegCount--;
    if (!this._hasNextSegment())
      return false;
    for (this._partLength = 0, this._partIsLast = true, this._partSegCount = 0; this._hasNextSegment(); )
      if (this._partLength += this.getSegLength(this._nextSegment()), this._partSegCount++, this._pathCursor.getControlPointAt(this._getEndPointIndex())) {
        this._partIsLast = !this._hasNextSegment();
        break;
      }
    let t15 = this._partSegCount;
    for (; t15; )
      this._previousSegment(), --t15;
    this._currentPosition.segment = this._nextSegment(), this._currentPosition.segmentLength = this.getSegLength(this._currentPosition.segment), this._currentPosition.abscissa = 0, this._currentPosition.isPathEnd = this._currentPosition.isPartEnd = false, --this._partSegCount;
    const e14 = this._getStartPointIndex();
    this._ctrlPtBegin = this._pathCursor.getControlPointAt(e14);
    let s13 = e14 + this._partSegCount + 1;
    if (s13 >= this._pathCursor.pathSize && (s13 = 0), this._ctrlPtEnd = this._pathCursor.getControlPointAt(s13), this._patternLength > 0) {
      const t16 = this._ctrlPtBegin ? this._partCtrlPtGap : this._partExtPtGap, e15 = this._ctrlPtEnd ? this._partCtrlPtGap : this._partExtPtGap;
      let s14 = Math.round((this._partLength - (t16 + e15)) / this._patternLength);
      s14 <= 0 && (s14 = t16 + e15 > 0 ? 0 : 1), this._partLengthRatio = this._partLength / (t16 + e15 + s14 * this._patternLength), this._partLengthRatio < 0.01 && (this._partLengthRatio = 1);
    } else
      this._partLengthRatio = 1;
    return true;
  }
  _hasNextSegment() {
    return this._seg < this._pathCursor.pathSize - 2;
  }
  _previousSegment() {
    return this.getSeg(--this._seg);
  }
  _nextSegment() {
    return this.getSeg(++this._seg);
  }
  _getStartPointIndex() {
    return this._seg;
  }
  _getEndPointIndex() {
    return this._seg + 1;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectDashes.js
var n10 = class _n {
  static local() {
    return null === _n.instance && (_n.instance = new _n()), _n.instance;
  }
  execute(t15, e14, s13, i14, r16) {
    return new h5(t15, e14, s13);
  }
};
n10.instance = null;
var h5 = class extends i5 {
  constructor(t15, e14, s13) {
    super(t15, true, true), this._firstCurve = null, this._walker = new o3(), this._walker.updateTolerance(s13), this._endings = e14.lineDashEnding, this._customDashPos = -(e14.offsetAlongLine ?? 0) * s13, this._offsetAtEnd = (e14.customEndingOffset ?? 0) * s13, this._pattern = new i6(), this._pattern.init(e14.dashTemplate, true), this._pattern.scale(s13);
  }
  processPath(s13) {
    if (0 === this._pattern.length()) {
      this.iteratePath = false;
      const i14 = n(s13);
      return a6.fromJSONCIM({ paths: [i14] });
    }
    if (!this.iteratePath) {
      let r17 = true;
      switch (this._endings) {
        case k2.HalfPattern:
        case k2.HalfGap:
        default:
          this._pattern.extPtGap = 0;
          break;
        case k2.FullPattern:
          this.isClosed || (this._pattern.extPtGap = 0.5 * this._pattern.firstValue());
          break;
        case k2.FullGap:
          this.isClosed || (this._pattern.extPtGap = 0.5 * this._pattern.lastValue());
          break;
        case k2.NoConstraint:
          this.isClosed || (r17 = false);
          break;
        case k2.Custom:
          this.isClosed || (this._pattern.extPtGap = 0.5 * this._offsetAtEnd);
      }
      const a12 = s13.pathLength();
      if (this._pattern.isEmpty() || a12 < 0.1 * this._pattern.length()) {
        const i14 = n(s13);
        return a6.fromJSONCIM({ paths: [i14] });
      }
      if (!this._walker.init(s13, this._pattern, r17)) {
        const i14 = n(s13);
        return a6.fromJSONCIM({ paths: [i14] });
      }
    }
    let r16;
    if (this.iteratePath)
      r16 = this._pattern.nextValue();
    else {
      let t15;
      switch (this._endings) {
        case k2.HalfPattern:
        default:
          t15 = 0.5 * this._pattern.firstValue();
          break;
        case k2.HalfGap:
          t15 = 0.5 * -this._pattern.lastValue();
          break;
        case k2.FullGap:
          t15 = -this._pattern.lastValue();
          break;
        case k2.FullPattern:
          t15 = 0;
          break;
        case k2.NoConstraint:
        case k2.Custom:
          t15 = -this._customDashPos;
      }
      let e14 = t15 / this._pattern.length();
      e14 -= Math.floor(e14), t15 = e14 * this._pattern.length(), this._pattern.reset(), r16 = this._pattern.nextValue();
      let s14 = false;
      for (; t15 >= r16; )
        t15 -= r16, r16 = this._pattern.nextValue(), s14 = !s14;
      r16 -= t15, s14 ? (this._walker.nextPosition(r16), r16 = this._pattern.nextValue()) : this.isClosed && (this._firstCurve = this._walker.nextCurve(r16), r16 = this._pattern.nextValue(), this._walker.nextPosition(r16), r16 = this._pattern.nextValue());
    }
    let a11 = this._walker.nextCurve(r16);
    if (a11)
      if (this._walker.isPathEnd()) {
        if (this.iteratePath = false, this._firstCurve) {
          for (this._firstCurve.nextPath(); this._firstCurve.nextPoint(); )
            a11.pushXY(this._firstCurve.x, this._firstCurve.y);
          this._firstCurve = null;
        }
      } else
        r16 = this._pattern.nextValue(), !this._walker.nextPosition(r16) || this._walker.isPathEnd() ? (this.iteratePath = false, this._firstCurve && (a11.pushCursor(this._firstCurve), this._firstCurve = null)) : this.iteratePath = true;
    else
      this.iteratePath = false, a11 = this._firstCurve, this._firstCurve = null;
    return a11 == null ? void 0 : a11.reset(), a11;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectDonut.js
var s8 = class _s {
  static local() {
    return null === _s.instance && (_s.instance = new _s()), _s.instance;
  }
  execute(t15, e14, i14, n19, s13, m7) {
    return new r7(t15, e14, i14, n19, s13, m7);
  }
};
s8.instance = null;
var r7 = class {
  constructor(t15, e14, n19, s13, r16, m7) {
    switch (this._inputGeometries = t15, this._tileKey = s13, this._geometryEngine = r16, this._maxInflateSize = m7 * n19, this._width = (void 0 !== e14.width ? e14.width : 2) * n19, e14.method) {
      case B.Mitered:
      case B.Bevelled:
      case B.Rounded:
      case B.TrueBuffer:
      case B.Square:
    }
    this._option = e14.option;
  }
  next() {
    let i14;
    for (; i14 = this._inputGeometries.next(); ) {
      if ("esriGeometryEnvelope" === i14.geometryType && this._width > 0) {
        const e14 = i14.asJSON();
        return Math.min(e14.xmax - e14.xmin, e14.ymax - e14.ymin) - 2 * this._width < 0 ? i14 : a6.fromJSONCIM({ paths: [[[e14.xmin + this._width, e14.ymin + this._width], [e14.xmax - this._width, e14.ymin + this._width], [e14.xmax - this._width, e14.ymax - this._width], [e14.xmin + this._width, e14.ymax - this._width], [e14.xmin + this._width, e14.ymin + this._width]], [[e14.xmin, e14.ymin], [e14.xmin, e14.ymax], [e14.xmax, e14.ymax], [e14.xmax, e14.ymin], [e14.xmin, e14.ymin]]] });
      }
      if ("esriGeometryPolygon" === i14.geometryType) {
        if (0 === this._width)
          return i14.clone();
        const t15 = this._geometryEngine;
        if (null == t15)
          return null;
        const s13 = this._tileKey ? i4(i14, this._maxInflateSize) : i14.clone();
        if (!s13)
          continue;
        const r16 = t15.buffer(f.WebMercator, s13.asJSON(), -this._width, 1);
        if (r16)
          for (const e14 of r16.rings)
            e14 && s13.pushPath(e14.reverse());
        return s13;
      }
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectJog.js
var e8 = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(t15, i14, s13, e14, o6) {
    return new n11(t15, i14, s13);
  }
};
e8.instance = null;
var n11 = class extends i5 {
  constructor(t15, i14, e14) {
    super(t15, false, true), this._curveHelper = new s7(), this._length = (void 0 !== i14.length ? i14.length : 20) * e14, this._angle = void 0 !== i14.angle ? i14.angle : 225, this._position = void 0 !== i14.position ? i14.position : 50, this._length < 0 && (this._length = -this._length), this._position < 20 && (this._position = 20), this._position > 80 && (this._position = 80), this._mirror = false;
  }
  processPath(i14) {
    const s13 = a6.createEmptyOptimizedCIM("esriGeometryPolyline");
    if (this._curveHelper.isEmpty(i14))
      return null;
    i14.seekInPath(0);
    const e14 = i14.x, n19 = i14.y;
    i14.seekInPath(i14.pathSize - 1);
    const o6 = i14.x, r16 = i14.y, h8 = [o6 - e14, r16 - n19];
    this._curveHelper.normalize(h8);
    const l9 = e14 + (o6 - e14) * this._position / 100, _3 = n19 + (r16 - n19) * this._position / 100, a11 = Math.cos((90 - this._angle) / 180 * Math.PI);
    let p3 = Math.sin((90 - this._angle) / 180 * Math.PI);
    this._mirror && (p3 = -p3), this._mirror = !this._mirror;
    const c4 = [l9 - this._length / 2 * a11, _3 - this._length / 2 * p3], m7 = [l9 + this._length / 2 * a11, _3 + this._length / 2 * p3];
    return s13.pushPath([[e14, n19], c4, m7, [o6, r16]]), s13;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectMove.js
var t11 = class _t {
  static local() {
    return null === _t.instance && (_t.instance = new _t()), _t.instance;
  }
  execute(t15, s13, n19, o6, i14) {
    return new e9(t15, s13, n19);
  }
};
t11.instance = null;
var e9 = class {
  constructor(t15, e14, s13) {
    this._inputGeometries = t15, this._offsetX = void 0 !== e14.offsetX ? e14.offsetX * s13 : 0, this._offsetY = void 0 !== e14.offsetY ? e14.offsetY * s13 : 0;
  }
  next() {
    let t15 = this._inputGeometries.next();
    for (; t15; ) {
      if (t15.totalSize > 0)
        return this._move(t15.clone(), this._offsetX, this._offsetY);
      t15 = this._inputGeometries.next();
    }
    return null;
  }
  _move(t15, e14, s13) {
    for (; t15.nextPath(); )
      for (; t15.nextPoint(); )
        t15.x = t15.x + e14, t15.y = t15.y + s13;
    return t15.reset(), t15;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectOffset.js
var m6 = class _m {
  static local() {
    return null === _m.instance && (_m.instance = new _m()), _m.instance;
  }
  execute(t15, e14, o6, s13, r16, i14) {
    return new h6(t15, e14, o6, s13, r16, i14);
  }
};
m6.instance = null;
var h6 = class {
  constructor(t15, e14, o6, s13, n19, f5) {
    this._inputGeometries = t15, this._tileKey = s13, this._geometryEngine = n19, this._curveHelper = new s7(), this._offset = (e14.offset ?? 1) * o6, this._method = e14.method, this._maxInflateSize = f5 * o6, this._option = e14.option, this._offsetFlattenError = n8 * o6;
  }
  next() {
    let r16;
    for (; r16 = this._inputGeometries.next(); ) {
      if (0 === this._offset)
        return r16.clone();
      if ("esriGeometryEnvelope" === r16.geometryType) {
        if (this._method === O.Rounded && this._offset > 0) {
          const o6 = n(r16), s14 = this._curveHelper.offset(o6, -this._offset, this._method, 4, this._offsetFlattenError);
          if (s14) {
            const e14 = a6.createEmptyOptimizedCIM(r16.geometryType);
            return e14.pushPath(s14), e14;
          }
          return null;
        }
        const s13 = r16.asJSON();
        if (m(s13) && Math.min(s13.xmax - s13.xmin, s13.ymax - s13.ymin) + 2 * this._offset > 0)
          return a6.fromJSONCIM({ xmin: s13.xmin - this._offset, xmax: s13.xmax + this._offset, ymin: s13.ymin - this._offset, ymax: s13.ymax + this._offset });
      }
      const i14 = this._geometryEngine;
      if (null == i14)
        continue;
      const m7 = this._tileKey ? i4(r16, this._maxInflateSize) : r16.clone();
      if (!m7)
        continue;
      const h8 = i14.offset(f.WebMercator, m7.asJSON(), -this._offset, 1, this._method, 4, this._offsetFlattenError);
      return h8 ? a6.fromJSONCIM(h8) : null;
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectReverse.js
var e10 = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(e14, n19, r16, s13, i14) {
    return new t12(e14, n19, r16);
  }
};
e10.instance = null;
var t12 = class {
  constructor(e14, t15, n19) {
    this._inputGeometries = e14, this._reverse = void 0 === t15.reverse || t15.reverse;
  }
  next() {
    let e14 = this._inputGeometries.next();
    for (; e14; ) {
      if (!this._reverse)
        return e14;
      if ("esriGeometryPolyline" === e14.geometryType)
        return n12(e14.clone());
      e14 = this._inputGeometries.next();
    }
    return null;
  }
};
function n12(e14) {
  for (; e14.nextPath(); )
    for (let t15 = 0; t15 < e14.pathSize / 2; t15++) {
      e14.seekInPath(t15);
      const n19 = e14.x, r16 = e14.y;
      e14.seekInPath(e14.pathSize - t15 - 1);
      const s13 = e14.x, i14 = e14.y;
      e14.x = n19, e14.y = r16, e14.seekInPath(t15), e14.x = s13, e14.y = i14;
    }
  return e14.reset(), e14;
}

// node_modules/@arcgis/core/symbols/cim/effects/EffectRotate.js
var e11 = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(t15, e14, r16, s13, o6) {
    return new n13(t15, e14, r16);
  }
};
e11.instance = null;
var n13 = class {
  constructor(t15, e14, n19) {
    this._inputGeometries = t15, this._rotateAngle = void 0 !== e14.angle ? e14.angle * Math.PI / 180 : 0;
  }
  next() {
    let e14 = this._inputGeometries.next();
    for (; e14; ) {
      if (0 === this._rotateAngle || "esriGeometryPoint" === e14.geometryType)
        return e14;
      if (e14.totalSize > 0) {
        const n19 = c(e14), r16 = (n19[2] + n19[0]) / 2, s13 = (n19[3] + n19[1]) / 2;
        return e14.reset(), this._rotate(e14.clone(), r16, s13);
      }
      e14 = this._inputGeometries.next();
    }
    return null;
  }
  _rotate(t15, e14, n19) {
    const r16 = Math.cos(this._rotateAngle), s13 = Math.sin(this._rotateAngle);
    for (; t15.nextPath(); )
      for (; t15.nextPoint(); ) {
        const o6 = t15.x - e14, i14 = t15.y - n19;
        t15.x = e14 + o6 * r16 - i14 * s13, t15.y = n19 + o6 * s13 + i14 * r16;
      }
    return t15.reset(), t15;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectScale.js
var e12 = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(t15, e14, o6, s13, n19) {
    return new r8(t15, e14, o6);
  }
};
e12.instance = null;
var r8 = class {
  constructor(t15, e14, r16) {
    this._inputGeometries = t15, this._xFactor = void 0 !== e14.XScaleFactor ? e14.XScaleFactor : 1.15, this._yFactor = void 0 !== e14.YScaleFactor ? e14.YScaleFactor : 1.15;
  }
  next() {
    const e14 = this._inputGeometries.next();
    if (e14) {
      if (1 === this._xFactor && 1 === this._yFactor)
        return e14;
      if ("esriGeometryPoint" === e14.geometryType)
        return e14;
      if (e14.totalSize > 0) {
        const r16 = c(e14), o6 = (r16[2] + r16[0]) / 2, s13 = (r16[3] + r16[1]) / 2;
        return e14.reset(), this._scaleCursor(e14.clone(), o6, s13);
      }
    }
    return null;
  }
  _scaleCursor(t15, e14, r16) {
    for (; t15.nextPath(); )
      for (; t15.nextPoint(); )
        t15.x = e14 + (t15.x - e14) * this._xFactor, t15.y = r16 + (t15.y - r16) * this._yFactor;
    return t15.reset(), t15;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectWave.js
var n14 = class _n {
  static local() {
    return null === _n.instance && (_n.instance = new _n()), _n.instance;
  }
  execute(t15, e14, i14, s13, h8) {
    return new r9(t15, e14, i14);
  }
};
n14.instance = null;
var r9 = class {
  constructor(t15, e14, h8) {
    this._inputGeometries = t15, this._height = (void 0 !== e14.amplitude ? e14.amplitude : 2) * h8, this._period = (void 0 !== e14.period ? e14.period : 3) * h8, this._style = e14.waveform, this._height <= 0 && (this._height = Math.abs(this._height)), this._period <= 0 && (this._period = Math.abs(this._period)), this._pattern = new i6(), this._pattern.addValue(this._period), this._pattern.addValue(this._period), this._walker = new o3(), this._walker.updateTolerance(h8);
  }
  next() {
    let t15 = this._inputGeometries.next();
    for (; t15; ) {
      if (0 === this._height || 0 === this._period)
        return t15;
      const e14 = this._processGeom(t15);
      if (e14)
        return e14;
      t15 = this._inputGeometries.next();
    }
    return null;
  }
  _processGeom(i14) {
    const s13 = a6.createEmptyOptimizedCIM(i14.geometryType);
    for (; i14.nextPath(); ) {
      s13.startPath();
      const t15 = i14.pathLength();
      if (this._walker.init(i14, this._pattern))
        switch (this._style) {
          case A.Sinus:
          default:
            this._constructCurve(s13, t15, false);
            break;
          case A.Square:
            this._constructSquare(s13, t15);
            break;
          case A.Triangle:
            this._constructTriangle(s13, t15);
            break;
          case A.Random:
            this._constructCurve(s13, t15, true);
        }
      else
        for (; i14.nextPoint(); )
          s13.pushXY(i14.x, i14.y);
    }
    return s13;
  }
  _constructCurve(t15, e14, i14) {
    let s13 = Math.round(e14 / this._period);
    0 === s13 && (s13 = 1);
    const n19 = s13 * 16 + 1, r16 = e14 / s13, a11 = this._period / 16, o6 = 1 / n19, p3 = 2 * Math.PI * e14 / r16, _3 = 2 * Math.PI * Math.random(), u9 = 2 * Math.PI * Math.random(), l9 = 2 * Math.PI * Math.random(), c4 = 0.75 - Math.random() / 2, d2 = 0.75 - Math.random() / 2, g4 = new h4();
    this._walker.curPointAndAngle(g4), t15.pushPoint(g4.pt);
    let w6 = 0;
    for (; ; ) {
      if (!this._walker.nextPointAndAngle(a11, g4)) {
        t15.pushPoint(this._walker.getPathEnd());
        break;
      }
      {
        const e15 = w6;
        let s14;
        if (w6 += o6, i14) {
          const t16 = this._height / 2 * (1 + 0.3 * Math.sin(c4 * p3 * e15 + _3));
          s14 = t16 * Math.sin(p3 * e15 + u9), s14 += t16 * Math.sin(d2 * p3 * e15 + l9), s14 /= 2;
        } else
          s14 = 0.5 * this._height * Math.sin(0.5 * p3 * e15);
        t15.pushXY(g4.pt[0] - s14 * g4.sa, g4.pt[1] + s14 * g4.ca);
      }
    }
  }
  _constructSquare(t15, e14) {
    Math.round(e14 / this._period);
    let i14 = true;
    for (; ; ) {
      let e15 = false;
      if (this._walker.curPositionIsValid()) {
        const s13 = new h4();
        this._walker.curPointAndAngle(s13);
        const n19 = new h4();
        if (this._walker.nextPointAndAngle(this._period, n19)) {
          const r16 = new h4();
          this._walker.nextPointAndAngle(this._period, r16) && (i14 ? (t15.pushPoint(s13.pt), i14 = false) : t15.pushPoint(s13.pt), t15.pushXY(s13.pt[0] - this._height / 2 * s13.sa, s13.pt[1] + this._height / 2 * s13.ca), t15.pushXY(n19.pt[0] - this._height / 2 * n19.sa, n19.pt[1] + this._height / 2 * n19.ca), t15.pushXY(n19.pt[0] + this._height / 2 * n19.sa, n19.pt[1] - this._height / 2 * n19.ca), t15.pushXY(r16.pt[0] + this._height / 2 * r16.sa, r16.pt[1] - this._height / 2 * r16.ca), e15 = true);
        }
      }
      if (!e15) {
        t15.pushPoint(this._walker.getPathEnd());
        break;
      }
    }
  }
  _constructTriangle(t15, e14) {
    Math.round(e14 / this._period);
    let i14 = true;
    for (; ; ) {
      let e15 = false;
      if (this._walker.curPositionIsValid()) {
        const s13 = new h4();
        this._walker.curPointAndAngle(s13);
        const n19 = new h4();
        if (this._walker.nextPointAndAngle(this._period / 2, n19)) {
          const r16 = new h4();
          this._walker.nextPointAndAngle(this._period, r16) && (this._walker.nextPosition(this._period / 2) && (i14 ? (t15.pushPoint(s13.pt), i14 = false) : t15.pushPoint(s13.pt), t15.pushXY(n19.pt[0] - this._height / 2 * n19.sa, n19.pt[1] + this._height / 2 * n19.ca), t15.pushXY(r16.pt[0] + this._height / 2 * r16.sa, r16.pt[1] - this._height / 2 * r16.ca)), e15 = true);
        }
      }
      if (!e15) {
        t15.pushPoint(this._walker.getPathEnd());
        break;
      }
    }
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementAlongLineSameSize.js
var a8 = class _a {
  static local() {
    return null === _a.instance && (_a.instance = new _a()), _a.instance;
  }
  execute(t15, e14, s13, i14, n19) {
    return new r10(t15, e14, s13);
  }
};
a8.instance = null;
var r10 = class extends s6 {
  constructor(t15, e14, n19) {
    super(t15), this._geometryWalker = new o3(), this._geometryWalker.updateTolerance(n19), this._angleToLine = e14.angleToLine ?? true, this._offset = (e14.offset ? e14.offset : 0) * n19, this._originalEndings = e14.endings, this._offsetAtEnd = (e14.customEndingOffset ? e14.customEndingOffset : 0) * n19, this._position = -(e14.offsetAlongLine ? e14.offsetAlongLine : 0) * n19, this._pattern = new i6(), this._pattern.init(e14.placementTemplate, false), this._pattern.scale(n19), this._endings = this._originalEndings;
  }
  processPath(t15) {
    if (this._pattern.isEmpty())
      return null;
    let s13;
    if (this.iteratePath)
      s13 = this._pattern.nextValue();
    else {
      this._originalEndings === X.WithFullGap && this.isClosed ? this._endings = X.WithMarkers : this._endings = this._originalEndings, this._pattern.extPtGap = 0;
      let i15, n19 = true;
      switch (this._endings) {
        case X.NoConstraint:
          i15 = -this._position, i15 = this._adjustPosition(i15), n19 = false;
          break;
        case X.WithHalfGap:
        default:
          i15 = -this._pattern.lastValue() / 2;
          break;
        case X.WithFullGap:
          i15 = -this._pattern.lastValue(), this._pattern.extPtGap = this._pattern.lastValue();
          break;
        case X.WithMarkers:
          i15 = 0;
          break;
        case X.Custom:
          i15 = -this._position, i15 = this._adjustPosition(i15), this._pattern.extPtGap = 0.5 * this._offsetAtEnd;
      }
      if (!this._geometryWalker.init(t15, this._pattern, n19))
        return null;
      this._pattern.reset();
      let a11 = 0;
      for (; i15 > a11; )
        i15 -= a11, a11 = this._pattern.nextValue();
      a11 -= i15, s13 = a11, this.iteratePath = true;
    }
    const i14 = new h4();
    return this._geometryWalker.nextPointAndAngle(s13, i14) ? this._endings === X.WithFullGap && this._geometryWalker.isPathEnd() ? (this.iteratePath = false, null) : this._endings === X.WithMarkers && this._geometryWalker.isPathEnd() && (this.iteratePath = false, this.isClosed) ? null : (this.internalPlacement.setTranslate(i14.pt[0] - this._offset * i14.sa, i14.pt[1] + this._offset * i14.ca), this._angleToLine && this.internalPlacement.setRotateCS(i14.ca, i14.sa), this.internalPlacement) : (this.iteratePath = false, null);
  }
  _adjustPosition(t15) {
    let e14 = t15 / this._pattern.length();
    return e14 -= Math.floor(e14), e14 * this._pattern.length();
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementAtExtremities.js
var i7 = class _i {
  static local() {
    return null === _i.instance && (_i.instance = new _i()), _i.instance;
  }
  execute(e14, t15, s13, i14, r16) {
    return new n15(e14, t15, s13);
  }
};
i7.instance = null;
var n15 = class extends s6 {
  constructor(e14, s13, i14) {
    super(e14, false, true), this._curveHelper = new s7(), this._angleToLine = void 0 === s13.angleToLine || s13.angleToLine, this._offset = void 0 !== s13.offset ? s13.offset * i14 : 0, this._type = s13.extremityPlacement, this._position = void 0 !== s13.offsetAlongLine ? s13.offsetAlongLine * i14 : 0, this._beginProcessed = false;
  }
  processPath(e14) {
    let t15;
    switch (this._type) {
      case o.Both:
      default:
        this._beginProcessed ? (t15 = this._atExtremities(e14, this._position, false), this._beginProcessed = false, this.iteratePath = false) : (t15 = this._atExtremities(e14, this._position, true), this._beginProcessed = true, this.iteratePath = true);
        break;
      case o.JustBegin:
        t15 = this._atExtremities(e14, this._position, true);
        break;
      case o.JustEnd:
        t15 = this._atExtremities(e14, this._position, false);
      case o.None:
    }
    return t15;
  }
  _atExtremities(e14, t15, s13) {
    if (s13 || e14.seekPathEnd(), s13 ? e14.nextPoint() : e14.prevPoint()) {
      let i14 = 0, [n19, r16] = [0, 0], [o6, a11] = [e14.x, e14.y];
      for (; s13 ? e14.nextPoint() : e14.prevPoint(); ) {
        n19 = o6, r16 = a11, o6 = e14.x, a11 = e14.y;
        const s14 = this._curveHelper.getLength(n19, r16, o6, a11);
        if (i14 + s14 > t15) {
          const e15 = (t15 - i14) / s14, [h8, l9] = this._curveHelper.getAngleCS(n19, r16, o6, a11, e15), c4 = this._curveHelper.getCoord2D(n19, r16, o6, a11, e15);
          return this.internalPlacement.setTranslate(c4[0] - this._offset * l9, c4[1] + this._offset * h8), this._angleToLine && this.internalPlacement.setRotateCS(-h8, -l9), this.internalPlacement;
        }
        i14 += s14;
      }
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementAtRatioPositions.js
var a9 = class _a {
  static local() {
    return null === _a.instance && (_a.instance = new _a()), _a.instance;
  }
  execute(t15, i14, s13, e14, n19) {
    return new r11(t15, i14, s13);
  }
};
a9.instance = null;
var r11 = class extends s6 {
  constructor(t15, e14, n19) {
    super(t15), this._walker = new o3(), this._walker.updateTolerance(n19), this._angleToLine = void 0 === e14.angleToLine || e14.angleToLine, this._offset = void 0 !== e14.offset ? e14.offset * n19 : 0, this._beginGap = void 0 !== e14.beginPosition ? e14.beginPosition * n19 : 0, this._endGap = void 0 !== e14.endPosition ? e14.endPosition * n19 : 0, this._flipFirst = void 0 === e14.flipFirst || e14.flipFirst, this._pattern = new i6(), this._pattern.init(e14.positionArray, false, false), this._subPathLen = 0, this._posCount = this._pattern.size(), this._isFirst = true, this._prevPos = 0;
  }
  processPath(t15) {
    if (this._pattern.isEmpty())
      return null;
    let i14;
    if (this.iteratePath) {
      const t16 = this._pattern.nextValue() * this._subPathLen, s14 = this._beginGap + t16;
      i14 = s14 - this._prevPos, this._prevPos = s14;
    } else {
      if (this._posCount = this._pattern.size(), this._isFirst = true, this._prevPos = 0, this._subPathLen = t15.pathLength() - this._beginGap - this._endGap, this._subPathLen < 0)
        return this.iteratePath = false, null;
      if (!this._walker.init(t15, this._pattern, false))
        return null;
      this._pattern.reset();
      const s14 = this._pattern.nextValue() * this._subPathLen, e14 = this._beginGap + s14;
      i14 = e14 - this._prevPos, this._prevPos = e14, this.iteratePath = true;
    }
    const s13 = new h4();
    if (!this._walker.nextPointAndAngle(i14, s13, r6.END))
      return this.iteratePath = false, null;
    this.internalPlacement.setTranslate(s13.pt[0] - this._offset * s13.sa, s13.pt[1] + this._offset * s13.ca);
    const a11 = this._isFirst && this._flipFirst;
    let r16, h8;
    return this._angleToLine ? (r16 = s13.ca, h8 = s13.sa) : (r16 = 1, h8 = 0), a11 && (r16 = -r16, h8 = -h8), this.internalPlacement.setRotateCS(r16, h8), this._isFirst = false, this._posCount--, 0 === this._posCount && (this.iteratePath = false), this.internalPlacement;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementInsidePolygon.js
var e13 = 512;
var h7 = 10;
var n16 = 24;
var _ = 1e-6;
var r12 = class _r {
  static local() {
    return null === _r.instance && (_r.instance = new _r()), _r.instance;
  }
  execute(t15, s13, i14, e14, h8) {
    return new a10(t15, s13, i14, e14, h8);
  }
};
r12.instance = null;
var a10 = class _a {
  constructor(h8, n19, _3, r16, a11) {
    if (this._xMin = 0, this._xMax = 0, this._yMin = 0, this._yMax = 0, this._currentX = 0, this._currentY = 0, this._accelerationMap = null, this._testInsidePolygon = false, this._verticalSubdivision = true, this._stepX = Math.abs(n19.stepX ?? 16) * _3, this._stepY = Math.abs(n19.stepY ?? 16) * _3, this._stepX = Math.round(128 * this._stepX) / 128, this._stepY = Math.round(128 * this._stepY) / 128, 0 !== this._stepX && 0 !== this._stepY) {
      if (this._gridType = n19.gridType ?? Y.Fixed, this._gridType === Y.Random) {
        const s13 = n19.seed ?? 13, i14 = 1;
        this._randomLCG = new t(s13 * i14), this._randomness = (n19.randomness ?? 100) / 100, this._gridAngle = 0, this._shiftOddRows = false, this._cosAngle = 1, this._sinAngle = 0, this._offsetX = 0, this._offsetY = 0, this._buildRandomValues();
      } else {
        if (this._randomness = 0, this._gridAngle = n19.gridAngle ?? 0, this._shiftOddRows = n19.shiftOddRows ?? false, this._offsetX = (n19.offsetX ?? 0) * _3, this._offsetY = (n19.offsetY ?? 0) * _3, this._cosAngle = Math.cos(this._gridAngle / 180 * Math.PI), this._sinAngle = -Math.sin(this._gridAngle / 180 * Math.PI), this._stepX)
          if (this._offsetX < 0)
            for (; this._offsetX < -0.5 * this._stepX; )
              this._offsetX += this._stepX;
          else
            for (; this._offsetX >= 0.5 * this._stepX; )
              this._offsetX -= this._stepX;
        if (this._stepY)
          if (this._offsetY < 0)
            for (; this._offsetY < -0.5 * this._stepY; )
              this._offsetY += this._stepY;
          else
            for (; this._offsetY >= 0.5 * this._stepY; )
              this._offsetY -= this._stepY;
      }
      if (this._graphicOriginX = 0, this._graphicOriginY = 0, null != r16) {
        const [t15, s13, i14, h9] = r16.split("/"), n20 = parseFloat(t15), _4 = parseFloat(s13), a12 = parseFloat(i14), o6 = parseFloat(h9);
        this._graphicOriginX = -(o6 * 2 ** n20 + a12) * e13, this._graphicOriginY = _4 * e13, this._testInsidePolygon = true;
      }
      this._internalPlacement = new t8(), this._calculateMinMax(h8), this._geometryCursor = h8;
    }
  }
  next() {
    return this._geometryCursor ? this._nextInside() : null;
  }
  _buildRandomValues() {
    if (!_a._randValues) {
      _a._randValues = [];
      for (let t15 = 0; t15 < n16; t15++)
        for (let s13 = 0; s13 < n16; s13++)
          _a._randValues.push(this._randomLCG.getFloat()), _a._randValues.push(this._randomLCG.getFloat());
    }
  }
  _calculateMinMax(t15) {
    let s13, i14, h8, n19, _3, r16, a11, o6, l9, f5, c4, u9, p3, M2;
    this._xMin = 0, this._xMax = 0, this._yMin = 0, this._yMax = 0, a11 = o6 = p3 = c4 = Number.MAX_VALUE, l9 = f5 = M2 = u9 = -Number.MAX_VALUE;
    const g4 = 1 !== this._cosAngle;
    for (t15.reset(); t15.nextPath(); )
      for (; t15.nextPoint(); )
        r16 = t15.x, _3 = t15.y, s13 = r16 - this._graphicOriginX - this._offsetX, i14 = _3 - this._graphicOriginY - this._offsetY, g4 ? (h8 = this._cosAngle * s13 - this._sinAngle * i14, n19 = this._sinAngle * s13 + this._cosAngle * i14) : (h8 = s13, n19 = i14), a11 = Math.min(a11, h8), l9 = Math.max(l9, h8), o6 = Math.min(o6, n19), f5 = Math.max(f5, n19), c4 = Math.min(c4, _3), u9 = Math.max(u9, _3), p3 = Math.min(p3, r16), M2 = Math.max(M2, r16);
    c4 = c4 !== Number.MAX_VALUE ? c4 : -e13 - this._stepY, u9 = u9 !== -Number.MAX_VALUE ? u9 : this._stepY, p3 = p3 !== Number.MAX_VALUE ? p3 : -this._stepX, M2 = M2 !== -Number.MAX_VALUE ? M2 : e13 + this._stepX;
    const d2 = u9 - c4, X2 = M2 - p3;
    if (this._verticalSubdivision = d2 >= X2, this._polygonMin = this._verticalSubdivision ? c4 : p3, this._testInsidePolygon) {
      let t16 = 0 - this._graphicOriginX - this._offsetX - this._stepX, s14 = e13 - this._graphicOriginX - this._offsetX + this._stepX, i15 = -e13 - this._graphicOriginY - this._offsetY - this._stepY, h9 = 0 - this._graphicOriginY - this._offsetY + this._stepY;
      if (g4) {
        const e14 = [[t16, i15], [t16, h9], [s14, i15], [s14, h9]];
        t16 = i15 = Number.MAX_VALUE, s14 = h9 = -Number.MAX_VALUE;
        for (const n20 of e14) {
          const e15 = this._cosAngle * n20[0] - this._sinAngle * n20[1], _4 = this._sinAngle * n20[0] + this._cosAngle * n20[1];
          t16 = Math.min(t16, e15), s14 = Math.max(s14, e15), i15 = Math.min(i15, _4), h9 = Math.max(h9, _4);
        }
      }
      a11 = a11 !== Number.MAX_VALUE ? Math.max(a11, t16) : t16, o6 = o6 !== Number.MAX_VALUE ? Math.max(o6, i15) : i15, l9 = l9 !== -Number.MAX_VALUE ? Math.min(l9, s14) : s14, f5 = f5 !== -Number.MAX_VALUE ? Math.min(f5, h9) : h9;
    }
    this._xMin = Math.round(a11 / this._stepX), this._xMax = Math.round(l9 / this._stepX), this._yMin = Math.round(o6 / this._stepY), this._yMax = Math.round(f5 / this._stepY), this._currentX = this._xMax + 1, this._currentY = this._yMin - 1, this._buildAccelerationMap(t15, p3, M2, c4, u9);
  }
  _buildAccelerationMap(t15, s13, i14, n19, _3) {
    t15.reset();
    const r16 = /* @__PURE__ */ new Map(), a11 = this._verticalSubdivision, o6 = a11 ? _3 - n19 : i14 - s13;
    let f5 = Math.ceil(o6 / h7);
    if (f5 <= 1)
      return;
    const c4 = Math.floor(o6 / f5);
    let u9, p3, M2, g4, d2, X2, m7, x3, A5, Y3, y3;
    for (f5++, this._delta = c4, a11 ? (A5 = -e13 - this._stepY, Y3 = this._stepY, y3 = n19) : (A5 = -this._stepX, Y3 = e13 + this._stepX, y3 = s13); t15.nextPath(); )
      if (!(t15.pathSize < 2) && t15.nextPoint())
        for (u9 = t15.x, p3 = t15.y; t15.nextPoint(); u9 = M2, p3 = g4) {
          if (M2 = t15.x, g4 = t15.y, a11) {
            if (p3 === g4 || p3 < A5 && g4 < A5 || p3 > Y3 && g4 > Y3)
              continue;
            d2 = Math.min(p3, g4), X2 = Math.max(p3, g4);
          } else {
            if (u9 === M2 || u9 < A5 && M2 < A5 || u9 > Y3 && M2 > Y3)
              continue;
            d2 = Math.min(u9, M2), X2 = Math.max(u9, M2);
          }
          for (; d2 < X2; )
            m7 = Math.floor((d2 - y3) / c4), l7(m7, u9, p3, M2, g4, r16), d2 += c4;
          x3 = Math.floor((X2 - y3) / c4), x3 > m7 && l7(x3, u9, p3, M2, g4, r16);
        }
    this._accelerationMap = r16;
  }
  _nextInside() {
    for (; ; ) {
      if (this._currentX > this._xMax) {
        if (this._currentY++, this._currentY > this._yMax)
          return null;
        this._currentX = this._xMin, this._shiftOddRows && this._currentY % 2 && this._currentX--;
      }
      let t15 = this._currentX * this._stepX + this._offsetX;
      this._shiftOddRows && this._currentY % 2 && (t15 += 0.5 * this._stepX);
      const s13 = this._currentY * this._stepY + this._offsetY;
      let e14, h8;
      if (this._currentX++, this._gridType === Y.Random) {
        const i14 = (this._currentX % n16 + n16) % n16, _3 = (this._currentY % n16 + n16) % n16;
        e14 = this._graphicOriginX + t15 + this._stepX * this._randomness * (0.5 - _a._randValues[_3 * n16 + i14]) * 2 / 3, h8 = this._graphicOriginY + s13 + this._stepY * this._randomness * (0.5 - _a._randValues[_3 * n16 + i14 + 1]) * 2 / 3;
      } else
        e14 = this._graphicOriginX + this._cosAngle * t15 + this._sinAngle * s13, h8 = this._graphicOriginY - this._sinAngle * t15 + this._cosAngle * s13;
      if (!this._testInsidePolygon || this._isInsidePolygon(e14, h8, this._geometryCursor))
        return this._internalPlacement.setTranslate(e14, h8), this._internalPlacement;
    }
  }
  _isInsidePolygon(t15, s13, i14) {
    if (null == this._accelerationMap)
      return o4(t15, s13, i14);
    t15 += _, s13 += _;
    const e14 = this._verticalSubdivision, h8 = e14 ? s13 : t15, n19 = Math.floor((h8 - this._polygonMin) / this._delta), r16 = this._accelerationMap.get(n19);
    if (!r16)
      return false;
    let a11, l9, f5, c4 = 0;
    for (const _3 of r16) {
      if (a11 = _3[0], l9 = _3[1], e14) {
        if (a11[1] > s13 == l9[1] > s13)
          continue;
        f5 = (l9[0] - a11[0]) * (s13 - a11[1]) - (l9[1] - a11[1]) * (t15 - a11[0]);
      } else {
        if (a11[0] > t15 == l9[0] > t15)
          continue;
        f5 = (l9[1] - a11[1]) * (t15 - a11[0]) - (l9[0] - a11[0]) * (s13 - a11[1]);
      }
      f5 > 0 ? c4++ : c4--;
    }
    return 0 !== c4;
  }
};
function o4(t15, s13, i14) {
  let e14, h8, n19, r16, a11 = 0;
  for (t15 += _, s13 += _, i14.reset(); i14.nextPath(); )
    if (i14.nextPoint())
      for (e14 = i14.x, h8 = i14.y; i14.nextPoint(); e14 = n19, h8 = r16) {
        if (n19 = i14.x, r16 = i14.y, h8 > s13 == r16 > s13)
          continue;
        (n19 - e14) * (s13 - h8) - (r16 - h8) * (t15 - e14) > 0 ? a11++ : a11--;
      }
  return 0 !== a11;
}
function l7(t15, s13, i14, e14, h8, n19) {
  let _3 = n19.get(t15);
  _3 || (_3 = [], n19.set(t15, _3)), _3.push([[s13, i14], [e14, h8]]);
}

// node_modules/@arcgis/core/symbols/cim/placements/PlacementOnLine.js
var i8 = 1e-3;
var s9 = class _s {
  static local() {
    return null === _s.instance && (_s.instance = new _s()), _s.instance;
  }
  execute(e14, t15, n19, i14, s13) {
    return new r13(e14, t15, n19);
  }
};
s9.instance = null;
var r13 = class extends s6 {
  constructor(e14, n19, s13) {
    super(e14), this._curveHelper = new s7(), this._angleToLine = void 0 === n19.angleToLine || n19.angleToLine, this._offset = void 0 !== n19.offset ? n19.offset * s13 : 0, this._relativeTo = n19.relativeTo, this._position = void 0 !== n19.startPointOffset ? n19.startPointOffset * s13 : 0, this._epsilon = i8 * s13;
  }
  processPath(e14) {
    const t15 = this._position;
    if (this._relativeTo === Z.SegmentMidpoint) {
      if (this.iteratePath || (this.iteratePath = true), e14.nextPoint()) {
        let [t16, n19] = [e14.x, e14.y], [i15, s13] = [0, 0];
        for (; e14.nextPoint(); ) {
          i15 = e14.x, s13 = e14.y;
          const r16 = this._curveHelper.getLength(t16, n19, i15, s13);
          if (r16 < this._epsilon) {
            t16 = i15, n19 = s13;
            continue;
          }
          const o6 = 0.5 + this._position / r16, [a11, l9] = this._curveHelper.getAngleCS(t16, n19, i15, s13, o6), h8 = this._curveHelper.getCoord2D(t16, n19, i15, s13, o6);
          return this.internalPlacement.setTranslate(h8[0] - this._offset * l9, h8[1] + this._offset * a11), this._angleToLine && this.internalPlacement.setRotateCS(a11, l9), this.internalPlacement;
        }
      }
      return this.iteratePath = false, null;
    }
    const i14 = this._relativeTo === Z.LineEnd;
    return this.onLine(e14, t15, i14);
  }
  onLine(e14, t15, i14) {
    let s13, r16 = false;
    switch (this._relativeTo) {
      case Z.LineMiddle:
      default:
        e14.seekPathStart(), s13 = e14.pathLength() / 2 + t15;
        break;
      case Z.LineBeginning:
        s13 = t15;
        break;
      case Z.LineEnd:
        s13 = t15, r16 = true;
    }
    i14 ? e14.seekPathEnd() : e14.seekPathStart();
    let o6 = 0;
    if (i14 ? e14.prevPoint() : e14.nextPoint()) {
      let [t16, n19] = [e14.x, e14.y], [a11, l9] = [0, 0];
      for (; i14 ? e14.prevPoint() : e14.nextPoint(); ) {
        a11 = e14.x, l9 = e14.y;
        const i15 = this._curveHelper.getLength(t16, n19, a11, l9);
        if (o6 + i15 > s13) {
          const e15 = (s13 - o6) / i15, [h8, c4] = this._curveHelper.getAngleCS(t16, n19, a11, l9, e15), f5 = this._curveHelper.getCoord2D(t16, n19, a11, l9, e15), u9 = r16 ? -this._offset : this._offset;
          return this.internalPlacement.setTranslate(f5[0] - u9 * c4, f5[1] + u9 * h8), this._angleToLine && (r16 ? this.internalPlacement.setRotateCS(-h8, -c4) : this.internalPlacement.setRotateCS(h8, c4)), this.internalPlacement;
        }
        t16 = a11, n19 = l9, o6 += i15;
      }
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementOnVertices.js
var s10 = 1e-15;
var i9 = class _i {
  static local() {
    return null === _i.instance && (_i.instance = new _i()), _i.instance;
  }
  execute(t15, e14, s13, i14, o6) {
    return new n17(t15, e14, s13);
  }
};
i9.instance = null;
var n17 = class extends s6 {
  constructor(t15, s13, i14) {
    super(t15), this._curveHelper = new s7(), this._angleToLine = void 0 === s13.angleToLine || s13.angleToLine, this._offset = void 0 !== s13.offset ? s13.offset * i14 : 0, this._endPoints = void 0 === s13.placeOnEndPoints || s13.placeOnEndPoints, this._controlPoints = void 0 === s13.placeOnControlPoints || s13.placeOnControlPoints, this._regularVertices = void 0 === s13.placeOnRegularVertices || s13.placeOnRegularVertices, this._tags = [], this._tagIterator = 0;
  }
  processPath(t15) {
    if (this.iteratePath || (this._preparePath(t15), this.iteratePath = true), this._tagIterator >= this._tags.length)
      return this._tags.length = 0, this._tagIterator = 0, this.iteratePath = false, null;
    const e14 = this._tags[this._tagIterator];
    this._angleToLine && this.internalPlacement.setRotate(e14[2]);
    let s13 = e14[0], i14 = e14[1];
    if (0 !== this._offset) {
      const t16 = Math.cos(e14[2]), n19 = Math.sin(e14[2]);
      s13 -= this._offset * n19, i14 += this._offset * t16;
    }
    return this.internalPlacement.setTranslate(s13, i14), this._tagIterator++, this.internalPlacement;
  }
  _preparePath(t15) {
    this._tags.length = 0, this._tagIterator = 0, t15.seekPathStart();
    const e14 = t15.isClosed();
    let s13 = 0, i14 = false, n19 = 0, r16 = 0;
    if (t15.seekPathStart(), t15.nextPoint()) {
      let a11 = t15.x, h8 = t15.y, l9 = t15.getControlPoint(), _3 = true, c4 = t15.nextPoint();
      for (; c4; ) {
        const g4 = t15.x, P4 = t15.y, u9 = t15.getControlPoint();
        (this._angleToLine || 0 !== this._offset) && (n19 = this._curveHelper.getAngle(a11, h8, g4, P4, 0)), _3 ? (_3 = false, e14 ? (s13 = n19, i14 = l9) : (this._endPoints || this._controlPoints && l9) && this._tags.push([a11, h8, n19])) : l9 ? this._controlPoints && this._tags.push([a11, h8, o5(r16, n19)]) : this._regularVertices && this._tags.push([a11, h8, o5(r16, n19)]), (this._angleToLine || 0 !== this._offset) && (r16 = this._curveHelper.getAngle(a11, h8, g4, P4, 1)), c4 = t15.nextPoint(), c4 || (e14 ? u9 || i14 ? this._controlPoints && this._tags.push([g4, P4, o5(r16, s13)]) : this._regularVertices && this._tags.push([g4, P4, o5(r16, s13)]) : (this._endPoints || this._controlPoints && u9) && this._tags.push([g4, P4, r16])), a11 = g4, h8 = P4, l9 = u9;
      }
    }
    this._tagIterator = 0;
  }
};
function o5(t15, e14) {
  const i14 = Math.PI;
  for (; Math.abs(e14 - t15) > i14 + 2 * s10; )
    e14 - t15 > i14 ? e14 -= 2 * i14 : e14 += 2 * i14;
  return (t15 + e14) / 2;
}

// node_modules/@arcgis/core/symbols/cim/placements/PlacementPolygonCenter.js
var r14 = class _r {
  static local() {
    return null === _r.instance && (_r.instance = new _r()), _r.instance;
  }
  execute(t15, e14, s13, n19, o6) {
    return new i10(t15, e14, s13);
  }
};
r14.instance = null;
var i10 = class {
  constructor(t15, e14, s13) {
    this._geometryCursor = t15, this._offsetX = void 0 !== e14.offsetX ? e14.offsetX * s13 : 0, this._offsetY = void 0 !== e14.offsetY ? e14.offsetY * s13 : 0, this._method = void 0 !== e14.method ? e14.method : K.OnPolygon, this._internalPlacement = new t8();
  }
  next() {
    const t15 = this._geometryCursor;
    return this._geometryCursor = null, t15 ? this._polygonCenter(t15) : null;
  }
  _polygonCenter(n19) {
    let r16 = false;
    switch (this._method) {
      case K.CenterOfMass:
        {
          const t15 = f2(n19);
          t15 && (this._internalPlacement.setTranslate(t15[0] + this._offsetX, t15[1] + this._offsetY), r16 = true);
        }
        break;
      case K.BoundingBoxCenter:
        {
          const e14 = c(n19);
          e14 && (this._internalPlacement.setTranslate((e14[2] + e14[0]) / 2 + this._offsetX, (e14[3] + e14[1]) / 2 + this._offsetY), r16 = true);
        }
        break;
      case K.OnPolygon:
      default: {
        const t15 = l4(n19);
        null !== t15 && (this._internalPlacement.setTranslate(t15[0] + this._offsetX, t15[1] + this._offsetY), r16 = true);
      }
    }
    return r16 ? this._internalPlacement : null;
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMOperators.js
function A3(p3) {
  if (!p3)
    return null;
  switch (p3.type) {
    case "CIMGeometricEffectAddControlPoints":
      return e6.local();
    case "CIMGeometricEffectArrow":
      return p.local();
    case "CIMGeometricEffectBuffer":
      return m5.local();
    case "CIMGeometricEffectControlMeasureLine":
      return e7.local();
    case "CIMGeometricEffectCut":
      return r5.local();
    case "CIMGeometricEffectDashes":
      return n10.local();
    case "CIMGeometricEffectDonut":
      return s8.local();
    case "CIMGeometricEffectJog":
      return e8.local();
    case "CIMGeometricEffectMove":
      return t11.local();
    case "CIMGeometricEffectOffset":
      return m6.local();
    case "CIMGeometricEffectReverse":
      return e10.local();
    case "CIMGeometricEffectRotate":
      return e11.local();
    case "CIMGeometricEffectScale":
      return e12.local();
    case "CIMGeometricEffectWave":
      return n14.local();
  }
  return null;
}
function g2(e14) {
  if (!e14)
    return null;
  switch (e14.type) {
    case "CIMMarkerPlacementAlongLineSameSize":
      return a8.local();
    case "CIMMarkerPlacementAtExtremities":
      return i7.local();
    case "CIMMarkerPlacementAtRatioPositions":
      return a9.local();
    case "CIMMarkerPlacementInsidePolygon":
      return r12.local();
    case "CIMMarkerPlacementOnLine":
      return s9.local();
    case "CIMMarkerPlacementOnVertices":
      return i9.local();
    case "CIMMarkerPlacementPolygonCenter":
      return r14.local();
  }
  return null;
}

// node_modules/@arcgis/core/symbols/cim/imageUtils.js
function t13(t15) {
  const e14 = t15.getFrame(0);
  if (e14 instanceof HTMLImageElement || e14 instanceof HTMLCanvasElement)
    return e14;
  const n19 = document.createElement("canvas");
  n19.width = t15.width, n19.height = t15.height;
  const a11 = n19.getContext("2d");
  return e14 instanceof ImageData ? a11.putImageData(e14, 0, 0) : a11.drawImage(e14, 0, 0), n19;
}

// node_modules/@arcgis/core/symbols/cim/Rect.js
var t14 = class {
  constructor(t15 = 0, h8 = 0, i14 = 0, s13 = 0) {
    this.x = t15, this.y = h8, this.width = i14, this.height = s13;
  }
  get isEmpty() {
    return this.width <= 0 || this.height <= 0;
  }
  union(t15) {
    this.x = Math.min(this.x, t15.x), this.y = Math.min(this.y, t15.y), this.width = Math.max(this.width, t15.width), this.height = Math.max(this.height, t15.height);
  }
};

// node_modules/@arcgis/core/symbols/cim/TextRasterizer.js
function i11(t15) {
  return `rgb(${t15.slice(0, 3).toString()})`;
}
function s11(t15) {
  return `rgba(${t15.slice(0, 3).toString()},${t15[3]})`;
}
var r15 = class {
  constructor(t15) {
    t15 && (this._textRasterizationCanvas = t15);
  }
  rasterizeText(r16, o6) {
    var _a, _b;
    this._textRasterizationCanvas || (this._textRasterizationCanvas = document.createElement("canvas"));
    const h8 = this._textRasterizationCanvas, a11 = h8.getContext("2d");
    this._setFontProperties(a11, o6), this._parameters = o6, this._textLines = r16.split(/\r?\n/), this._lineHeight = this._computeLineHeight();
    const { decoration: l9, weight: d2 } = o6.font;
    this._lineThroughWidthOffset = l9 && "line-through" === l9 ? 0.1 * this._lineHeight : 0;
    const c4 = null != o6.backgroundColor || null != o6.borderLine, _3 = c4 ? s4 : 0, g4 = this._computeTextWidth(a11, o6) + 2 * _3, f5 = this._lineHeight * this._textLines.length + 2 * _3;
    if (h8.width = g4 + 2 * this._lineThroughWidthOffset, h8.height = f5, 0 === h8.width || 0 === h8.height)
      return h8.width = h8.height = 1, { size: [0, 0], image: new Uint32Array(0), sdf: false, simplePattern: false, anchorX: 0, anchorY: 0, canvas: h8 };
    this._renderedLineHeight = Math.round(this._lineHeight * o6.pixelRatio), this._renderedHaloSize = u3(o6.halo.size) * o6.pixelRatio, this._renderedWidth = g4 * o6.pixelRatio, this._renderedHeight = f5 * o6.pixelRatio, this._lineThroughWidthOffset *= o6.pixelRatio;
    const u9 = o6.color ?? [0, 0, 0, 0], p3 = o6.halo && o6.halo.color ? o6.halo.color : [0, 0, 0, 0];
    this._fillStyle = s11(u9), this._haloStyle = i11(p3);
    const x3 = this._renderedLineHeight, m7 = this._renderedHaloSize;
    a11.save(), a11.clearRect(0, 0, h8.width, h8.height), this._setFontProperties(a11, o6);
    const b4 = _3 * o6.pixelRatio, w6 = n18(a11.textAlign, this._renderedWidth - 2 * b4) + m7 + b4, z2 = m7 + b4, v3 = m7 > 0;
    let y3 = this._lineThroughWidthOffset, R3 = 0;
    if (c4) {
      a11.save();
      const e14 = o6.backgroundColor ?? [0, 0, 0, 0], i14 = ((_a = o6.borderLine) == null ? void 0 : _a.color) ?? [0, 0, 0, 0], r17 = 2 * u3(((_b = o6.borderLine) == null ? void 0 : _b.size) ?? 0);
      a11.fillStyle = s11(e14), a11.strokeStyle = s11(i14), a11.lineWidth = r17, a11.fillRect(0, 0, h8.width, h8.height), a11.strokeRect(0, 0, h8.width, h8.height), a11.restore();
    }
    v3 && this._renderHalo(a11, w6, z2, y3, R3, o6), R3 += z2, y3 += w6;
    for (const t15 of this._textLines)
      v3 ? (a11.globalCompositeOperation = "destination-out", a11.fillStyle = "rgb(0, 0, 0)", a11.fillText(t15, y3, R3), a11.globalCompositeOperation = "source-over", a11.fillStyle = this._fillStyle, a11.fillText(t15, y3, R3)) : (a11.fillStyle = this._fillStyle, a11.fillText(t15, y3, R3)), l9 && "none" !== l9 && this._renderDecoration(a11, y3, R3, l9, d2), R3 += x3;
    a11.restore();
    const H = this._renderedWidth + 2 * this._lineThroughWidthOffset, S3 = this._renderedHeight, C3 = a11.getImageData(0, 0, H, S3), T2 = new Uint8Array(C3.data);
    if (o6.premultiplyColors) {
      let t15;
      for (let e14 = 0; e14 < T2.length; e14 += 4)
        t15 = T2[e14 + 3] / 255, T2[e14] = T2[e14] * t15, T2[e14 + 1] = T2[e14 + 1] * t15, T2[e14 + 2] = T2[e14 + 2] * t15;
    }
    let W3, k5;
    switch (o6.horizontalAlignment) {
      case "left":
        W3 = -0.5;
        break;
      case "right":
        W3 = 0.5;
        break;
      default:
        W3 = 0;
    }
    switch (o6.verticalAlignment) {
      case "bottom":
        k5 = -0.5;
        break;
      case "top":
        k5 = 0.5;
        break;
      default:
        k5 = 0;
    }
    return { size: [H, S3], image: new Uint32Array(T2.buffer), sdf: false, simplePattern: false, anchorX: W3, anchorY: k5, canvas: h8 };
  }
  _renderHalo(t15, e14, i14, s13, r16, n19) {
    const o6 = this._renderedWidth, h8 = this._renderedHeight;
    this._haloRasterizationCanvas || (this._haloRasterizationCanvas = document.createElement("canvas")), this._haloRasterizationCanvas.width = o6, this._haloRasterizationCanvas.height = h8;
    const a11 = this._haloRasterizationCanvas, l9 = a11.getContext("2d");
    l9.clearRect(0, 0, o6, h8), this._setFontProperties(l9, n19);
    const { decoration: d2, weight: c4 } = n19.font;
    l9.fillStyle = this._haloStyle, l9.strokeStyle = this._haloStyle, l9.lineJoin = "round", this._renderHaloNative(l9, e14, i14, d2, c4), t15.globalAlpha = this._parameters.halo.color[3], t15.drawImage(a11, 0, 0, o6, h8, s13, r16, o6, h8), t15.globalAlpha = 1;
  }
  _renderHaloNative(t15, e14, i14, s13, r16) {
    const n19 = this._renderedLineHeight, o6 = this._renderedHaloSize;
    for (const h8 of this._textLines) {
      const a11 = 2 * o6, l9 = 5, d2 = 0.1;
      for (let n20 = 0; n20 < l9; n20++) {
        const o7 = (1 - (l9 - 1) * d2 + n20 * d2) * a11;
        t15.lineWidth = o7, t15.strokeText(h8, e14, i14), s13 && "none" !== s13 && this._renderDecoration(t15, e14, i14, s13, r16, o7);
      }
      i14 += n19;
    }
  }
  _setFontProperties(e14, i14) {
    const s13 = Math.max(i14.size, 0.5), r16 = i14.font, n19 = `${r16.style} ${r16.weight} ${u3(s13 * i14.pixelRatio).toFixed(1)}px ${r16.family}, sans-serif`;
    let o6;
    switch (e14.font = n19, e14.textBaseline = "top", i14.horizontalAlignment) {
      case "left":
      default:
        o6 = "left";
        break;
      case "right":
        o6 = "right";
        break;
      case "center":
        o6 = "center";
    }
    e14.textAlign = o6;
  }
  computeTextSize(t15, e14) {
    this._textRasterizationCanvas || (this._textRasterizationCanvas = document.createElement("canvas"));
    const i14 = this._textRasterizationCanvas, s13 = i14.getContext("2d");
    this._setFontProperties(s13, e14), this._parameters = e14, this._textLines = t15.split(/\r?\n/), this._lineHeight = this._computeLineHeight();
    const r16 = this._computeTextWidth(s13, e14), n19 = this._lineHeight * this._textLines.length;
    return i14.width = r16, i14.height = n19, [r16 * e14.pixelRatio, n19 * e14.pixelRatio];
  }
  _computeTextWidth(e14, i14) {
    let s13 = 0;
    for (const t15 of this._textLines)
      s13 = Math.max(s13, e14.measureText(t15).width);
    const r16 = i14.font;
    return ("italic" === r16.style || "oblique" === r16.style || "string" == typeof r16.weight && ("bold" === r16.weight || "bolder" === r16.weight) || "number" == typeof r16.weight && r16.weight > 600) && (s13 += 0.3 * e14.measureText("w").width), s13 += 2 * u3(this._parameters.halo.size), Math.round(s13);
  }
  _computeLineHeight() {
    let e14 = 1.275 * this._parameters.size;
    const i14 = this._parameters.font.decoration;
    return i14 && "underline" === i14 && (e14 *= 1.3), Math.round(e14 + 2 * u3(this._parameters.halo.size));
  }
  _renderDecoration(t15, e14, i14, s13, r16, n19) {
    const o6 = 0.9 * this._lineHeight, h8 = "bold" === r16 ? 0.06 : "bolder" === r16 ? 0.09 : 0.04;
    switch (t15.textAlign) {
      case "center":
        e14 -= this._renderedWidth / 2;
        break;
      case "right":
        e14 -= this._renderedWidth;
    }
    const a11 = t15.textBaseline;
    if ("underline" === s13)
      switch (a11) {
        case "top":
          i14 += o6;
          break;
        case "middle":
          i14 += o6 / 2;
      }
    else if ("line-through" === s13)
      switch (a11) {
        case "top":
          i14 += o6 / 1.5;
          break;
        case "middle":
          i14 += o6 / 3;
      }
    const l9 = n19 ? 1.5 * n19 : Math.ceil(o6 * h8);
    t15.save(), t15.beginPath(), t15.strokeStyle = t15.fillStyle, t15.lineWidth = l9, t15.moveTo(e14 - this._lineThroughWidthOffset, i14), t15.lineTo(e14 + this._renderedWidth + 2 * this._lineThroughWidthOffset, i14), t15.stroke(), t15.restore();
  }
};
function n18(t15, e14) {
  return "center" === t15 ? 0.5 * e14 : "right" === t15 ? e14 : 0;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/collisions/BoundingBox.js
var i12 = class _i {
  constructor(i14, e14, s13, r16) {
    this.center = t5(i14, e14), this.centerT = n3(), this.halfWidth = s13 / 2, this.halfHeight = r16 / 2, this.width = s13, this.height = r16;
  }
  get x() {
    return this.center[0];
  }
  get y() {
    return this.center[1];
  }
  get blX() {
    return this.center[0] + this.halfWidth;
  }
  get blY() {
    return this.center[1] + this.halfHeight;
  }
  get trX() {
    return this.center[0] - this.halfWidth;
  }
  get trY() {
    return this.center[1] - this.halfHeight;
  }
  get xmin() {
    return this.x - this.halfWidth;
  }
  get xmax() {
    return this.x + this.halfWidth;
  }
  get ymin() {
    return this.y - this.halfHeight;
  }
  get ymax() {
    return this.y + this.halfHeight;
  }
  set x(t15) {
    this.center[0] = t15;
  }
  set y(t15) {
    this.center[1] = t15;
  }
  clone() {
    return new _i(this.x, this.y, this.width, this.height);
  }
  serialize(t15) {
    return t15.writeF32(this.center[0]), t15.writeF32(this.center[1]), t15.push(this.width), t15.push(this.height), t15;
  }
  findCollisionDelta(t15, h8 = 4) {
    const i14 = Math.abs(t15.centerT[0] - this.centerT[0]), e14 = Math.abs(t15.centerT[1] - this.centerT[1]), s13 = (t15.halfWidth + this.halfWidth + h8) / i14, r16 = (t15.halfHeight + this.halfHeight + h8) / e14, n19 = Math.min(s13, r16);
    return Math.log2(n19);
  }
  extend(t15) {
    const h8 = Math.min(this.xmin, t15.xmin), i14 = Math.min(this.ymin, t15.ymin), e14 = Math.max(this.xmax, t15.xmax) - h8, s13 = Math.max(this.ymax, t15.ymax) - i14, r16 = h8 + e14 / 2, n19 = i14 + s13 / 2;
    this.width = e14, this.height = s13, this.halfWidth = e14 / 2, this.halfHeight = s13 / 2, this.x = r16, this.y = n19;
  }
  static deserialize(t15) {
    const h8 = t15.readF32(), e14 = t15.readF32(), s13 = t15.readInt32(), r16 = t15.readInt32();
    return new _i(h8, e14, s13, r16);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/shapingUtils.js
var l8 = 26;
var g3 = 4;
var _2 = l8 + g3;
var p2 = l8 - 6;
var x2 = 3;
var w5 = 8;
var y2 = Math.PI / 180;
var M = 8;
var b3 = 1.5;
var B2 = class {
  constructor(t15, s13, e14, i14) {
    this._rotationT = n2(), this._xBounds = 0, this._yBounds = 0, this.minZoom = 0, this.maxZoom = 255, this._bounds = null;
    const n19 = e14.rect, h8 = new Float32Array(8);
    t15 *= i14, s13 *= i14;
    const r16 = e14.code ? n19.width * i14 : e14.metrics.width, a11 = e14.code ? n19.height * i14 : e14.metrics.height;
    this.width = r16, this.height = a11, h8[0] = t15, h8[1] = s13, h8[2] = t15 + r16, h8[3] = s13, h8[4] = t15, h8[5] = s13 + a11, h8[6] = t15 + r16, h8[7] = s13 + a11, this._data = h8, this._setTextureCoords(n19), this._scale = i14, this._mosaic = e14, this.x = t15, this.y = s13, this.maxOffset = Math.max(t15 + r16, s13 + a11);
  }
  get mosaic() {
    return this._mosaic;
  }
  set angle(t15) {
    this._angle = t15, h(this._rotationT, -t15), this._setOffsets(this._data);
  }
  get angle() {
    return this._angle;
  }
  get xTopLeft() {
    return this._data[0];
  }
  get yTopLeft() {
    return this._data[1];
  }
  get xBottomRight() {
    return this._data[6];
  }
  get yBottomRight() {
    return this._data[7];
  }
  get texcoords() {
    return this._texcoords;
  }
  get textureBinding() {
    return this._mosaic.textureBinding;
  }
  get offsets() {
    return this._offsets || this._setOffsets(this._data), this._offsets;
  }
  get char() {
    return String.fromCharCode(this._mosaic.code);
  }
  get code() {
    return this._mosaic.code;
  }
  get bounds() {
    if (!this._bounds) {
      const { height: t15, width: s13 } = this._mosaic.metrics, i14 = s13 * this._scale, n19 = Math.abs(t15) * this._scale, r16 = new Float32Array(8);
      r16[0] = this.x, r16[1] = this.y, r16[2] = this.x + i14, r16[3] = this.y, r16[4] = this.x, r16[5] = this.y + n19, r16[6] = this.x + i14, r16[7] = this.y + n19;
      const a11 = o2(n2(), this._rotationT, this._transform);
      a5(r16, r16, a11);
      let c4 = 1 / 0, d2 = 1 / 0, f5 = 0, m7 = 0;
      for (let e14 = 0; e14 < 4; e14++) {
        const t16 = r16[2 * e14], s14 = r16[2 * e14 + 1];
        c4 = Math.min(c4, t16), d2 = Math.min(d2, s14), f5 = Math.max(f5, t16), m7 = Math.max(m7, s14);
      }
      const l9 = f5 - c4, g4 = m7 - d2, _3 = c4 + l9 / 2, p3 = d2 + g4 / 2;
      this._bounds = new i12(_3, p3, l9, g4);
    }
    return this._bounds;
  }
  setTransform(t15) {
    this._transform = t15, this._offsets = null;
  }
  _setOffsets(t15) {
    this._offsets || (this._offsets = { upperLeft: 0, upperRight: 0, lowerLeft: 0, lowerRight: 0 });
    const s13 = this._offsets, i14 = new Float32Array(8), n19 = o2(n2(), this._rotationT, this._transform);
    a5(i14, t15, n19), s13.upperLeft = w3(i14[0] * w5, i14[1] * w5), s13.upperRight = w3(i14[2] * w5, i14[3] * w5), s13.lowerLeft = w3(i14[4] * w5, i14[5] * w5), s13.lowerRight = w3(i14[6] * w5, i14[7] * w5);
  }
  _setTextureCoords({ x: t15, y: s13, width: e14, height: i14 }) {
    this._texcoords = { upperLeft: w3(t15, s13), upperRight: w3(t15 + e14, s13), lowerLeft: w3(t15, s13 + i14), lowerRight: w3(t15 + e14, s13 + i14) };
  }
};
var L2 = (t15, s13) => ({ code: 0, page: 0, sdf: true, rect: new t6(0, 0, 11, 8), textureBinding: s13, metrics: { advance: 0, height: 4, width: t15, left: 0, top: 0 } });
function R2(t15, s13) {
  return t15.forEach((t16) => z(t16, t16, s13)), { upperLeft: w3(w5 * t15[0][0], w5 * t15[0][1]), upperRight: w3(w5 * t15[1][0], w5 * t15[1][1]), lowerLeft: w3(w5 * t15[2][0], w5 * t15[2][1]), lowerRight: w3(w5 * t15[3][0], w5 * t15[3][1]) };
}
var T = class {
  constructor(t15, s13, e14) {
    this._rotation = 0, this._decorate(t15, s13, e14), this.glyphs = t15, this.bounds = this._createBounds(t15), this.isMultiline = s13.length > 1, this._hasRotation = 0 !== e14.angle, this._transform = this._createGlyphTransform(this.bounds, e14), this._borderLineSize = e14.borderLineSize, (e14.borderLineSize || e14.hasBackground) && ([this.bounds, this.background] = this.shapeBackground(this._transform));
    for (const i14 of t15)
      i14.setTransform(this._transform);
  }
  setRotation(t15) {
    if (0 === t15 && 0 === this._rotation)
      return;
    this._rotation = t15;
    const i14 = this._transform, n19 = h(n2(), t15);
    o2(i14, n19, i14);
    for (const s13 of this.glyphs)
      s13.setTransform(this._transform);
  }
  _decorate(t15, s13, e14) {
    if (!e14.decoration || "none" === e14.decoration || !t15.length)
      return;
    const i14 = e14.scale, n19 = "underline" === e14.decoration ? _2 : p2, o6 = t15[0].textureBinding;
    for (const h8 of s13) {
      const s14 = h8.startX * i14, e15 = h8.startY * i14, r16 = (h8.width + h8.glyphWidthEnd) * i14;
      t15.push(new B2(s14, e15 + n19 * i14, L2(r16, o6), 1));
    }
  }
  shapeBackground(s13) {
    const e14 = M, { xmin: i14, ymin: n19, xmax: o6, ymax: h8, x: r16, y: a11, width: c4, height: d2 } = this.bounds, f5 = Math.min(c4, d2) + 2 * e14 - b3, m7 = Math.min(u3(this._borderLineSize || 0), f5), l9 = (b3 + m7) / 2, g4 = this._borderLineSize ? l9 : 0, _3 = [i14 - e14, n19 - e14], p3 = [o6 + e14, n19 - e14], x3 = [i14 - e14, h8 + e14], w6 = [o6 + e14, h8 + e14], y3 = R2([[_3[0] - l9, _3[1] - l9], [p3[0] + l9, p3[1] - l9], [_3[0] + g4, _3[1] + g4], [p3[0] - g4, p3[1] + g4]], s13), B3 = R2([[x3[0] + g4, x3[1] - g4], [w6[0] - g4, w6[1] - g4], [x3[0] - l9, x3[1] + l9], [w6[0] + l9, w6[1] + l9]], s13), L3 = R2([[_3[0] - l9, _3[1] - l9], [_3[0] + g4, _3[1] + g4], [x3[0] - l9, x3[1] + l9], [x3[0] + g4, x3[1] - g4]], s13), T2 = R2([[p3[0] - g4, p3[1] + g4], [p3[0] + l9, p3[1] - l9], [w6[0] - g4, w6[1] - g4], [w6[0] + l9, w6[1] + l9]], s13), v3 = { main: R2([_3, p3, x3, w6], s13), top: y3, bot: B3, left: L3, right: T2 };
    return [new i12(r16, a11, c4 + 2 * l9, d2 + 2 * l9), v3];
  }
  get boundsT() {
    const t15 = this.bounds, s13 = r(n3(), t15.x, t15.y);
    if (z(s13, s13, this._transform), this._hasRotation) {
      const e14 = Math.max(t15.width, t15.height);
      return new i12(s13[0], s13[1], e14, e14);
    }
    return new i12(s13[0], s13[1], t15.width, t15.height);
  }
  _createBounds(t15) {
    let s13 = 1 / 0, e14 = 1 / 0, i14 = 0, n19 = 0;
    for (const r16 of t15)
      s13 = Math.min(s13, r16.xTopLeft), e14 = Math.min(e14, r16.yTopLeft), i14 = Math.max(i14, r16.xBottomRight), n19 = Math.max(n19, r16.yBottomRight);
    const o6 = i14 - s13, h8 = n19 - e14;
    return new i12(s13 + o6 / 2, e14 + h8 / 2, o6, h8);
  }
  _createGlyphTransform(t15, s13) {
    const e14 = y2 * s13.angle, h8 = n2(), a11 = n3();
    return i(h8, h8, r(a11, s13.xOffset, -s13.yOffset)), s13.isCIM ? e3(h8, h8, e14) : (i(h8, h8, r(a11, t15.x, t15.y)), e3(h8, h8, e14), i(h8, h8, r(a11, -t15.x, -t15.y))), h8;
  }
};
var v2 = class {
  constructor(t15, s13, e14, i14, n19, o6) {
    this.glyphWidthEnd = 0, this.startX = 0, this.startY = 0, this.start = Math.max(0, Math.min(s13, e14)), this.end = Math.max(0, Math.max(s13, e14)), this.end < t15.length && (this.glyphWidthEnd = t15[this.end].metrics.width), this.width = i14, this.yMin = n19, this.yMax = o6;
  }
};
var j = (t15) => 10 === t15;
var k4 = (t15) => 32 === t15;
function A4(t15, s13, e14) {
  const i14 = new Array(), n19 = 1 / e14.scale, o6 = e14.maxLineWidth * n19, h8 = s13 ? t15.length - 1 : 0, r16 = s13 ? -1 : t15.length, a11 = s13 ? -1 : 1;
  let c4 = h8, d2 = 0, f5 = 0, m7 = c4, u9 = m7, l9 = 0, g4 = 1 / 0, _3 = 0;
  for (; c4 !== r16; ) {
    const { code: s14, metrics: e15 } = t15[c4], n20 = Math.abs(e15.top);
    if (j(s14) || k4(s14) || (g4 = Math.min(g4, n20), _3 = Math.max(_3, n20 + e15.height)), j(s14))
      c4 !== h8 && (i14.push(new v2(t15, m7, c4 - a11, d2, g4, _3)), g4 = 1 / 0, _3 = 0), d2 = 0, m7 = c4 + a11, u9 = c4 + a11, f5 = 0;
    else if (k4(s14))
      u9 = c4 + a11, f5 = 0, l9 = e15.advance, d2 += e15.advance;
    else if (d2 > o6) {
      if (u9 !== m7) {
        const s15 = u9 - 2 * a11;
        d2 -= l9, i14.push(new v2(t15, m7, s15, d2 - f5, g4, _3)), g4 = 1 / 0, _3 = 0, m7 = u9, d2 = f5;
      } else
        i14.push(new v2(t15, m7, c4 - a11, d2, g4, _3)), g4 = 1 / 0, _3 = 0, m7 = c4, u9 = c4, d2 = 0;
      d2 += e15.advance, f5 += e15.advance;
    } else
      d2 += e15.advance, f5 += e15.advance;
    c4 += a11;
  }
  const p3 = new v2(t15, m7, c4 - a11, d2, g4, _3);
  return p3.start >= 0 && p3.end < t15.length && i14.push(p3), i14;
}
function O2(t15, s13) {
  let e14 = 0;
  for (let o6 = 0; o6 < t15.length; o6++) {
    const { width: s14 } = t15[o6];
    e14 = Math.max(s14, e14);
  }
  const i14 = "underline" === s13.decoration ? g3 : 0, n19 = t15[0].yMin;
  return { x: 0, y: n19, height: t15[t15.length - 1].yMax + s13.lineHeight * (t15.length - 1) + i14 - n19, width: e14 };
}
function S2(t15, s13, e14) {
  const i14 = e14.scale, n19 = new Array(), o6 = A4(t15, s13, e14), h8 = O2(o6, e14), { vAlign: r16, hAlign: a11 } = e14, c4 = r16 === t3.Baseline ? 1 : 0, f5 = c4 ? 0 : r16 - 1, m7 = (1 - c4) * -h8.y + f5 * (h8.height / 2) + (c4 ? 1 : 0) * -l8;
  for (let d2 = 0; d2 < o6.length; d2++) {
    const { start: s14, end: h9, width: r17 } = o6[d2];
    let c5 = -1 * (a11 + 1) * (r17 / 2) - x2;
    const f6 = d2 * e14.lineHeight + m7 - x2;
    o6[d2].startX = c5, o6[d2].startY = f6;
    for (let e15 = s14; e15 <= h9; e15++) {
      const s15 = t15[e15];
      if (j(s15.code))
        continue;
      const o7 = new B2(c5 + s15.metrics.left, f6 - s15.metrics.top, s15, i14);
      c5 += s15.metrics.advance, n19.push(o7);
    }
  }
  return new T(n19, o6, e14);
}

// node_modules/@arcgis/core/symbols/cim/CIMSymbolDrawHelper.js
var J = Math.PI / 180;
var N = s.getLogger("esri.symbols.cim.CIMSymbolDrawHelper");
var O3 = 4;
var q2 = 10;
var V = 10;
var Y2 = 4;
var W = 10;
var Q = class _Q {
  constructor(t15) {
    this._t = t15;
  }
  static createIdentity() {
    return new _Q([1, 0, 0, 0, 1, 0]);
  }
  clone() {
    const t15 = this._t;
    return new _Q(t15.slice());
  }
  transform(t15) {
    const e14 = this._t;
    return [e14[0] * t15[0] + e14[1] * t15[1] + e14[2], e14[3] * t15[0] + e14[4] * t15[1] + e14[5]];
  }
  static createScale(t15, e14) {
    return new _Q([t15, 0, 0, 0, e14, 0]);
  }
  scale(t15, e14) {
    const r16 = this._t;
    return r16[0] *= t15, r16[1] *= t15, r16[2] *= t15, r16[3] *= e14, r16[4] *= e14, r16[5] *= e14, this;
  }
  scaleRatio() {
    return Math.sqrt(this._t[0] * this._t[0] + this._t[1] * this._t[1]);
  }
  static createTranslate(t15, e14) {
    return new _Q([0, 0, t15, 0, 0, e14]);
  }
  translate(t15, e14) {
    const r16 = this._t;
    return r16[2] += t15, r16[5] += e14, this;
  }
  static createRotate(t15) {
    const e14 = Math.cos(t15), r16 = Math.sin(t15);
    return new _Q([e14, -r16, 0, r16, e14, 0]);
  }
  rotate(t15) {
    return _Q.multiply(this, _Q.createRotate(t15), this);
  }
  angle() {
    const t15 = this._t[0], e14 = this._t[3], r16 = Math.sqrt(t15 * t15 + e14 * e14);
    return [t15 / r16, e14 / r16];
  }
  static multiply(t15, e14, r16) {
    const i14 = t15._t, s13 = e14._t, o6 = i14[0] * s13[0] + i14[3] * s13[1], n19 = i14[1] * s13[0] + i14[4] * s13[1], a11 = i14[2] * s13[0] + i14[5] * s13[1] + s13[2], l9 = i14[0] * s13[3] + i14[3] * s13[4], h8 = i14[1] * s13[3] + i14[4] * s13[4], c4 = i14[2] * s13[3] + i14[5] * s13[4] + s13[5], m7 = r16._t;
    return m7[0] = o6, m7[1] = n19, m7[2] = a11, m7[3] = l9, m7[4] = h8, m7[5] = c4, r16;
  }
  invert() {
    const t15 = this._t;
    let e14 = t15[0] * t15[4] - t15[1] * t15[3];
    if (0 === e14)
      return new _Q([0, 0, 0, 0, 0, 0]);
    e14 = 1 / e14;
    const r16 = (t15[1] * t15[5] - t15[2] * t15[4]) * e14, i14 = (t15[2] * t15[3] - t15[0] * t15[5]) * e14, s13 = t15[4] * e14, o6 = -t15[1] * e14, n19 = -t15[3] * e14, a11 = t15[0] * e14;
    return new _Q([s13, o6, r16, n19, a11, i14]);
  }
};
var Z2 = class {
  constructor(t15, e14) {
    this._resourceManager = t15, this._transfos = [], this._sizeTransfos = [], this._geomUnitsPerPoint = 1, this._placementPool = new e(t8, void 0, void 0, 100), this._earlyReturn = false, this._mapRotation = 0, this._transfos.push(e14 || Q.createIdentity()), this._sizeTransfos.push(e14 ? e14.scaleRatio() : 1);
  }
  setTransform(t15, e14) {
    this._transfos = [t15 || Q.createIdentity()], this._sizeTransfos = [e14 || (t15 ? t15.scaleRatio() : 1)];
  }
  setGeomUnitsPerPoint(t15) {
    this._geomUnitsPerPoint = t15;
  }
  transformPt(t15) {
    return this._transfos[this._transfos.length - 1].transform(t15);
  }
  transformSize(t15) {
    return t15 * this._sizeTransfos[this._sizeTransfos.length - 1];
  }
  reverseTransformPt(t15) {
    return this._transfos[this._transfos.length - 1].invert().transform(t15);
  }
  reverseTransformSize(t15) {
    return t15 / this._sizeTransfos[this._sizeTransfos.length - 1];
  }
  getTransformAngle() {
    return this._transfos[this._transfos.length - 1].angle();
  }
  geomUnitsPerPoint() {
    return this.isEmbedded() ? 1 : this._geomUnitsPerPoint;
  }
  isEmbedded() {
    return this._transfos.length > 1;
  }
  back() {
    return this._transfos[this._transfos.length - 1];
  }
  push(t15, e14) {
    const r16 = e14 ? t15.scaleRatio() : 1;
    Q.multiply(t15, this.back(), t15), this._transfos.push(t15), this._sizeTransfos.push(this._sizeTransfos[this._sizeTransfos.length - 1] * r16);
  }
  pop() {
    this._transfos.splice(-1, 1), this._sizeTransfos.splice(-1, 1);
  }
  drawSymbol(t15, e14, r16) {
    if (t15)
      switch (t15.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol":
          this.drawMultiLayerSymbol(t15, e14);
          break;
        case "CIMTextSymbol":
          this.drawTextSymbol(t15, e14, r16);
      }
  }
  drawMultiLayerSymbol(t15, e14) {
    if (!t15 || !e14)
      return;
    const r16 = t15.symbolLayers;
    if (!r16)
      return;
    const i14 = t15.effects;
    if (i14 && i14.length > 0) {
      const t16 = this.executeEffects(i14, e14);
      if (t16) {
        let e15 = t16.next();
        for (; e15; )
          this.drawSymbolLayers(r16, e15.asJSON()), e15 = t16.next();
      }
    } else
      this.drawSymbolLayers(r16, e14);
  }
  executeEffects(t15, e14) {
    const r16 = this._resourceManager.geometryEngine;
    let i14 = new s5(a6.fromJSONCIM(e14));
    for (const s13 of t15) {
      const t16 = A3(s13);
      t16 && (i14 = t16.execute(i14, s13, this.geomUnitsPerPoint(), null, r16));
    }
    return i14;
  }
  drawSymbolLayers(t15, e14) {
    let r16 = t15.length;
    for (; r16--; ) {
      const i14 = t15[r16];
      if (!i14 || false === i14.enable)
        continue;
      const s13 = i14.effects;
      if (s13 && s13.length > 0) {
        const t16 = this.executeEffects(s13, e14);
        if (t16) {
          let e15 = null;
          for (; (e15 = t16.next()) && (this.drawSymbolLayer(i14, e15.asJSON()), !this._earlyReturn); )
            ;
        }
      } else
        this.drawSymbolLayer(i14, e14);
      if (this._earlyReturn)
        return;
    }
  }
  drawSymbolLayer(t15, e14) {
    switch (t15.type) {
      case "CIMSolidFill":
        this.drawSolidFill(e14, t15.color);
        break;
      case "CIMHatchFill":
        this.drawHatchFill(e14, t15);
        break;
      case "CIMPictureFill":
        this.drawPictureFill(e14, t15);
        break;
      case "CIMGradientFill":
        this.drawGradientFill(e14, t15);
        break;
      case "CIMSolidStroke":
        this.drawSolidStroke(e14, t15.color, t15.width, t15.capStyle, t15.joinStyle, t15.miterLimit);
        break;
      case "CIMPictureStroke":
        this.drawPictureStroke(e14, t15);
        break;
      case "CIMGradientStroke":
        this.drawGradientStroke(e14, t15);
        break;
      case "CIMCharacterMarker":
      case "CIMPictureMarker":
      case "CIMVectorMarker":
        this.drawMarkerLayer(t15, e14);
    }
  }
  drawHatchFill(t15, e14) {
    const r16 = this._buildHatchPolyline(e14, t15, this.geomUnitsPerPoint());
    r16 && (this.pushClipPath(t15), this.drawMultiLayerSymbol(e14.lineSymbol, r16), this.popClipPath());
  }
  drawPictureFill(t15, e14) {
  }
  drawGradientFill(t15, e14) {
  }
  drawPictureStroke(t15, e14) {
  }
  drawGradientStroke(t15, e14) {
  }
  drawMarkerLayer(t15, e14) {
    const r16 = t15.markerPlacement;
    if (r16) {
      const i14 = g2(r16);
      if (i14) {
        const s13 = "CIMMarkerPlacementInsidePolygon" === r16.type || "CIMMarkerPlacementPolygonCenter" === r16.type && r16.clipAtBoundary;
        s13 && this.pushClipPath(e14);
        const o6 = i14.execute(a6.fromJSONCIM(e14), r16, this.geomUnitsPerPoint(), null, this._resourceManager.geometryEngine);
        if (o6) {
          let e15 = null;
          for (; (e15 = o6.next()) && (this.drawMarker(t15, e15), !this._earlyReturn); )
            ;
        }
        s13 && this.popClipPath();
      }
    } else {
      const r17 = this._placementPool.acquire();
      if (l2(e14))
        r17.tx = e14.x, r17.ty = e14.y, this.drawMarker(t15, r17);
      else if (f4(e14)) {
        const i14 = l(e14);
        i14 && ([r17.tx, r17.ty] = i14, this.drawMarker(t15, r17));
      } else
        for (const i14 of e14.points)
          if (r17.tx = i14[0], r17.ty = i14[1], this.drawMarker(t15, r17), this._earlyReturn)
            break;
      this._placementPool.release(r17);
    }
  }
  drawMarker(t15, e14) {
    switch (t15.type) {
      case "CIMCharacterMarker":
      case "CIMPictureMarker":
        this.drawPictureMarker(t15, e14);
        break;
      case "CIMVectorMarker":
        this.drawVectorMarker(t15, e14);
    }
  }
  drawPictureMarker(t15, e14) {
    if (!t15)
      return;
    const r16 = this._resourceManager.getResource(t15.url), i14 = b2(t15.size, q2);
    if (null == r16 || i14 <= 0)
      return;
    const s13 = r16.width, o6 = r16.height;
    if (!s13 || !o6)
      return;
    const n19 = s13 / o6, a11 = b2(t15.scaleX, 1), l9 = Q.createIdentity(), h8 = t15.anchorPoint;
    if (h8) {
      let e15 = h8.x, r17 = h8.y;
      "Absolute" !== t15.anchorPointUnits && (e15 *= i14 * n19 * a11, r17 *= i14), l9.translate(-e15, -r17);
    }
    let c4 = b2(t15.rotation);
    t15.rotateClockwise && (c4 = -c4), this._mapRotation && (c4 += this._mapRotation), c4 && l9.rotate(c4 * J);
    let m7 = b2(t15.offsetX), f5 = b2(t15.offsetY);
    if (m7 || f5) {
      if (this._mapRotation) {
        const t16 = J * this._mapRotation, e15 = Math.cos(t16), r17 = Math.sin(t16), i15 = m7 * r17 + f5 * e15;
        m7 = m7 * e15 - f5 * r17, f5 = i15;
      }
      l9.translate(m7, f5);
    }
    const u9 = this.geomUnitsPerPoint();
    1 !== u9 && l9.scale(u9, u9);
    const d2 = e14.getAngle();
    d2 && l9.rotate(d2), l9.translate(e14.tx, e14.ty), this.push(l9, false), this.drawImage(t15, i14), this.pop();
  }
  drawVectorMarker(t15, e14) {
    if (!t15)
      return;
    const r16 = t15.markerGraphics;
    if (!r16)
      return;
    const i14 = b2(t15.size, q2), s13 = t15.frame, o6 = s13 ? s13.ymax - s13.ymin : 0, n19 = i14 && o6 ? i14 / o6 : 1, a11 = Q.createIdentity();
    s13 && a11.translate(0.5 * -(s13.xmax + s13.xmin), 0.5 * -(s13.ymax + s13.ymin));
    const l9 = t15.anchorPoint;
    if (l9) {
      let e15 = l9.x, r17 = l9.y;
      "Absolute" !== t15.anchorPointUnits ? s13 && (e15 *= s13.xmax - s13.xmin, r17 *= s13.ymax - s13.ymin) : (e15 /= n19, r17 /= n19), a11.translate(-e15, -r17);
    }
    1 !== n19 && a11.scale(n19, n19);
    let h8 = b2(t15.rotation);
    t15.rotateClockwise && (h8 = -h8), this._mapRotation && (h8 += this._mapRotation), h8 && a11.rotate(h8 * J);
    let c4 = b2(t15.offsetX), m7 = b2(t15.offsetY);
    if (c4 || m7) {
      if (this._mapRotation) {
        const t16 = J * this._mapRotation, e15 = Math.cos(t16), r17 = Math.sin(t16), i15 = c4 * r17 + m7 * e15;
        c4 = c4 * e15 - m7 * r17, m7 = i15;
      }
      a11.translate(c4, m7);
    }
    const f5 = this.geomUnitsPerPoint();
    1 !== f5 && a11.scale(f5, f5);
    const u9 = e14.getAngle();
    u9 && a11.rotate(u9), a11.translate(e14.tx, e14.ty), this.push(a11, t15.scaleSymbolsProportionally);
    for (const d2 of r16)
      if ((d2 == null ? void 0 : d2.symbol) && d2.geometry || N.error("Invalid marker graphic", d2), this.drawSymbol(d2.symbol, d2.geometry, d2.textString), this._earlyReturn)
        break;
    this.pop();
  }
  drawTextSymbol(t15, e14, r16) {
    if (!t15)
      return;
    if (!l2(e14))
      return;
    if (b2(t15.height, W) <= 0)
      return;
    const i14 = Q.createIdentity();
    let s13 = b2(t15.angle);
    s13 = -s13, s13 && i14.rotate(s13 * J);
    const o6 = b2(t15.offsetX), n19 = b2(t15.offsetY);
    (o6 || n19) && i14.translate(o6, n19);
    const a11 = this.geomUnitsPerPoint();
    1 !== a11 && i14.scale(a11, a11), i14.translate(e14.x, e14.y), this.push(i14, false), this.drawText(t15, r16), this.pop();
  }
  _buildHatchPolyline(t15, e14, r16) {
    let i14 = b2(t15.separation, Y2) * r16, s13 = b2(t15.rotation);
    if (0 === i14)
      return null;
    i14 < 0 && (i14 = -i14);
    let o6 = 0;
    const n19 = 0.5 * i14;
    for (; o6 > n19; )
      o6 -= i14;
    for (; o6 < -n19; )
      o6 += i14;
    const a11 = u();
    a3(a11, e14), a11[0] -= n19, a11[1] -= n19, a11[2] += n19, a11[3] += n19;
    const h8 = [[a11[0], a11[1]], [a11[0], a11[3]], [a11[2], a11[3]], [a11[2], a11[1]]];
    for (; s13 > 180; )
      s13 -= 180;
    for (; s13 < 0; )
      s13 += 180;
    const m7 = Math.cos(s13 * J), f5 = Math.sin(s13 * J), u9 = -i14 * f5, d2 = i14 * m7;
    let p3, _3, g4, y3;
    o6 = b2(t15.offsetX) * r16 * f5 - b2(t15.offsetY) * r16 * m7, p3 = g4 = Number.MAX_VALUE, _3 = y3 = -Number.MAX_VALUE;
    for (const l9 of h8) {
      const t16 = l9[0], e15 = l9[1], r17 = m7 * t16 + f5 * e15, i15 = -f5 * t16 + m7 * e15;
      p3 = Math.min(p3, r17), g4 = Math.min(g4, i15), _3 = Math.max(_3, r17), y3 = Math.max(y3, i15);
    }
    g4 = Math.floor(g4 / i14) * i14;
    let P4 = m7 * p3 - f5 * g4 - u9 * o6 / i14, w6 = f5 * p3 + m7 * g4 - d2 * o6 / i14, x3 = m7 * _3 - f5 * g4 - u9 * o6 / i14, S3 = f5 * _3 + m7 * g4 - d2 * o6 / i14;
    const M2 = 1 + Math.round((y3 - g4) / i14), b4 = [];
    for (let l9 = 0; l9 < M2; l9++)
      P4 += u9, w6 += d2, x3 += u9, S3 += d2, b4.push([[P4, w6], [x3, S3]]);
    return { paths: b4 };
  }
};
var $ = class extends Z2 {
  constructor(t15, e14) {
    super(t15, e14), this.reset();
  }
  reset() {
    this._xmin = this._ymin = 1 / 0, this._xmax = this._ymax = -1 / 0, this._clipCount = 0;
  }
  envelope() {
    return new t14(this._xmin, this._ymin, this._xmax - this._xmin, this._ymax - this._ymin);
  }
  bounds() {
    return a2(this._xmin, this._ymin, this._xmax, this._ymax);
  }
  drawSolidFill(t15) {
    if (t15 && !(this._clipCount > 0))
      if (f4(t15))
        this._processPath(t15.rings, 0);
      else if (s3(t15))
        this._processPath(t15.paths, 0);
      else if (m(t15)) {
        const e14 = it(t15);
        e14 && this._processPath(e14.rings, 0);
      } else
        console.error("drawSolidFill Unexpected geometry type!");
  }
  drawSolidStroke(t15, e14, r16) {
    if (!t15 || this._clipCount > 0)
      return;
    const i14 = 0.5 * this.transformSize(b2(r16, O3));
    if (f4(t15))
      this._processPath(t15.rings, i14);
    else if (s3(t15))
      this._processPath(t15.paths, i14);
    else if (m(t15)) {
      const e15 = it(t15);
      e15 && this._processPath(e15.rings, i14);
    } else
      console.error("drawSolidStroke unexpected geometry type!");
  }
  drawMarkerLayer(t15, e14) {
    f4(e14) && t15.markerPlacement && ("CIMMarkerPlacementInsidePolygon" === t15.markerPlacement.type || "CIMMarkerPlacementPolygonCenter" === t15.markerPlacement.type && t15.markerPlacement.clipAtBoundary) ? this._processPath(e14.rings, 0) : super.drawMarkerLayer(t15, e14);
  }
  drawHatchFill(t15, e14) {
    this.drawSolidFill(t15);
  }
  drawPictureFill(t15, e14) {
    this.drawSolidFill(t15);
  }
  drawGradientFill(t15, e14) {
    this.drawSolidFill(t15);
  }
  drawPictureStroke(t15, e14) {
    this.drawSolidStroke(t15, null, e14.width);
  }
  drawGradientStroke(t15, e14) {
    this.drawSolidStroke(t15, null, e14.width);
  }
  pushClipPath(t15) {
    this.drawSolidFill(t15), this._clipCount++;
  }
  popClipPath() {
    this._clipCount--;
  }
  drawImage(t15, e14) {
    const { url: r16 } = t15, i14 = b2(t15.scaleX, 1);
    let s13 = i14 * e14, o6 = e14;
    const n19 = this._resourceManager.getResource(r16);
    e14 || null == n19 || (s13 = i14 * n19.width, o6 = n19.height), this._merge(this.transformPt([-s13 / 2, -o6 / 2]), 0), this._merge(this.transformPt([-s13 / 2, o6 / 2]), 0), this._merge(this.transformPt([s13 / 2, -o6 / 2]), 0), this._merge(this.transformPt([s13 / 2, o6 / 2]), 0);
  }
  drawText(t15, e14) {
    if (!e14 || 0 === e14.length)
      return;
    this._textRasterizer || (this._textRasterizer = new r15());
    const r16 = at(t15), [i14, s13] = this._textRasterizer.computeTextSize(e14, r16);
    let o6 = 0;
    switch (t15.horizontalAlignment) {
      case "Left":
        o6 = i14 / 2;
        break;
      case "Right":
        o6 = -i14 / 2;
    }
    let n19 = 0;
    switch (t15.verticalAlignment) {
      case "Bottom":
        n19 = s13 / 2;
        break;
      case "Top":
        n19 = -s13 / 2;
        break;
      case "Baseline":
        n19 = s13 / 6;
    }
    this._merge(this.transformPt([-i14 / 2 + o6, -s13 / 2 + n19]), 0), this._merge(this.transformPt([-i14 / 2 + o6, s13 / 2 + n19]), 0), this._merge(this.transformPt([i14 / 2 + o6, -s13 / 2 + n19]), 0), this._merge(this.transformPt([i14 / 2 + o6, s13 / 2 + n19]), 0);
  }
  _processPath(t15, e14) {
    if (t15)
      for (const r16 of t15) {
        const t16 = r16 ? r16.length : 0;
        if (t16 > 1) {
          this._merge(this.transformPt(r16[0]), e14);
          for (let i14 = 1; i14 < t16; i14++)
            this._merge(this.transformPt(r16[i14]), e14);
        }
      }
  }
  _merge(t15, e14) {
    t15[0] - e14 < this._xmin && (this._xmin = t15[0] - e14), t15[0] + e14 > this._xmax && (this._xmax = t15[0] + e14), t15[1] - e14 < this._ymin && (this._ymin = t15[1] - e14), t15[1] + e14 > this._ymax && (this._ymax = t15[1] + e14);
  }
};
var tt = class extends Z2 {
  constructor() {
    super(...arguments), this._searchPoint = [0, 0], this._searchDistPoint = 0, this._textInfo = null;
  }
  hitTest(t15, e14, r16, i14, s13, o6) {
    const a11 = o6 * u3(1);
    this.setTransform(), this.setGeomUnitsPerPoint(a11), this._searchPoint = [(t15[0] + t15[2]) / 2, (t15[1] + t15[3]) / 2], this._searchDistPoint = (t15[2] - t15[0]) / 2 / a11, this._textInfo = i14;
    const l9 = e14 && ("CIMPointSymbol" === e14.type && "Map" !== e14.angleAlignment || "CIMTextSymbol" === e14.type);
    return this._mapRotation = l9 ? s13 : 0, this._earlyReturn = false, this.drawSymbol(e14, r16), this._earlyReturn;
  }
  drawSolidFill(t15, e14) {
    this._hitTestFill(t15);
  }
  drawHatchFill(t15, e14) {
    this._hitTestFill(t15);
  }
  drawPictureFill(t15, e14) {
    this._hitTestFill(t15);
  }
  drawGradientFill(t15, e14) {
    this._hitTestFill(t15);
  }
  drawSolidStroke(t15, e14, r16, i14, s13, o6) {
    this._hitTestStroke(t15, r16);
  }
  drawPictureStroke(t15, e14) {
    this._hitTestStroke(t15, e14.width);
  }
  drawGradientStroke(t15, e14) {
    this._hitTestStroke(t15, e14.width);
  }
  drawMarkerLayer(t15, e14) {
    t15.markerPlacement && ("CIMMarkerPlacementInsidePolygon" === t15.markerPlacement.type || "CIMMarkerPlacementPolygonCenter" === t15.markerPlacement.type && t15.markerPlacement.clipAtBoundary) ? this._hitTestFill(e14) : super.drawMarkerLayer(t15, e14);
  }
  pushClipPath(t15) {
  }
  popClipPath() {
  }
  drawImage(t15, e14) {
    const { url: r16 } = t15, i14 = b2(t15.scaleX, 1), s13 = this._resourceManager.getResource(r16);
    if (null == s13 || 0 === s13.height || 0 === e14)
      return;
    const o6 = e14 * this.geomUnitsPerPoint(), n19 = o6 * i14 * (s13.width / s13.height), a11 = this.reverseTransformPt(this._searchPoint), l9 = this._searchDistPoint;
    Math.abs(a11[0]) < n19 / 2 + l9 && Math.abs(a11[1]) < o6 / 2 + l9 && (this._earlyReturn = true);
  }
  drawText(e14, r16) {
    var _a, _b;
    const i14 = this._textInfo;
    if (!i14)
      return;
    const s13 = i14.get(e14);
    if (!s13)
      return;
    const { text: o6, mosaicItem: n19 } = s13;
    if (!((_a = n19 == null ? void 0 : n19.glyphMosaicItems) == null ? void 0 : _a.length))
      return;
    const a11 = b2(e14.height, W), { lineGapType: l9, lineGap: h8 } = e14, c4 = l9 ? nt(l9, b2(h8), a11) : 0, m7 = i3(o6)[1], f5 = n19.glyphMosaicItems, u9 = "CIMBackgroundCallout" === ((_b = e14.callout) == null ? void 0 : _b.type), d2 = S2(f5, m7, { scale: a11 / b, angle: 0, xOffset: 0, yOffset: 0, hAlign: st(e14.horizontalAlignment), vAlign: ot(e14.verticalAlignment), maxLineWidth: 512, lineHeight: w * Math.max(0.25, Math.min(c4 || 1, 4)), decoration: e14.font.decoration || "none", isCIM: true, hasBackground: u9 }), p3 = this.reverseTransformPt(this._searchPoint), _3 = p3[0], g4 = p3[1];
    for (const t15 of d2.glyphs)
      if (_3 > t15.xTopLeft && _3 < t15.xBottomRight && g4 > -t15.yBottomRight && g4 < -t15.yTopLeft) {
        this._earlyReturn = true;
        break;
      }
  }
  _hitTestFill(t15) {
    let e14 = null;
    if (m(t15)) {
      const r17 = t15;
      e14 = [[[r17.xmin, r17.ymin], [r17.xmin, r17.ymax], [r17.xmax, r17.ymax], [r17.xmax, r17.ymin], [r17.xmin, r17.ymin]]];
    } else if (f4(t15))
      e14 = t15.rings;
    else {
      if (!s3(t15))
        return;
      e14 = t15.paths;
    }
    const r16 = this.reverseTransformPt(this._searchPoint);
    if (this._pointInPolygon(r16, e14) && (this._earlyReturn = true), !this._earlyReturn) {
      const t16 = this.reverseTransformSize(this._searchDistPoint) * this.geomUnitsPerPoint();
      this._nearLine(r16, e14, t16) && (this._earlyReturn = true);
    }
  }
  _hitTestStroke(t15, e14) {
    let r16 = null;
    if (m(t15)) {
      const e15 = t15;
      r16 = [[[e15.xmin, e15.ymin], [e15.xmin, e15.ymax], [e15.xmax, e15.ymax], [e15.xmax, e15.ymin], [e15.xmin, e15.ymin]]];
    } else if (f4(t15))
      r16 = t15.rings;
    else {
      if (!s3(t15))
        return;
      r16 = t15.paths;
    }
    const i14 = this.reverseTransformPt(this._searchPoint), s13 = b2(e14, O3) * this.geomUnitsPerPoint(), o6 = this.reverseTransformSize(this._searchDistPoint) * this.geomUnitsPerPoint();
    this._nearLine(i14, r16, s13 / 2 + o6) && (this._earlyReturn = true);
  }
  _pointInPolygon(t15, e14) {
    let r16 = 0;
    for (const i14 of e14) {
      const e15 = i14.length;
      for (let s13 = 1; s13 < e15; s13++) {
        const e16 = i14[s13 - 1], o6 = i14[s13];
        if (e16[1] > t15[1] == o6[1] > t15[1])
          continue;
        (o6[0] - e16[0]) * (t15[1] - e16[1]) - (o6[1] - e16[1]) * (t15[0] - e16[0]) > 0 ? r16++ : r16--;
      }
    }
    return 0 !== r16;
  }
  _nearLine(t15, e14, r16) {
    for (const i14 of e14) {
      const e15 = i14.length;
      for (let s13 = 1; s13 < e15; s13++) {
        const e16 = i14[s13 - 1], o6 = i14[s13];
        let n19 = (o6[0] - e16[0]) * (o6[0] - e16[0]) + (o6[1] - e16[1]) * (o6[1] - e16[1]);
        if (0 === n19)
          continue;
        n19 = Math.sqrt(n19);
        const a11 = ((o6[0] - e16[0]) * (t15[1] - e16[1]) - (o6[1] - e16[1]) * (t15[0] - e16[0])) / n19;
        if (Math.abs(a11) < r16) {
          const i15 = ((o6[0] - e16[0]) * (t15[0] - e16[0]) + (o6[1] - e16[1]) * (t15[1] - e16[1])) / n19;
          if (i15 > -r16 && i15 < n19 + r16)
            return true;
        }
      }
    }
    return false;
  }
};
var et = class extends Z2 {
  constructor(t15, e14, r16, i14) {
    super(e14, r16), this._applyAdditionalRenderProps = i14, this._colorSubstitutionHelper = new t9(), this._ctx = t15;
  }
  drawSolidFill(t15, e14) {
    if (!t15)
      return;
    if (f4(t15))
      this._buildPath(t15.rings, true);
    else if (s3(t15))
      this._buildPath(t15.paths, true);
    else if (m(t15))
      this._buildPath(it(t15).rings, true);
    else {
      if (!u2(t15))
        return;
      console.log("CanvasDrawHelper.drawSolidFill - No implementation!");
    }
    const r16 = this._ctx;
    r16.fillStyle = "string" == typeof e14 ? e14 : "rgba(" + Math.round(e14[0]) + "," + Math.round(e14[1]) + "," + Math.round(e14[2]) + "," + (e14[3] ?? 255) / 255 + ")", r16.fill("evenodd");
  }
  drawSolidStroke(t15, e14, r16, i14, s13, o6) {
    if (!t15 || !e14 || 0 === r16)
      return;
    if (f4(t15))
      this._buildPath(t15.rings, true);
    else if (s3(t15))
      this._buildPath(t15.paths, false);
    else {
      if (!m(t15))
        return void console.log("CanvasDrawHelper.drawSolidStroke isn't implemented!");
      this._buildPath(it(t15).rings, true);
    }
    const n19 = this._ctx;
    n19.strokeStyle = "string" == typeof e14 ? e14 : "rgba(" + Math.round(e14[0]) + "," + Math.round(e14[1]) + "," + Math.round(e14[2]) + "," + (e14[3] ?? 255) / 255 + ")", n19.lineWidth = Math.max(this.transformSize(r16), 0.5), this._setCapStyle(i14), this._setJoinStyle(s13), n19.miterLimit = o6, n19.stroke();
  }
  pushClipPath(t15) {
    if (this._ctx.save(), f4(t15))
      this._buildPath(t15.rings, true);
    else if (s3(t15))
      this._buildPath(t15.paths, true);
    else {
      if (!m(t15))
        return;
      this._buildPath(it(t15).rings, true);
    }
    this._ctx.clip("evenodd");
  }
  popClipPath() {
    this._ctx.restore();
  }
  drawImage(t15, e14) {
    const { colorSubstitutions: r16, url: i14, tintColor: s13 } = t15, o6 = b2(t15.scaleX, 1), n19 = this._resourceManager.getResource(i14);
    if (null == n19)
      return;
    let a11 = e14 * (n19.width / n19.height), l9 = e14;
    e14 || (a11 = n19.width, l9 = n19.height);
    const h8 = F(i14) || "src" in n19 && F(n19.src);
    let c4 = "getFrame" in n19 ? t13(n19) : n19;
    r16 && (c4 = this._colorSubstitutionHelper.applyColorSubstituition(c4, r16)), this._applyAdditionalRenderProps && !h8 && s13 && (c4 = this._colorSubstitutionHelper.tintImageData(c4, s13));
    const m7 = this.transformPt([0, 0]), [f5, u9] = this.getTransformAngle(), d2 = this.transformSize(1), p3 = this._ctx;
    p3.save(), p3.setTransform({ m11: o6 * d2 * f5, m12: o6 * d2 * u9, m21: -d2 * u9, m22: d2 * f5, m41: m7[0], m42: m7[1] }), p3.drawImage(c4, -a11 / 2, -l9 / 2, a11, l9), p3.restore();
  }
  drawText(t15, e14) {
    if (!e14 || 0 === e14.length)
      return;
    this._textRasterizer || (this._textRasterizer = new r15());
    const r16 = at(t15);
    r16.size *= this.transformSize(e2(1));
    const i14 = this._textRasterizer.rasterizeText(e14, r16);
    if (!i14)
      return;
    const { size: s13, anchorX: n19, anchorY: a11, canvas: l9 } = i14, h8 = s13[0] * (n19 + 0.5), c4 = s13[1] * (a11 - 0.5), m7 = this._ctx, f5 = this.transformPt([0, 0]), [u9, d2] = this.getTransformAngle(), p3 = 1;
    m7.save(), m7.setTransform({ m11: p3 * u9, m12: p3 * d2, m21: -p3 * d2, m22: p3 * u9, m41: f5[0] - p3 * h8, m42: f5[1] + p3 * c4 }), m7.drawImage(l9, 0, 0), m7.restore();
  }
  drawPictureFill(t15, e14) {
    if (!t15)
      return;
    let { colorSubstitutions: r16, height: i14, offsetX: s13, offsetY: o6, rotation: n19, scaleX: a11, tintColor: l9, url: h8 } = e14;
    const c4 = this._resourceManager.getResource(h8);
    if (null == c4)
      return;
    if (f4(t15))
      this._buildPath(t15.rings, true);
    else if (s3(t15))
      this._buildPath(t15.paths, true);
    else if (m(t15))
      this._buildPath(it(t15).rings, true);
    else {
      if (!u2(t15))
        return;
      console.log("CanvasDrawHelper.drawPictureFill - No implementation!");
    }
    const m7 = this._ctx, f5 = F(h8) || "src" in c4 && F(c4.src);
    let g4, y3 = "getFrame" in c4 ? t13(c4) : c4;
    if (r16 && (y3 = this._colorSubstitutionHelper.applyColorSubstituition(y3, r16)), this._applyAdditionalRenderProps) {
      f5 || l9 && (y3 = this._colorSubstitutionHelper.tintImageData(y3, l9)), g4 = m7.createPattern(y3, "repeat");
      const t16 = this.transformSize(1);
      n19 || (n19 = 0), s13 ? s13 *= t16 : s13 = 0, o6 ? o6 *= t16 : o6 = 0, i14 && (i14 *= t16);
      const e15 = i14 ? i14 / c4.height : 1, r17 = a11 && i14 ? a11 * i14 / c4.width : 1;
      if (0 !== n19 || 1 !== e15 || 1 !== r17 || 0 !== s13 || 0 !== o6) {
        const t17 = new DOMMatrix();
        t17.rotateSelf(0, 0, -n19).translateSelf(s13, o6).scaleSelf(r17, e15, 1), g4.setTransform(t17);
      }
    } else
      g4 = m7.createPattern(y3, "repeat");
    m7.save(), m7.fillStyle = g4, m7.fill("evenodd"), m7.restore();
  }
  drawPictureStroke(t15, e14) {
    if (!t15)
      return;
    let { colorSubstitutions: i14, capStyle: s13, joinStyle: o6, miterLimit: a11, tintColor: l9, url: h8, width: c4 } = e14;
    const m7 = this._resourceManager.getResource(h8);
    if (null == m7)
      return;
    let f5;
    if (f4(t15))
      f5 = t15.rings;
    else if (s3(t15))
      f5 = t15.paths;
    else {
      if (!m(t15))
        return u2(t15) ? void console.log("CanvasDrawHelper.drawPictureStroke - No implementation!") : void 0;
      f5 = it(t15).rings;
    }
    c4 || (c4 = m7.width);
    const g4 = F(h8) || "src" in m7 && F(m7.src);
    let y3 = "getFrame" in m7 ? t13(m7) : m7;
    i14 && (y3 = this._colorSubstitutionHelper.applyColorSubstituition(y3, i14)), this._applyAdditionalRenderProps && (g4 || l9 && (y3 = this._colorSubstitutionHelper.tintImageData(y3, l9)));
    const P4 = Math.max(this.transformSize(u3(c4)), 0.5), w6 = P4 / y3.width, x3 = this._ctx, S3 = x3.createPattern(y3, "repeat-y");
    let M2, k5;
    x3.save(), this._setCapStyle(s13), this._setJoinStyle(o6), void 0 !== a11 && (x3.miterLimit = a11), x3.lineWidth = P4;
    for (let n19 of f5)
      if (n19 = a(n19), ht(n19), n19 && !(n19.length <= 1)) {
        M2 = this.transformPt(n19[0]);
        for (let t16 = 1; t16 < n19.length; t16++) {
          k5 = this.transformPt(n19[t16]);
          const e15 = rt(M2, k5), r16 = new DOMMatrix();
          r16.translateSelf(0, M2[1] - P4 / 2).scaleSelf(w6, w6, 1).rotateSelf(0, 0, 90 - e15), S3.setTransform(r16), x3.strokeStyle = S3, x3.beginPath(), x3.moveTo(M2[0], M2[1]), x3.lineTo(k5[0], k5[1]), x3.stroke(), M2 = k5;
        }
      }
    x3.restore();
  }
  _buildPath(t15, e14) {
    const r16 = this._ctx;
    if (r16.beginPath(), t15)
      for (const i14 of t15) {
        const t16 = i14 ? i14.length : 0;
        if (t16 > 1) {
          let s13 = this.transformPt(i14[0]);
          r16.moveTo(s13[0], s13[1]);
          for (let e15 = 1; e15 < t16; e15++)
            s13 = this.transformPt(i14[e15]), r16.lineTo(s13[0], s13[1]);
          e14 && r16.closePath();
        }
      }
  }
  _setCapStyle(t15) {
    switch (t15) {
      case U2.Butt:
        this._ctx.lineCap = "butt";
        break;
      case U2.Round:
        this._ctx.lineCap = "round";
        break;
      case U2.Square:
        this._ctx.lineCap = "square";
    }
  }
  _setJoinStyle(t15) {
    switch (t15) {
      case w2.Bevel:
        this._ctx.lineJoin = "bevel";
        break;
      case w2.Round:
        this._ctx.lineJoin = "round";
        break;
      case w2.Miter:
        this._ctx.lineJoin = "miter";
    }
  }
};
function rt(t15, e14) {
  const r16 = e14[0] - t15[0], i14 = e14[1] - t15[1];
  return 180 / Math.PI * Math.atan2(i14, r16);
}
var it = (t15) => t15 ? { spatialReference: t15.spatialReference, rings: [[[t15.xmin, t15.ymin], [t15.xmin, t15.ymax], [t15.xmax, t15.ymax], [t15.xmax, t15.ymin], [t15.xmin, t15.ymin]]] } : null;
var st = (t15) => {
  switch (t15) {
    case "Left":
      return e4.Left;
    case "Right":
      return e4.Right;
    case "Center":
      return e4.Center;
    case "Justify":
      return N.warnOnce("Horizontal alignment 'justify' is not implemented. Falling back to 'center'."), e4.Center;
  }
};
var ot = (t15) => {
  switch (t15) {
    case "Top":
      return t3.Top;
    case "Center":
      return t3.Center;
    case "Bottom":
      return t3.Bottom;
    case "Baseline":
      return t3.Baseline;
  }
};
var nt = (t15, e14, r16) => {
  switch (t15) {
    case "ExtraLeading":
      return 1 + e14 / r16;
    case "Multiple":
      return e14;
    case "Exact":
      return e14 / r16;
  }
};
function at(t15, r16 = 1) {
  var _a;
  const i14 = k3(t15), s13 = S(t15.fontStyleName), o6 = t15.fontFamilyName ?? t7, { weight: n19, style: a11 } = s13, l9 = r16 * (t15.height || 5), h8 = x(t15.horizontalAlignment), c4 = G(t15.verticalAlignment), m7 = P2(t15), f5 = P2(t15.haloSymbol), u9 = f5 ? r16 * (0 | t15.haloSize) : 0, d2 = "CIMBackgroundCallout" === ((_a = t15.callout) == null ? void 0 : _a.type) ? t15.callout.backgroundSymbol : null, p3 = P2(d2), _3 = L(d2), g4 = w4(d2);
  return { color: m7, size: l9, horizontalAlignment: h8, verticalAlignment: c4, font: { family: o6, style: h2(a11), weight: g(n19), decoration: i14 }, halo: { size: u9 || 0, color: f5, style: a11 }, backgroundColor: p3, borderLine: null != _3 && null != g4 ? { size: _3, color: g4 } : null, pixelRatio: 1, premultiplyColors: true };
}
var lt = 1e-4;
function ht(t15) {
  let e14, r16, i14, s13, o6, n19 = t15[0], a11 = 1;
  for (; a11 < t15.length; )
    e14 = t15[a11][0] - n19[0], r16 = t15[a11][1] - n19[1], s13 = 0 !== e14 ? r16 / e14 : Math.PI / 2, void 0 !== i14 && s13 - i14 <= lt ? (t15.splice(a11 - 1, 1), n19 = o6) : (o6 = n19, n19 = t15[a11], a11++), i14 = s13;
}

// node_modules/@arcgis/core/views/2d/arcade/callExpressionWithFeature.js
function s12(e14, t15, o6, n19, a11) {
  if (null == e14)
    return null;
  const s13 = e14.referencesGeometry() && a11 ? i13(t15, n19, a11) : t15, u9 = e14.repurposeFeature(s13);
  try {
    return e14.evaluate({ ...o6, $feature: u9 }, e14.services);
  } catch (c4) {
    return s.getLogger("esri.views.2d.support.arcadeOnDemand").warn("Feature arcade evaluation failed:", c4), null;
  }
}
var u8 = /* @__PURE__ */ new Map();
function i13(e14, r16, t15) {
  const { transform: o6, hasZ: n19, hasM: a11 } = t15;
  u8.has(r16) || u8.set(r16, c3(r16));
  const s13 = u8.get(r16)(e14.geometry, o6, n19, a11);
  return { ...e14, geometry: s13 };
}
function c3(s13) {
  const u9 = {};
  switch (s13) {
    case "esriGeometryPoint":
      return (e14, r16, t15, o6) => k(r16, u9, e14, t15, o6);
    case "esriGeometryPolygon":
      return (e14, r16, t15, o6) => q(r16, u9, e14, t15, o6);
    case "esriGeometryPolyline":
      return (e14, r16, t15, n19) => v(r16, u9, e14, t15, n19);
    case "esriGeometryMultipoint":
      return (e14, r16, o6, n19) => U(r16, u9, e14, o6, n19);
    default:
      return s.getLogger("esri.views.2d.support.arcadeOnDemand").error(new s2("mapview-arcade", `Unable to handle geometryType: ${s13}`)), (e14) => e14;
  }
}

// node_modules/@arcgis/core/symbols/cim/CIMSymbolHelper.js
var W2 = Math.PI;
var J2 = W2 / 2;
var K2 = Math.PI / 180;
var Q2 = 96 / 72;
var Z3 = 4;
var ee = s.getLogger("esri.symbols.cim.CIMSymbolHelper");
function te(e14) {
  if (!(e14 == null ? void 0 : e14.type))
    return null;
  let t15;
  switch (e14.type) {
    case "cim":
      return e14.data;
    case "web-style":
      return e14;
    case "simple-marker": {
      const r16 = ne2.fromSimpleMarker(e14);
      if (!r16)
        return null;
      t15 = r16;
      break;
    }
    case "picture-marker":
      t15 = ne2.fromPictureMarker(e14);
      break;
    case "simple-line":
      t15 = ne2.fromSimpleLineSymbol(e14);
      break;
    case "simple-fill":
      t15 = ne2.fromSimpleFillSymbol(e14);
      break;
    case "picture-fill":
      t15 = ne2.fromPictureFillSymbol(e14);
      break;
    case "text":
      t15 = ne2.fromTextSymbol(e14);
  }
  return { type: "CIMSymbolReference", symbol: t15 };
}
function re(e14, t15, r16) {
  switch (t15.type) {
    case "CIMSymbolReference":
      return re(e14, t15.symbol, r16);
    case "CIMPointSymbol":
      null == r16 && (r16 = { x: 0, y: 0 }), e14.drawSymbol(t15, r16);
      break;
    case "CIMLineSymbol":
      null == r16 && (r16 = { paths: [[[0, 0], [10, 0]]] }), e14.drawSymbol(t15, r16);
      break;
    case "CIMPolygonSymbol":
      null == r16 && (r16 = { rings: [[[0, 0], [0, 10], [10, 10], [10, 0], [0, 0]]] }), e14.drawSymbol(t15, r16);
      break;
    case "CIMTextSymbol": {
      const r17 = { x: 0, y: 0 };
      e14.drawSymbol(t15, r17);
      break;
    }
    case "CIMVectorMarker": {
      const r17 = new t8();
      e14.drawMarker(t15, r17);
      break;
    }
  }
  return e14.envelope();
}
function oe2(e14) {
  if (!e14)
    return 0;
  switch (e14.type) {
    case "CIMMarkerPlacementAlongLineSameSize":
    case "CIMMarkerPlacementAlongLineRandomSize":
    case "CIMMarkerPlacementAtExtremities":
    case "CIMMarkerPlacementAtMeasuredUnits":
    case "CIMMarkerPlacementAtRatioPositions":
    case "CIMMarkerPlacementOnLine":
    case "CIMMarkerPlacementOnVertices":
      return Math.abs(e14.offset);
    default:
      return 0;
  }
}
function ae(e14) {
  if (!e14)
    return 0;
  switch (e14.type) {
    case "CIMGeometricEffectArrow":
      return Math.abs(0.5 * e14.width);
    case "CIMGeometricEffectBuffer":
      return Math.abs(e14.size);
    case "CIMGeometricEffectExtension":
    case "CIMGeometricEffectRadial":
      return Math.abs(e14.length);
    case "CIMGeometricEffectJog":
      return Math.abs(0.5 * e14.length);
    case "CIMGeometricEffectMove":
      return Math.max(Math.abs(b2(e14.offsetX)), Math.abs(b2(e14.offsetY)));
    case "CIMGeometricEffectOffset":
    case "CIMGeometricEffectOffsetTangent":
      return Math.abs(e14.offset);
    case "CIMGeometricEffectRegularPolygon":
      return Math.abs(e14.radius);
    case "CIMGeometricEffectRotate":
    case "CIMGeometricEffectScale":
    default:
      return 0;
    case "CIMGeometricEffectTaperedPolygon":
      return 0.5 * Math.max(Math.abs(e14.fromWidth), Math.abs(e14.toWidth));
    case "CIMGeometricEffectWave":
      return Math.abs(e14.amplitude);
    case "CIMGeometricEffectDonut":
      return Math.abs(e14.width);
  }
}
function se2(e14) {
  if (!e14)
    return 0;
  let t15 = 0;
  for (const r16 of e14)
    t15 += ae(r16);
  return t15;
}
var ie2 = class {
  getSymbolInflateSize(e14, t15, r16, o6, a11) {
    return e14 || (e14 = [0, 0, 0, 0]), t15 ? this._getInflateSize(e14, t15, r16, o6, a11) : e14;
  }
  static safeSize(e14) {
    const t15 = Math.max(Math.abs(e14[0]), Math.abs(e14[2])), r16 = Math.max(Math.abs(e14[1]), Math.abs(e14[3]));
    return Math.sqrt(t15 * t15 + r16 * r16);
  }
  _vectorMarkerBounds(e14, t15, r16, o6) {
    let a11 = true;
    const s13 = u();
    if (t15 == null ? void 0 : t15.markerGraphics)
      for (const i14 of t15.markerGraphics) {
        const t16 = [0, 0, 0, 0];
        i14.geometry && (a3(s13, i14.geometry), t16[0] = 0, t16[1] = 0, t16[2] = 0, t16[3] = 0, this.getSymbolInflateSize(t16, i14.symbol, r16, 0, o6), s13[0] += t16[0], s13[1] += t16[1], s13[2] += t16[2], s13[3] += t16[3], a11 ? (e14[0] = s13[0], e14[1] = s13[1], e14[2] = s13[2], e14[3] = s13[3], a11 = false) : (e14[0] = Math.min(e14[0], s13[0]), e14[1] = Math.min(e14[1], s13[1]), e14[2] = Math.max(e14[2], s13[2]), e14[3] = Math.max(e14[3], s13[3])));
      }
    return e14;
  }
  _getInflateSize(e14, t15, r16, o6, a11) {
    if (Se(t15)) {
      const s13 = this._getLayersInflateSize(e14, t15.symbolLayers, r16, o6, a11), i14 = se2(t15.effects);
      return i14 > 0 && (s13[0] -= i14, s13[1] -= i14, s13[2] += i14, s13[3] += i14), s13;
    }
    return this._getTextInflatedSize(e14, t15, a11);
  }
  _getLayersInflateSize(e14, t15, r16, o6, a11) {
    let s13 = true;
    if (!t15)
      return e14;
    for (const i14 of t15) {
      if (!i14)
        continue;
      let t16 = [0, 0, 0, 0];
      switch (i14.type) {
        case "CIMSolidFill":
        case "CIMPictureFill":
        case "CIMHatchFill":
        case "CIMGradientFill":
          break;
        case "CIMSolidStroke":
        case "CIMPictureStroke":
        case "CIMGradientStroke": {
          const e15 = i14;
          let r17 = e15.width;
          null != r17 && (e15.capStyle === U2.Square || e15.joinStyle === w2.Miter ? r17 /= 1.4142135623730951 : r17 /= 2, t16[0] = -r17, t16[1] = -r17, t16[2] = r17, t16[3] = r17);
          break;
        }
        case "CIMCharacterMarker":
        case "CIMVectorMarker":
        case "CIMPictureMarker": {
          const e15 = i14;
          if ("CIMVectorMarker" === i14.type) {
            const e16 = i14;
            if (t16 = this._vectorMarkerBounds(t16, e16, r16, a11), e16.frame) {
              const r17 = (e16.frame.xmin + e16.frame.xmax) / 2, o7 = (e16.frame.ymin + e16.frame.ymax) / 2;
              if (t16[0] -= r17, t16[1] -= o7, t16[2] -= r17, t16[3] -= o7, null != e16.size) {
                const r18 = e16.size / (e16.frame.ymax - e16.frame.ymin);
                t16[0] *= r18, t16[1] *= r18, t16[2] *= r18, t16[3] *= r18;
              }
            }
          } else if ("CIMPictureMarker" === i14.type) {
            const o7 = i14, a12 = r16.getResource(o7.url);
            let s15 = 1;
            if (null != a12 && a12.height && (s15 = a12.width / a12.height), null != e15.size) {
              const r17 = e15.size / 2, a13 = e15.size * s15 * o7.scaleX / 2;
              t16 = [-a13, -r17, a13, r17];
            }
          } else if (null != e15.size) {
            const r17 = e15.size / 2;
            t16 = [-r17, -r17, r17, r17];
          }
          if (e15.anchorPoint) {
            let r17, o7;
            "Absolute" === e15.anchorPointUnits ? (r17 = e15.anchorPoint.x, o7 = e15.anchorPoint.y) : (r17 = e15.anchorPoint.x * (t16[2] - t16[0]), o7 = e15.anchorPoint.y * (t16[3] - t16[1])), t16[0] -= r17, t16[1] -= o7, t16[2] -= r17, t16[3] -= o7;
          }
          let s14 = b2(e15.rotation);
          if (e15.rotateClockwise && (s14 = -s14), o6 && (s14 -= o6), s14) {
            const e16 = K2 * s14, r17 = Math.cos(e16), o7 = Math.sin(e16), a12 = u([n4, n4, -n4, -n4]);
            f3(a12, [t16[0] * r17 - t16[1] * o7, t16[0] * o7 + t16[1] * r17]), f3(a12, [t16[0] * r17 - t16[3] * o7, t16[0] * o7 + t16[3] * r17]), f3(a12, [t16[2] * r17 - t16[1] * o7, t16[2] * o7 + t16[1] * r17]), f3(a12, [t16[2] * r17 - t16[3] * o7, t16[2] * o7 + t16[3] * r17]), t16 = a12;
          }
          let c5 = b2(e15.offsetX), f5 = b2(e15.offsetY);
          if (o6) {
            const e16 = K2 * o6, t17 = Math.cos(e16), r17 = Math.sin(e16), a12 = c5 * r17 + f5 * t17;
            c5 = c5 * t17 - f5 * r17, f5 = a12;
          }
          t16[0] += c5, t16[1] += f5, t16[2] += c5, t16[3] += f5;
          const m7 = oe2(e15.markerPlacement);
          m7 > 0 && (t16[0] -= m7, t16[1] -= m7, t16[2] += m7, t16[3] += m7);
          break;
        }
      }
      const c4 = se2(i14.effects);
      c4 > 0 && (t16[0] -= c4, t16[1] -= c4, t16[2] += c4, t16[3] += c4), s13 ? (e14[0] = t16[0], e14[1] = t16[1], e14[2] = t16[2], e14[3] = t16[3], s13 = false) : (e14[0] = Math.min(e14[0], t16[0]), e14[1] = Math.min(e14[1], t16[1]), e14[2] = Math.max(e14[2], t16[2]), e14[3] = Math.max(e14[3], t16[3]));
    }
    return e14;
  }
  _getTextInflatedSize(e14, r16, o6) {
    var _a, _b;
    const a11 = r16.height ?? W;
    if (e14[0] = -a11 / 2, e14[1] = -a11 / 2, e14[2] = a11 / 2, e14[3] = a11 / 2, !o6)
      return e14;
    const s13 = o6.get(r16);
    if (!s13)
      return e14;
    const { text: i14, mosaicItem: n19 } = s13;
    if (!((_a = n19 == null ? void 0 : n19.glyphMosaicItems) == null ? void 0 : _a.length))
      return e14;
    const { lineGapType: l9, lineGap: c4 } = r16, f5 = l9 ? nt(l9, c4 ?? 0, a11) : 0, m7 = i3(i14)[1], y3 = n19.glyphMosaicItems, M2 = "CIMBackgroundCallout" === ((_b = r16.callout) == null ? void 0 : _b.type), d2 = S2(y3, m7, { scale: a11 / b, angle: b2(r16.angle), xOffset: b2(r16.offsetX), yOffset: b2(r16.offsetY), hAlign: st(r16.horizontalAlignment), vAlign: ot(r16.verticalAlignment), maxLineWidth: 512, lineHeight: w * Math.max(0.25, Math.min(f5 || 1, 4)), decoration: r16.font.decoration || "none", isCIM: true, hasBackground: M2 }).boundsT;
    return e14[0] = d2.x - d2.halfWidth, e14[1] = -d2.y - d2.halfHeight, e14[2] = d2.x + d2.halfWidth, e14[3] = -d2.y + d2.halfHeight, e14;
  }
};
var ne2 = class _ne {
  static getEnvelope(e14, t15, r16) {
    if (!e14)
      return null;
    const o6 = new $(r16);
    if (Array.isArray(e14)) {
      let r17;
      for (const a11 of e14)
        r17 ? r17.union(re(o6, a11, t15)) : r17 = re(o6, a11, t15);
      return r17;
    }
    return re(o6, e14, t15);
  }
  static getTextureAnchor(e14, t15) {
    const r16 = this.getEnvelope(e14, null, t15);
    if (!r16)
      return [0, 0, 0];
    const o6 = (r16.x + 0.5 * r16.width) * Q2, a11 = (r16.y + 0.5 * r16.height) * Q2, s13 = r16.width * Q2 + 2, i14 = r16.height * Q2 + 2;
    return [-o6 / s13, -a11 / i14, i14];
  }
  static rasterize(e14, t15, r16, o6, a11 = true) {
    const s13 = r16 || this.getEnvelope(t15, null, o6);
    if (!s13)
      return [null, 0, 0, 0, 0];
    const i14 = (s13.x + 0.5 * s13.width) * Q2, n19 = (s13.y + 0.5 * s13.height) * Q2;
    e14.width = s13.width * Q2, e14.height = s13.height * Q2, r16 || (e14.width += 2, e14.height += 2);
    const l9 = e14.getContext("2d"), c4 = Q.createScale(Q2, -Q2);
    c4.translate(0.5 * e14.width - i14, 0.5 * e14.height + n19);
    const f5 = new et(l9, o6, c4);
    switch (t15.type) {
      case "CIMPointSymbol": {
        const e15 = { type: "point", x: 0, y: 0 };
        f5.drawSymbol(t15, e15);
        break;
      }
      case "CIMVectorMarker": {
        const e15 = new t8();
        f5.drawMarker(t15, e15);
        break;
      }
    }
    const m7 = l9.getImageData(0, 0, e14.width, e14.height), u9 = new Uint8Array(m7.data);
    if (a11) {
      let e15;
      for (let t16 = 0; t16 < u9.length; t16 += 4)
        e15 = u9[t16 + 3] / 255, u9[t16] = u9[t16] * e15, u9[t16 + 1] = u9[t16 + 1] * e15, u9[t16 + 2] = u9[t16 + 2] * e15;
    }
    return [u9, e14.width, e14.height, -i14 / e14.width, -n19 / e14.height];
  }
  static fromTextSymbol(e14) {
    const { angle: r16, color: o6, font: a11, haloColor: s13, haloSize: i14, horizontalAlignment: n19, kerning: l9, text: c4, verticalAlignment: f5, xoffset: m7, yoffset: y3, backgroundColor: u9, borderLineColor: h8, borderLineSize: p3 } = e14;
    let M2, d2, S3, b4, C3, g4;
    a11 && (M2 = a11.family, d2 = a11.style, S3 = a11.weight, b4 = a11.size, C3 = a11.decoration);
    let I2 = false;
    if (c4) {
      I2 = i3(c4)[1];
    }
    return (u9 || p3) && (g4 = { type: "CIMBackgroundCallout", margin: null, backgroundSymbol: { type: "CIMPolygonSymbol", symbolLayers: [{ type: "CIMSolidFill", color: ue(u9) }, { type: "CIMSolidStroke", color: ue(h8), width: p3 }] }, accentBarSymbol: null, gap: null, leaderLineSymbol: null, lineStyle: null }), { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, anchorPointUnits: "Relative", dominantSizeAxis3D: "Y", size: 10, billboardMode3D: "FaceNearPlane", frame: { xmin: -5, ymin: -5, xmax: 5, ymax: 5 }, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: { x: 0, y: 0 }, symbol: { type: "CIMTextSymbol", angle: r16, blockProgression: C2.BTT, depth3D: 1, extrapolateBaselines: true, fontEffects: l3.Normal, fontEncoding: a4.Unicode, fontFamilyName: M2 || "Arial", fontStyleName: he(d2, S3), fontType: u4.Unspecified, haloSize: i14, height: b4, hinting: y.Default, horizontalAlignment: me(n19 ?? "center"), kerning: l9, letterWidth: 100, ligatures: true, lineGapType: "Multiple", offsetX: b2(m7), offsetY: b2(y3), strikethrough: "line-through" === C3, underline: "underline" === C3, symbol: { type: "CIMPolygonSymbol", symbolLayers: [{ type: "CIMSolidFill", enable: true, color: ue(o6) }] }, haloSymbol: { type: "CIMPolygonSymbol", symbolLayers: [{ type: "CIMSolidFill", enable: true, color: ue(s13) }] }, shadowColor: [0, 0, 0, 255], shadowOffsetX: 1, shadowOffsetY: 1, textCase: "Normal", textDirection: I2 ? ne.RTL : ne.LTR, verticalAlignment: ye(f5 ?? "baseline"), verticalGlyphOrientation: oe.Right, wordSpacing: 100, billboardMode3D: m2.FaceNearPlane, callout: g4 }, textString: c4 }], scaleSymbolsProportionally: true, respectFrame: true }], scaleX: 1, angleAlignment: "Display" };
  }
  static fromPictureFillSymbol(e14) {
    const { height: t15, outline: r16, width: o6, xoffset: a11, xscale: s13, yoffset: i14, yscale: n19 } = e14, l9 = [], c4 = { type: "CIMPolygonSymbol", symbolLayers: l9 };
    if (r16) {
      const e15 = ke(r16);
      e15 && l9.push(e15);
    }
    let f5 = e14.url;
    "esriPFS" === e14.type && e14.imageData && (f5 = e14.imageData);
    const m7 = "angle" in e14 ? e14.angle ?? 0 : 0, y3 = (o6 ?? 0) * (s13 || 1), u9 = (t15 ?? 0) * (n19 || 1);
    return l9.push({ type: "CIMPictureFill", invertBackfaceTexture: false, scaleX: 1, textureFilter: ie.Picture, tintColor: null, url: f5, height: u9, width: y3, offsetX: b2(a11), offsetY: b2(i14), rotation: b2(-m7), colorSubstitutions: null }), c4;
  }
  static fromSimpleFillSymbol(e14) {
    const { color: t15, style: o6, outline: a11 } = e14, s13 = [], n19 = { type: "CIMPolygonSymbol", symbolLayers: s13 };
    if (a11) {
      const e15 = ke(a11);
      e15 && s13.push(e15);
    }
    if (o6 && "solid" !== o6 && "none" !== o6 && "esriSFSSolid" !== o6 && "esriSFSNull" !== o6) {
      const e15 = { type: "CIMLineSymbol", symbolLayers: [{ type: "CIMSolidStroke", color: ue(t15), capStyle: U2.Butt, joinStyle: w2.Miter, width: 0.75 }] };
      let a12 = 0;
      const n20 = e2(Ce(o6) ? 8 : 10);
      switch (o6) {
        case "vertical":
        case "esriSFSVertical":
          a12 = 90;
          break;
        case "forward-diagonal":
        case "esriSFSForwardDiagonal":
        case "diagonal-cross":
        case "esriSFSDiagonalCross":
          a12 = -45;
          break;
        case "backward-diagonal":
        case "esriSFSBackwardDiagonal":
          a12 = 45;
          break;
        case "cross":
        case "esriSFSCross":
          a12 = 0;
      }
      s13.push({ type: "CIMHatchFill", lineSymbol: e15, offsetX: 0, offsetY: 0, rotation: a12, separation: n20 }), "cross" === o6 || "esriSFSCross" === o6 ? s13.push({ type: "CIMHatchFill", lineSymbol: a(e15), offsetX: 0, offsetY: 0, rotation: 90, separation: n20 }) : "diagonal-cross" !== o6 && "esriSFSDiagonalCross" !== o6 || s13.push({ type: "CIMHatchFill", lineSymbol: a(e15), offsetX: 0, offsetY: 0, rotation: 45, separation: n20 });
    } else
      !o6 || "solid" !== o6 && "esriSFSSolid" !== o6 || s13.push({ type: "CIMSolidFill", enable: true, color: ue(t15) });
    return n19;
  }
  static fromSimpleLineSymbol(e14) {
    const { cap: t15, color: r16, join: o6, marker: a11, miterLimit: s13, style: i14, width: n19 } = e14;
    let l9 = null;
    "solid" !== i14 && "none" !== i14 && "esriSLSSolid" !== i14 && "esriSLSNull" !== i14 && (l9 = [{ type: "CIMGeometricEffectDashes", dashTemplate: de(i14, t15), lineDashEnding: "NoConstraint", scaleDash: true, offsetAlongLine: null }]);
    const c4 = [];
    if (a11) {
      let e15;
      switch (a11.placement) {
        case "begin-end":
          e15 = o.Both;
          break;
        case "begin":
          e15 = o.JustBegin;
          break;
        case "end":
          e15 = o.JustEnd;
          break;
        default:
          e15 = o.None;
      }
      const t16 = _ne.fromSimpleMarker(a11, n19, r16).symbolLayers[0];
      t16.markerPlacement = { type: "CIMMarkerPlacementAtExtremities", angleToLine: true, offset: 0, extremityPlacement: e15, offsetAlongLine: 0 }, c4.push(t16);
    }
    return c4.push({ type: "CIMSolidStroke", color: "none" !== i14 && "esriSLSNull" !== i14 ? ue(r16) : [0, 0, 0, 0], capStyle: ce(t15), joinStyle: fe(o6), miterLimit: s13, width: n19, effects: l9 }), { type: "CIMLineSymbol", symbolLayers: c4 };
  }
  static fromPictureMarker(e14) {
    const { angle: t15, height: r16, width: o6, xoffset: a11, yoffset: s13 } = e14;
    let i14 = e14.url;
    return "esriPMS" === e14.type && e14.imageData && (i14 = e14.imageData), { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMPictureMarker", invertBackfaceTexture: false, scaleX: 1, textureFilter: ie.Picture, tintColor: null, url: i14, size: r16, width: o6, offsetX: b2(a11), offsetY: b2(s13), rotation: b2(-t15) }] };
  }
  static fromSimpleMarker(e14, t15, r16) {
    const { style: o6 } = e14, a11 = e14.color ?? r16;
    if ("path" === o6) {
      const t16 = [];
      if ("outline" in e14 && e14.outline) {
        const r18 = e14.outline;
        t16.push({ type: "CIMSolidStroke", enable: true, width: u3(Math.round(e2(r18.width))), color: ue(r18.color), path: e14.path });
      }
      t16.push({ type: "CIMSolidFill", enable: true, color: ue(a11), path: e14.path });
      const [r17, o7] = be("square");
      return { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, rotation: b2(-e14.angle), size: b2(e14.size || 6), offsetX: b2(e14.xoffset), offsetY: b2(e14.yoffset), frame: r17, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: o7, symbol: { type: "CIMPolygonSymbol", symbolLayers: t16 } }] }] };
    }
    const n19 = [];
    let l9, c4;
    if ("outline" in e14 && e14.outline && "none" !== e14.outline.style && "esriSLSNull" !== e14.outline.style) {
      const t16 = e14.outline, r17 = "solid" !== t16.style && "esriSLSSolid" !== t16.style;
      [l9, c4] = r17 ? be(o6, e14.size) : be(o6);
      const a12 = "cross" !== e14.style && "x" !== e14.style || "dot" === (e14 == null ? void 0 : e14.outline.style) || "short-dot" === (e14 == null ? void 0 : e14.outline.style) ? k2.HalfGap : k2.FullPattern, f6 = r17 ? [{ type: "CIMGeometricEffectAddControlPoints" }, { type: "CIMGeometricEffectDashes", dashTemplate: de(t16.style, null).map((e15) => t16.width && t16.width > 0 ? e15 * t16.width : e15), lineDashEnding: a12, controlPointEnding: k2.FullPattern }] : void 0;
      n19.push({ type: "CIMSolidStroke", capStyle: r17 ? U2.Round : U2.Butt, enable: true, width: null != t16.width && t16.width > 0.667 ? u3(Math.round(e2(t16.width))) : t16.width, color: ue(t16.color), effects: f6 });
    } else
      !t15 || "line-marker" !== e14.type || "cross" !== e14.style && "x" !== e14.style ? [l9, c4] = be(o6) : ([l9, c4] = be(o6), n19.push({ type: "CIMSolidStroke", enable: true, width: t15, color: ue(a11) }));
    n19.push({ type: "CIMSolidFill", enable: true, color: ue(a11) });
    const f5 = { type: "CIMPolygonSymbol", symbolLayers: n19 };
    return { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, rotation: b2(-e14.angle), size: b2(e14.size || 6 * t15), offsetX: b2(e14.xoffset), offsetY: b2(e14.yoffset), frame: l9, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: c4, symbol: f5 }] }] };
  }
  static fromCIMHatchFill(e14, t15) {
    var _a;
    const o6 = t15 * (e14.separation ?? Y2), a11 = o6 / 2, s13 = a(e14.lineSymbol);
    (_a = s13.symbolLayers) == null ? void 0 : _a.forEach((e15) => {
      var _a2;
      switch (e15.type) {
        case "CIMSolidStroke":
          null != e15.width && (e15.width *= t15), (_a2 = e15.effects) == null ? void 0 : _a2.forEach((e16) => {
            "CIMGeometricEffectDashes" === e16.type && (e16.dashTemplate = e16.dashTemplate.map((e17) => e17 * t15));
          });
          break;
        case "CIMVectorMarker": {
          null != e15.size && (e15.size *= t15);
          const r16 = e15.markerPlacement;
          null != r16 && "placementTemplate" in r16 && (r16.placementTemplate = r16.placementTemplate.map((e16) => e16 * t15));
          break;
        }
      }
    });
    let i14 = this._getLineSymbolPeriod(s13) || Z3;
    for (; i14 < Z3; )
      i14 *= 2;
    const n19 = i14 / 2;
    return { type: "CIMVectorMarker", frame: { xmin: -n19, xmax: n19, ymin: -a11, ymax: a11 }, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: { paths: [[[-n19, 0], [n19, 0]]] }, symbol: s13 }], size: o6 };
  }
  static fetchResources(e14, t15, r16) {
    if (e14 && t15)
      switch (e14.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol": {
          const o6 = e14.symbolLayers;
          if (!o6)
            return;
          for (const e15 of o6)
            switch (Ie(e15, t15, r16), e15.type) {
              case "CIMPictureFill":
              case "CIMHatchFill":
              case "CIMGradientFill":
              case "CIMPictureStroke":
              case "CIMGradientStroke":
              case "CIMCharacterMarker":
              case "CIMPictureMarker":
                "url" in e15 && e15.url && r16.push(t15.fetchResource(e15.url, null));
                break;
              case "CIMVectorMarker": {
                const o7 = e15.markerGraphics;
                if (!o7)
                  continue;
                for (const e16 of o7)
                  if (e16) {
                    const o8 = e16.symbol;
                    o8 && _ne.fetchResources(o8, t15, r16);
                  }
              }
            }
          break;
        }
      }
  }
  static fetchFonts(e14, t15, r16) {
    if (e14 && t15) {
      if ("symbolLayers" in e14 && e14.symbolLayers) {
        for (const o6 of e14.symbolLayers)
          if ("CIMVectorMarker" === o6.type && o6.markerGraphics)
            for (const e15 of o6.markerGraphics)
              (e15 == null ? void 0 : e15.symbol) && _ne.fetchFonts(e15.symbol, t15, r16);
      } else if ("CIMTextSymbol" === e14.type) {
        const { fontFamilyName: o6, fontStyleName: a11 } = e14;
        if (!o6 || "calcitewebcoreicons" === o6.toLowerCase())
          return;
        const { style: s13, weight: i14 } = S(a11), n19 = k3(e14), l9 = new m3({ family: o6, style: s13, weight: i14, decoration: n19 });
        r16.push(t15.loadFont(l9).catch(() => {
          ee.error(`Unsupported font ${o6} in CIM symbol`);
        }));
      }
    }
  }
  static _getLineSymbolPeriod(e14) {
    if (e14) {
      const t15 = this._getEffectsRepeat(e14.effects);
      if (t15)
        return t15;
      if (e14.symbolLayers) {
        for (const r16 of e14.symbolLayers)
          if (r16) {
            const e15 = this._getEffectsRepeat(r16.effects);
            if (e15)
              return e15;
            switch (r16.type) {
              case "CIMCharacterMarker":
              case "CIMPictureMarker":
              case "CIMVectorMarker":
              case "CIMObjectMarker3D":
              case "CIMglTFMarker3D": {
                const e16 = this._getPlacementRepeat(r16.markerPlacement);
                if (e16)
                  return e16;
              }
            }
          }
      }
    }
    return 0;
  }
  static _getEffectsRepeat(e14) {
    if (e14) {
      for (const t15 of e14)
        if (t15)
          switch (t15.type) {
            case "CIMGeometricEffectDashes": {
              const e15 = t15.dashTemplate;
              if (e15 && e15.length) {
                let t16 = 0;
                for (const r16 of e15)
                  t16 += r16;
                return 1 & e15.length && (t16 *= 2), t16;
              }
              break;
            }
            case "CIMGeometricEffectWave":
              return t15.period;
            default:
              ee.error(`unsupported geometric effect type ${t15.type}`);
          }
    }
    return 0;
  }
  static _getPlacementRepeat(e14) {
    if (e14)
      switch (e14.type) {
        case "CIMMarkerPlacementAlongLineSameSize":
        case "CIMMarkerPlacementAlongLineRandomSize":
        case "CIMMarkerPlacementAlongLineVariableSize": {
          const t15 = e14.placementTemplate;
          if (t15 && t15.length) {
            let e15 = 0;
            for (const r16 of t15)
              e15 += +r16;
            return 1 & t15.length && (e15 *= 2), e15;
          }
          break;
        }
      }
    return 0;
  }
  static fromCIMInsidePolygon(e14) {
    const t15 = e14.markerPlacement, r16 = { ...e14 };
    r16.markerPlacement = null, r16.anchorPoint = null;
    const o6 = Math.abs(t15.stepX), s13 = Math.abs(t15.stepY), n19 = (t15.randomness ?? 100) / 100;
    let l9, c4, f5, m7;
    if ("Random" === t15.gridType) {
      const e15 = e2(se), r17 = Math.max(Math.floor(e15 / o6), 1), y3 = Math.max(Math.floor(e15 / s13), 1);
      l9 = r17 * o6 / 2, c4 = y3 * s13 / 2, f5 = 2 * c4;
      const u9 = new t(t15.seed), h8 = n19 * o6 / 1.5, p3 = n19 * s13 / 1.5;
      m7 = [];
      for (let t16 = 0; t16 < r17; t16++)
        for (let e16 = 0; e16 < y3; e16++) {
          const r18 = t16 * o6 - l9 + h8 * (0.5 - u9.getFloat()), a11 = e16 * s13 - c4 + p3 * (0.5 - u9.getFloat());
          m7.push({ x: r18, y: a11 }), 0 === t16 && m7.push({ x: r18 + 2 * l9, y: a11 }), 0 === e16 && m7.push({ x: r18, y: a11 + 2 * c4 });
        }
    } else
      true === t15.shiftOddRows ? (l9 = o6 / 2, c4 = s13, f5 = 2 * s13, m7 = [{ x: -l9, y: 0 }, { x: l9, y: 0 }, { x: 0, y: c4 }, { x: 0, y: -c4 }]) : (l9 = o6 / 2, c4 = s13 / 2, f5 = s13, m7 = [{ x: -o6, y: 0 }, { x: 0, y: -s13 }, { x: -o6, y: -s13 }, { x: 0, y: 0 }, { x: o6, y: 0 }, { x: 0, y: s13 }, { x: o6, y: s13 }, { x: -o6, y: s13 }, { x: o6, y: -s13 }]);
    return { type: "CIMVectorMarker", frame: { xmin: -l9, xmax: l9, ymin: -c4, ymax: c4 }, markerGraphics: m7.map((e15) => ({ type: "CIMMarkerGraphic", geometry: e15, symbol: { type: "CIMPointSymbol", symbolLayers: [r16] } })), size: f5 };
  }
  static getSize(e14) {
    if (e14)
      switch (e14.type) {
        case "CIMTextSymbol":
          return e14.height;
        case "CIMPointSymbol": {
          let t15 = 0;
          if (e14.symbolLayers) {
            for (const r16 of e14.symbolLayers)
              if (r16)
                switch (r16.type) {
                  case "CIMCharacterMarker":
                  case "CIMPictureMarker":
                  case "CIMVectorMarker":
                  case "CIMObjectMarker3D":
                  case "CIMglTFMarker3D": {
                    const e15 = r16.size;
                    null != e15 && e15 > t15 && (t15 = e15);
                    break;
                  }
                }
          }
          return t15;
        }
        case "CIMLineSymbol":
        case "CIMPolygonSymbol": {
          let t15 = 0;
          if (e14.symbolLayers) {
            for (const r16 of e14.symbolLayers)
              if (r16)
                switch (r16.type) {
                  case "CIMSolidStroke":
                  case "CIMPictureStroke":
                  case "CIMGradientStroke": {
                    const e15 = r16.width;
                    null != e15 && e15 > t15 && (t15 = e15);
                    break;
                  }
                  case "CIMCharacterMarker":
                  case "CIMPictureMarker":
                  case "CIMVectorMarker":
                  case "CIMObjectMarker3D":
                  case "CIMglTFMarker3D":
                    if (r16.markerPlacement && m4(r16.markerPlacement)) {
                      const e15 = r16.size;
                      null != e15 && e15 > t15 && (t15 = e15);
                    }
                }
          }
          return t15;
        }
      }
  }
  static getMarkerScaleRatio(e14) {
    if (e14 && "CIMVectorMarker" === e14.type) {
      if (false !== e14.scaleSymbolsProportionally && e14.frame && null != e14.size) {
        const t15 = e14.frame.ymax - e14.frame.ymin;
        return e14.size / t15;
      }
    }
    return 1;
  }
};
var le = class _le {
  static findApplicableOverrides(e14, t15, r16) {
    if (e14 && t15) {
      if (e14.primitiveName) {
        let o6 = false;
        for (const t16 of r16)
          if (t16.primitiveName === e14.primitiveName) {
            o6 = true;
            break;
          }
        if (!o6)
          for (const a11 of t15)
            a11.primitiveName === e14.primitiveName && r16.push(a11);
      }
      switch (e14.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol":
          if (e14.effects)
            for (const o6 of e14.effects)
              _le.findApplicableOverrides(o6, t15, r16);
          if (e14.symbolLayers)
            for (const o6 of e14.symbolLayers)
              _le.findApplicableOverrides(o6, t15, r16);
          break;
        case "CIMTextSymbol":
          break;
        case "CIMSolidStroke":
        case "CIMPictureStroke":
        case "CIMGradientStroke":
        case "CIMSolidFill":
        case "CIMPictureFill":
        case "CIMHatchFill":
        case "CIMGradientFill":
        case "CIMVectorMarker":
        case "CIMCharacterMarker":
        case "CIMPictureMarker":
          if (e14.effects)
            for (const o6 of e14.effects)
              _le.findApplicableOverrides(o6, t15, r16);
          if (e14.markerPlacement && _le.findApplicableOverrides(e14.markerPlacement, t15, r16), "CIMVectorMarker" === e14.type) {
            if (e14.markerGraphics)
              for (const o6 of e14.markerGraphics)
                _le.findApplicableOverrides(o6, t15, r16), _le.findApplicableOverrides(o6.symbol, t15, r16);
          } else
            "CIMCharacterMarker" === e14.type ? _le.findApplicableOverrides(e14.symbol, t15, r16) : "CIMHatchFill" === e14.type ? _le.findApplicableOverrides(e14.lineSymbol, t15, r16) : "CIMPictureMarker" === e14.type && _le.findApplicableOverrides(e14.animatedSymbolProperties, t15, r16);
      }
    }
  }
  static findEffectOverrides(e14, t15, r16) {
    if (!t15 || !e14)
      return;
    const o6 = e14.length;
    for (let a11 = 0; a11 < o6; a11++) {
      const o7 = e14[a11], s13 = o7 == null ? void 0 : o7.primitiveName;
      if (s13) {
        let e15 = false;
        for (const t16 of r16)
          if (t16.primitiveName === s13) {
            e15 = true;
            break;
          }
        if (!e15)
          for (const o8 of t15)
            o8.primitiveName === s13 && r16.push(o8);
      }
    }
  }
  static async resolveSymbolOverrides(e14, t15, o6, a11, s13, i14, n19) {
    if (!(e14 == null ? void 0 : e14.symbol))
      return null;
    let { symbol: l9, primitiveOverrides: c4 } = e14;
    const f5 = !!c4;
    if (!f5 && !a11)
      return l9;
    l9 = a(l9);
    let m7 = true;
    if (t15 || (t15 = { attributes: {} }, m7 = false), f5) {
      if (m7 || (c4 = c4.filter((e15) => {
        var _a;
        return !((_a = e15.valueExpressionInfo) == null ? void 0 : _a.expression.includes("$feature"));
      })), n19 || (c4 = c4.filter((e15) => {
        var _a;
        return !((_a = e15.valueExpressionInfo) == null ? void 0 : _a.expression.includes("$view"));
      })), c4.length > 0) {
        const e15 = A2(t15.attributes);
        await _le.evaluateOverrides(c4, t15, { spatialReference: o6, fields: e15, geometryType: s13 }, i14, n19);
      }
      _le.applyOverrides(l9, c4);
    }
    return a11 && _le.applyDictionaryTextOverrides(l9, t15, a11), l9;
  }
  static async evaluateOverrides(e14, t15, r16, o6, a11) {
    if (!t15)
      return;
    let s13;
    for (const i14 of e14) {
      const e15 = i14.valueExpressionInfo;
      if (e15 && (r16 == null ? void 0 : r16.geometryType)) {
        s13 || (s13 = []), i14.value = void 0;
        const n19 = n5(e15.expression, r16.spatialReference, r16.fields).then((e16) => {
          i14.value = s12(e16, t15, { $view: a11 }, r16.geometryType, o6);
        });
        s13.push(n19);
      }
    }
    void 0 !== s13 && s13.length > 0 && await Promise.all(s13);
  }
  static applyDictionaryTextOverrides(e14, t15, r16, o6 = "Normal") {
    if (e14 == null ? void 0 : e14.type)
      switch (e14.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol":
        case "CIMTextSymbol":
          {
            const a11 = e14.symbolLayers;
            if (!a11)
              return;
            for (const s13 of a11)
              s13 && "CIMVectorMarker" === s13.type && _le.applyDictionaryTextOverrides(s13, t15, r16, "CIMTextSymbol" === e14.type ? e14.textCase : o6);
          }
          break;
        case "CIMVectorMarker":
          {
            const o7 = e14.markerGraphics;
            if (!o7)
              return;
            for (const e15 of o7)
              e15 && _le.applyDictionaryTextOverrides(e15, t15, r16);
          }
          break;
        case "CIMMarkerGraphic": {
          const a11 = e14.textString;
          if (a11 && a11.includes("[")) {
            const s13 = i2(a11, r16);
            e14.textString = l5(t15, s13, o6);
          }
        }
      }
  }
  static applyOverrides(e14, t15, r16, o6) {
    if (e14.primitiveName) {
      for (const a11 of t15)
        if (a11.primitiveName === e14.primitiveName) {
          const t16 = ge(a11.propertyName);
          if (o6 && o6.push({ cim: e14, nocapPropertyName: t16, value: e14[t16] }), a11.expression && (a11.value = _le.toValue(a11.propertyName, a11.expression)), r16) {
            let t17 = false;
            for (const o7 of r16)
              o7.primitiveName === e14.primitiveName && (t17 = true);
            t17 || r16.push(a11);
          }
          null != a11.value && (e14[t16] = a11.value);
        }
    }
    switch (e14.type) {
      case "CIMPointSymbol":
      case "CIMLineSymbol":
      case "CIMPolygonSymbol":
        if (e14.effects)
          for (const a11 of e14.effects)
            _le.applyOverrides(a11, t15, r16, o6);
        if (e14.symbolLayers)
          for (const a11 of e14.symbolLayers)
            _le.applyOverrides(a11, t15, r16, o6);
        break;
      case "CIMTextSymbol":
        break;
      case "CIMSolidStroke":
      case "CIMSolidFill":
      case "CIMVectorMarker":
        if (e14.effects)
          for (const a11 of e14.effects)
            _le.applyOverrides(a11, t15, r16, o6);
        if ("CIMVectorMarker" === e14.type && e14.markerGraphics)
          for (const a11 of e14.markerGraphics)
            _le.applyOverrides(a11, t15, r16, o6), _le.applyOverrides(a11.symbol, t15, r16, o6);
    }
  }
  static restoreOverrides(e14) {
    for (const t15 of e14)
      t15.cim[t15.nocapPropertyName] = t15.value;
  }
  static buildOverrideKey(e14) {
    let t15 = "";
    for (const r16 of e14)
      void 0 !== r16.value && (t15 += `${r16.primitiveName}${r16.propertyName}${JSON.stringify(r16.value)}`);
    return t15;
  }
  static toValue(t15, r16) {
    if ("DashTemplate" === t15)
      return r16.split(" ").map((e14) => Number(e14));
    if ("Color" === t15) {
      const t16 = new u5(r16).toRgba();
      return t16[3] *= 255, t16;
    }
    return r16;
  }
};
var ce = (e14) => {
  if (!e14)
    return U2.Butt;
  switch (e14) {
    case "butt":
      return U2.Butt;
    case "square":
      return U2.Square;
    case "round":
      return U2.Round;
  }
};
var fe = (e14) => {
  if (!e14)
    return w2.Miter;
  switch (e14) {
    case "miter":
      return w2.Miter;
    case "round":
      return w2.Round;
    case "bevel":
      return w2.Bevel;
  }
};
var me = (e14) => {
  if (null == e14)
    return "Center";
  switch (e14) {
    case "left":
      return "Left";
    case "right":
      return "Right";
    case "center":
      return "Center";
  }
};
var ye = (e14) => {
  if (null == e14)
    return "Center";
  switch (e14) {
    case "baseline":
      return "Baseline";
    case "top":
      return "Top";
    case "middle":
      return "Center";
    case "bottom":
      return "Bottom";
  }
};
var ue = (e14) => {
  if (!e14)
    return [0, 0, 0, 0];
  const { r: t15, g: r16, b: o6, a: a11 } = e14;
  return [t15, r16, o6, 255 * a11];
};
var he = (e14, t15) => {
  const r16 = pe(t15), o6 = Me(e14);
  return r16 && o6 ? `${r16}-${o6}` : `${r16}${o6}`;
};
var pe = (e14) => {
  if (!e14)
    return "";
  switch (e14.toLowerCase()) {
    case "bold":
    case "bolder":
      return "bold";
  }
  return "";
};
var Me = (e14) => {
  if (!e14)
    return "";
  switch (e14.toLowerCase()) {
    case "italic":
    case "oblique":
      return "italic";
  }
  return "";
};
var de = (e14, t15) => {
  const r16 = has("safari") ? 1e-3 : 0, o6 = "butt" === t15;
  switch (e14) {
    case "dash":
    case "esriSLSDash":
      return o6 ? [4, 3] : [3, 4];
    case "dash-dot":
    case "esriSLSDashDot":
      return o6 ? [4, 3, 1, 3] : [3, 4, r16, 4];
    case "dot":
    case "esriSLSDot":
      return o6 ? [1, 3] : [r16, 4];
    case "long-dash":
    case "esriSLSLongDash":
      return o6 ? [8, 3] : [7, 4];
    case "long-dash-dot":
    case "esriSLSLongDashDot":
      return o6 ? [8, 3, 1, 3] : [7, 4, r16, 4];
    case "long-dash-dot-dot":
    case "esriSLSDashDotDot":
      return o6 ? [8, 3, 1, 3, 1, 3] : [7, 4, r16, 4, r16, 4];
    case "short-dash":
    case "esriSLSShortDash":
      return o6 ? [4, 1] : [3, 2];
    case "short-dash-dot":
    case "esriSLSShortDashDot":
      return o6 ? [4, 1, 1, 1] : [3, 2, r16, 2];
    case "short-dash-dot-dot":
    case "esriSLSShortDashDotDot":
      return o6 ? [4, 1, 1, 1, 1, 1] : [3, 2, r16, 2, r16, 2];
    case "short-dot":
    case "esriSLSShortDot":
      return o6 ? [1, 1] : [r16, 2];
    case "solid":
    case "esriSLSSolid":
    case "none":
      return ee.error("Unexpected: style does not require rasterization"), [0, 0];
    default:
      return ee.error(`Tried to rasterize SLS, but found an unexpected style: ${e14}!`), [0, 0];
  }
};
function Se(e14) {
  return void 0 !== e14.symbolLayers;
}
var be = (e14, t15 = 100) => {
  const r16 = t15 / 2;
  let o6, a11;
  const s13 = e14;
  if ("circle" === s13 || "esriSMSCircle" === s13) {
    const e15 = 0.25;
    let t16 = Math.acos(1 - e15 / r16), s14 = Math.ceil(W2 / t16 / 4);
    0 === s14 && (s14 = 1), t16 = J2 / s14, s14 *= 4;
    const i14 = [];
    i14.push([r16, 0]);
    for (let o7 = 1; o7 < s14; o7++)
      i14.push([r16 * Math.cos(o7 * t16), -r16 * Math.sin(o7 * t16)]);
    i14.push([r16, 0]), o6 = { rings: [i14] }, a11 = { xmin: -r16, ymin: -r16, xmax: r16, ymax: r16 };
  } else if ("cross" === s13 || "esriSMSCross" === s13) {
    const e15 = 0;
    o6 = { paths: [[[e15, r16], [e15, -r16]], [[r16, e15], [-r16, e15]]] }, a11 = { xmin: -r16, ymin: -r16, xmax: r16, ymax: r16 };
  } else if ("diamond" === s13 || "esriSMSDiamond" === s13)
    o6 = { rings: [[[-r16, 0], [0, r16], [r16, 0], [0, -r16], [-r16, 0]]] }, a11 = { xmin: -r16, ymin: -r16, xmax: r16, ymax: r16 };
  else if ("square" === s13 || "esriSMSSquare" === s13)
    o6 = { rings: [[[-r16, -r16], [-r16, r16], [r16, r16], [r16, -r16], [-r16, -r16]]] }, a11 = { xmin: -r16, ymin: -r16, xmax: r16, ymax: r16 };
  else if ("x" === s13 || "esriSMSX" === s13)
    o6 = { paths: [[[r16, r16], [-r16, -r16]], [[r16, -r16], [-r16, r16]]] }, a11 = { xmin: -r16, ymin: -r16, xmax: r16, ymax: r16 };
  else if ("triangle" === s13 || "esriSMSTriangle" === s13) {
    const e15 = t15 * 0.5773502691896257, r17 = -e15, s14 = 2 / 3 * t15, i14 = s14 - t15;
    o6 = { rings: [[[r17, i14], [0, s14], [e15, i14], [r17, i14]]] }, a11 = { xmin: r17, ymin: i14, xmax: e15, ymax: s14 };
  } else
    "arrow" === s13 && (o6 = { rings: [[[-50, 50], [50, 0], [-50, -50], [-33, -20], [-33, 20], [-50, 50]]] }, a11 = { xmin: -r16, ymin: -r16, xmax: r16, ymax: r16 });
  return [a11, o6];
};
var Ce = (e14) => "vertical" === e14 || "horizontal" === e14 || "cross" === e14 || "esriSFSCross" === e14 || "esriSFSVertical" === e14 || "esriSFSHorizontal" === e14;
var ge = (e14) => e14 ? e14.charAt(0).toLowerCase() + e14.substr(1) : e14;
function Ie(e14, t15, r16) {
  if (!e14.effects || null != t15.geometryEngine)
    return;
  if (t15.geometryEnginePromise)
    return void r16.push(t15.geometryEnginePromise);
  d(e14.effects) && (t15.geometryEnginePromise = I(), r16.push(t15.geometryEnginePromise), t15.geometryEnginePromise.then((e15) => t15.geometryEngine = e15));
}
function ke(e14) {
  if (!e14)
    return null;
  let t15 = null;
  const { cap: r16, color: o6, join: a11, miterLimit: s13, style: i14, width: n19 } = e14;
  return "solid" !== i14 && "none" !== i14 && "esriSLSSolid" !== i14 && "esriSLSNull" !== i14 && (t15 = [{ type: "CIMGeometricEffectDashes", dashTemplate: de(i14, r16), lineDashEnding: "NoConstraint", scaleDash: true, offsetAlongLine: null }]), { type: "CIMSolidStroke", color: "esriSLSNull" !== i14 && "none" !== i14 ? ue(o6) : [0, 0, 0, 0], capStyle: ce(r16), joinStyle: fe(a11), miterLimit: s13, width: n19, effects: t15 };
}

export {
  i3 as i,
  s5 as s,
  A3 as A,
  g2 as g,
  S2 as S,
  t14 as t,
  r15 as r,
  O3 as O,
  q2 as q,
  V,
  Y2 as Y,
  W,
  Q,
  tt,
  et,
  s12 as s2,
  te,
  se2 as se,
  ie2 as ie,
  ne2 as ne,
  le,
  de
};
//# sourceMappingURL=chunk-WR3GXMXV.js.map
