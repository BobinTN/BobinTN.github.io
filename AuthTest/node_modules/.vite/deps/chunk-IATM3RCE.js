import {
  l
} from "./chunk-PJQIAD5D.js";
import {
  e
} from "./chunk-EIY2DYTV.js";
import {
  o,
  s
} from "./chunk-F6MD5VOH.js";

// node_modules/@arcgis/core/chunks/mat4f32.js
function e2() {
  const e5 = new Float32Array(16);
  return e5[0] = 1, e5[5] = 1, e5[10] = 1, e5[15] = 1, e5;
}
function r(e5) {
  const r3 = new Float32Array(16);
  return r3[0] = e5[0], r3[1] = e5[1], r3[2] = e5[2], r3[3] = e5[3], r3[4] = e5[4], r3[5] = e5[5], r3[6] = e5[6], r3[7] = e5[7], r3[8] = e5[8], r3[9] = e5[9], r3[10] = e5[10], r3[11] = e5[11], r3[12] = e5[12], r3[13] = e5[13], r3[14] = e5[14], r3[15] = e5[15], r3;
}
function t(e5, r3, t3, n2, o4, a3, c3, u2, l4, s3, f2, i, y2, w, b, A) {
  const F = new Float32Array(16);
  return F[0] = e5, F[1] = r3, F[2] = t3, F[3] = n2, F[4] = o4, F[5] = a3, F[6] = c3, F[7] = u2, F[8] = l4, F[9] = s3, F[10] = f2, F[11] = i, F[12] = y2, F[13] = w, F[14] = b, F[15] = A, F;
}
function n(e5, r3) {
  return new Float32Array(e5, r3, 16);
}
var o2 = e2();
var a = Object.freeze(Object.defineProperty({ __proto__: null, IDENTITY: o2, clone: r, create: e2, createView: n, fromValues: t }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/layers/effects/colorMatrixFunctions.js
var r2 = (r3, s3) => {
  const o4 = s(r3, s3, 0, 0, 0, 0, s3, 0, 0, 0, 0, s3, 0, 0, 0, 0, 1);
  return o(o4, o4);
};
var s2 = (r3, s3) => {
  const o4 = s(r3, s3, 0, 0, 0.5 - 0.5 * s3, 0, s3, 0, 0.5 - 0.5 * s3, 0, 0, s3, 0.5 - 0.5 * s3, 0, 0, 0, 1);
  return o(o4, o4);
};
var o3 = (r3, s3) => {
  const o4 = 1 - s3, c3 = s(r3, 0.2126 + 0.7874 * o4, 0.7152 - 0.7152 * o4, 0.0722 - 0.0722 * o4, 0, 0.2126 - 0.2126 * o4, 0.7152 + 0.2848 * o4, 0.0722 - 0.0722 * o4, 0, 0.2126 - 0.2126 * o4, 0.7152 - 0.7152 * o4, 0.0722 + 0.9278 * o4, 0, 0, 0, 0, 1);
  return o(c3, c3);
};
var c = (r3, s3) => {
  const o4 = Math.sin(s3 * Math.PI / 180), c3 = Math.cos(s3 * Math.PI / 180), e5 = s(r3, 0.213 + 0.787 * c3 - 0.213 * o4, 0.715 - 0.715 * c3 - 0.715 * o4, 0.072 - 0.072 * c3 + 0.928 * o4, 0, 0.213 - 0.213 * c3 + 0.143 * o4, 0.715 + 0.285 * c3 + 0.14 * o4, 0.072 - 0.072 * c3 - 0.283 * o4, 0, 0.213 - 0.213 * c3 - 0.787 * o4, 0.715 - 0.715 * c3 + 0.715 * o4, 0.072 + 0.928 * c3 + 0.072 * o4, 0, 0, 0, 0, 1);
  return o(e5, e5);
};
var e3 = (r3, s3) => {
  const o4 = 1 - 2 * s3, c3 = s(r3, o4, 0, 0, s3, 0, o4, 0, s3, 0, 0, o4, s3, 0, 0, 0, 1);
  return o(c3, c3);
};
var u = (r3, s3) => {
  const o4 = s(r3, 0.213 + 0.787 * s3, 0.715 - 0.715 * s3, 0.072 - 0.072 * s3, 0, 0.213 - 0.213 * s3, 0.715 + 0.285 * s3, 0.072 - 0.072 * s3, 0, 0.213 - 0.213 * s3, 0.715 - 0.715 * s3, 0.072 + 0.928 * s3, 0, 0, 0, 0, 1);
  return o(o4, o4);
};
var a2 = (r3, s3) => {
  const o4 = 1 - s3, c3 = s(r3, 0.393 + 0.607 * o4, 0.769 - 0.769 * o4, 0.189 - 0.189 * o4, 0, 0.349 - 0.349 * o4, 0.686 + 0.314 * o4, 0.168 - 0.168 * o4, 0, 0.272 - 0.272 * o4, 0.534 - 0.534 * o4, 0.131 + 0.869 * o4, 0, 0, 0, 0, 1);
  return o(c3, c3);
};

// node_modules/@arcgis/core/layers/effects/effects.js
var c2 = class _c {
  constructor(t3, s3, r3) {
    this.strength = t3, this.radius = s3, this.threshold = r3, this.type = "bloom";
  }
  interpolate(t3, s3, r3) {
    this.strength = M(t3.strength, s3.strength, r3), this.radius = M(t3.radius, s3.radius, r3), this.threshold = M(t3.threshold, s3.threshold, r3);
  }
  clone() {
    return new _c(this.strength, this.radius, this.threshold);
  }
  toJSON() {
    return { type: "bloom", radius: y(this.radius), strength: this.strength, threshold: this.threshold };
  }
};
var l2 = class _l {
  constructor(t3) {
    this.radius = t3, this.type = "blur";
  }
  interpolate(t3, s3, r3) {
    this.radius = Math.round(M(t3.radius, s3.radius, r3));
  }
  clone() {
    return new _l(this.radius);
  }
  toJSON() {
    return { type: "blur", radius: y(this.radius) };
  }
};
var p = class _p {
  constructor(t3, s3) {
    this.type = t3, this.amount = s3, "invert" !== this.type && "grayscale" !== this.type && "sepia" !== this.type || (this.amount = Math.min(this.amount, 1));
  }
  get colorMatrix() {
    return this._colorMatrix || this._updateMatrix(), this._colorMatrix;
  }
  interpolate(t3, s3, r3) {
    this.amount = M(t3.amount, s3.amount, r3), this._updateMatrix();
  }
  clone() {
    return new _p(this.type, this.amount);
  }
  toJSON() {
    return { type: this.type, amount: this.amount };
  }
  _updateMatrix() {
    const t3 = this._colorMatrix || e2();
    switch (this.type) {
      case "brightness":
        this._colorMatrix = r2(t3, this.amount);
        break;
      case "contrast":
        this._colorMatrix = s2(t3, this.amount);
        break;
      case "grayscale":
        this._colorMatrix = o3(t3, this.amount);
        break;
      case "invert":
        this._colorMatrix = e3(t3, this.amount);
        break;
      case "saturate":
        this._colorMatrix = u(t3, this.amount);
        break;
      case "sepia":
        this._colorMatrix = a2(t3, this.amount);
    }
  }
};
var d = class _d {
  constructor(t3, s3, r3, o4) {
    this.offsetX = t3, this.offsetY = s3, this.blurRadius = r3, this.color = o4, this.type = "drop-shadow";
  }
  interpolate(t3, s3, r3) {
    this.offsetX = M(t3.offsetX, s3.offsetX, r3), this.offsetY = M(t3.offsetY, s3.offsetY, r3), this.blurRadius = M(t3.blurRadius, s3.blurRadius, r3), this.color[0] = Math.round(M(t3.color[0], s3.color[0], r3)), this.color[1] = Math.round(M(t3.color[1], s3.color[1], r3)), this.color[2] = Math.round(M(t3.color[2], s3.color[2], r3)), this.color[3] = M(t3.color[3], s3.color[3], r3);
  }
  clone() {
    return new _d(this.offsetX, this.offsetY, this.blurRadius, [...this.color]);
  }
  toJSON() {
    const t3 = [...this.color];
    return t3[3] *= 255, { type: "drop-shadow", xoffset: y(this.offsetX), yoffset: y(this.offsetY), blurRadius: y(this.blurRadius), color: t3 };
  }
};
var m = class _m {
  constructor(t3) {
    this.angle = t3, this.type = "hue-rotate";
  }
  get colorMatrix() {
    return this._colorMatrix || this._updateMatrix(), this._colorMatrix;
  }
  interpolate(t3, s3, r3) {
    this.angle = M(t3.angle, s3.angle, r3), this._updateMatrix();
  }
  clone() {
    return new _m(this.angle);
  }
  toJSON() {
    return { type: "hue-rotate", angle: this.angle };
  }
  _updateMatrix() {
    const t3 = this._colorMatrix || e2();
    this._colorMatrix = c(t3, this.angle);
  }
};
var f = class _f {
  constructor(t3) {
    this.amount = t3, this.type = "opacity", this.amount = Math.min(this.amount, 1);
  }
  interpolate(t3, s3, r3) {
    this.amount = M(t3.amount, s3.amount, r3);
  }
  clone() {
    return new _f(this.amount);
  }
  toJSON() {
    return { type: "opacity", amount: this.amount };
  }
};
function M(t3, s3, r3) {
  return t3 + (s3 - t3) * r3;
}
function y(t3) {
  return Math.round(1e3 * e(t3)) / 1e3;
}
function x(s3) {
  switch (s3.type) {
    case "grayscale":
    case "sepia":
    case "invert":
      return new p(s3.type, 0);
    case "saturate":
    case "brightness":
    case "contrast":
      return new p(s3.type, 1);
    case "opacity":
      return new f(1);
    case "hue-rotate":
      return new m(0);
    case "blur":
      return new l2(0);
    case "drop-shadow":
      return new d(0, 0, 0, [...l("transparent")]);
    case "bloom":
      return new c2(0, 0, 1);
  }
}

// node_modules/@arcgis/core/layers/effects/utils.js
function t2(n2, t3) {
  const e5 = n2.length > t3.length ? n2 : t3;
  return (n2.length > t3.length ? t3 : n2).every((n3, t4) => n3.type === e5[t4].type);
}
function e4(t3, e5) {
  const l4 = t3.length > e5.length ? t3 : e5, r3 = t3.length > e5.length ? e5 : t3;
  for (let g = r3.length; g < l4.length; g++)
    r3.push(x(l4[g]));
}
function l3(n2) {
  const t3 = n2[0];
  return !!t3 && "type" in t3;
}

export {
  c2 as c,
  l2 as l,
  p,
  d,
  m,
  f,
  t2 as t,
  e4 as e,
  l3 as l2
};
//# sourceMappingURL=chunk-IATM3RCE.js.map
