import {
  M as M2,
  c,
  e,
  f as f2,
  h,
  i,
  r as r4
} from "./chunk-EY7PGBJG.js";
import {
  n,
  r as r3
} from "./chunk-CMGHBCKF.js";
import {
  C,
  a,
  g,
  j,
  l,
  o,
  q,
  r as r2,
  s,
  v as v2,
  y,
  z as z2
} from "./chunk-NDKHIQMD.js";
import {
  P,
  v
} from "./chunk-LOGPPZUD.js";
import {
  l as l2
} from "./chunk-J2R5B4T4.js";
import {
  D,
  E,
  _,
  b
} from "./chunk-4HKQSEUR.js";
import {
  r
} from "./chunk-GINTRQSD.js";
import {
  V
} from "./chunk-JUZJCTW2.js";
import {
  M
} from "./chunk-Y5D433JZ.js";
import {
  p,
  x2 as x
} from "./chunk-QNOCEWCR.js";
import {
  f
} from "./chunk-QWPLZ3QH.js";
import {
  G,
  W,
  d2 as d,
  z
} from "./chunk-HLGIRLYQ.js";

// node_modules/@arcgis/core/chunks/mat2df64.js
function e2() {
  return [1, 0, 0, 1, 0, 0];
}
function r5(e3) {
  return [e3[0], e3[1], e3[2], e3[3], e3[4], e3[5]];
}
function t(e3, r6, t2, n3, o3, a2) {
  return [e3, r6, t2, n3, o3, a2];
}
function n2(e3, r6) {
  return new Float64Array(e3, r6, 6);
}
var o2 = Object.freeze(Object.defineProperty({ __proto__: null, clone: r5, create: e2, createView: n2, fromValues: t }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/views/2d/viewpointUtils.js
var U = 96;
var O = 39.37;
var Q = 180 / Math.PI;
function T(t2) {
  return t2.wkid ? t2 : t2.spatialReference || f.WGS84;
}
function B(t2, e3) {
  return e3.type ? r2(t2, e3.x, e3.y) : a(t2, e3);
}
function D2(t2) {
  return z(t2);
}
function W2(t2, e3) {
  const n3 = Math.max(1, e3[0]), r6 = Math.max(1, e3[1]);
  return Math.max(t2.width / n3, t2.height / r6) * it(t2.spatialReference);
}
async function H(t2, n3, r6, o3) {
  var _a, _b;
  let a2, i2;
  if (!t2)
    return null;
  if (Array.isArray(t2) && !t2.length)
    return null;
  if (V.isCollection(t2) && (t2 = t2.toArray()), Array.isArray(t2) && t2.length && "object" == typeof t2[0]) {
    const e3 = t2.every((t3) => "attributes" in t3), a3 = t2.some((t3) => !t3.geometry);
    let i3 = t2;
    if (e3 && a3 && n3 && n3.allLayerViews) {
      const e4 = /* @__PURE__ */ new Map();
      for (const n4 of t2) {
        const t3 = n4.layer, r8 = e4.get(t3) || [], o5 = n4.attributes[t3.objectIdField];
        null != o5 && r8.push(o5), e4.set(t3, r8);
      }
      const r7 = [];
      e4.forEach((t3, e5) => {
        const o5 = n3.allLayerViews.find((t4) => t4.layer.id === e5.id);
        if (o5 && "queryFeatures" in o5) {
          const n4 = e5.createQuery();
          n4.objectIds = t3, n4.returnGeometry = true, r7.push(o5.queryFeatures(n4));
        }
      });
      const o4 = await Promise.all(r7), a4 = [];
      for (const t3 of o4)
        if (t3 && t3.features && t3.features.length)
          for (const e5 of t3.features)
            null != e5.geometry && a4.push(e5.geometry);
      i3 = a4;
    }
    for (const t3 of i3)
      o3 = await H(t3, n3, r6, o3);
    return o3;
  }
  if (Array.isArray(t2) && 2 === t2.length && "number" == typeof t2[0] && "number" == typeof t2[1])
    a2 = new x(t2);
  else if (t2 instanceof p)
    a2 = t2;
  else if ("geometry" in t2) {
    if (t2.geometry)
      a2 = t2.geometry;
    else if (t2.layer) {
      const e3 = t2.layer, r7 = n3.allLayerViews.find((t3) => t3.layer.id === e3.id);
      if (r7 && "queryFeatures" in r7) {
        const n4 = e3.createQuery();
        n4.objectIds = [t2.attributes[e3.objectIdField]], n4.returnGeometry = true;
        const o4 = await r7.queryFeatures(n4);
        a2 = (_b = (_a = o4 == null ? void 0 : o4.features) == null ? void 0 : _a[0]) == null ? void 0 : _b.geometry;
      }
    }
  }
  if (null == a2)
    return null;
  switch (a2.type) {
    case "point":
      i2 = new M({ xmin: a2.x, ymin: a2.y, xmax: a2.x, ymax: a2.y, spatialReference: a2.spatialReference });
      break;
    case "extent":
    case "multipoint":
    case "polygon":
    case "polyline":
      i2 = v(a2);
      break;
    default:
      i2 = a2.extent;
  }
  if (!i2)
    return null;
  E() || D(i2.spatialReference, r6) || await _();
  const c2 = b(i2, r6);
  return c2 ? o3 = o3 ? o3.union(c2) : c2 : null;
}
function J(t2) {
  var _a;
  if (t2 && (!Array.isArray(t2) || "number" != typeof t2[0]) && ("object" == typeof t2 || Array.isArray(t2) && "object" == typeof t2[0])) {
    if ("layer" in t2 && null != ((_a = t2.layer) == null ? void 0 : _a.minScale) && null != t2.layer.maxScale) {
      const e3 = t2.layer;
      return { min: e3.minScale, max: e3.maxScale };
    }
    if (Array.isArray(t2) && t2.length && t2.every((t3) => "layer" in t3)) {
      let e3 = 0, n3 = 0;
      for (const r6 of t2) {
        const t3 = r6.layer;
        (t3 == null ? void 0 : t3.minScale) && t3.maxScale && (e3 = t3.minScale < e3 ? t3.minScale : e3, n3 = t3.maxScale > n3 ? t3.maxScale : n3);
      }
      return e3 && n3 ? { min: e3, max: n3 } : null;
    }
  }
}
function K(t2, e3) {
  return d(T(t2), e3) ? t2 : b(t2, e3);
}
async function X(e3, n3) {
  var _a;
  if (!e3 || !n3)
    return new l2({ targetGeometry: new x(), scale: 0, rotation: 0 });
  let r6 = n3.spatialReference;
  const { constraints: o3, padding: a2, viewpoint: i2, size: c2 } = n3, s2 = [a2 ? c2[0] - a2.left - a2.right : c2[0], a2 ? c2[1] - a2.top - a2.bottom : c2[1]];
  let u = null;
  e3 instanceof l2 ? u = e3 : e3.viewpoint ? u = e3.viewpoint : e3.target && "esri.Viewpoint" === e3.target.declaredClass && (u = e3.target);
  let f3 = null;
  (u == null ? void 0 : u.targetGeometry) ? f3 = u.targetGeometry : e3 instanceof M ? f3 = e3 : (e3 || e3 && ("center" in e3 || "extent" in e3 || "target" in e3)) && (f3 = await H(e3.center, n3, r6) || await H(e3.extent, n3, r6) || await H(e3.target, n3, r6) || await H(e3, n3, r6)), !f3 && (i2 == null ? void 0 : i2.targetGeometry) ? f3 = i2.targetGeometry : !f3 && n3.extent && (f3 = n3.extent), r6 || (r6 = T(n3.spatialReference || n3.extent || f3)), E() || d(f3.spatialReference, r6) || D(f3.spatialReference, r6) || await _();
  const l3 = K("center" in f3 ? f3.center : f3, r6);
  false !== n3.pickClosestTarget && "point" === l3.type && "point" === ((_a = i2.targetGeometry) == null ? void 0 : _a.type) && (l3.x = P(l3.x, i2.targetGeometry.x, l3.spatialReference));
  let m = 0;
  if (null != (u == null ? void 0 : u.targetGeometry) && "point" === u.targetGeometry.type)
    m = u.scale;
  else if ("scale" in e3 && e3.scale)
    m = e3.scale;
  else if ("zoom" in e3 && -1 !== e3.zoom && o3 && o3.effectiveLODs)
    m = o3.zoomToScale(e3.zoom);
  else if (Array.isArray(f3) || "point" === f3.type || "extent" === f3.type && 0 === f3.width && 0 === f3.height) {
    const t2 = K(n3.extent, r6);
    m = null != t2 ? W2(t2, s2) : n3.extent ? W2(n3.extent, s2) : i2.scale;
  } else
    m = W2(K(f3.extent, r6), s2);
  const y2 = J(e3.target ?? e3);
  y2 && (y2.min && y2.min < m ? m = y2.min : y2.max && y2.max > m && (m = y2.max));
  let p2 = 0;
  u ? p2 = u.rotation : e3.hasOwnProperty("rotation") ? p2 = e3.rotation : i2 && (p2 = i2.rotation);
  let g2 = new l2({ targetGeometry: l3, scale: m, rotation: p2 });
  return o3 && (g2 = o3.fit(g2), o3.constrainByGeometry(g2), o3.rotationEnabled || (g2.rotation = i2.rotation)), g2;
}
function Y(t2, e3) {
  const n3 = t2.targetGeometry, r6 = e3.targetGeometry;
  return n3.x = r6.x, n3.y = r6.y, n3.spatialReference = r6.spatialReference, t2.scale = e3.scale, t2.rotation = e3.rotation, t2;
}
function Z(t2, e3, n3) {
  return n3 ? r2(t2, 0.5 * (e3[0] - n3.right + n3.left), 0.5 * (e3[1] - n3.bottom + n3.top)) : l(t2, e3, 0.5);
}
var $ = function() {
  const t2 = n();
  return function(e3, n3, r6) {
    const o3 = n3.targetGeometry;
    B(t2, o3);
    const a2 = 0.5 * rt(n3);
    return e3.xmin = t2[0] - a2 * r6[0], e3.ymin = t2[1] - a2 * r6[1], e3.xmax = t2[0] + a2 * r6[0], e3.ymax = t2[1] + a2 * r6[1], e3.spatialReference = o3.spatialReference, e3;
  };
}();
function _2(t2, e3, n3, r6, o3) {
  var _a;
  return gt(t2, e3, n3.center), t2.scale = W2(n3, r6), (_a = o3 == null ? void 0 : o3.constraints) == null ? void 0 : _a.constrain(t2), t2;
}
function tt(t2, e3, n3, r6) {
  return ut(t2, e3, n3, r6), r4(t2, t2);
}
var et = function() {
  const t2 = n();
  return function(e3, n3, r6) {
    return C(e3, ct(e3, n3), Z(t2, n3, r6));
  };
}();
var nt = function() {
  const t2 = e2(), e3 = n();
  return function(n3, r6, c2, s2) {
    const u = rt(r6), f3 = at(r6);
    return r2(e3, u, u), M2(t2, e3), e(t2, t2, f3), i(t2, t2, et(e3, c2, s2)), i(t2, t2, [0, s2.top - s2.bottom]), r2(n3, t2[4], t2[5]);
  };
}();
function rt(t2) {
  return t2.scale * ot(t2.targetGeometry);
}
function ot(t2) {
  return null != t2 && W(t2.spatialReference) ? 1 / (D2(t2.spatialReference) * O * U) : 1;
}
function at(t2) {
  return r(t2.rotation) || 0;
}
function it(t2) {
  return W(t2) ? D2(t2) * O * U : 1;
}
function ct(t2, e3) {
  return l(t2, e3, 0.5);
}
var st = function() {
  const t2 = n(), e3 = n(), n3 = n();
  return function(r6, o3, u, f3, l3, p2) {
    return g(t2, o3), l(e3, u, 0.5 * p2), r2(n3, 1 / f3 * p2, -1 / f3 * p2), f2(r6, e3), l3 && e(r6, r6, l3), c(r6, r6, n3), i(r6, r6, t2), r6;
  };
}();
var ut = function() {
  const t2 = n();
  return function(e3, n3, r6, o3) {
    const a2 = rt(n3), i2 = at(n3);
    return B(t2, n3.targetGeometry), st(e3, t2, r6, a2, i2, o3);
  };
}();
var ft = function() {
  const t2 = n();
  return function(e3, n3, r6, o3) {
    const a2 = rt(n3);
    return B(t2, n3.targetGeometry), st(e3, t2, r6, a2, 0, o3);
  };
}();
function lt(t2) {
  const e3 = G(t2);
  return e3 ? e3.valid[1] - e3.valid[0] : 0;
}
function mt(t2, e3) {
  return Math.round(lt(t2) / e3);
}
var yt = function() {
  const t2 = n(), e3 = n(), n3 = [0, 0, 0];
  return function(r6, o3, a2) {
    o(t2, r6, o3), v2(t2, t2), o(e3, r6, a2), v2(e3, e3), y(n3, t2, e3);
    let i2 = Math.acos(j(t2, e3) / (q(t2) * q(e3))) * Q;
    return n3[2] < 0 && (i2 = -i2), isNaN(i2) && (i2 = 0), i2;
  };
}();
var pt = function() {
  const t2 = n();
  return function(e3, n3, r6, o3) {
    const a2 = e3.targetGeometry;
    return Y(e3, n3), nt(t2, n3, r6, o3), a2.x += t2[0], a2.y += t2[1], e3;
  };
}();
var gt = function(t2, e3, n3) {
  Y(t2, e3);
  const r6 = t2.targetGeometry;
  return r6.x = n3.x, r6.y = n3.y, r6.spatialReference = n3.spatialReference, t2;
};
var xt = function() {
  const t2 = n();
  return function(e3, n3, r6, o3, a2) {
    a2 || (a2 = "center"), C(t2, r6, o3), l(t2, t2, 0.5);
    const i2 = t2[0], c2 = t2[1];
    switch (a2) {
      case "center":
        r2(t2, 0, 0);
        break;
      case "left":
        r2(t2, -i2, 0);
        break;
      case "top":
        r2(t2, 0, c2);
        break;
      case "right":
        r2(t2, i2, 0);
        break;
      case "bottom":
        r2(t2, 0, -c2);
        break;
      case "top-left":
        r2(t2, -i2, c2);
        break;
      case "bottom-left":
        r2(t2, -i2, -c2);
        break;
      case "top-right":
        r2(t2, i2, c2);
        break;
      case "bottom-right":
        r2(t2, i2, -c2);
    }
    return At(e3, n3, t2), e3;
  };
}();
function ht(t2, e3, n3) {
  return Y(t2, e3), t2.rotation += n3, t2;
}
function bt(t2, e3, n3) {
  return Y(t2, e3), t2.rotation = n3, t2;
}
var wt = function() {
  const t2 = n();
  return function(e3, n3, r6, o3, a2) {
    return Y(e3, n3), isNaN(r6) || 0 === r6 || (Rt(t2, o3, n3, a2), e3.scale = n3.scale * r6, kt(t2, t2, e3, a2), At(e3, e3, r2(t2, t2[0] - o3[0], o3[1] - t2[1]))), e3;
  };
}();
function dt(t2, e3, n3) {
  return Y(t2, e3), t2.scale = n3, t2;
}
var jt = function() {
  const t2 = n();
  return function(e3, n3, r6, o3, a2, i2) {
    return Y(e3, n3), isNaN(r6) || 0 === r6 || (Rt(t2, a2, n3, i2), e3.scale = n3.scale * r6, e3.rotation += o3, kt(t2, t2, e3, i2), At(e3, e3, r2(t2, t2[0] - a2[0], a2[1] - t2[1]))), e3;
  };
}();
var Gt = function() {
  const t2 = n(), e3 = n();
  return function(n3, r6, o3, a2, i2, c2, s2) {
    return et(e3, c2, s2), s(t2, i2, e3), a2 ? jt(n3, r6, o3, a2, t2, c2) : wt(n3, r6, o3, t2, c2);
  };
}();
var Rt = function() {
  const t2 = e2();
  return function(e3, n3, r6, o3) {
    return z2(e3, n3, tt(t2, r6, o3, 1));
  };
}();
var kt = function() {
  const t2 = e2();
  return function(e3, n3, r6, o3) {
    return z2(e3, n3, ut(t2, r6, o3, 1));
  };
}();
var At = function() {
  const t2 = n(), e3 = e2();
  return function(n3, r6, o3) {
    Y(n3, r6);
    const a2 = rt(r6), i2 = n3.targetGeometry;
    return h(e3, at(r6)), c(e3, e3, r3(a2, a2)), z2(t2, o3, e3), i2.x += t2[0], i2.y += t2[1], n3;
  };
}();

export {
  e2 as e,
  W2 as W,
  X,
  Y,
  Z,
  $,
  _2 as _,
  et,
  rt,
  st,
  ut,
  ft,
  lt,
  mt,
  yt,
  pt,
  gt,
  xt,
  ht,
  bt,
  dt,
  jt,
  Gt,
  At
};
//# sourceMappingURL=chunk-3II2L7GF.js.map
