import {
  E,
  K,
  N,
  V,
  a as a6,
  c as c6,
  c2 as c7,
  d as d4,
  f as f5,
  h,
  i as i3,
  j as j6,
  k as k3,
  l as l3,
  m as m4,
  n as n5,
  p as p4,
  t as t4
} from "./chunk-AB7HTXGZ.js";
import {
  d as d5,
  g as g2,
  m as m3,
  p as p3
} from "./chunk-RS353LH2.js";
import "./chunk-M4XZJQJO.js";
import {
  t as t3
} from "./chunk-EX6UN27G.js";
import {
  A as A2,
  B2 as B,
  G,
  L2 as L,
  P,
  c2 as c4,
  j as j5,
  m as m2,
  n2 as n3,
  n3 as n4
} from "./chunk-OEIWJN32.js";
import {
  l2,
  s as s7,
  s3 as s8,
  u2
} from "./chunk-ABKJC2RS.js";
import "./chunk-XZLDDXLF.js";
import {
  n as n2,
  s as s5
} from "./chunk-FULBQ2BU.js";
import {
  s as s6
} from "./chunk-QJ3HQI3B.js";
import "./chunk-FDNAIASW.js";
import "./chunk-XI27PUTI.js";
import "./chunk-WROAERAR.js";
import "./chunk-S6CVQWN7.js";
import "./chunk-JWPJ4Y6I.js";
import "./chunk-OYPRFNII.js";
import "./chunk-747B2TEO.js";
import "./chunk-4NEWABLH.js";
import "./chunk-FW2Y26A2.js";
import "./chunk-5WG7GACT.js";
import "./chunk-NYTJIWNN.js";
import {
  e as e2
} from "./chunk-323PT7GB.js";
import {
  l
} from "./chunk-36R5EC6A.js";
import {
  o as o2
} from "./chunk-5DLICG33.js";
import {
  a as a5
} from "./chunk-WZZO74UB.js";
import {
  p as p2
} from "./chunk-AYCE4MD7.js";
import "./chunk-F3LMPTMS.js";
import {
  A
} from "./chunk-U4ONWLTG.js";
import {
  j as j4
} from "./chunk-KQ7MCWUF.js";
import {
  f as f4
} from "./chunk-NHWXARIK.js";
import {
  a as a4
} from "./chunk-P5VIVFJT.js";
import "./chunk-SA3C7GIT.js";
import "./chunk-P3R45ANF.js";
import {
  t as t2
} from "./chunk-PIEUUBJ5.js";
import {
  u as u3
} from "./chunk-OTTMOIDW.js";
import {
  m
} from "./chunk-P5GW5DPX.js";
import {
  c as c5,
  d as d3,
  g,
  y as y3
} from "./chunk-WDO2BXGR.js";
import "./chunk-E3I4MGUC.js";
import "./chunk-IYYYQK4Y.js";
import {
  b as b2
} from "./chunk-QN7I7LNY.js";
import "./chunk-64EQFPYJ.js";
import "./chunk-HKYMYCLL.js";
import "./chunk-ICVVQFO6.js";
import {
  d as d2
} from "./chunk-O3E2OZKN.js";
import "./chunk-IYJG2X3Y.js";
import "./chunk-UTCX6DGX.js";
import "./chunk-3RBII4KE.js";
import "./chunk-SEKLTVY5.js";
import "./chunk-7YZ4X2DS.js";
import "./chunk-UPGPT5OX.js";
import "./chunk-VA52CKTT.js";
import {
  b
} from "./chunk-45OAWGCA.js";
import "./chunk-R4LYFMZX.js";
import "./chunk-X2TA76Q5.js";
import "./chunk-T3Y5GTKO.js";
import {
  y as y2
} from "./chunk-XN6LAULS.js";
import {
  Z
} from "./chunk-CKGVKMVG.js";
import "./chunk-CSWPLQ7Q.js";
import "./chunk-KWSMYM7P.js";
import "./chunk-RP5SAUAF.js";
import "./chunk-AMSVADDY.js";
import "./chunk-6B7VJB6C.js";
import "./chunk-GAJBN4TM.js";
import {
  R
} from "./chunk-LOGPPZUD.js";
import "./chunk-HYU6N3H3.js";
import {
  b as b3
} from "./chunk-WETX22HQ.js";
import "./chunk-IYXYJAVC.js";
import "./chunk-NCLD32JB.js";
import "./chunk-24NOAXOQ.js";
import {
  c as c3
} from "./chunk-B3RXTW72.js";
import {
  k as k2
} from "./chunk-DCYI44X2.js";
import "./chunk-JHJVOI7Q.js";
import "./chunk-TWNBDJHC.js";
import "./chunk-4NU7FZD7.js";
import "./chunk-WYZCKLOR.js";
import "./chunk-S6NERLXF.js";
import "./chunk-MLRHWRJQ.js";
import "./chunk-H4ZZ5S37.js";
import "./chunk-G557TGXY.js";
import "./chunk-2AXFVQBN.js";
import {
  c as c2
} from "./chunk-WOGT6UK2.js";
import "./chunk-RHT6WWRD.js";
import {
  f as f3,
  i,
  s as s4
} from "./chunk-EUGXS5RE.js";
import "./chunk-IRNKV32L.js";
import "./chunk-IATM3RCE.js";
import "./chunk-BEALJUHO.js";
import "./chunk-GRHSIT57.js";
import "./chunk-PJQIAD5D.js";
import "./chunk-GAWSWBHO.js";
import "./chunk-SZAJDZCO.js";
import "./chunk-3DSKWYU4.js";
import {
  n
} from "./chunk-ZZYUEH57.js";
import "./chunk-VTWXDFFD.js";
import {
  p,
  v as v2
} from "./chunk-IPCIO3PX.js";
import "./chunk-EIY2DYTV.js";
import {
  i as i2
} from "./chunk-WJ4LS3YG.js";
import "./chunk-F6MD5VOH.js";
import "./chunk-V2RPSCV3.js";
import "./chunk-AOJ6OCPK.js";
import "./chunk-LMT5JII2.js";
import "./chunk-A43TI6AT.js";
import "./chunk-2D3PORS4.js";
import "./chunk-4HKQSEUR.js";
import "./chunk-V3U4F2NL.js";
import "./chunk-ZB6PGKG5.js";
import {
  j as j3,
  u
} from "./chunk-OIIDE5GZ.js";
import "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import {
  d
} from "./chunk-TBSVVR6M.js";
import "./chunk-6TJWLWLO.js";
import "./chunk-H7BKONNV.js";
import "./chunk-K6C6RVSV.js";
import "./chunk-KBJ5Z4R2.js";
import "./chunk-JUZJCTW2.js";
import "./chunk-423VNHLR.js";
import "./chunk-FN47E7YK.js";
import "./chunk-XZS3Q5K4.js";
import "./chunk-WZPOQGKL.js";
import "./chunk-CCXEAKIM.js";
import {
  M
} from "./chunk-Y5D433JZ.js";
import {
  x2 as x
} from "./chunk-QNOCEWCR.js";
import {
  o
} from "./chunk-WURET5CW.js";
import {
  f as f2,
  r
} from "./chunk-QWPLZ3QH.js";
import {
  T as T2,
  Ue,
  de,
  fe
} from "./chunk-HLGIRLYQ.js";
import "./chunk-N2K4VRZH.js";
import "./chunk-WL4VPODY.js";
import "./chunk-OMPEZIP5.js";
import {
  s as s3
} from "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import {
  I,
  j as j2
} from "./chunk-R5DM4YAB.js";
import {
  f
} from "./chunk-NSRXJNTS.js";
import {
  j,
  t,
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  T,
  a2 as a3,
  c,
  v
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  a as a2,
  k
} from "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  a,
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import "./chunk-4V6374PV.js";
import "./chunk-A34O4XB5.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/support/rasterFunctions/rasterFunctionSchema.js
var e3 = { StretchFunction: { arguments: { ComputeGamma: { isDataset: false, isPublic: false, name: "ComputeGamma", type: "RasterFunctionVariable", value: false }, DRA: { isDataset: false, isPublic: false, name: "DRA", type: "RasterFunctionVariable", value: false }, EstimateStatsHistogram: { isDataset: false, isPublic: false, name: "EstimateStatsHistogram", type: "RasterFunctionVariable", value: false }, Gamma: { displayName: "Gamma", isDataset: false, isPublic: false, name: "Gamma", type: "RasterFunctionVariable" }, Histograms: { isDataset: false, isPublic: false, name: "Histograms", type: "RasterFunctionVariable" }, Max: { isDataset: false, isPublic: false, name: "Max", type: "RasterFunctionVariable", value: 255 }, MaxPercent: { isDataset: false, isPublic: false, name: "MaxPercent", type: "RasterFunctionVariable", value: 0.5 }, Min: { isDataset: false, isPublic: false, name: "Min", type: "RasterFunctionVariable", value: 0 }, MinPercent: { isDataset: false, isPublic: false, name: "MinPercent", type: "RasterFunctionVariable", value: 0.25 }, NumberOfStandardDeviations: { isDataset: false, isPublic: false, name: "NumberOfStandardDeviation", type: "RasterFunctionVariable", value: 2 }, Raster: { isDataset: true, isPublic: false, name: "Raster", type: "RasterFunctionVariable" }, SigmoidStrengthLevel: { isDataset: false, isPublic: false, name: "SigmoidStrengthLevel", type: "RasterFunctionVariable", value: 2 }, Statistics: { isDataset: false, isPublic: false, name: "Statistics", type: "RasterFunctionVariable" }, StretchType: { isDataset: false, isPublic: false, name: "StretchType", type: "RasterFunctionVariable", value: 0 }, type: "StretchFunctionArguments", UseGamma: { isDataset: false, isPublic: false, name: "UseGamma", type: "RasterFunctionVariable", value: false } }, description: "Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.", function: { description: "Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.", name: "Stretch", pixelType: "UNKNOWN", type: "StretchFunction" }, functionType: 0, name: "Stretch", thumbnail: "" }, RemapFunction: { name: "Remap", description: "Changes pixel values by assigning new values to ranges of pixel values or using an external table.", function: { type: "RemapFunction", pixelType: "UNKNOWN", name: "Remap", description: "Changes pixel values by assigning new values to ranges of pixel values or using an external table." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, UseTable: { name: "UseTable", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, InputRanges: { name: "InputRanges", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "Input Ranges" }, OutputValues: { name: "OutputValues", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "Output Values" }, NoDataRanges: { name: "NoDataRanges", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "NoData Ranges" }, Table: { name: "Table", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, InputField: { name: "InputField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, OutputField: { name: "OutputField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, InputMaxField: { name: "InputMaxField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, RemapTableType: { name: "RemapTableType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, AllowUnmatched: { name: "AllowUnmatched", isPublic: false, isDataset: false, value: true, type: "RasterFunctionVariable" }, type: "RemapFunctionArguments" }, functionType: 0, thumbnail: "" }, ColormapFunction: { name: "Colormap", description: "Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp.", function: { type: "ColormapFunction", pixelType: "UNKNOWN", name: "Colormap", description: "Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ColorSchemeType: { name: "ColorSchemeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, Colormap: { name: "Colormap", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, ColormapName: { name: "ColormapName", isPublic: false, isDataset: false, value: "Gray", type: "RasterFunctionVariable" }, ColorRamp: { name: "ColorRamp", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, type: "ColormapFunctionArguments" }, functionType: 0, thumbnail: "" }, ShadedReliefFunction: { name: "Shaded Relief", description: "Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image.", function: { type: "ShadedReliefFunction", pixelType: "UNKNOWN", name: "Shaded Relief", description: "Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ColorSchemeType: { name: "ColorSchemeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ColorRamp: { name: "ColorRamp", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, HillshadeType: { name: "HillshadeType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, Colormap: { name: "Colormap", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, Azimuth: { name: "Azimuth", isPublic: false, isDataset: false, value: 315, type: "RasterFunctionVariable" }, Altitude: { name: "Altitude", isPublic: false, isDataset: false, value: 45, type: "RasterFunctionVariable" }, SlopeType: { name: "SlopeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ZFactor: { name: "ZFactor", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, PSPower: { name: "PSPower", isPublic: false, isDataset: false, value: 0.664, type: "RasterFunctionVariable" }, PSZFactor: { name: "PSZFactor", isPublic: false, isDataset: false, value: 0.024, type: "RasterFunctionVariable" }, RemoveEdgeEffect: { name: "RemoveEdgeEffect", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, type: "ShadedReliefFunctionArguments" }, functionType: 0, thumbnail: "" }, HillshadeFunction: { name: "Hillshade", description: "Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image", function: { type: "HillshadeFunction", pixelType: "UNKNOWN", name: "Hillshade", description: "Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image" }, arguments: { DEM: { name: "DEM", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, HillshadeType: { name: "HillshadeType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, Azimuth: { name: "Azimuth", isPublic: false, isDataset: false, value: 315, type: "RasterFunctionVariable" }, Altitude: { name: "Altitude", isPublic: false, isDataset: false, value: 45, type: "RasterFunctionVariable" }, SlopeType: { name: "SlopeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ZFactor: { name: "ZFactor", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, PSPower: { name: "PSPower", isPublic: false, isDataset: false, value: 0.664, type: "RasterFunctionVariable" }, PSZFactor: { name: "PSZFactor", isPublic: false, isDataset: false, value: 0.024, type: "RasterFunctionVariable" }, RemoveEdgeEffect: { name: "RemoveEdgeEffect", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, type: "HillshadeFunctionArguments" }, functionType: 0, thumbnail: "" }, ResampleFunction: { name: "Resample", description: "Changes the cell size of a raster.", function: { type: "ResampleFunction", pixelType: "UNKNOWN", name: "Resample", description: "Changes the cell size of a raster." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ResamplingType: { name: "ResamplingType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, InputCellSize: { name: "InputCellsize", isPublic: false, isDataset: false, value: { x: 0, y: 0 }, type: "RasterFunctionVariable" }, OutputCellSize: { name: "OutputCellsize", isPublic: false, isDataset: false, value: { x: 0, y: 0 }, type: "RasterFunctionVariable" }, type: "ResampleFunctionArguments" }, functionType: 0, thumbnail: "" } };

// node_modules/@arcgis/core/layers/support/imageryRendererUtils.js
var c8 = /* @__PURE__ */ new Set(["u1", "u2", "u4", "u8", "s8", "u16", "s16"]);
var m5 = { simple_scalar: "Simple Scalar", wind_barb: "Wind Barb", single_arrow: "Single Arrow", beaufort_kn: "Beaufort Wind (Knots)", beaufort_m: "Beaufort Wind (MetersPerSecond)", ocean_current_m: "Ocean Current (MetersPerSecond)", ocean_current_kn: "Ocean Current (Knots)" };
var f6 = /* @__PURE__ */ new Set(["raster-stretch", "unique-value", "class-breaks", "raster-shaded-relief", "vector-field", "raster-colormap"]);
function p5(e4) {
  return f6.has(e4.type);
}
function g3(n9, t6) {
  var _a;
  if (!n9 || !t6)
    return a(n9 || t6);
  const r2 = a(n9);
  if (r2.functionDefinition && t6.rasterFunctionDefinition) {
    const e4 = t6.rasterFunctionDefinition;
    (e4.thumbnail || e4.thumbnailEx) && (e4.thumbnail = e4.thumbnailEx = void 0), d6(r2.functionDefinition.arguments, t6), r2.rasterFunctionDefinition = r2.functionDefinition.toJSON();
  } else if ("none" !== ((_a = t6.functionName) == null ? void 0 : _a.toLowerCase())) {
    b4(r2.functionArguments).Raster = t6;
  }
  return r2;
}
function d6(e4, n9) {
  for (const t6 in e4)
    "raster" === t6.toLowerCase() && ("RasterFunctionVariable" === e4[t6].type ? (e4[t6] = n9.rasterFunctionDefinition, e4[t6].type = "RasterFunctionTemplate") : "RasterFunctionTemplate" === e4[t6].type && d6(e4[t6].arguments, n9));
}
function h2(n9) {
  const t6 = a(e3[n9.functionName + "Function"]), o3 = n9.functionArguments;
  for (const e4 in o3)
    "raster" === e4.toLowerCase() ? (t6.arguments[e4] = h2(o3[e4]), t6.arguments[e4].type = "RasterFunctionTemplate") : "colormap" === e4.toLowerCase() ? (t6.arguments[e4].value = V2(o3[e4]), t6.arguments.ColorSchemeType.value = 0) : t6.arguments[e4].value = o3[e4];
  return t6;
}
function y4(e4, n9) {
  switch (n9 = n9 || {}, e4.type) {
    case "raster-stretch":
      return w(e4, n9);
    case "class-breaks":
      return S(e4, n9);
    case "unique-value":
      return F(e4, n9);
    case "raster-colormap":
      return A3(e4, n9);
    case "vector-field":
      return T3(e4, n9);
    case "raster-shaded-relief":
      return v3(e4, n9);
    case "flow":
      throw new Error("Unsupported rendering rule.");
  }
}
function b4(e4) {
  const n9 = (e4 == null ? void 0 : e4.Raster) ?? (e4 == null ? void 0 : e4.raster);
  return n9 && "esri.layers.support.RasterFunction" === n9.declaredClass ? b4(n9.functionArguments) : e4;
}
var R2 = { none: 0, standardDeviation: 3, histogramEqualization: 4, minMax: 5, percentClip: 6, sigmoid: 9 };
function T3(e4, t6) {
  const r2 = new N();
  r2.functionName = "VectorFieldRenderer";
  const { dataType: o3, bandNames: a13 } = t6, i7 = "vector-uv" === o3;
  let s9, u8;
  if (a13 && 2 === a13.length) {
    const e5 = a13.map((e6) => e6.toLowerCase());
    s9 = e5.indexOf("magnitude"), u8 = e5.indexOf("direction");
  }
  -1 !== s9 && null !== s9 || (s9 = 0, u8 = 1);
  const c17 = "arithmetic" === e4.rotationType ? 1 : 2, f7 = "flow-from" === e4.flowRepresentation ? 0 : 1, p14 = e4.visualVariables ? e4.visualVariables.find((e5) => "Magnitude" === e5.field) : new b2(), g5 = { magnitudeBandID: s9, directionBandID: u8, isUVComponents: i7, referenceSystem: c17, massFlowAngleRepresentation: f7, symbolTileSize: 50, symbolTileSizeUnits: 100, calculationMethod: "Vector Average", symbologyName: m5[e4.style.toLowerCase().replace("-", "_")], minimumMagnitude: p14.minDataValue, maximumMagnitude: p14.maxDataValue, minimumSymbolSize: p14.minSize, maximumSymbolSize: p14.maxSize };
  r2.functionArguments = g5;
  const d10 = h2(r2);
  return t6.convertToRFT ? N.fromJSON({ rasterFunctionDefinition: d10 }) : r2;
}
function v3(e4, t6) {
  const r2 = t6.convertToRFT;
  if ("elevation" !== t6.dataType && ("generic" !== t6.dataType || 1 !== t6.bandCount || "s16" !== t6.pixelType && "s32" !== t6.pixelType && "f32" !== t6.pixelType && "f64" !== t6.pixelType))
    return new N();
  const i7 = new N();
  i7.functionName = "Hillshade";
  const s9 = "traditional" === e4.hillshadeType ? 0 : 1, u8 = "none" === e4.scalingType ? 1 : 3, l9 = { HillshadeType: s9, SlopeType: u8, ZFactor: e4.zFactor };
  return 0 === s9 && (l9.Azimuth = e4.azimuth, l9.Altitude = e4.altitude), 3 === u8 && (l9.PSPower = e4.pixelSizePower, l9.PSZFactor = e4.pixelSizeFactor), i7.functionArguments = l9, i7.variableName = "Raster", e4.colorRamp && (i7.functionName = "ShadedRelief", r2 ? l9.ColorRamp = G(e4.colorRamp) : l9.Colormap = B(e4.colorRamp)), r2 ? new N({ rasterFunctionDefinition: h2(i7) }) : i7;
}
function w(e4, t6) {
  var _a;
  const r2 = t6.convertToRFT, s9 = new N();
  s9.functionName = "Stretch";
  const l9 = R2[n4.toJSON(e4.stretchType)], c17 = "u8", m8 = { StretchType: l9, Statistics: N2(e4.statistics ?? []), DRA: e4.dynamicRangeAdjustment, UseGamma: e4.useGamma, Gamma: e4.gamma, ComputeGamma: e4.computeGamma };
  if (null != e4.outputMin && (m8.Min = e4.outputMin), null != e4.outputMax && (m8.Max = e4.outputMax), l9 === R2.standardDeviation ? (m8.NumberOfStandardDeviations = e4.numberOfStandardDeviations, s9.outputPixelType = c17) : l9 === R2.percentClip ? (m8.MinPercent = e4.minPercent, m8.MaxPercent = e4.maxPercent, s9.outputPixelType = c17) : l9 === R2.minMax ? s9.outputPixelType = c17 : l9 === R2.sigmoid && (m8.SigmoidStrengthLevel = e4.sigmoidStrengthLevel), s9.functionArguments = m8, s9.variableName = "Raster", e4.colorRamp) {
    const u8 = e4.colorRamp, l10 = new N();
    if (r2)
      l10.functionArguments = { ColorRamp: G(u8) };
    else {
      const n9 = c4(u8, true);
      if (n9)
        l10.functionArguments = { colorRampName: n9 };
      else if (!t6.convertColorRampToColormap || "algorithmic" !== u8.type && "multipart" !== u8.type) {
        const n10 = e4.colorRamp.toJSON();
        "algorithmic" === n10.type ? n10.algorithm = n10.algorithm || "esriCIELabAlgorithm" : "multipart" === n10.type && ((_a = n10.colorRamps) == null ? void 0 : _a.length) && n10.colorRamps.forEach((e5) => e5.algorithm = e5.algorithm || "esriCIELabAlgorithm"), l10.functionArguments = { colorRamp: n10 };
      } else
        l10.functionArguments = { Colormap: B(u8) };
    }
    return l10.variableName = "Raster", l10.functionName = "Colormap", l10.functionArguments.Raster = s9, r2 ? new N({ rasterFunctionDefinition: h2(l10) }) : l10;
  }
  return r2 ? new N({ rasterFunctionDefinition: h2(s9) }) : s9;
}
function S(e4, t6) {
  const r2 = [], o3 = [], a13 = [], i7 = [], s9 = 1e-4, { pixelType: u8, rasterAttributeTable: l9 } = t6, c17 = null == l9 ? null : l9.features, m8 = C(l9);
  if (m8 && c17 && Array.isArray(c17) && e4.classBreakInfos) {
    e4.classBreakInfos.forEach((n9, t7) => {
      var _a;
      const r4 = (_a = n9.symbol) == null ? void 0 : _a.color;
      let o5;
      (r4 == null ? void 0 : r4.a) && null != n9.minValue && null != n9.maxValue && c17.forEach((a14) => {
        null != n9.minValue && null != n9.maxValue && (o5 = a14.attributes[e4.field], (o5 >= n9.minValue && o5 < n9.maxValue || t7 === e4.classBreakInfos.length - 1 && o5 >= n9.minValue) && i7.push([a14.attributes[m8], r4.r, r4.g, r4.b]));
      });
    });
    const r3 = u8 ? x2(i7, u8) : i7, o4 = new N();
    return o4.functionName = "Colormap", o4.functionArguments = {}, o4.functionArguments.Colormap = r3, o4.variableName = "Raster", t6.convertToRFT ? new N({ rasterFunctionDefinition: h2(o4) }) : o4;
  }
  e4.classBreakInfos.forEach((e5, n9) => {
    if (null == e5.minValue || null == e5.maxValue)
      return;
    const t7 = e5.symbol && e5.symbol.color;
    (t7 == null ? void 0 : t7.a) ? (0 === n9 ? r2.push(e5.minValue, e5.maxValue + s9) : r2.push(e5.minValue + s9, e5.maxValue + s9), o3.push(n9), i7.push([n9, t7.r, t7.g, t7.b])) : a13.push(e5.minValue, e5.maxValue);
  });
  const f7 = u8 ? x2(i7, u8) : i7, p14 = new N();
  p14.functionName = "Remap", p14.functionArguments = { InputRanges: r2, OutputValues: o3, NoDataRanges: a13 }, p14.variableName = "Raster";
  const g5 = new N();
  return g5.functionName = "Colormap", g5.functionArguments = { Colormap: f7, Raster: p14 }, t6.convertToRFT ? new N({ rasterFunctionDefinition: h2(g5) }) : g5;
}
function x2(e4, n9) {
  const r2 = c8.has(n9) ? s7(n9) : null;
  return r2 && e4.push([Math.floor(r2[0] - 1), 0, 0, 0], [Math.ceil(r2[1] + 1), 0, 0, 0]), e4;
}
function C(e4) {
  if (null == e4)
    return;
  const { fields: n9 } = e4, t6 = n9 == null ? void 0 : n9.find((e5) => (e5 == null ? void 0 : e5.name) && "value" === e5.name.toLowerCase());
  return t6 == null ? void 0 : t6.name;
}
function F(e4, t6) {
  var _a, _b, _c;
  const r2 = [], { pixelType: o3, rasterAttributeTable: a13 } = t6, i7 = null == a13 ? null : a13.features, s9 = C(a13), u8 = (_b = (_a = e4.defaultSymbol) == null ? void 0 : _a.color) == null ? void 0 : _b.toRgb(), l9 = e4.uniqueValueInfos;
  if (l9)
    if (i7) {
      if (s9) {
        const n9 = /* @__PURE__ */ new Map();
        l9.forEach((e5) => {
          var _a2;
          const t8 = e5.value, r3 = (_a2 = e5.symbol) == null ? void 0 : _a2.color;
          null != t8 && (r3 == null ? void 0 : r3.a) && n9.set(String(t8), r3.toRgb());
        });
        const t7 = e4.field;
        i7.forEach(({ attributes: e5 }) => {
          const o4 = String(e5[t7]), a14 = e5[s9], i8 = n9.get(o4);
          i8 ? r2.push([a14, ...i8]) : u8 && r2.push([a14, ...u8]);
        });
      }
    } else
      for (let n9 = 0; n9 < l9.length; n9++) {
        const e5 = l9[n9], t7 = (_c = e5.symbol) == null ? void 0 : _c.color, o4 = +e5.value;
        if (t7 == null ? void 0 : t7.a) {
          if (isNaN(o4))
            return null;
          r2.push([o4, t7.r, t7.g, t7.b]);
        }
      }
  const c17 = o3 ? x2(r2, o3) : r2, m8 = new N();
  return m8.functionName = "Colormap", m8.functionArguments = {}, m8.functionArguments.Colormap = c17, m8.variableName = "Raster", t6.convertToRFT ? new N({ rasterFunctionDefinition: h2(m8) }) : m8;
}
function A3(e4, t6) {
  const r2 = e4.extractColormap();
  if (!r2 || 0 === r2.length)
    return null;
  const { pixelType: o3 } = t6, a13 = o3 ? x2(r2, o3) : r2, i7 = new N();
  return i7.functionName = "Colormap", i7.functionArguments = {}, i7.functionArguments.Colormap = a13, t6.convertToRFT ? new N({ rasterFunctionDefinition: h2(i7) }) : i7;
}
function N2(e4) {
  const n9 = [];
  return e4 == null ? void 0 : e4.forEach((e5) => {
    const t6 = e5;
    if (Array.isArray(t6))
      n9.push(t6);
    else {
      if (null == t6.min || null == t6.max)
        return;
      const e6 = [t6.min, t6.max, t6.avg || 0, t6.stddev || 0];
      n9.push(e6);
    }
  }), n9;
}
function V2(e4) {
  const n9 = [], t6 = [];
  return e4.forEach((e5) => {
    n9.push(e5[0]), t6.push(A2([...e5.slice(1), 255]));
  }), { type: "RasterColormap", values: n9, colors: t6 };
}

// node_modules/@arcgis/core/layers/support/ExportImageServiceParameters.js
var y5 = class extends f {
  constructor() {
    super(...arguments), this.layer = null, this.compression = void 0, this.pixelType = void 0, this.lercVersion = 2;
  }
  get adjustAspectRatio() {
    return this.layer.adjustAspectRatio;
  }
  writeAdjustAspectRatio(e4, t6, r2) {
    this.layer.version < 10.3 || (t6[r2] = e4);
  }
  get bandIds() {
    return this.layer.bandIds;
  }
  get compressionQuality() {
    return this.layer.compressionQuality;
  }
  writeCompressionQuality(e4, t6, r2) {
    this.format && this.format.toLowerCase().includes("jpg") && null != e4 && (t6[r2] = e4);
  }
  get compressionTolerance() {
    return this.layer.compressionTolerance;
  }
  writeCompressionTolerance(e4, t6, r2) {
    "lerc" === this.format && null != e4 && (t6[r2] = e4);
  }
  get format() {
    var _a;
    return "vector-field" === ((_a = this.layer.renderer) == null ? void 0 : _a.type) ? "lerc" : this.layer.format;
  }
  get interpolation() {
    return this.layer.interpolation;
  }
  get noData() {
    return this.layer.noData;
  }
  get noDataInterpretation() {
    return this.layer.noDataInterpretation;
  }
  writeLercVersion(e4, t6, r2) {
    "lerc" === this.format && this.layer.version >= 10.5 && (t6[r2] = e4);
  }
  get version() {
    const e4 = this.layer;
    return e4.commitProperty("bandIds"), e4.commitProperty("format"), e4.commitProperty("compressionQuality"), e4.commitProperty("compressionTolerance"), e4.commitProperty("interpolation"), e4.commitProperty("noData"), e4.commitProperty("noDataInterpretation"), e4.commitProperty("mosaicRule"), e4.commitProperty("rasterFunction"), e4.commitProperty("adjustAspectRatio"), e4.commitProperty("pixelFilter"), e4.commitProperty("definitionExpression"), e4.commitProperty("multidimensionalSubset"), (this._get("version") || 0) + 1;
  }
  set version(e4) {
    this._set("version", e4);
  }
  get mosaicRule() {
    const e4 = this.layer;
    let t6 = e4.mosaicRule;
    const r2 = e4.definitionExpression;
    return t6 ? r2 && r2 !== t6.where && (t6 = t6.clone(), t6.where = r2) : r2 && (t6 = new j6({ where: r2 })), t6;
  }
  get rasterFunction() {
    var _a, _b;
    const e4 = this.layer;
    let { rasterFunction: t6 } = e4;
    const r2 = e4.pixelFilter, o3 = !e4.format || e4.format.includes("jpg") || e4.format.includes("png");
    t6 = this._addResampleRasterFunction(t6);
    const i7 = (_a = e4.multidimensionalSubset) == null ? void 0 : _a.areaOfInterest;
    return i7 && (t6 = this._addClipFunction(t6, i7)), o3 && !r2 && "vector-field" !== ((_b = e4.renderer) == null ? void 0 : _b.type) && (t6 = this.combineRendererWithRenderingRule(t6)), t6;
  }
  combineRendererWithRenderingRule(e4) {
    const t6 = this.layer, { rasterInfo: r2, renderer: o3 } = t6;
    if (e4 = e4 || t6.rasterFunction, !o3 || !p5(o3))
      return e4;
    return g3(y4(o3, { rasterAttributeTable: r2.attributeTable, pixelType: r2.pixelType, dataType: r2.dataType, bandNames: r2.bandInfos.map(({ name: e5 }) => e5), convertColorRampToColormap: t6.version < 10.6, convertToRFT: !!(e4 == null ? void 0 : e4.rasterFunctionDefinition), bandCount: r2.bandCount }), e4);
  }
  _addResampleRasterFunction(e4) {
    var _a;
    if (!("vector-field" === ((_a = this.layer.renderer) == null ? void 0 : _a.type)) || "Resample" === (e4 == null ? void 0 : e4.functionName))
      return e4;
    const t6 = "esriImageServiceDataTypeVector-UV" === this.layer.serviceDataType ? 7 : 10, r2 = this.layer.serviceRasterInfo.pixelSize;
    let o3 = new N({ functionName: "Resample", functionArguments: { ResamplingType: t6, InputCellSize: r2 } });
    return o3 = (e4 == null ? void 0 : e4.rasterFunctionDefinition) ? new N({ rasterFunctionDefinition: h2(o3) }) : o3, g3(o3, e4);
  }
  _addClipFunction(e4, t6) {
    const r2 = new N({ functionName: "Clip", functionArguments: { ClippingGeometry: t6.toJSON(), ClippingType: 1 } });
    return g3(r2, e4);
  }
};
e([y()], y5.prototype, "layer", void 0), e([y({ json: { write: true } })], y5.prototype, "adjustAspectRatio", null), e([r("adjustAspectRatio")], y5.prototype, "writeAdjustAspectRatio", null), e([y({ json: { write: true } })], y5.prototype, "bandIds", null), e([y({ json: { write: true } })], y5.prototype, "compression", void 0), e([y({ json: { write: true } })], y5.prototype, "compressionQuality", null), e([r("compressionQuality")], y5.prototype, "writeCompressionQuality", null), e([y({ json: { write: true } })], y5.prototype, "compressionTolerance", null), e([r("compressionTolerance")], y5.prototype, "writeCompressionTolerance", null), e([y({ json: { write: true } })], y5.prototype, "format", null), e([y({ type: String, json: { read: { reader: a6.read }, write: { writer: a6.write } } })], y5.prototype, "interpolation", null), e([y({ json: { write: true } })], y5.prototype, "noData", null), e([y({ type: String, json: { read: { reader: i3.read }, write: { writer: i3.write } } })], y5.prototype, "noDataInterpretation", null), e([y({ json: { write: true } })], y5.prototype, "pixelType", void 0), e([y({ json: { write: true } })], y5.prototype, "lercVersion", void 0), e([r("lercVersion")], y5.prototype, "writeLercVersion", null), e([y({ type: Number })], y5.prototype, "version", null), e([y({ json: { write: true } })], y5.prototype, "mosaicRule", null), e([y({ json: { write: true, name: "renderingRule" } })], y5.prototype, "rasterFunction", null), y5 = e([c("esri.layers.mixins.ExportImageServiceParameters")], y5);

// node_modules/@arcgis/core/rest/support/ImageAngleResult.js
var p6 = class extends f {
  constructor(r2) {
    super(r2), this.north = null, this.up = null, this.spatialReference = null;
  }
};
e([y({ type: Number, json: { write: true } })], p6.prototype, "north", void 0), e([y({ type: Number, json: { write: true } })], p6.prototype, "up", void 0), e([y({ type: f2, json: { write: true } })], p6.prototype, "spatialReference", void 0), p6 = e([c("esri.rest.support.ImageAngleResult")], p6);
var i4 = p6;

// node_modules/@arcgis/core/rest/support/BaseImageMeasureResult.js
var u4 = class extends f {
  constructor() {
    super(...arguments), this.value = null, this.displayValue = null, this.uncertainty = null;
  }
};
e([y({ type: Number, json: { read: true, write: true } })], u4.prototype, "value", void 0), e([y({ type: String, json: { read: true, write: true } })], u4.prototype, "displayValue", void 0), e([y({ type: Number, json: { read: true, write: true } })], u4.prototype, "uncertainty", void 0), u4 = e([c("esri.rest.support.ImageMeasureResultValue")], u4);
var a7 = class extends u4 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
e([y({ type: String, json: { read: de.read, write: de.write } })], a7.prototype, "unit", void 0), a7 = e([c("esri.rest.support.ImageMeasureResultLengthValue")], a7);
var n6 = class extends u4 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
e([y({ type: String, json: { read: fe.read, write: fe.write } })], n6.prototype, "unit", void 0), n6 = e([c("esri.rest.support.ImageMeasureResultAreaValue")], n6);
var l4 = class extends u4 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
e([y({ type: String, json: { read: Ue.read, write: Ue.write } })], l4.prototype, "unit", void 0), l4 = e([c("esri.rest.support.ImageMeasureResultAngleValue")], l4);
var c9 = class extends f {
  constructor() {
    super(...arguments), this.name = null, this.sensorName = null;
  }
};
e([y({ type: String, json: { read: true, write: true } })], c9.prototype, "name", void 0), e([y({ type: String, json: { read: true, write: true } })], c9.prototype, "sensorName", void 0), c9 = e([c("esri.rest.support.BaseImageMeasureResult")], c9);

// node_modules/@arcgis/core/rest/support/ImageAreaResult.js
var a8 = class extends c9 {
  constructor() {
    super(...arguments), this.area = null, this.perimeter = null;
  }
};
e([y({ type: n6, json: { read: true, write: true } })], a8.prototype, "area", void 0), e([y({ type: a7, json: { read: true, write: true } })], a8.prototype, "perimeter", void 0), a8 = e([c("esri.rest.support.ImageAreaResult")], a8);
var c10 = a8;

// node_modules/@arcgis/core/rest/support/ImageDistanceResult.js
var a9 = class extends c9 {
  constructor() {
    super(...arguments), this.distance = null, this.azimuthAngle = null, this.elevationAngle = null;
  }
};
e([y({ type: a7, json: { read: true, write: true } })], a9.prototype, "distance", void 0), e([y({ type: l4, json: { read: true, write: true } })], a9.prototype, "azimuthAngle", void 0), e([y({ type: l4, json: { read: true, write: true } })], a9.prototype, "elevationAngle", void 0), a9 = e([c("esri.rest.support.ImageDistanceResult")], a9);
var i5 = a9;

// node_modules/@arcgis/core/rest/support/ImageHeightResult.js
var p7 = class extends c9 {
  constructor() {
    super(...arguments), this.height = null;
  }
};
e([y({ type: a7, json: { read: true, write: true } })], p7.prototype, "height", void 0), p7 = e([c("esri.rest.support.ImageHeightResult")], p7);
var c11 = p7;

// node_modules/@arcgis/core/rest/support/ImageIdentifyResult.js
var p8 = class extends f {
  constructor() {
    super(...arguments), this.catalogItemVisibilities = null, this.catalogItems = null, this.location = null, this.name = null, this.objectId = null, this.processedValues = null, this.properties = null, this.value = null;
  }
};
e([y({ json: { write: true } })], p8.prototype, "catalogItemVisibilities", void 0), e([y({ type: d2, json: { write: true } })], p8.prototype, "catalogItems", void 0), e([y({ type: x, json: { write: true } })], p8.prototype, "location", void 0), e([y({ json: { write: true } })], p8.prototype, "name", void 0), e([y({ json: { write: true } })], p8.prototype, "objectId", void 0), e([y({ json: { write: true } })], p8.prototype, "processedValues", void 0), e([y({ json: { write: true } })], p8.prototype, "properties", void 0), e([y({ json: { write: true } })], p8.prototype, "value", void 0), p8 = e([c("esri.rest.support.ImageIdentifyResult")], p8);
var l5 = p8;

// node_modules/@arcgis/core/rest/support/ImagePixelLocationResult.js
var t5 = class extends f {
  constructor() {
    super(...arguments), this.geometries = null;
  }
};
e([y({ json: { write: true } })], t5.prototype, "geometries", void 0), t5 = e([c("esri.rest.support.ImagePixelLocationResult")], t5);
var p9 = t5;

// node_modules/@arcgis/core/rest/support/ImagePointResult.js
var p10 = class extends c9 {
  constructor() {
    super(...arguments), this.point = null;
  }
};
e([y({ type: x, json: { name: "point.value", read: true, write: true } })], p10.prototype, "point", void 0), p10 = e([c("esri.rest.support.ImagePointResult")], p10);
var a10 = p10;

// node_modules/@arcgis/core/rest/support/ImageSample.js
var i6 = class extends f {
  constructor() {
    super(...arguments), this.attributes = null, this.location = null, this.locationId = null, this.rasterId = null, this.resolution = null, this.pixelValue = null;
  }
};
e([y({ json: { write: true } })], i6.prototype, "attributes", void 0), e([y({ type: x, json: { write: true } })], i6.prototype, "location", void 0), e([y({ json: { write: true } })], i6.prototype, "locationId", void 0), e([y({ json: { write: true } })], i6.prototype, "rasterId", void 0), e([y({ json: { write: true } })], i6.prototype, "resolution", void 0), e([y({ json: { write: true } })], i6.prototype, "pixelValue", void 0), i6 = e([c("esri.rest.support.ImageSample")], i6);
var p11 = i6;

// node_modules/@arcgis/core/rest/support/ImageSampleResult.js
var p12 = class extends f {
  constructor() {
    super(...arguments), this.samples = null;
  }
};
e([y({ type: [p11], json: { write: true } })], p12.prototype, "samples", void 0), p12 = e([c("esri.rest.support.ImageSampleResult")], p12);
var c12 = p12;

// node_modules/@arcgis/core/rest/imageService.js
function y6(t6) {
  const e4 = t6 == null ? void 0 : t6.time;
  if (e4 && (null != e4.start || null != e4.end)) {
    const o3 = [];
    null != e4.start && o3.push(e4.start), null == e4.end || o3.includes(e4.end) || o3.push(e4.end), t6.time = o3.join(",");
  }
}
async function d7(t6, o3, s9) {
  const i7 = f3(t6), m8 = o3.geometry ? [o3.geometry] : [], u8 = await R(m8), c17 = o3.toJSON();
  y6(c17);
  const l9 = u8 == null ? void 0 : u8[0];
  null != l9 && (c17.geometry = l9.toJSON());
  const p14 = s4({ ...i7.query, f: "json", ...c17 });
  return i(p14, s9);
}
async function S2(e4, o3, i7) {
  var _a, _b, _c;
  const m8 = o3.toJSON();
  null != m8.angleName && (m8.angleName = m8.angleName.join(",")), ((_b = (_a = o3 == null ? void 0 : o3.point) == null ? void 0 : _a.spatialReference) == null ? void 0 : _b.imageCoordinateSystem) && (m8.point.spatialReference = G2(o3.point.spatialReference)), ((_c = o3 == null ? void 0 : o3.spatialReference) == null ? void 0 : _c.imageCoordinateSystem) && (m8.spatialReference = $(o3.spatialReference));
  const u8 = f3(e4), c17 = s4({ ...u8.query, f: "json", ...m8 }), l9 = i(c17, i7), { data: p14 } = await j2(`${u8.path}/computeAngles`, l9);
  return p14.spatialReference = p14.spatialReference ? null != p14.spatialReference.geodataXform ? new f2({ wkid: 0, imageCoordinateSystem: p14.spatialReference }) : f2.fromJSON(p14.spatialReference) : null, "NaN" === p14.north && (p14.north = null), "NaN" === p14.up && (p14.up = null), new i4(p14);
}
async function N3(e4, o3, s9) {
  var _a;
  const i7 = o3.toJSON(), { geometries: m8 } = o3;
  if (m8)
    for (let t6 = 0; t6 < m8.length; t6++)
      ((_a = m8[t6].spatialReference) == null ? void 0 : _a.imageCoordinateSystem) && (i7.geometries.geometries[t6].spatialReference = G2(m8[t6].spatialReference));
  const u8 = f3(e4), c17 = s4({ ...u8.query, f: "json", ...i7 }), p14 = i(c17, s9), { data: f7 } = await j2(`${u8.path}/computePixelLocation`, p14);
  return p9.fromJSON(f7);
}
async function R3(e4, o3, a13) {
  const r2 = await d7(e4, o3, a13), s9 = f3(e4), { data: i7 } = await j2(`${s9.path}/computeStatisticsHistograms`, r2), { statistics: m8 } = i7;
  return (m8 == null ? void 0 : m8.length) && m8.forEach((t6) => {
    t6.avg = t6.mean, t6.stddev = t6.standardDeviation;
  }), { statistics: m8, histograms: i7.histograms };
}
async function j7(e4, o3, a13) {
  const r2 = await d7(e4, o3, a13), s9 = f3(e4), { data: i7 } = await j2(`${s9.path}/computeHistograms`, r2);
  return { histograms: i7.histograms };
}
async function J(o3, s9, i7) {
  var _a, _b;
  const m8 = s9.toJSON();
  y6(m8), ((_a = m8.outFields) == null ? void 0 : _a.length) && (m8.outFields = m8.outFields.join(","));
  const u8 = await R(s9.geometry), c17 = u8 == null ? void 0 : u8[0];
  null != c17 && (m8.geometry = c17.toJSON());
  const l9 = f3(o3), p14 = s4({ ...l9.query, f: "json", ...m8 }), g5 = i(p14, i7), { data: d10 } = await j2(`${l9.path}/getSamples`, g5), S3 = (_b = d10 == null ? void 0 : d10.samples) == null ? void 0 : _b.map((t6) => {
    const e4 = "NaN" === t6.value || "" === t6.value ? null : t6.value.split(" ").map((t7) => Number(t7));
    return { ...t6, pixelValue: e4 };
  });
  return c12.fromJSON({ samples: S3 });
}
async function O(o3, s9, i7) {
  const m8 = f3(o3), u8 = s9.geometry ? [s9.geometry] : [];
  return R(u8).then((e4) => {
    const o4 = s9.toJSON(), n9 = e4 == null ? void 0 : e4[0];
    null != n9 && (o4.geometry = JSON.stringify(n9.toJSON()));
    const u9 = s4({ ...m8.query, f: "json", ...o4 }), c17 = i(u9, i7);
    return j2(m8.path + "/identify", c17);
  }).then((t6) => l5.fromJSON(t6.data));
}
async function h3(t6, e4, o3) {
  const n9 = await q(t6, e4, [e4.fromGeometry, e4.toGeometry], o3);
  return c11.fromJSON(n9);
}
async function w2(t6, e4, o3) {
  const n9 = await q(t6, e4, [e4.geometry], o3);
  return c10.fromJSON(n9);
}
async function C2(t6, e4, o3) {
  const n9 = await q(t6, e4, [e4.geometry], o3);
  return a10.fromJSON(n9);
}
async function I2(t6, e4, o3) {
  const n9 = await q(t6, e4, [e4.fromGeometry, e4.toGeometry], o3);
  return i5.fromJSON(n9);
}
async function q(o3, s9, i7, m8) {
  const u8 = f3(o3), c17 = await R(i7), l9 = s9.toJSON();
  null != c17[0] && (l9.fromGeometry = JSON.stringify(v4(c17[0]))), null != c17[1] && (l9.toGeometry = JSON.stringify(v4(c17[1])));
  const p14 = s4({ ...u8.query, f: "json", ...l9 }), f7 = i(p14, m8), { data: g5 } = await j2(u8.path + "/measure", f7);
  return g5;
}
function v4(t6) {
  var _a;
  const e4 = t6.toJSON();
  return ((_a = t6.spatialReference) == null ? void 0 : _a.imageCoordinateSystem) && (e4.spatialReference = G2(t6.spatialReference)), e4;
}
function G2(t6) {
  const { imageCoordinateSystem: e4 } = t6;
  if (e4) {
    const { id: t7, referenceServiceName: o3 } = e4;
    return null != t7 ? o3 ? { icsid: t7, icsns: o3 } : { icsid: t7 } : { ics: e4 };
  }
  return t6.toJSON();
}
function $(t6, e4) {
  if (!t6.imageCoordinateSystem)
    return T2(t6);
  const n9 = G2(t6), { icsid: a13, icsns: r2 } = n9;
  return null == a13 || null != r2 && !(e4 == null ? void 0 : e4.toLowerCase().includes("/" + r2.toLowerCase() + "/")) ? JSON.stringify(n9) : `0:${a13}`;
}

// node_modules/@arcgis/core/rest/imageService/getCatalogItemRasterInfo.js
async function n7(n9, m8, p14) {
  var _a, _b;
  const f7 = f3(n9), u8 = s4({ ...f7 == null ? void 0 : f7.query, f: "json" }), h5 = i(u8, p14), d10 = `${f7 == null ? void 0 : f7.path}/${m8}/info`, c17 = j2(`${d10}`, h5), g5 = j2(`${d10}/keyProperties`, h5), x4 = await Promise.allSettled([c17, g5]), y12 = "fulfilled" === x4[0].status ? x4[0].value.data : null, v5 = "fulfilled" === x4[1].status ? x4[1].value.data : null;
  let P2 = null;
  ((_a = y12.statistics) == null ? void 0 : _a.length) && (P2 = y12.statistics.map((e4) => ({ min: e4[0], max: e4[1], avg: e4[2], stddev: e4[3] })));
  const S3 = M.fromJSON(y12.extent), j9 = Math.ceil(S3.width / y12.pixelSizeX - 0.1), w3 = Math.ceil(S3.height / y12.pixelSizeY - 0.1), b5 = S3.spatialReference, k4 = new x({ x: y12.pixelSizeX, y: y12.pixelSizeY, spatialReference: b5 }), z = ((_b = y12.histograms) == null ? void 0 : _b.length) ? y12.histograms : null, L2 = new n3({ origin: y12.origin, blockWidth: y12.blockWidth, blockHeight: y12.blockHeight, firstPyramidLevel: y12.firstPyramidLevel, maximumPyramidLevel: y12.maxPyramidLevel });
  return new m2({ width: j9, height: w3, bandCount: y12.bandCount, extent: S3, spatialReference: b5, pixelSize: k4, pixelType: y12.pixelType.toLowerCase(), statistics: P2, histograms: z, keyProperties: v5, storageInfo: L2 });
}

// node_modules/@arcgis/core/rest/support/ImageAngleParameters.js
var n8;
var m6 = n8 = class extends f {
  constructor(e4) {
    super(e4), this.angleNames = null, this.point = null, this.spatialReference = null, this.rasterId = null;
  }
  clone() {
    return new n8(a({ angleNames: this.angleNames, point: this.point, spatialReference: this.spatialReference, rasterId: this.rasterId }));
  }
};
e([y({ type: [String], json: { name: "angleName", write: true } })], m6.prototype, "angleNames", void 0), e([y({ type: x, json: { write: true } })], m6.prototype, "point", void 0), e([y({ type: f2, json: { write: true } })], m6.prototype, "spatialReference", void 0), e([y({ type: T, json: { write: true } })], m6.prototype, "rasterId", void 0), m6 = n8 = e([c("esri.rest.support.ImageAngleParameters")], m6);
var l6 = m6;

// node_modules/@arcgis/core/rest/support/BaseImageMeasureParameters.js
var a11 = new s3({ esriMensurationPoint: "point", esriMensurationCentroid: "centroid", esriMensurationDistanceAndAngle: "distance-and-angle", esriMensurationAreaAndPerimeter: "area-and-perimeter", esriMensurationHeightFromBaseAndTop: "base-and-top", esriMensurationHeightFromBaseAndTopShadow: "base-and-top-shadow", esriMensurationHeightFromTopAndTopShadow: "top-and-top-shadow", esriMensurationPoint3D: "point-3D", esriMensurationCentroid3D: "centroid-3D", esriMensurationDistanceAndAngle3D: "distance-and-angle-3D", esriMensurationAreaAndPerimeter3D: "area-and-perimeter-3D" });
var p13 = class extends f {
  constructor() {
    super(...arguments), this.type = null, this.measureOperation = null, this.mosaicRule = null, this.pixelSize = null, this.raster = void 0;
  }
};
e([y()], p13.prototype, "type", void 0), e([y({ type: a11.apiValues, json: { read: a11.read, write: a11.write } })], p13.prototype, "measureOperation", void 0), e([y({ type: j6, json: { write: true } })], p13.prototype, "mosaicRule", void 0), e([y({ type: x, json: { write: true } })], p13.prototype, "pixelSize", void 0), e([y({ json: { write: true } })], p13.prototype, "raster", void 0), p13 = e([c("esri.rest.support.BaseImageMeasureParameters")], p13);

// node_modules/@arcgis/core/rest/support/ImageAreaParameters.js
var l7;
var u5 = l7 = class extends p13 {
  constructor() {
    super(...arguments), this.type = "area-perimeter", this.geometry = null, this.is3D = false, this.linearUnit = "meters", this.areaUnit = "square-meters";
  }
  writeGeometry(e4, r2, t6) {
    null != e4 && (r2.geometryType = v2(e4), r2[t6] = e4.toJSON());
  }
  get measureOperation() {
    return this.is3D ? "area-and-perimeter-3D" : "area-and-perimeter";
  }
  clone() {
    return new l7(a({ geometry: this.geometry, is3D: this.is3D, linearUnit: this.linearUnit, areaUnit: this.areaUnit, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
e([y({ types: n, json: { name: "fromGeometry", read: true, write: true } })], u5.prototype, "geometry", void 0), e([r("geometry")], u5.prototype, "writeGeometry", null), e([y({ type: a11.apiValues, json: { write: a11.write } })], u5.prototype, "measureOperation", null), e([y({ json: { read: true } })], u5.prototype, "is3D", void 0), e([y({ type: String, json: { read: de.read, write: de.write } })], u5.prototype, "linearUnit", void 0), e([y({ type: String, json: { read: fe.read, write: fe.write } })], u5.prototype, "areaUnit", void 0), u5 = l7 = e([c("esri.rest.support.ImageAreaParameters")], u5);
var y7 = u5;

// node_modules/@arcgis/core/rest/support/ImageDistanceParameters.js
var y8;
var c13 = y8 = class extends p13 {
  constructor() {
    super(...arguments), this.type = "distance-angle", this.fromGeometry = null, this.toGeometry = null, this.is3D = false, this.linearUnit = "meters", this.angularUnit = "degrees";
  }
  writeFromGeometry(e4, r2, t6) {
    null != e4 && (r2.geometryType = v2(e4), r2[t6] = e4.toJSON());
  }
  get measureOperation() {
    return this.is3D ? "distance-and-angle-3D" : "distance-and-angle";
  }
  clone() {
    return new y8(a({ fromGeometry: this.fromGeometry, toGeometry: this.toGeometry, is3D: this.is3D, linearUnit: this.linearUnit, angularUnit: this.angularUnit, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
e([y({ type: x, json: { read: true, write: true } })], c13.prototype, "fromGeometry", void 0), e([r("fromGeometry")], c13.prototype, "writeFromGeometry", null), e([y({ type: x, json: { read: true, write: true } })], c13.prototype, "toGeometry", void 0), e([y({ type: a11.apiValues, json: { write: a11.write } })], c13.prototype, "measureOperation", null), e([y({ json: { read: true } })], c13.prototype, "is3D", void 0), e([y({ type: String, json: { read: de.read, write: de.write } })], c13.prototype, "linearUnit", void 0), e([y({ type: String, json: { read: Ue.read, write: Ue.write } })], c13.prototype, "angularUnit", void 0), c13 = y8 = e([c("esri.rest.support.ImageDistanceParameters")], c13);
var u6 = c13;

// node_modules/@arcgis/core/rest/support/ImageHeightParameters.js
var y9;
var l8 = y9 = class extends p13 {
  constructor() {
    super(...arguments), this.type = "height", this.fromGeometry = null, this.toGeometry = null, this.operationType = "base-and-top", this.linearUnit = "meters";
  }
  writeFromGeometry(e4, r2, t6) {
    null != e4 && (r2.geometryType = v2(e4), r2[t6] = e4.toJSON());
  }
  get measureOperation() {
    return this.operationType;
  }
  clone() {
    return new y9(a({ fromGeometry: this.fromGeometry, toGeometry: this.toGeometry, operationType: this.operationType, linearUnit: this.linearUnit, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
e([y({ type: x, json: { read: true } })], l8.prototype, "fromGeometry", void 0), e([r("fromGeometry")], l8.prototype, "writeFromGeometry", null), e([y({ type: x, json: { read: true, write: true } })], l8.prototype, "toGeometry", void 0), e([y({ type: a11.apiValues, json: { write: a11.write } })], l8.prototype, "measureOperation", null), e([y({ json: { read: true } })], l8.prototype, "operationType", void 0), e([y({ type: String, json: { read: de.read, write: de.write } })], l8.prototype, "linearUnit", void 0), l8 = y9 = e([c("esri.rest.support.ImageHeightParameters")], l8);
var c14 = l8;

// node_modules/@arcgis/core/rest/support/ImageIdentifyParameters.js
var y10;
var g4 = y10 = class extends f {
  constructor() {
    super(...arguments), this.geometry = null, this.rasterFunctions = null, this.pixelSize = null, this.returnGeometry = true, this.returnCatalogItems = true, this.returnPixelValues = true, this.maxItemCount = null, this.timeExtent = null, this.raster = void 0, this.viewId = void 0, this.processAsMultidimensional = false;
  }
  writeGeometry(e4, t6, r2) {
    null != e4 && (t6.geometryType = v2(e4), t6[r2] = JSON.stringify(e4.toJSON()));
  }
  set mosaicRule(e4) {
    let t6 = e4;
    (t6 == null ? void 0 : t6.mosaicMethod) && (t6 = j6.fromJSON({ ...t6.toJSON(), mosaicMethod: t6.mosaicMethod, mosaicOperation: t6.mosaicOperation })), this._set("mosaicRule", t6);
  }
  writeMosaicRule(e4, t6, r2) {
    null != e4 && (t6[r2] = JSON.stringify(e4.toJSON()));
  }
  get renderingRule() {
    return t(s.getLogger(this), "renderingRule", { replacement: "rasterFunction", version: "4.27", warnOnce: true }), this._get("rasterFunction");
  }
  set renderingRule(e4) {
    t(s.getLogger(this), "renderingRule", { replacement: "rasterFunction", version: "4.27", warnOnce: true }), this._set("rasterFunction", e4);
  }
  get renderingRules() {
    return t(s.getLogger(this), "renderingRules", { replacement: "rasterFunctions", version: "4.27", warnOnce: true }), this._get("rasterFunctions");
  }
  set renderingRules(e4) {
    t(s.getLogger(this), "renderingRules", { replacement: "rasterFunctions", version: "4.27", warnOnce: true }), this._set("rasterFunctions", e4);
  }
  set rasterFunction(e4) {
    let t6 = e4;
    (t6 == null ? void 0 : t6.rasterFunction) && (t6 = N.fromJSON({ ...t6.toJSON(), rasterFunction: t6.rasterFunction, rasterFunctionArguments: t6.rasterFunctionArguments })), this._set("rasterFunction", t6);
  }
  writeRasterFunction(e4, t6, r2) {
    null != e4 && (t6[r2] = JSON.stringify(e4.toJSON())), e4.rasterFunctionDefinition && (t6[r2] = JSON.stringify(e4.rasterFunctionDefinition));
  }
  writeRasterFunctions(e4, t6, r2) {
    null != e4 && (t6[r2] = JSON.stringify(e4.map((e5) => e5.rasterFunctionDefinition || e5.toJSON())));
  }
  writePixelSize(e4, t6, r2) {
    null != e4 && (t6[r2] = JSON.stringify(e4));
  }
  writeTimeExtent(e4, t6, r2) {
    if (null != e4) {
      const o3 = null != e4.start ? e4.start.getTime() : null, i7 = null != e4.end ? e4.end.getTime() : null;
      t6[r2] = null != o3 ? null != i7 ? `${o3},${i7}` : `${o3}` : null;
    }
  }
  clone() {
    return new y10(a({ geometry: this.geometry, mosaicRule: this.mosaicRule, rasterFunction: this.rasterFunction, rasterFunctions: this.rasterFunctions, pixelSize: this.pixelSize, returnGeometry: this.returnGeometry, returnCatalogItems: this.returnCatalogItems, returnPixelValues: this.returnPixelValues, maxItemCount: this.maxItemCount, processAsMultidimensional: this.processAsMultidimensional, raster: this.raster, viewId: this.viewId, timeExtent: this.timeExtent }));
  }
};
e([y({ json: { write: true } })], g4.prototype, "geometry", void 0), e([r("geometry")], g4.prototype, "writeGeometry", null), e([y({ type: j6, json: { write: true } })], g4.prototype, "mosaicRule", null), e([r("mosaicRule")], g4.prototype, "writeMosaicRule", null), e([y({ type: N })], g4.prototype, "renderingRule", null), e([y({ type: [N] })], g4.prototype, "renderingRules", null), e([y({ type: N, json: { write: true, name: "renderingRule" } })], g4.prototype, "rasterFunction", null), e([r("rasterFunction")], g4.prototype, "writeRasterFunction", null), e([y({ type: [N], json: { write: true, name: "renderingRules" } })], g4.prototype, "rasterFunctions", void 0), e([r("rasterFunctions")], g4.prototype, "writeRasterFunctions", null), e([y({ type: x, json: { write: true } })], g4.prototype, "pixelSize", void 0), e([r("pixelSize")], g4.prototype, "writePixelSize", null), e([y({ type: Boolean, json: { write: true } })], g4.prototype, "returnGeometry", void 0), e([y({ type: Boolean, json: { write: true } })], g4.prototype, "returnCatalogItems", void 0), e([y({ type: Boolean, json: { write: true } })], g4.prototype, "returnPixelValues", void 0), e([y({ type: Number, json: { write: true } })], g4.prototype, "maxItemCount", void 0), e([y({ type: c2, json: { write: { target: "time" } } })], g4.prototype, "timeExtent", void 0), e([r("timeExtent")], g4.prototype, "writeTimeExtent", null), e([y({ json: { write: true } })], g4.prototype, "raster", void 0), e([y({ json: { write: true } })], g4.prototype, "viewId", void 0), e([y({ type: Boolean, json: { write: true } })], g4.prototype, "processAsMultidimensional", void 0), g4 = y10 = e([c("esri.rest.support.ImageIdentifyParameters")], g4);
var d8 = g4;

// node_modules/@arcgis/core/rest/support/ImagePixelLocationParameters.js
var m7;
var c15 = m7 = class extends f {
  constructor() {
    super(...arguments), this.geometries = null, this.rasterId = null;
  }
  writeGeometry(r2, e4, o3) {
    e4.geometries = { geometryType: "esriGeometryPoint", geometries: r2.map((r3) => r3.toJSON()) };
  }
  clone() {
    var _a;
    return new m7({ geometries: ((_a = this.geometries) == null ? void 0 : _a.map((r2) => r2.clone())) ?? [], rasterId: this.rasterId });
  }
};
e([y({ type: [x], json: { write: true } })], c15.prototype, "geometries", void 0), e([r("geometries")], c15.prototype, "writeGeometry", null), e([y({ type: T, json: { write: true } })], c15.prototype, "rasterId", void 0), c15 = m7 = e([c("esri.rest.support.ImagePixelLocationParameters")], c15);
var a12 = c15;

// node_modules/@arcgis/core/rest/support/ImagePointParameters.js
var c16;
var u7 = c16 = class extends p13 {
  constructor() {
    super(...arguments), this.type = "point", this.geometry = null, this.is3D = false;
  }
  writeGeometry(e4, r2, t6) {
    null != e4 && (r2.geometryType = v2(e4), r2[t6] = e4.toJSON());
  }
  get measureOperation() {
    const { is3D: e4, geometry: r2 } = this;
    return "point" === r2.type ? e4 ? "point-3D" : "point" : e4 ? "centroid-3D" : "centroid";
  }
  clone() {
    return new c16(a({ geometry: this.geometry, is3D: this.is3D, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
e([y({ types: n, json: { name: "fromGeometry", read: p } })], u7.prototype, "geometry", void 0), e([r("geometry")], u7.prototype, "writeGeometry", null), e([y({ type: a11.apiValues, json: { read: a11.read, write: a11.write } })], u7.prototype, "measureOperation", null), e([y({ json: { read: true } })], u7.prototype, "is3D", void 0), u7 = c16 = e([c("esri.rest.support.ImagePointParameters")], u7);
var y11 = u7;

// node_modules/@arcgis/core/rest/support/ImageSampleParameters.js
var d9;
var j8 = d9 = class extends f {
  constructor() {
    super(...arguments), this.geometry = null, this.interpolation = "nearest", this.mosaicRule = null, this.outFields = null, this.pixelSize = null, this.returnFirstValueOnly = true, this.sampleDistance = null, this.sampleCount = null, this.sliceId = null, this.timeExtent = null;
  }
  writeGeometry(t6, e4, o3) {
    null != t6 && (e4.geometryType = v2(t6), e4[o3] = t6.toJSON());
  }
  set locations(t6) {
    if (t6 == null ? void 0 : t6.length) {
      const e4 = new u({ spatialReference: t6[0].spatialReference });
      e4.points = t6.map((t7) => [t7.x, t7.y]), this._set("locations", t6), this.geometry = e4;
    }
  }
  clone() {
    return new d9(a({ geometry: this.geometry, locations: this.locations, interpolation: this.interpolation, mosaicRule: this.mosaicRule, outFields: this.outFields, raster: this.raster, returnFirstValueOnly: this.returnFirstValueOnly, sampleDistance: this.sampleDistance, sampleCount: this.sampleCount, sliceId: this.sliceId, pixelSize: this.pixelSize, timeExtent: this.timeExtent }));
  }
};
e([y({ types: n, json: { read: p } })], j8.prototype, "geometry", void 0), e([r("geometry")], j8.prototype, "writeGeometry", null), e([y()], j8.prototype, "locations", null), e([y({ type: String, json: { type: a6.jsonValues, read: a6.read, write: a6.write } })], j8.prototype, "interpolation", void 0), e([y({ type: j6, json: { write: true } })], j8.prototype, "mosaicRule", void 0), e([y({ type: [String], json: { write: true } })], j8.prototype, "outFields", void 0), e([y({ type: x, json: { write: true } })], j8.prototype, "pixelSize", void 0), e([y({ type: String, json: { write: true } })], j8.prototype, "raster", void 0), e([y({ type: Boolean, json: { write: true } })], j8.prototype, "returnFirstValueOnly", void 0), e([y({ type: Number, json: { write: true } })], j8.prototype, "sampleDistance", void 0), e([y({ type: Number, json: { write: true } })], j8.prototype, "sampleCount", void 0), e([y({ type: Number, json: { write: true } })], j8.prototype, "sliceId", void 0), e([y({ type: c2, json: { read: { source: "time" }, write: { target: "time" } } })], j8.prototype, "timeExtent", void 0), j8 = d9 = e([c("esri.rest.support.ImageSampleParameters")], j8);
var h4 = j8;

// node_modules/@arcgis/core/layers/mixins/ArcGISImageService.js
var je = /* @__PURE__ */ new Set(["png", "png8", "png24", "png32", "jpg", "bmp", "gif", "jpgpng", "lerc", "tiff"]);
var Pe = j(a3, { min: 0, max: 255 });
function Te(e4) {
  if (!e4)
    return null;
  const t6 = JSON.stringify(e4).match(/"rasterFunction":"(.*?")/gi), r2 = t6 == null ? void 0 : t6.map((e5) => e5.replace('"rasterFunction":"', "").replace('"', ""));
  return r2 ? r2.join("/") : null;
}
var Oe = (d10) => {
  let y12 = class extends d10 {
    constructor() {
      super(...arguments), this._functionRasterInfos = {}, this._rasterJobHandler = { instance: null, refCount: 0, connectionPromise: null }, this._cachedRendererJson = null, this._serviceSupportsMosaicRule = null, this._rasterAttributeTableFieldPrefix = "Raster.", this.adjustAspectRatio = null, this.bandIds = void 0, this.capabilities = null, this.compressionQuality = void 0, this.compressionTolerance = 0.01, this.copyright = null, this.defaultMosaicRule = null, this.definitionExpression = null, this.exportImageServiceParameters = null, this.rasterInfo = null, this.fields = null, this.fullExtent = null, this.hasMultidimensions = false, this.imageMaxHeight = 4100, this.imageMaxWidth = 4100, this.interpolation = void 0, this.minScale = 0, this.maxScale = 0, this.multidimensionalInfo = null, this.multidimensionalSubset = null, this.noData = null, this.noDataInterpretation = void 0, this.objectIdField = null, this.geometryType = "polygon", this.typeIdField = null, this.types = [], this.pixelFilter = null, this.raster = void 0, this.sourceType = null, this.viewId = void 0, this.symbolizer = null, this.rasterFunctionInfos = null, this.serviceDataType = null, this.spatialReference = null, this.pixelType = null, this.serviceRasterInfo = null, this.sourceJSON = null, this.url = null, this.version = void 0;
    }
    initialize() {
      this._set("exportImageServiceParameters", new y5({ layer: this }));
    }
    readServiceSupportsMosaicRule(e4, t6) {
      return this._isMosaicRuleSupported(t6);
    }
    get _rasterFunctionNamesIndex() {
      const e4 = /* @__PURE__ */ new Map();
      return !this.rasterFunctionInfos || null != this.rasterFunctionInfos && this.rasterFunctionInfos.length < 1 || null != this.rasterFunctionInfos && this.rasterFunctionInfos.forEach((t6) => {
        e4.set(t6.name.toLowerCase().replaceAll(/ /gi, "_"), t6.name);
      }), e4;
    }
    readBandIds(e4, t6) {
      if (Array.isArray(e4) && e4.length > 0 && e4.every((e5) => "number" == typeof e5))
        return e4;
    }
    readCapabilities(e4, t6) {
      return this._readCapabilities(t6);
    }
    writeCompressionQuality(e4, t6, r2) {
      null != e4 && "lerc" !== this.format && (t6[r2] = e4);
    }
    writeCompressionTolerance(e4, t6, r2) {
      "lerc" === this.format && null != e4 && (t6[r2] = e4);
    }
    readDefaultMosaicRule(e4, t6) {
      return this._serviceSupportsMosaicRule ? j6.fromJSON(t6) : null;
    }
    get fieldsIndex() {
      return this.fields ? new Z(this.fields) : null;
    }
    set format(e4) {
      e4 && je.has(e4.toLowerCase()) && this._set("format", e4.toLowerCase());
    }
    readFormat(e4, t6) {
      return "esriImageServiceDataTypeVector-UV" === t6.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === t6.serviceDataType || null != this.pixelFilter ? "lerc" : "jpgpng";
    }
    readMinScale(e4, t6) {
      return null != t6.minLOD && null != t6.maxLOD ? e4 : 0;
    }
    readMaxScale(e4, t6) {
      return null != t6.minLOD && null != t6.maxLOD ? e4 : 0;
    }
    set mosaicRule(e4) {
      let t6 = e4;
      (t6 == null ? void 0 : t6.mosaicMethod) && (t6 = j6.fromJSON({ ...t6.toJSON(), mosaicMethod: t6.mosaicMethod, mosaicOperation: t6.mosaicOperation })), this._set("mosaicRule", t6);
    }
    readMosaicRule(e4, t6) {
      const r2 = e4 || t6.mosaicRule;
      return r2 ? j6.fromJSON(r2) : this._isMosaicRuleSupported(t6) ? j6.fromJSON(t6) : null;
    }
    writeMosaicRule(e4, t6, r2) {
      let i7 = this.mosaicRule;
      const s9 = this.definitionExpression;
      i7 ? s9 && s9 !== i7.where && (i7 = i7.clone(), i7.where = s9) : s9 && (i7 = new j6({ where: s9 })), this._isValidCustomizedMosaicRule(i7) && (t6[r2] = i7.toJSON());
    }
    writeNoData(e4, t6, r2) {
      null != e4 && "number" == typeof e4 && (t6[r2] = Pe(e4));
    }
    readObjectIdField(e4, t6) {
      if (!e4) {
        const r2 = t6.fields.find((e5) => "esriFieldTypeOID" === e5.type || "oid" === e5.type);
        e4 = r2 == null ? void 0 : r2.name;
      }
      return e4;
    }
    get parsedUrl() {
      return I(this.url);
    }
    readSourceType(e4, t6) {
      return this._isMosaicDataset(t6) ? "mosaic-dataset" : "raster-dataset";
    }
    set renderer(e4) {
      this.loaded && (e4 = this._configRenderer(e4)), this._set("renderer", e4);
    }
    readRenderer(e4, t6, r2) {
      var _a, _b;
      const i7 = (_b = (_a = t6 == null ? void 0 : t6.layerDefinition) == null ? void 0 : _a.drawingInfo) == null ? void 0 : _b.renderer, n9 = c6(i7, r2);
      return null == n9 ? null : ("vector-field" === n9.type && t6.symbolTileSize && !i7.symbolTileSize && (n9.symbolTileSize = t6.symbolTileSize), p5(n9) || s.getLogger(this).warn("ArcGISImageService", "Imagery layer doesn't support given renderer type."), n9);
    }
    writeRenderer(e4, t6, r2) {
      t6.layerDefinition = t6.layerDefinition || {}, t6.layerDefinition.drawingInfo = t6.layerDefinition.drawingInfo || {}, t6.layerDefinition.drawingInfo.renderer = e4.toJSON(), "vector-field" === e4.type && (t6.symbolTileSize = e4.symbolTileSize);
    }
    get rasterFields() {
      var _a;
      const e4 = this._rasterAttributeTableFieldPrefix, t6 = new y2({ name: "Raster.ItemPixelValue", alias: "Item Pixel Value", domain: null, editable: false, length: 50, type: "string" }), r2 = new y2({ name: "Raster.ServicePixelValue", alias: "Service Pixel Value", domain: null, editable: false, length: 50, type: "string" }), i7 = new y2({ name: "Raster.ServicePixelValue.Raw", alias: "Raw Service Pixel Value", domain: null, editable: false, length: 50, type: "string" });
      let s9 = this.fields ? a(this.fields) : [];
      s9.push(r2), ((_a = this.capabilities) == null ? void 0 : _a.operations.supportsQuery) && this.fields && this.fields.length > 0 && s9.push(t6), this.version >= 10.4 && null != this.rasterFunctionInfos && this.rasterFunctionInfos.some((e5) => "none" === e5.name.toLowerCase()) && s9.push(i7), null != this.rasterFunctionInfos && this.rasterFunctionInfos.filter((e5) => "none" !== e5.name.toLowerCase()).forEach((e5) => {
        s9.push(new y2({ name: "Raster.ServicePixelValue." + e5.name, alias: e5.name, domain: null, editable: false, length: 50, type: "string" }));
      }), this._isVectorDataSet() && (s9.push(new y2({ name: "Raster.Magnitude", alias: "Magnitude", domain: null, editable: false, type: "double" })), s9.push(new y2({ name: "Raster.Direction", alias: "Direction", domain: null, editable: false, type: "double" })));
      const { attributeTable: n9 } = this.rasterInfo ?? {};
      if (null != n9) {
        const t7 = n9.fields.filter((e5) => "esriFieldTypeOID" !== e5.type && "value" !== e5.name.toLowerCase()).map((t8) => {
          const r3 = a(t8);
          return r3.name = e4 + t8.name, r3;
        });
        s9 = s9.concat(t7);
      }
      return s9;
    }
    get renderingRule() {
      return t(s.getLogger(this), "renderingRule", { replacement: "rasterFunction", version: "4.27", warnOnce: true }), this.rasterFunction;
    }
    set renderingRule(e4) {
      t(s.getLogger(this), "renderingRule", { replacement: "rasterFunction", version: "4.27", warnOnce: true }), this._set("rasterFunction", e4);
    }
    set rasterFunction(e4) {
      let t6 = e4;
      (t6 == null ? void 0 : t6.rasterFunction) && (t6 = N.fromJSON({ ...t6.toJSON(), rasterFunction: t6.rasterFunction, rasterFunctionArguments: t6.rasterFunctionArguments })), this._set("rasterFunction", t6);
    }
    readRasterFunction(e4, t6) {
      const r2 = t6.rasterFunctionInfos;
      return t6.renderingRule || (r2 == null ? void 0 : r2.length) && "None" !== r2[0].name ? this._isRFTJson(t6.renderingRule) ? N.fromJSON({ rasterFunctionDefinition: t6.renderingRule }) : N.fromJSON(t6.renderingRule || { rasterFunctionInfos: t6.rasterFunctionInfos }) : null;
    }
    readSpatialReference(e4, t6) {
      const r2 = e4 || t6.extent.spatialReference;
      return r2 ? f2.fromJSON(r2) : null;
    }
    readPixelType(e4) {
      return n5.fromJSON(e4) || e4;
    }
    writePixelType(e4, t6, r2) {
      null != this.serviceRasterInfo && this.pixelType === this.serviceRasterInfo.pixelType || (t6[r2] = n5.toJSON(e4));
    }
    readVersion(e4, t6) {
      let r2 = t6.currentVersion;
      return r2 || (r2 = t6.hasOwnProperty("fields") || t6.hasOwnProperty("timeInfo") ? 10 : 9.3), r2;
    }
    applyFilter(e4) {
      let t6 = e4;
      return this.pixelFilter && (t6 = this._clonePixelData(e4), this.pixelFilter(t6)), t6;
    }
    async applyRenderer(e4, t6) {
      let r2 = e4;
      const { renderer: i7, symbolizer: s9, pixelFilter: n9, bandIds: o3 } = this;
      if (!this._isPicture() && i7 && s9 && !n9) {
        const n10 = JSON.stringify(this._cachedRendererJson) !== JSON.stringify(i7.toJSON()), a13 = this._rasterJobHandler.instance;
        if (a13) {
          n10 && (s9.bind(), await a13.updateSymbolizer(s9, t6), this._cachedRendererJson = i7.toJSON());
          const l9 = await a13.symbolize({ bandIds: o3, ...e4 }, t6);
          r2 = { extent: e4.extent, pixelBlock: l9 };
        } else
          r2 = { extent: e4.extent, pixelBlock: s9.symbolize({ bandIds: o3, ...e4 }) };
      }
      return r2;
    }
    destroy() {
      this._shutdownJobHandler();
    }
    increaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount++;
    }
    decreaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount--, this._rasterJobHandler.refCount <= 0 && this._shutdownJobHandler();
    }
    async computeAngles(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsComputeAngles)
        throw new s2("imagery-layer:compute-angles", "this operation is not supported on the input image service");
      return e4 = v(l6, e4).clone(), S2(this.url, e4, this._getRequestOptions(t6));
    }
    async computePixelSpaceLocations(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsComputePixelLocation)
        throw new s2("imagery-layer:compute-pixel-space-locations", "this operation is not supported on the input image service");
      return e4 = v(a12, e4).clone(), N3(this.url, e4, this._getRequestOptions(t6));
    }
    async computeHistograms(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsComputeHistograms)
        throw new s2("imagery-layer:compute-histograms", "this operation is not supported on the input image service");
      return e4 = v(h, e4).clone(), this._applyMosaicAndRenderingRules(e4), j7(this.url, e4, this._getRequestOptions(t6));
    }
    async computeStatisticsHistograms(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsComputeStatisticsHistograms)
        throw new s2("imagery-layer:compute-statistics-histograms", "this operation is not supported on the input image service");
      return e4 = v(h, e4).clone(), this._applyMosaicAndRenderingRules(e4), R3(this.url, e4, this._getRequestOptions(t6));
    }
    async measureHeight(e4, t6) {
      const r2 = await this._fetchCapabilities(t6 == null ? void 0 : t6.signal);
      if (!("base-and-top" === e4.operationType ? r2.mensuration.supportsHeightFromBaseAndTop : "base-and-top-shadow" === e4.operationType ? r2.mensuration.supportsHeightFromBaseAndTopShadow : r2.mensuration.supportsHeightFromTopAndTopShadow))
        throw new s2("imagery-layer:measure-height", "this operation is not supported on the input image service");
      return e4 = v(c14, e4).clone(), this._applyMosaicAndRenderingRules(e4), h3(this.url, e4, this._getRequestOptions(t6));
    }
    async measureAreaAndPerimeter(e4, t6) {
      const r2 = await this._fetchCapabilities(t6 == null ? void 0 : t6.signal);
      if (!(r2.mensuration.supportsAreaAndPerimeter && (!e4.is3D || r2.mensuration.supports3D)))
        throw new s2("imagery-layer:measure-area-and-perimeter", "this operation is not supported on the input image service");
      return e4 = v(y7, e4).clone(), this._applyMosaicAndRenderingRules(e4), w2(this.url, e4, this._getRequestOptions(t6));
    }
    async measureDistanceAndAngle(e4, t6) {
      const r2 = await this._fetchCapabilities(t6 == null ? void 0 : t6.signal);
      if (!(r2.mensuration.supportsDistanceAndAngle && (!e4.is3D || r2.mensuration.supports3D)))
        throw new s2("imagery-layer:measure-distance-and-angle", "this operation is not supported on the input image service");
      return e4 = v(u6, e4).clone(), this._applyMosaicAndRenderingRules(e4), I2(this.url, e4, this._getRequestOptions(t6));
    }
    async measurePointOrCentroid(e4, t6) {
      const r2 = await this._fetchCapabilities(t6 == null ? void 0 : t6.signal);
      if (!(r2.mensuration.supportsPointOrCentroid && (!e4.is3D || r2.mensuration.supports3D)))
        throw new s2("imagery-layer:measure-point-or-centroid", "this operation is not supported on the input image service");
      return e4 = v(y11, e4).clone(), this._applyMosaicAndRenderingRules(e4), C2(this.url, e4, this._getRequestOptions(t6));
    }
    getField(e4) {
      const { fieldsIndex: t6 } = this;
      return null != t6 ? t6.get(e4) : void 0;
    }
    getFieldDomain(e4, t6) {
      const r2 = this.getField(e4);
      return r2 ? r2.domain : null;
    }
    async fetchImage(e4, t6, r2, i7 = {}) {
      if (null == e4 || null == t6 || null == r2)
        throw new s2("imagery-layer:fetch-image", "Insufficient parameters for requesting an image. A valid extent, width and height values are required.");
      if (this.renderer || this.symbolizer) {
        const e5 = await this._generateRasterInfo(this.rasterFunction, { signal: i7.signal });
        e5 && (this.rasterInfo = e5);
      }
      const s9 = this.getExportImageServiceParameters(e4, t6, r2, i7.timeExtent);
      if (null == s9) {
        if (i7.requestAsImageElement && this._canRequestImageElement(this.format)) {
          const e5 = document.createElement("canvas");
          if (e5.width = t6, e5.height = r2, i7.returnImageBitmap) {
            return { imageBitmap: await t3(e5, `${Oe2(this.parsedUrl)}/exportImage`, i7.signal) };
          }
          return { imageOrCanvasElement: e5 };
        }
        const { bandIds: s10, rasterInfo: n10 } = this, o4 = ((s10 == null ? void 0 : s10.length) || n10.bandCount) ?? 0, a13 = t6 * r2, l10 = n10.pixelType, u8 = [];
        for (let e5 = 0; e5 < o4; e5++)
          u8.push(u2.createEmptyBand(l10, a13));
        return { pixelData: { pixelBlock: new u2({ width: t6, height: r2, pixels: u8, mask: new Uint8Array(a13), pixelType: l10 }), extent: e4 } };
      }
      const n9 = !!i7.requestAsImageElement && !this.pixelFilter, o3 = n9 && !!i7.returnImageBitmap, l9 = { imageServiceParameters: s9, imageProps: { extent: e4, width: t6, height: r2, format: this.format }, requestAsImageElement: n9, returnImageBitmap: o3, signal: i7.signal };
      return this._requestArrayBuffer(l9);
    }
    fetchKeyProperties(e4) {
      return j2(Oe2(this.parsedUrl) + "/keyProperties", { query: this._getQueryParams({ renderingRule: this.version >= 10.3 ? e4 == null ? void 0 : e4.rasterFunction : null }) }).then((e5) => e5.data);
    }
    fetchRasterAttributeTable(e4) {
      return this.version < 10.1 ? Promise.reject(new s2("#fetchRasterAttributeTable()", "Failed to get rasterAttributeTable")) : j2(Oe2(this.parsedUrl) + "/rasterAttributeTable", { query: this._getQueryParams({ renderingRule: this.version >= 10.3 ? e4 == null ? void 0 : e4.rasterFunction : null }) }).then((e5) => d2.fromJSON(e5.data));
    }
    getCatalogItemRasterInfo(e4, t6) {
      const r2 = { ...t6, query: this._getQueryParams() };
      return n7(Oe2(this.parsedUrl), e4, r2);
    }
    async getCatalogItemICSInfo(e4, t6) {
      var _a, _b, _c, _d, _e;
      const { data: r2 } = await j2(Oe2(this.parsedUrl) + "/" + e4 + "/info/ics", { query: this._getQueryParams(), ...t6 }), i7 = r2 == null ? void 0 : r2.ics;
      if (!i7)
        return;
      let s9 = null;
      try {
        s9 = (await j2(Oe2(this.parsedUrl) + "/" + e4 + "/info", { query: this._getQueryParams(), ...t6 })).data.extent;
      } catch {
      }
      if (!s9 || !s9.spatialReference)
        return { ics: i7, icsToPixelTransform: null, icsExtent: null, northDirection: null };
      const o3 = this.version >= 10.7 ? j2(Oe2(this.parsedUrl) + "/" + e4 + "/info/icstopixel", { query: this._getQueryParams(), ...t6 }).then((e5) => e5.data).catch(() => ({})) : {}, a13 = s9.spatialReference, l9 = { geometries: JSON.stringify({ geometryType: "esriGeometryEnvelope", geometries: [s9] }), inSR: T2(a13), outSR: "0:" + e4 }, u8 = j2(Oe2(this.parsedUrl) + "/project", { query: this._getQueryParams(l9), ...t6 }).then((e5) => e5.data).catch(() => ({})), p14 = 5, c17 = (s9.xmin + s9.xmax) / 2, m8 = (s9.ymax - s9.ymin) / (p14 + 1), d11 = s9.ymin + m8, h5 = [];
      for (let n9 = 0; n9 < p14; n9++)
        h5.push({ x: c17, y: d11 + m8 * n9 });
      const f7 = { geometries: JSON.stringify({ geometryType: "esriGeometryPoint", geometries: h5 }), inSR: T2(a13), outSR: "0:" + e4 }, y13 = j2(Oe2(this.parsedUrl) + "/project", { query: this._getQueryParams(f7), ...t6 }).then((e5) => e5.data).catch(() => ({})), g5 = await Promise.all([o3, u8, y13]);
      let R4 = g5[0].ipxf;
      if (null == R4) {
        const e5 = (_a = i7.geodataXform) == null ? void 0 : _a.xf_0;
        "topup" === ((_b = e5 == null ? void 0 : e5.name) == null ? void 0 : _b.toLowerCase()) && 6 === ((_c = e5 == null ? void 0 : e5.coefficients) == null ? void 0 : _c.length) && (R4 = { affine: { name: "ics [sensor: Frame] to pixel (column, row) transformation", coefficients: e5.coefficients, cellsizeRatio: 0, type: "GeometricXform" } });
      }
      const b5 = M.fromJSON((_e = (_d = g5[1]) == null ? void 0 : _d.geometries) == null ? void 0 : _e[0]);
      b5 && (b5.spatialReference = new f2({ wkid: 0, imageCoordinateSystem: i7 }));
      const x4 = g5[2].geometries ? g5[2].geometries.filter((e5) => null != (e5 == null ? void 0 : e5.x) && null != e5.y && "NaN" !== e5.x && "NaN" !== e5.y) : [], S3 = x4.length;
      if (S3 < 3)
        return { ics: i7, icsToPixelTransform: R4, icsExtent: b5, northDirection: null };
      let I3 = 0, w3 = 0, _ = 0, F2 = 0;
      for (let n9 = 0; n9 < S3; n9++)
        I3 += x4[n9].x, w3 += x4[n9].y, _ += x4[n9].x * x4[n9].x, F2 += x4[n9].x * x4[n9].y;
      const D = (S3 * F2 - I3 * w3) / (S3 * _ - I3 * I3);
      let j9 = 0;
      const P2 = x4[p14 - 1].x > x4[0].x, T5 = x4[p14 - 1].y > x4[0].y;
      return D === 1 / 0 ? j9 = T5 ? 90 : 270 : 0 === D ? j9 = P2 ? 0 : 180 : D > 0 ? j9 = P2 ? 180 * Math.atan(D) / Math.PI : 180 * Math.atan(D) / Math.PI + 180 : D < 0 && (j9 = T5 ? 180 + 180 * Math.atan(D) / Math.PI : 360 + 180 * Math.atan(D) / Math.PI), { ics: i7, icsToPixelTransform: R4, icsExtent: b5, northDirection: j9 };
    }
    async generateRasterInfo(e4, t6) {
      var _a;
      if (e4 = v(N, e4), this.serviceRasterInfo && (!e4 || "none" === ((_a = e4.functionName) == null ? void 0 : _a.toLowerCase()) || this._isVectorFieldResampleFunction(e4)))
        return this.serviceRasterInfo;
      const r2 = Te(e4);
      if (!r2)
        throw new s2("imagery-layer:generate-raster-info", "the rendering rule is not supported");
      if (this._functionRasterInfos[r2])
        return this._functionRasterInfos[r2];
      const i7 = { ...t6, query: this._getQueryParams() }, s9 = f5(Oe2(this.parsedUrl), e4, i7);
      this._functionRasterInfos[r2] = s9;
      try {
        return await s9;
      } catch (n9) {
        throw this._functionRasterInfos[r2] = null, n9;
      }
    }
    getExportImageServiceParameters(e4, t6, r2, i7) {
      var _a;
      e4 = e4.clone().shiftCentralMeridian();
      const s9 = $(e4.spatialReference, Oe2(this.parsedUrl));
      this.pixelType !== this.serviceRasterInfo.pixelType && (this.exportImageServiceParameters.pixelType = this.pixelType);
      const n9 = this.exportImageServiceParameters.toJSON(), { bandIds: o3, noData: a13 } = n9;
      let { renderingRule: l9 } = n9;
      const u8 = (_a = this.rasterFunction) == null ? void 0 : _a.rasterFunctionDefinition, p14 = !this.renderer || "raster-stretch" === this.renderer.type;
      if ((o3 == null ? void 0 : o3.length) && this._hasRasterFunction(this.rasterFunction) && !u8 && p14) {
        const e5 = { rasterFunction: "ExtractBand", rasterFunctionArguments: { BandIds: o3 } };
        if ("Stretch" === l9.rasterFunction)
          e5.rasterFunctionArguments.Raster = l9.rasterFunctionArguments.Raster, l9.rasterFunctionArguments.Raster = e5;
        else if ("Colormap" === l9.rasterFunction) {
          const t7 = l9.rasterFunctionArguments.Raster;
          "Stretch" === (t7 == null ? void 0 : t7.rasterFunction) ? (e5.rasterFunctionArguments.Raster = t7.rasterFunctionArguments.Raster, t7.rasterFunctionArguments.Raster = e5) : (e5.rasterFunctionArguments.Raster = t7, l9.rasterFunctionArguments.Raster = e5);
        } else
          e5.rasterFunctionArguments.Raster = l9, l9 = e5;
        n9.bandIds = void 0;
      } else
        n9.bandIds = o3 == null ? void 0 : o3.join(",");
      a13 instanceof Array && a13.length > 0 && (n9.noData = a13.join(","));
      const c17 = this._processMultidimensionalIntersection(null, i7, this.exportImageServiceParameters.mosaicRule);
      if (c17.isOutSide)
        return null;
      n9.mosaicRule = null != c17.mosaicRule ? JSON.stringify(c17.mosaicRule) : null, i7 = c17.timeExtent, n9.renderingRule = this._getRenderingRuleString(N.fromJSON(l9));
      const m8 = {};
      if (null != i7) {
        const { start: e5, end: t7 } = i7.toJSON();
        e5 && t7 && e5 === t7 ? m8.time = "" + e5 : null == e5 && null == t7 || (m8.time = `${e5 ?? "null"},${t7 ?? "null"}`);
      }
      return { bbox: e4.xmin + "," + e4.ymin + "," + e4.xmax + "," + e4.ymax, bboxSR: s9, imageSR: s9, size: t6 + "," + r2, ...n9, ...m8 };
    }
    async getSamples(e4, t6) {
      const r2 = await this._fetchCapabilities(t6 == null ? void 0 : t6.signal);
      if (!(r2 == null ? void 0 : r2.operations.supportsGetSamples))
        throw new s2("imagery-layer:get-samples", "getSamples operation is not supported on the input image service");
      e4 = v(h4, e4).clone();
      const { raster: i7 } = this;
      return i7 && null == e4.raster && (e4.raster = i7), J(this.url, e4, this._getRequestOptions(t6));
    }
    async identify(e4, t6) {
      var _a;
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsIdentify)
        throw new s2("imagery-layer:identify", "identify operation is not supported on the input image service");
      e4 = v(d8, e4).clone(), this.version < 10.91 && "extent" === ((_a = e4.geometry) == null ? void 0 : _a.type) && (e4.geometry = j3.fromExtent(e4.geometry));
      const r2 = this._processMultidimensionalIntersection(e4.geometry, e4.timeExtent, e4.mosaicRule || this.mosaicRule);
      if (r2.isOutSide)
        throw new s2("imagery-layer:identify", "the request cannot be fulfilled when falling outside of the multidimensional subset");
      e4.timeExtent = r2.timeExtent, e4.mosaicRule = r2.mosaicRule;
      const { raster: i7, rasterFunction: s9 } = this;
      return s9 && null == e4.rasterFunction && (e4.rasterFunction = s9), i7 && null == e4.raster && (e4.raster = i7), O(this.url, e4, this._getRequestOptions(t6));
    }
    createQuery() {
      const e4 = new b();
      return e4.outFields = ["*"], e4.returnGeometry = true, e4.where = this.definitionExpression || "1=1", e4;
    }
    async queryRasters(e4, t6) {
      return { query: e4, requestOptions: t6 } = await this._prepareForQuery(e4, t6), s6(this.url, e4, t6);
    }
    async queryObjectIds(e4, t6) {
      return { query: e4, requestOptions: t6 } = await this._prepareForQuery(e4, t6), s5(this.url, e4, t6);
    }
    async queryRasterCount(e4, t6) {
      return { query: e4, requestOptions: t6 } = await this._prepareForQuery(e4, t6), n2(this.url, e4, t6);
    }
    async queryVisibleRasters(e4, t6) {
      var _a, _b, _c, _d;
      if (!e4)
        throw new s2("imagery-layer: query-visible-rasters", "missing query parameter");
      await this.load();
      const { pixelSize: r2, returnDomainValues: i7, returnTopmostRaster: s9, showNoDataRecords: n9 } = t6 || { pixelSize: null, returnDomainValues: false, returnTopmostRaster: false, showNoDataRecords: false };
      let o3 = false, l9 = null, u8 = null;
      const p14 = "raster.servicepixelvalue", c17 = this._rasterFunctionNamesIndex;
      if (null != e4.outFields && (o3 = e4.outFields.some((e5) => !e5.toLowerCase().includes(p14)), this.version >= 10.4)) {
        const t7 = e4.outFields.filter((e5) => e5.toLowerCase().includes(p14) && e5.length > p14.length).map((e5) => {
          const t8 = e5.slice(p14.length + 1);
          return [this._updateRenderingRulesFunctionName(t8, c17), t8];
        });
        l9 = t7.map((e5) => new N({ functionName: e5[0] })), u8 = t7.map((e5) => e5[1]);
        const { rasterFunction: r3 } = this;
        0 === l9.length ? (r3 == null ? void 0 : r3.functionName) ? (l9.push(r3), u8.push(r3.functionName)) : l9 = null : (r3 == null ? void 0 : r3.functionName) && !l9.some((e5) => e5.functionName === r3.functionName) && (l9.push(r3), u8.push(r3.functionName));
      }
      const m8 = null == e4.outSpatialReference || e4.outSpatialReference.equals(this.spatialReference), { multidimensionalSubset: d11 } = this;
      let h5 = e4.timeExtent || this.timeExtent;
      if (d11) {
        const { isOutside: t7, intersection: r3 } = m3(d11, { geometry: e4.geometry, timeExtent: e4.timeExtent, multidimensionalDefinition: (_a = this.exportImageServiceParameters.mosaicRule) == null ? void 0 : _a.multidimensionalDefinition });
        if (t7)
          throw new s2("imagery-layer:query-visible-rasters", "the request cannot be fulfilled when falling outside of the multidimensional subset");
        null != (r3 == null ? void 0 : r3.timeExtent) && (h5 = r3.timeExtent);
      }
      const f7 = this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule, h5);
      let y13 = e4.geometry;
      this.version < 10.91 && "extent" === (y13 == null ? void 0 : y13.type) && (y13 = j3.fromExtent(y13));
      const g5 = this._getQueryParams({ geometry: y13, timeExtent: h5, mosaicRule: f7, rasterFunction: this.version < 10.4 ? this.rasterFunction : null, rasterFunctions: l9, pixelSize: r2, returnCatalogItems: o3, returnGeometry: m8, raster: this.raster, maxItemCount: s9 ? 1 : null });
      delete g5.f;
      const R4 = new d8(g5);
      try {
        await this._generateRasterInfo(this.rasterFunction);
        const r3 = await O(this.url, R4, { signal: t6 == null ? void 0 : t6.signal, query: { ...this.customParameters } }), s10 = e4.outFields, a13 = null != r3.value && r3.value.toLowerCase().includes("nodata");
        if (!(o3 && !m8 && ((_b = r3 == null ? void 0 : r3.catalogItems) == null ? void 0 : _b.features.length) && (n9 || !a13)))
          return this._processVisibleRastersResponse(r3, { returnDomainValues: i7, templateRRFunctionNames: u8, showNoDataRecords: n9, templateFields: s10 });
        const l10 = this.objectIdField || "ObjectId", p15 = ((_c = r3.catalogItems) == null ? void 0 : _c.features) ?? [], c18 = p15.map((e5) => {
          var _a2;
          return (_a2 = e5.attributes) == null ? void 0 : _a2[l10];
        }), d12 = new b({ objectIds: c18, returnGeometry: true, outSpatialReference: e4.outSpatialReference, outFields: [l10] }), h6 = await this.queryRasters(d12);
        return ((_d = h6 == null ? void 0 : h6.features) == null ? void 0 : _d.length) && h6.features.forEach((t7) => {
          p15.forEach((r4) => {
            r4.attributes[l10] === t7.attributes[l10] && (r4.geometry = new j3(t7.geometry), null != e4.outSpatialReference && (r4.geometry.spatialReference = e4.outSpatialReference));
          });
        }), this._processVisibleRastersResponse(r3, { returnDomainValues: i7, templateRRFunctionNames: u8, showNoDataRecords: n9, templateFields: s10 });
      } catch {
        throw new s2("imagery-layer:query-visible-rasters", "encountered error when querying visible rasters");
      }
    }
    async fetchVariableStatisticsHistograms(e4, t6) {
      const r2 = j2(Oe2(this.parsedUrl) + "/statistics", { query: this._getQueryParams({ variable: e4 }), signal: t6 }).then((e5) => {
        var _a;
        return (_a = e5.data) == null ? void 0 : _a.statistics;
      }), i7 = j2(Oe2(this.parsedUrl) + "/histograms", { query: this._getQueryParams({ variable: e4 }), signal: t6 }).then((e5) => {
        var _a;
        return (_a = e5.data) == null ? void 0 : _a.histograms;
      }), s9 = await Promise.all([r2, i7]);
      return s9[0] && s9[0].forEach((e5) => {
        e5.avg = e5.mean, e5.stddev = e5.standardDeviation;
      }), { statistics: s9[0] || null, histograms: s9[1] || null };
    }
    async createFlowMesh(e4, t6) {
      const r2 = this._rasterJobHandler.instance;
      return r2 ? r2.createFlowMesh(e4, t6) : s8(e4.meshType, e4.simulationSettings, e4.flowData, null != t6.signal ? t6.signal : new AbortController().signal);
    }
    getMultidimensionalSubsetVariables(e4) {
      const t6 = e4 ?? this.serviceRasterInfo.multidimensionalInfo;
      return g2(this.multidimensionalSubset, t6);
    }
    async _fetchService(e4) {
      await this._fetchServiceInfo(e4), this.rasterInfo || (this.rasterInfo = this.serviceRasterInfo);
      const t6 = this.sourceJSON, r2 = null != this.serviceRasterInfo ? Promise.resolve(this.serviceRasterInfo) : m4(Oe2(this.parsedUrl), t6, { signal: e4, query: this._getQueryParams() }).then((e5) => (this._set("serviceRasterInfo", e5), this._set("multidimensionalInfo", e5.multidimensionalInfo), p4(e5, t6), e5)), i7 = this._hasRasterFunction(this.rasterFunction) ? this._generateRasterInfo(this.rasterFunction, { signal: e4 }) : null, s9 = this._getRasterFunctionInfos();
      return Promise.all([r2, i7, s9]).then((e5) => {
        e5[1] ? this._set("rasterInfo", e5[1]) : this._set("rasterInfo", e5[0]), e5[2] && this._set("rasterFunctionInfos", e5[2]), this.renderer && !this._isSupportedRenderer(this.renderer) && (this._set("renderer", null), s.getLogger(this).warn("ArcGISImageService", "Switching to the default renderer. Renderer applied is not valid for this Imagery Layer")), this._set("renderer", this._configRenderer(this.renderer)), this.addHandles([d(() => this.rasterFunction, (e6) => {
          (this.renderer || this.symbolizer || this.popupEnabled && this.popupTemplate) && this._generateRasterInfo(e6).then((e7) => {
            e7 && (this.rasterInfo = e7);
          });
        })]);
        const { serviceRasterInfo: t7 } = this;
        null != t7.multidimensionalInfo && this._updateMultidimensionalDefinition(t7);
      });
    }
    _combineMosaicRuleWithTimeExtent(e4, t6) {
      var _a;
      const r2 = this.timeInfo, { multidimensionalInfo: i7 } = this.serviceRasterInfo;
      if (null == e4 || null == i7 || null == t6 || null == (r2 == null ? void 0 : r2.startField))
        return e4;
      const { startField: s9 } = r2, n9 = i7.variables.some((e5) => e5.dimensions.some((e6) => e6.name === s9)) ? s9 : "StdTime";
      if (e4 = e4.clone(), "mosaic-dataset" === this.sourceType)
        return e4.multidimensionalDefinition = (_a = e4.multidimensionalDefinition) == null ? void 0 : _a.filter((e5) => e5.dimensionName !== n9), this._cleanupMultidimensionalDefinition(e4);
      e4.multidimensionalDefinition = e4.multidimensionalDefinition || [];
      const o3 = e4.multidimensionalDefinition.filter((e5) => e5.dimensionName === n9), a13 = null != t6.start ? t6.start.getTime() : null, l9 = null != t6.end ? t6.end.getTime() : null, u8 = null == a13 || null == l9 || a13 === l9, p14 = u8 ? [a13 || l9] : [[a13, l9]], c17 = this.version >= 10.8;
      if (o3.length)
        o3.forEach((e5) => {
          e5.dimensionName === n9 && (c17 ? (e5.dimensionName = null, e5.isSlice = false, e5.values = []) : (e5.isSlice = u8, e5.values = p14));
        });
      else if (!c17) {
        const t7 = e4.multidimensionalDefinition.filter((e5) => null != e5.variableName && null == e5.dimensionName);
        t7.length ? t7.forEach((e5) => {
          e5.dimensionName = n9, e5.isSlice = u8, e5.values = p14;
        }) : e4.multidimensionalDefinition.push(new p3({ variableName: "", dimensionName: n9, isSlice: u8, values: p14 }));
      }
      return this._cleanupMultidimensionalDefinition(e4);
    }
    _cleanupMultidimensionalDefinition(e4) {
      return null == e4 ? null : (e4.multidimensionalDefinition && (e4.multidimensionalDefinition = e4.multidimensionalDefinition.filter((e5) => !(!e5.variableName && !e5.dimensionName)), 0 === e4.multidimensionalDefinition.length && (e4.multidimensionalDefinition = null)), "mosaic-dataset" !== this.sourceType && null == e4.multidimensionalDefinition ? null : e4);
    }
    async _prepareForQuery(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsQuery)
        throw new s2("imagery-layer:query-rasters", "query operation is not supported on the input image service");
      return e4 = null != e4 ? v(b, e4) : this.createQuery(), t6 = this._getRequestOptions(t6), this.raster && (t6.query = { ...t6.query, raster: this.raster }), { query: e4, requestOptions: t6 };
    }
    async _initJobHandler() {
      if (null != this._rasterJobHandler.connectionPromise)
        return this._rasterJobHandler.connectionPromise;
      const e4 = new t4();
      this._rasterJobHandler.connectionPromise = e4.initialize().then(() => {
        this._rasterJobHandler.instance = e4;
      }, () => {
      }), await this._rasterJobHandler.connectionPromise;
    }
    _shutdownJobHandler() {
      this._rasterJobHandler.instance && this._rasterJobHandler.instance.destroy(), this._rasterJobHandler.instance = null, this._rasterJobHandler.connectionPromise = null, this._rasterJobHandler.refCount = 0, this._cachedRendererJson = null;
    }
    _isSupportedRenderer(e4) {
      const { rasterInfo: t6, rasterFunction: r2 } = this;
      return "unique-value" === e4.type && this._hasRasterFunction(r2) && 1 === (t6 == null ? void 0 : t6.bandCount) && ["u8", "s8"].includes(t6.pixelType) || null != t6 && null != e4 && k3(t6).includes(e4.type);
    }
    async _fetchCapabilities(e4) {
      return this.capabilities || await this._fetchServiceInfo(e4), this.capabilities;
    }
    async _fetchServiceInfo(e4) {
      var _a;
      let t6 = this.sourceJSON;
      if (!t6) {
        const { data: r2, ssl: i7 } = await j2(Oe2(this.parsedUrl), { query: this._getQueryParams(), signal: e4 });
        t6 = r2, this.sourceJSON = t6, i7 && (this.url = this.url.replace(/^http:/i, "https:"));
      }
      if (((_a = t6.capabilities) == null ? void 0 : _a.toLowerCase().split(",").map((e5) => e5.trim()).indexOf("tilesonly")) > -1)
        throw new s2("imagery-layer:fetch-service-info", "use ImageryTileLayer to open tiles-only image services");
      this.read(t6, { origin: "service", url: this.parsedUrl });
    }
    _isMosaicDataset(e4) {
      var _a;
      return e4.serviceSourceType ? "esriImageServiceSourceTypeMosaicDataset" === e4.serviceSourceType : ((_a = e4.fields) == null ? void 0 : _a.length) > 0;
    }
    _isMosaicRuleSupported(e4) {
      var _a;
      if (!e4)
        return false;
      const t6 = this._isMosaicDataset(e4), r2 = e4.currentVersion >= 10.71 && e4.hasMultidimensions && !(((_a = e4.fields) == null ? void 0 : _a.length) > 1);
      return t6 || r2;
    }
    _isVectorFieldResampleFunction(e4) {
      if (null == e4)
        return false;
      const { functionName: t6, functionArguments: r2 } = e4, i7 = "resample" === (t6 == null ? void 0 : t6.toLowerCase()), s9 = (r2 == null ? void 0 : r2.ResampleType) || (r2 == null ? void 0 : r2.resampleType);
      return i7 && (7 === s9 || 10 === s9);
    }
    _isPicture() {
      return !this.format || this.format.includes("jpg") || this.format.includes("png");
    }
    _configRenderer(e4) {
      var _a, _b;
      const t6 = this._isPicture(), { rasterInfo: r2 } = this;
      if (!t6 && !this.pixelFilter || this._isVectorDataSet()) {
        if (!this.bandIds && r2.bandCount >= 3) {
          const e5 = E(r2);
          !e5 || 3 === r2.bandCount && 0 === e5[0] && 1 === e5[1] && 2 === e5[2] || (this.bandIds = e5);
        }
        e4 || (e4 = V(r2, { bandIds: this.bandIds, variableName: this.rasterFunction ? null : (_b = (_a = this.mosaicRule) == null ? void 0 : _a.multidimensionalDefinition) == null ? void 0 : _b[0].variableName }));
        const t7 = K(e4.toJSON());
        this.symbolizer ? (this.symbolizer.rendererJSON = t7, this.symbolizer.rasterInfo = r2) : this.symbolizer = new L({ rendererJSON: t7, rasterInfo: r2 }), this.symbolizer.bind().success || (this.symbolizer = null);
      }
      return e4;
    }
    _clonePixelData(e4) {
      return null == e4 ? e4 : { extent: e4.extent && e4.extent.clone(), pixelBlock: null != e4.pixelBlock ? e4.pixelBlock.clone() : null };
    }
    _getQueryParams(e4) {
      null != (e4 == null ? void 0 : e4.renderingRule) && "string" != typeof e4.renderingRule && (e4.renderingRule = this._getRenderingRuleString(e4.renderingRule));
      const { raster: t6, viewId: r2 } = this;
      return { raster: t6, viewId: r2, f: "json", ...e4, ...this.customParameters };
    }
    _getRequestOptions(e4) {
      return { ...e4, query: { ...e4 == null ? void 0 : e4.query, ...this.customParameters } };
    }
    _decodePixelBlock(e4, t6, r2) {
      return this._rasterJobHandler.instance ? this._rasterJobHandler.instance.decode({ data: e4, options: t6 }) : j5(e4, t6, r2);
    }
    async _getRasterFunctionInfos(e4) {
      var _a;
      const t6 = this.sourceJSON.rasterFunctionInfos;
      if (this.loaded)
        return t6;
      if (t6 && this.version >= 10.3) {
        if (1 === t6.length && "none" === t6[0].name.toLowerCase())
          return t6;
        const r2 = await j2(Oe2(this.parsedUrl) + "/rasterFunctionInfos", { query: this._getQueryParams(), signal: e4 });
        return (_a = r2.data) == null ? void 0 : _a.rasterFunctionInfos;
      }
      return null;
    }
    _canRequestImageElement(e4) {
      return !this.pixelFilter && (!e4 || e4.includes("png"));
    }
    async _requestArrayBuffer(e4) {
      const { imageProps: t6, requestAsImageElement: r2, returnImageBitmap: i7, signal: s9 } = e4;
      if (r2 && this._canRequestImageElement(t6.format)) {
        const r3 = `${Oe2(this.parsedUrl)}/exportImage`, { data: o4 } = await j2(r3, { responseType: i7 ? "blob" : "image", query: this._getQueryParams({ f: "image", ...this.refreshParameters, ...e4.imageServiceParameters }), signal: s9 });
        if (o4 instanceof Blob) {
          return { imageBitmap: await t3(o4, r3, s9), params: t6 };
        }
        return { imageOrCanvasElement: o4, params: t6 };
      }
      const o3 = this._initJobHandler(), l9 = j2(Oe2(this.parsedUrl) + "/exportImage", { responseType: "array-buffer", query: this._getQueryParams({ f: "image", ...e4.imageServiceParameters }), signal: s9 }), u8 = (await Promise.all([l9, o3]))[0].data, p14 = t6.format || "jpgpng";
      let c17 = p14;
      if ("bsq" !== c17 && "bip" !== c17 && (c17 = P(u8)), !c17)
        throw new s2("imagery-layer:fetch-image", "unsupported format signature " + String.fromCharCode.apply(null, new Uint8Array(u8)));
      const m8 = { signal: s9 }, d11 = "gif" === p14 || "bmp" === p14 || p14.includes("png") && ("png" === c17 || "jpg" === c17) ? j5(u8, { useCanvas: true, ...t6 }, m8) : this._decodePixelBlock(u8, { width: t6.width, height: t6.height, planes: null, pixelType: null, noDataValue: null, format: p14 }, m8);
      return { pixelData: { pixelBlock: await d11, extent: t6.extent }, params: t6 };
    }
    _generateRasterInfo(e4, t6) {
      return this.generateRasterInfo(e4, t6).catch(() => null);
    }
    _isValidCustomizedMosaicRule(e4) {
      var _a;
      return e4 && JSON.stringify(e4.toJSON()) !== JSON.stringify((_a = this.defaultMosaicRule) == null ? void 0 : _a.toJSON());
    }
    _updateMultidimensionalDefinition(e4) {
      var _a;
      if (this._isValidCustomizedMosaicRule(this.mosaicRule))
        return;
      let t6 = d5(e4, { multidimensionalSubset: this.multidimensionalSubset });
      if (null != t6 && t6.length > 0) {
        this.mosaicRule = this.mosaicRule || new j6();
        const e5 = this.mosaicRule.multidimensionalDefinition;
        !this.sourceJSON.defaultVariableName && this.rasterFunction && "none" !== ((_a = this.rasterFunction.functionName) == null ? void 0 : _a.toLowerCase()) && t6.forEach((e6) => e6.variableName = ""), t6 = t6.filter(({ variableName: e6, dimensionName: t7 }) => e6 && "*" !== e6 || t7), !(e5 == null ? void 0 : e5.length) && t6.length && (this.mosaicRule.multidimensionalDefinition = t6);
      }
    }
    _processVisibleRastersResponse(e4, r2) {
      var _a, _b, _c;
      r2 = r2 || {};
      const i7 = e4.value, { templateRRFunctionNames: s9, showNoDataRecords: n9, returnDomainValues: o3, templateFields: a13 } = r2, l9 = e4.processedValues;
      let u8 = (_a = e4.catalogItems) == null ? void 0 : _a.features, p14 = ((_c = (_b = e4.properties) == null ? void 0 : _b.Values) == null ? void 0 : _c.map((e5) => e5.replaceAll(/ /gi, ", "))) || [];
      const c17 = this.objectIdField || "ObjectId", m8 = "string" == typeof i7 && i7.toLowerCase().includes("nodata"), d11 = [];
      if (i7 && !u8 && !m8) {
        const e5 = {};
        e5[c17] = 0;
        p14 = [i7], u8 = [new c3(this.fullExtent, null, e5)];
      }
      if (!u8)
        return [];
      let h5, f7, y13;
      this._updateResponseFieldNames(u8, a13), m8 && !n9 && (u8 = []);
      for (let t6 = 0; t6 < u8.length; t6++) {
        if (h5 = u8[t6], null != i7) {
          if (f7 = p14[t6], y13 = this.rasterFunction && l9 && l9.length > 0 && s9 && s9.length > 0 && s9.includes(this.rasterFunction.functionName) ? l9[s9.indexOf(this.rasterFunction.functionName)] : i7, "nodata" === f7.toLowerCase() && !n9)
            continue;
          const e5 = "Raster.ItemPixelValue", r3 = "Raster.ServicePixelValue";
          h5.attributes[e5] = f7, h5.attributes[r3] = y13, this._updateFeatureWithMagDirValues(h5, f7);
          const o4 = this.fields && this.fields.length > 0;
          let a14 = this.rasterFunction && null != this.serviceRasterInfo.attributeTable ? o4 ? f7 : i7 : y13;
          this.rasterFunction || (a14 = o4 ? f7 : i7), this._updateFeatureWithRasterAttributeTableValues(h5, a14);
        }
        if (h5.sourceLayer = h5.layer = this, o3 && this._updateFeatureWithDomainValues(h5), s9 && l9 && s9.length === l9.length)
          for (let e5 = 0; e5 < s9.length; e5++) {
            const t7 = "Raster.ServicePixelValue." + s9[e5];
            h5.attributes[t7] = l9[e5];
          }
        d11.push(u8[t6]);
      }
      return d11;
    }
    _processMultidimensionalIntersection(e4, t6, r2) {
      const { multidimensionalSubset: i7 } = this;
      if (!i7)
        return { isOutSide: false, timeExtent: t6, mosaicRule: r2 = this._combineMosaicRuleWithTimeExtent(r2, t6) };
      if (i7) {
        const { isOutside: r3, intersection: s9 } = m3(i7, { geometry: e4, timeExtent: t6 });
        if (r3)
          return { isOutSide: true, timeExtent: null, mosaicRule: null };
        null != (s9 == null ? void 0 : s9.timeExtent) && (t6 = s9.timeExtent);
      }
      if (r2 = this._combineMosaicRuleWithTimeExtent(r2, t6), r2 == null ? void 0 : r2.multidimensionalDefinition) {
        const { isOutside: e5 } = m3(i7, { multidimensionalDefinition: r2.multidimensionalDefinition });
        if (e5)
          return { isOutSide: true, timeExtent: null, mosaicRule: null };
      }
      return { isOutSide: false, timeExtent: t6, mosaicRule: r2 };
    }
    _updateFeatureWithRasterAttributeTableValues(e4, t6) {
      const r2 = this.rasterInfo.attributeTable || this.serviceRasterInfo.attributeTable;
      if (null == r2)
        return;
      const { features: i7, fields: s9 } = r2, n9 = s9.map((e5) => e5.name).find((e5) => "value" === e5.toLowerCase());
      if (!n9)
        return;
      const o3 = i7.filter((e5) => e5.attributes[n9] === (null != t6 ? parseInt(t6, 10) : null));
      o3 && o3[0] && s9.forEach((t7) => {
        const r3 = this._rasterAttributeTableFieldPrefix + t7.name;
        e4.attributes[r3] = o3[0].attributes[t7.name];
      });
    }
    _updateFeatureWithMagDirValues(e4, t6) {
      if (!this._isVectorDataSet())
        return;
      const r2 = t6.split(/,\s*/).map((e5) => parseFloat(e5)), i7 = r2.map((e5) => [e5]), s9 = r2.map((e5) => ({ minValue: e5, maxValue: e5, noDataValue: null })), n9 = new u2({ height: 1, width: 1, pixelType: "f32", pixels: i7, statistics: s9 });
      null != this.pixelFilter && this.pixelFilter({ pixelBlock: n9, extent: new M(0, 0, 0, 0, this.spatialReference) });
      const o3 = "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType ? [n9.pixels[0][0], n9.pixels[1][0]] : l2([n9.pixels[0][0], n9.pixels[1][0]]);
      e4.attributes["Raster.Magnitude"] = o3[0], e4.attributes["Raster.Direction"] = o3[1];
    }
    _updateFeatureWithDomainValues(e4) {
      const t6 = this.fields && this.fields.filter((e5) => e5.domain && "coded-value" === e5.domain.type);
      null != t6 && t6.forEach((t7) => {
        const r2 = e4.attributes[t7.name];
        if (null != r2) {
          const i7 = t7.domain.codedValues.find((e5) => e5.code === r2);
          i7 && (e4.attributes[t7.name] = i7.name);
        }
      });
    }
    _updateResponseFieldNames(e4, t6) {
      if (!t6 || t6.length < 1)
        return;
      const r2 = this.fieldsIndex;
      null != r2 && e4.forEach((e5) => {
        var _a;
        if (e5 == null ? void 0 : e5.attributes)
          for (const i7 of t6) {
            const t7 = (_a = r2.get(i7)) == null ? void 0 : _a.name;
            t7 && t7 !== i7 && (e5.attributes[i7] = e5.attributes[t7], delete e5.attributes[t7]);
          }
      });
    }
    _getRenderingRuleString(e4) {
      if (e4) {
        let t6 = e4.toJSON();
        return t6 = t6.rasterFunctionDefinition ?? t6, (t6.thumbnail || t6.thumbnailEx) && (t6.thumbnail = t6.thumbnailEx = null), JSON.stringify(t6);
      }
      return null;
    }
    _hasRasterFunction(e4) {
      return null != (e4 == null ? void 0 : e4.functionName) && "none" !== e4.functionName.toLowerCase();
    }
    _updateRenderingRulesFunctionName(e4, t6) {
      if (!e4 || e4.length < 1)
        return;
      if ("Raw" === e4)
        return e4.replace("Raw", "None");
      const r2 = e4.toLowerCase().replaceAll(/ /gi, "_");
      return t6.has(r2) ? t6.get(r2) : e4;
    }
    _isRFTJson(e4) {
      return (e4 == null ? void 0 : e4.name) && e4.arguments && e4.function && e4.hasOwnProperty("functionType");
    }
    _isVectorDataSet() {
      return "esriImageServiceDataTypeVector-UV" === this.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType;
    }
    _applyMosaicAndRenderingRules(e4) {
      const { raster: t6, mosaicRule: r2, rasterFunction: i7 } = this;
      i7 && e4 instanceof h && null == e4.rasterFunction && (e4.rasterFunction = i7), r2 && null == e4.mosaicRule && (e4.mosaicRule = r2), t6 && null == e4.raster && (e4.raster = t6);
    }
    _readCapabilities(e4) {
      var _a;
      const t6 = e4.capabilities ? e4.capabilities.toLowerCase().split(",").map((e5) => e5.trim()) : ["image", "catalog"], { currentVersion: r2, advancedQueryCapabilities: i7, maxRecordCount: s9 } = e4, n9 = t6.includes("image"), o3 = "esriImageServiceDataTypeElevation" === e4.serviceDataType, a13 = !(!e4.spatialReference && !((_a = e4.extent) == null ? void 0 : _a.spatialReference)), l9 = t6.includes("edit"), u8 = t6.includes("mensuration") && a13, p14 = null == e4.mensurationCapabilities ? [] : e4.mensurationCapabilities.toLowerCase().split(",").map((e5) => e5.trim()), c17 = u8 && p14.includes("basic");
      return { data: { supportsAttachment: false }, operations: { supportsComputeHistograms: n9, supportsExportImage: n9, supportsIdentify: n9, supportsMeasure: u8, supportsDownload: t6.includes("download"), supportsQuery: t6.includes("catalog") && e4.fields && e4.fields.length > 0, supportsGetSamples: r2 >= 10.2 && n9, supportsProject: r2 >= 10.3 && n9, supportsComputeStatisticsHistograms: r2 >= 10.4 && n9, supportsQueryBoundary: r2 >= 10.6 && n9, supportsCalculateVolume: r2 >= 10.7 && o3, supportsComputePixelLocation: r2 >= 10.7 && t6.includes("catalog"), supportsComputeAngles: r2 >= 10.91, supportsAdd: l9, supportsDelete: l9, supportsEditing: l9, supportsUpdate: l9, supportsCalculate: false, supportsTruncate: false, supportsValidateSql: false, supportsChangeTracking: false, supportsQueryAttachments: false, supportsResizeAttachments: false, supportsSync: false, supportsExceedsLimitStatistics: false, supportsQueryAnalytics: false, supportsQueryTopFeatures: false, supportsAsyncConvert3D: false }, query: { maxRecordCount: s9, maxRecordCountFactor: void 0, supportsStatistics: !!(i7 == null ? void 0 : i7.supportsStatistics), supportsOrderBy: !!(i7 == null ? void 0 : i7.supportsOrderBy), supportsDistinct: !!(i7 == null ? void 0 : i7.supportsDistinct), supportsPagination: !!(i7 == null ? void 0 : i7.supportsPagination), supportsStandardizedQueriesOnly: !!(i7 == null ? void 0 : i7.useStandardizedQueries), supportsPercentileStatistics: !!(i7 == null ? void 0 : i7.supportsPercentileStatistics), supportsCentroid: !!(i7 == null ? void 0 : i7.supportsReturningGeometryCentroid), supportsDistance: !!(i7 == null ? void 0 : i7.supportsQueryWithDistance), supportsExtent: !!(i7 == null ? void 0 : i7.supportsReturningQueryExtent), supportsGeometryProperties: !!(i7 == null ? void 0 : i7.supportsReturningGeometryProperties), supportsHavingClause: !!(i7 == null ? void 0 : i7.supportsHavingClause), supportsQuantization: false, supportsQuantizationEditMode: false, supportsQueryGeometry: false, supportsResultType: false, supportsMaxRecordCountFactor: false, supportsSqlExpression: false, supportsTopFeaturesQuery: false, supportsQueryByAnonymous: false, supportsQueryByOthers: false, supportsHistoricMoment: false, supportsFormatPBF: false, supportsDisjointSpatialRelationship: false, supportsCacheHint: false, supportsSpatialAggregationStatistics: false, supportedSpatialAggregationStatistics: { envelope: false, centroid: false, convexHull: false }, supportsDefaultSpatialReference: !!(i7 == null ? void 0 : i7.supportsDefaultSR), supportsFullTextSearch: false, supportsCompactGeometry: false, standardMaxRecordCount: void 0, tileMaxRecordCount: void 0 }, mensuration: { supportsDistanceAndAngle: c17, supportsAreaAndPerimeter: c17, supportsPointOrCentroid: c17, supportsHeightFromBaseAndTop: u8 && p14.includes("base-top height"), supportsHeightFromBaseAndTopShadow: u8 && p14.includes("base-top shadow height"), supportsHeightFromTopAndTopShadow: u8 && p14.includes("top-top shadow height"), supports3D: u8 && p14.includes("3d") } };
    }
  };
  function Oe2(e4) {
    return (e4 == null ? void 0 : e4.path) ?? "";
  }
  return e([y({ clonable: false })], y12.prototype, "_functionRasterInfos", void 0), e([y({ clonable: false })], y12.prototype, "_rasterJobHandler", void 0), e([y({ clonable: false })], y12.prototype, "_cachedRendererJson", void 0), e([y({ readOnly: true })], y12.prototype, "_serviceSupportsMosaicRule", void 0), e([o("_serviceSupportsMosaicRule", ["currentVersion", "fields"])], y12.prototype, "readServiceSupportsMosaicRule", null), e([y({ readOnly: true })], y12.prototype, "_rasterAttributeTableFieldPrefix", void 0), e([y({ readOnly: true })], y12.prototype, "_rasterFunctionNamesIndex", null), e([y()], y12.prototype, "adjustAspectRatio", void 0), e([y({ type: [T], json: { write: true } })], y12.prototype, "bandIds", void 0), e([o("bandIds")], y12.prototype, "readBandIds", null), e([y({ readOnly: true, json: { read: false } })], y12.prototype, "capabilities", void 0), e([o("service", "capabilities", ["capabilities", "currentVersion", "serviceDataType"])], y12.prototype, "readCapabilities", null), e([y({ type: Number })], y12.prototype, "compressionQuality", void 0), e([r("compressionQuality")], y12.prototype, "writeCompressionQuality", null), e([y({ type: Number })], y12.prototype, "compressionTolerance", void 0), e([r("compressionTolerance")], y12.prototype, "writeCompressionTolerance", null), e([y({ json: { read: { source: "copyrightText" } } })], y12.prototype, "copyright", void 0), e([y({ readOnly: true, dependsOn: ["_serviceSupportsMosaicRule"] })], y12.prototype, "defaultMosaicRule", void 0), e([o("defaultMosaicRule", ["defaultMosaicMethod"])], y12.prototype, "readDefaultMosaicRule", null), e([y({ type: String, json: { name: "layerDefinition.definitionExpression", write: { enabled: true, allowNull: true } } })], y12.prototype, "definitionExpression", void 0), e([y({ readOnly: true, constructOnly: true })], y12.prototype, "exportImageServiceParameters", void 0), e([y()], y12.prototype, "rasterInfo", void 0), e([y({ readOnly: true, type: [y2] })], y12.prototype, "fields", void 0), e([y({ readOnly: true })], y12.prototype, "fieldsIndex", null), e([y({ type: ["png", "png8", "png24", "png32", "jpg", "bmp", "gif", "jpgpng", "lerc", "tiff"], json: { write: true } })], y12.prototype, "format", null), e([o("service", "format", ["serviceDataType"])], y12.prototype, "readFormat", null), e([y({ type: M })], y12.prototype, "fullExtent", void 0), e([y({ readOnly: true })], y12.prototype, "hasMultidimensions", void 0), e([y({ json: { read: { source: "maxImageHeight" } } })], y12.prototype, "imageMaxHeight", void 0), e([y({ json: { read: { source: "maxImageWidth" } } })], y12.prototype, "imageMaxWidth", void 0), e([y({ type: String, json: { type: a6.jsonValues, read: a6.read, write: a6.write } })], y12.prototype, "interpolation", void 0), e([y()], y12.prototype, "minScale", void 0), e([o("service", "minScale")], y12.prototype, "readMinScale", null), e([y()], y12.prototype, "maxScale", void 0), e([o("service", "maxScale")], y12.prototype, "readMaxScale", null), e([y({ type: j6 })], y12.prototype, "mosaicRule", null), e([o("mosaicRule", ["mosaicRule", "defaultMosaicMethod"])], y12.prototype, "readMosaicRule", null), e([r("mosaicRule")], y12.prototype, "writeMosaicRule", null), e([y()], y12.prototype, "multidimensionalInfo", void 0), e([y({ type: c7, json: { write: true } })], y12.prototype, "multidimensionalSubset", void 0), e([y({ json: { type: T } })], y12.prototype, "noData", void 0), e([r("noData")], y12.prototype, "writeNoData", null), e([y({ type: String, json: { type: i3.jsonValues, read: i3.read, write: i3.write } })], y12.prototype, "noDataInterpretation", void 0), e([y({ type: String, readOnly: true, json: { read: { source: ["fields"] } } })], y12.prototype, "objectIdField", void 0), e([o("objectIdField")], y12.prototype, "readObjectIdField", null), e([y({ readOnly: true })], y12.prototype, "geometryType", void 0), e([y({})], y12.prototype, "typeIdField", void 0), e([y({})], y12.prototype, "types", void 0), e([y({ readOnly: true })], y12.prototype, "parsedUrl", null), e([y({ type: Function })], y12.prototype, "pixelFilter", void 0), e([y()], y12.prototype, "raster", void 0), e([y({ readOnly: true })], y12.prototype, "sourceType", void 0), e([o("sourceType", ["serviceSourceType", "fields"])], y12.prototype, "readSourceType", null), e([y()], y12.prototype, "viewId", void 0), e([y({ types: l3, json: { name: "layerDefinition.drawingInfo.renderer", origins: { "web-scene": { types: d4, name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: (e4) => ({ enabled: e4 && "vector-field" !== e4.type && "flow" !== e4.type }) } } } } })], y12.prototype, "renderer", null), e([o("renderer")], y12.prototype, "readRenderer", null), e([r("renderer")], y12.prototype, "writeRenderer", null), e([y({ clonable: false })], y12.prototype, "symbolizer", void 0), e([y(g)], y12.prototype, "opacity", void 0), e([y({ readOnly: true })], y12.prototype, "rasterFields", null), e([y({ constructOnly: true })], y12.prototype, "rasterFunctionInfos", void 0), e([y({ type: N })], y12.prototype, "renderingRule", null), e([y({ type: N, json: { name: "renderingRule" } })], y12.prototype, "rasterFunction", null), e([o("rasterFunction", ["renderingRule", "rasterFunctionInfos"])], y12.prototype, "readRasterFunction", null), e([y({ readOnly: true })], y12.prototype, "serviceDataType", void 0), e([y({ readOnly: true, type: f2 })], y12.prototype, "spatialReference", void 0), e([o("spatialReference", ["spatialReference", "extent"])], y12.prototype, "readSpatialReference", null), e([y({ json: { type: n5.jsonValues } })], y12.prototype, "pixelType", void 0), e([o("pixelType")], y12.prototype, "readPixelType", null), e([r("pixelType")], y12.prototype, "writePixelType", null), e([y({ constructOnly: true, type: m2 })], y12.prototype, "serviceRasterInfo", void 0), e([y()], y12.prototype, "sourceJSON", void 0), e([y(d3)], y12.prototype, "url", void 0), e([y({ readOnly: true })], y12.prototype, "version", void 0), e([o("version", ["currentVersion", "fields", "timeInfo"])], y12.prototype, "readVersion", null), y12 = e([c("esri.layers.mixins.ArcGISImageService")], y12), y12;
};

// node_modules/@arcgis/core/layers/ImageryLayer.js
var T4 = class extends a4(a5(t2(u3(j4(Oe(f4(o2(l(m(i2(b3))))))))))) {
  constructor(...e4) {
    super(...e4), this.isReference = null, this.operationalLayerType = "ArcGISImageServiceLayer", this.popupEnabled = true, this.popupTemplate = null, this.type = "imagery", this._debouncedSaveOperations = k(async (e5, r2, t6) => {
      const { save: s9, saveAs: i7 } = await import("./imageryUtils-2FD5MQBG.js");
      switch (e5) {
        case A.SAVE:
          return s9(this, r2);
        case A.SAVE_AS:
          return i7(this, t6, r2);
      }
    });
  }
  normalizeCtorArgs(e4, r2) {
    return "string" == typeof e4 ? { url: e4, ...r2 } : e4;
  }
  load(e4) {
    const r2 = null != e4 ? e4.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"] }, e4).catch(a2).then(() => this._fetchService(r2))), Promise.resolve(this);
  }
  get legendEnabled() {
    return !this._isPreviewLayer && (this._get("legendEnabled") ?? true);
  }
  set legendEnabled(e4) {
    this._set("legendEnabled", e4);
  }
  get listMode() {
    return this._isPreviewLayer ? "hide" : this._get("listMode");
  }
  set listMode(e4) {
    this._set("listMode", e4);
  }
  writeOperationalLayerType(e4, r2, t6) {
    var _a;
    const s9 = "vector-field" === ((_a = this.renderer) == null ? void 0 : _a.type);
    r2[t6] = s9 ? "ArcGISImageServiceVectorLayer" : "ArcGISImageServiceLayer";
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get _isPreviewLayer() {
    var _a;
    return !(!this.raster || !((_a = this.url) == null ? void 0 : _a.toLowerCase().includes("/rasterrendering/imageserver")));
  }
  createPopupTemplate(e4) {
    var _a;
    const r2 = this.rasterFields, t6 = this.title, s9 = /* @__PURE__ */ new Set();
    let i7 = false, o3 = false;
    this.capabilities && (i7 = this.capabilities.operations.supportsQuery && this.fields && this.fields.length > 0, o3 = "esriImageServiceDataTypeVector-UV" === this.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType);
    const a13 = /* @__PURE__ */ new Set();
    i7 && a13.add("raster.itempixelvalue");
    for (const n9 of r2) {
      const e5 = n9.name.toLowerCase();
      a13.has(e5) || e5.includes("raster.servicepixelvalue.") || s9.add(n9.name);
    }
    o3 && s9.add("raster.magnitude").add("raster.direction");
    const p14 = p2({ fields: r2, title: t6 }, { ...e4, visibleFieldNames: s9 });
    return (p14 == null ? void 0 : p14.fieldInfos) && ((_a = this.rasterInfo) == null ? void 0 : _a.pixelType.startsWith("f")) && p14.fieldInfos.forEach(({ format: e5, fieldName: r3 }) => {
      e5 && /^raster\.(item|service)pixelvalue/i.test(r3) && (e5.places = 2);
    }), p14;
  }
  queryFeatures(e4, r2) {
    return this.queryRasters(e4, r2).then((e5) => {
      if (e5 == null ? void 0 : e5.features)
        for (const r3 of e5.features)
          r3.layer = r3.sourceLayer = this;
      return e5;
    });
  }
  queryFeatureCount(e4, r2) {
    return this.queryRasterCount(e4, r2);
  }
  redraw() {
    this.emit("redraw");
  }
  async save(e4) {
    return this._debouncedSaveOperations(A.SAVE, e4);
  }
  async saveAs(e4, r2) {
    return this._debouncedSaveOperations(A.SAVE_AS, r2, e4);
  }
  serviceSupportsSpatialReference(e4) {
    return e2(this, e4);
  }
  write(e4, r2) {
    if (!this._isPreviewLayer)
      return super.write(e4, r2);
    if (r2 == null ? void 0 : r2.messages) {
      const e5 = `${r2.origin}/${r2.layerContainerType || "operational-layers"}`;
      r2.messages.push(new s2("layer:unsupported", `Imagery preview layer (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${e5}'`, { layer: this }));
    }
    return null;
  }
};
e([y(c5)], T4.prototype, "legendEnabled", null), e([y({ type: ["show", "hide"] })], T4.prototype, "listMode", null), e([y({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], T4.prototype, "isReference", void 0), e([y({ type: ["ArcGISImageServiceLayer"], json: { origins: { "web-map": { type: ["ArcGISImageServiceLayer", "ArcGISImageServiceVectorLayer"], read: false, write: { target: "layerType", ignoreOrigin: true } } } } })], T4.prototype, "operationalLayerType", void 0), e([r("web-map", "operationalLayerType")], T4.prototype, "writeOperationalLayerType", null), e([y(y3)], T4.prototype, "popupEnabled", void 0), e([y({ type: k2, json: { read: { source: "popupInfo" }, write: { target: "popupInfo" } } })], T4.prototype, "popupTemplate", void 0), e([y({ readOnly: true })], T4.prototype, "defaultPopupTemplate", null), e([y({ readOnly: true, json: { read: false } })], T4.prototype, "type", void 0), e([y({ readOnly: true })], T4.prototype, "_isPreviewLayer", null), T4 = e([c("esri.layers.ImageryLayer")], T4);
var x3 = T4;
export {
  x3 as default
};
//# sourceMappingURL=ImageryLayer-IPMLN62F.js.map
