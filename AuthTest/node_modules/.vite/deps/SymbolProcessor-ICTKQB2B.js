import {
  E,
  a as a2,
  n as n2,
  o,
  x
} from "./chunk-JNWIDZDW.js";
import "./chunk-3XN3CFM5.js";
import "./chunk-DSGGSKRZ.js";
import "./chunk-MUSQVDUI.js";
import "./chunk-OG2GBCUQ.js";
import "./chunk-GSATUKJ4.js";
import {
  p as p2
} from "./chunk-TJGMKUCX.js";
import "./chunk-UMP4LYVN.js";
import "./chunk-W3TATJ3S.js";
import "./chunk-LJAHTUH5.js";
import {
  i
} from "./chunk-HR42LBYN.js";
import "./chunk-NS7I2ZSY.js";
import "./chunk-3S7E6CPQ.js";
import "./chunk-XI27PUTI.js";
import "./chunk-7REGXRO2.js";
import "./chunk-L2VCMOKZ.js";
import "./chunk-PHDOV32N.js";
import {
  S
} from "./chunk-TREPTI6V.js";
import "./chunk-Z26DT4RT.js";
import "./chunk-BUMLJETN.js";
import "./chunk-OPV4AZKI.js";
import {
  p
} from "./chunk-E4V5I23A.js";
import "./chunk-46VITINB.js";
import "./chunk-XFC7DZXI.js";
import "./chunk-PPQAHSM4.js";
import "./chunk-RCLKRKWR.js";
import "./chunk-5WG7GACT.js";
import "./chunk-7Y57Y6IH.js";
import {
  a,
  s as s2
} from "./chunk-SEKLTVY5.js";
import "./chunk-S6MJEC4A.js";
import "./chunk-CSWPLQ7Q.js";
import "./chunk-KWSMYM7P.js";
import "./chunk-DZE6ZO7Z.js";
import "./chunk-HHX6IUJQ.js";
import "./chunk-2FFBPEOX.js";
import "./chunk-XHP7ONEC.js";
import "./chunk-X2Y3P2BF.js";
import "./chunk-GJ4KNHRS.js";
import "./chunk-B7TIRUHV.js";
import "./chunk-EY7PGBJG.js";
import "./chunk-6M5DUIJQ.js";
import "./chunk-NDKHIQMD.js";
import "./chunk-EC5POYCL.js";
import "./chunk-24NOAXOQ.js";
import "./chunk-H4ZZ5S37.js";
import "./chunk-G557TGXY.js";
import "./chunk-PJQIAD5D.js";
import "./chunk-3DSKWYU4.js";
import "./chunk-ZZYUEH57.js";
import "./chunk-VTWXDFFD.js";
import "./chunk-IPCIO3PX.js";
import "./chunk-EIY2DYTV.js";
import "./chunk-OIIDE5GZ.js";
import "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import "./chunk-JUZJCTW2.js";
import "./chunk-423VNHLR.js";
import "./chunk-FN47E7YK.js";
import "./chunk-Y5D433JZ.js";
import "./chunk-QNOCEWCR.js";
import "./chunk-WURET5CW.js";
import {
  f
} from "./chunk-QWPLZ3QH.js";
import "./chunk-HLGIRLYQ.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import "./chunk-LXXF7K7W.js";
import {
  c
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  b,
  s
} from "./chunk-RFPH3ZTZ.js";
import {
  n
} from "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import "./chunk-WJ3HJKNC.js";
import "./chunk-4V6374PV.js";
import "./chunk-A34O4XB5.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/2d/layers/features/support/ResourceManagerProxy.js
var t = class {
  constructor(e2) {
    this._remoteClient = e2, this._resourceMap = /* @__PURE__ */ new Map(), this._inFlightResourceMap = /* @__PURE__ */ new Map(), this.geometryEngine = null, this.geometryEnginePromise = null;
  }
  destroy() {
  }
  async fetchResource(t2, r) {
    const s3 = this._resourceMap, i2 = s3.get(t2);
    if (i2)
      return i2;
    let n3 = this._inFlightResourceMap.get(t2);
    if (n3)
      return n3;
    try {
      n3 = this._remoteClient.invoke("tileRenderer.fetchResource", { url: t2 }, { ...r }), this._inFlightResourceMap.set(t2, n3), n3.then((e2) => (this._inFlightResourceMap.delete(t2), s3.set(t2, e2), e2));
    } catch (o2) {
      return b(o2) ? null : { width: 0, height: 0 };
    }
    return n3;
  }
  getResource(e2) {
    return this._resourceMap.get(e2) ?? null;
  }
  loadFont(e2) {
    return Promise.resolve(null);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processors/SymbolProcessor.js
function _(e2, t2) {
  const s3 = t2 - t2 / 4, r = t2 + t2 / 2;
  return (!e2.minScale || e2.minScale >= s3) && (!e2.maxScale || e2.maxScale <= r);
}
function b2(e2) {
  var _a;
  const t2 = e2.message, s3 = { message: { data: {}, tileKey: t2.tileKey, tileKeyOrigin: t2.tileKeyOrigin, version: t2.version }, transferList: new Array() };
  for (const r in t2.data) {
    const e3 = r, i2 = t2.data[e3];
    if (s3.message.data[e3] = null, null != i2) {
      const t3 = i2.stride, r2 = i2.indices.slice(0), a3 = i2.vertices.slice(0), o2 = i2.records.slice(0), n3 = (_a = i2.metrics) == null ? void 0 : _a.slice(0), l = { stride: t3, indices: r2, vertices: a3, records: o2, metrics: n3 };
      s3.transferList.push(r2, a3, o2), s3.message.data[e3] = l;
    }
  }
  return s3;
}
var S2 = class extends p {
  constructor() {
    super(...arguments), this.type = "symbol", this._matchers = { feature: null, aggregate: null }, this._bufferData = /* @__PURE__ */ new Map(), this._bufferIds = /* @__PURE__ */ new Map();
  }
  initialize() {
    this.addHandles([this.tileStore.on("update", this.onTileUpdate.bind(this))]), this._resourceManagerProxy = new t(this.remoteClient);
  }
  destroy() {
    this._resourceManagerProxy.destroy();
  }
  get supportsTileUpdates() {
    return true;
  }
  forEachBufferId(e2) {
    this._bufferIds.forEach((t2) => {
      t2.forEach(e2);
    });
  }
  async update(e2, t2) {
    var _a;
    const s3 = t2.schema.processors[0];
    if ("symbol" !== s3.type)
      return;
    const r = a(this._schema, s3);
    (s2(r, "mesh") || s2(r, "target")) && (e2.mesh = true, (_a = e2.why) == null ? void 0 : _a.mesh.push("Symbology changed"), this._schema = s3, this._factory = this._createFactory(s3), this._factory.update(s3, this.tileStore.tileScheme.tileInfo));
  }
  onTileMessage(e2, t2, s3, i2) {
    return s(i2), this._onTileData(e2, t2, s3, i2);
  }
  onTileClear(e2, t2) {
    const s3 = { clear: true, end: t2 };
    return this._bufferData.delete(e2.key.id), this._bufferIds.delete(e2.key.id), this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: e2.id, data: s3 });
  }
  onTileError(e2, t2, s3) {
    const r = s3.signal, i2 = { tileKey: e2.id, error: t2 };
    return this.remoteClient.invoke("tileRenderer.onTileError", i2, { signal: r });
  }
  onTileUpdate(e2) {
    for (const t2 of e2.removed)
      this._bufferData.has(t2.key.id) && this._bufferData.delete(t2.key.id), this._bufferIds.has(t2.key.id) && this._bufferIds.delete(t2.key.id);
    for (const t2 of e2.added)
      this._bufferData.forEach((e3) => {
        for (const s3 of e3)
          s3.message.tileKey === t2.id && this._updateTileMesh("append", t2, b2(s3), [], false, false, null);
      });
  }
  _addBufferData(e2, t2) {
    var _a;
    this._bufferData.has(e2) || this._bufferData.set(e2, []), (_a = this._bufferData.get(e2)) == null ? void 0 : _a.push(b2(t2));
  }
  _createFactory(e2) {
    const { geometryType: t2, objectIdField: s3, fields: r } = this.service, i2 = (e3, t3) => this.remoteClient.invoke("tileRenderer.getMaterialItems", e3, t3), a3 = { geometryType: t2, fields: r, spatialReference: f.fromJSON(this.spatialReference) }, o2 = new x(i2, this.tileStore.tileScheme.tileInfo), { matcher: n3, aggregateMatcher: c2 } = e2.mesh;
    return this._store = o2, this._matchers.feature = o(n3, o2, a3, this._resourceManagerProxy), this._matchers.aggregate = c2 ? o(c2, o2, a3, this._resourceManagerProxy) : null, new a2(t2, s3, o2);
  }
  async _onTileData(e2, t2, s3, i2) {
    var _a;
    s(i2);
    const { type: a3, addOrUpdate: o2, remove: n3, clear: l, end: c2 } = t2, d = !!this._schema.mesh.sortKey;
    if (!o2) {
      const t3 = { type: a3, addOrUpdate: null, remove: n3, clear: l, end: c2, sort: d };
      return this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: e2.id, data: t3 }, i2);
    }
    const h = this._processFeatures(e2, o2, s3, i2, (_a = t2.status) == null ? void 0 : _a.version);
    try {
      const s4 = await h;
      if (null == s4) {
        const t3 = { type: a3, addOrUpdate: null, remove: n3, clear: l, end: c2, sort: d };
        return this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: e2.id, data: t3 }, i2);
      }
      const r = [];
      for (const t3 of s4) {
        let s5 = false;
        const i3 = t3.message.bufferIds, a4 = e2.key.id, o3 = t3.message.tileKey;
        if (a4 !== o3 && null != i3) {
          if (!this.tileStore.get(o3)) {
            this._addBufferData(a4, t3), r.push(t3);
            continue;
          }
          let e3 = this._bufferIds.get(o3);
          e3 || (e3 = /* @__PURE__ */ new Set(), this._bufferIds.set(o3, e3));
          const n4 = Array.from(i3);
          for (const t4 of n4) {
            if (e3.has(t4)) {
              s5 = true;
              break;
            }
            e3.add(t4);
          }
        }
        s5 || (this._addBufferData(a4, t3), r.push(t3));
      }
      await Promise.all(r.map((s5) => {
        const r2 = e2.key.id === s5.message.tileKey, o3 = r2 ? t2.remove : [], n4 = r2 && t2.end;
        return this._updateTileMesh(a3, e2, s5, o3, n4, !!t2.clear, i2.signal);
      }));
    } catch (f2) {
      this._handleError(e2, f2, i2);
    }
  }
  async _updateTileMesh(e2, t2, s3, i2, a3, o2, n3) {
    const l = e2, c2 = s3.message.tileKey, d = !!this._schema.mesh.sortKey;
    c2 !== t2.key.id && (a3 = false);
    const h = s3 == null ? void 0 : s3.message, f2 = { type: l, addOrUpdate: h, remove: i2, clear: o2, end: a3, sort: d }, u = { transferList: (s3 == null ? void 0 : s3.transferList) ?? [], signal: n3 };
    return s(u), this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: c2, data: f2 }, u);
  }
  async _processFeatures(e2, t2, s3, i2, a3) {
    if (null == t2 || !t2.hasFeatures)
      return null;
    const o2 = { transform: e2.transform, hasZ: false, hasM: false }, n3 = this._factory, l = { viewingMode: "", scale: e2.scale }, c2 = await this._matchers.feature, d = await this._matchers.aggregate;
    s(i2);
    const h = this._getLabelInfos(e2, t2);
    return await n3.analyze(t2.getCursor(), this._resourceManagerProxy, c2, d, o2, l), s(i2), this._writeFeatureSet(e2, t2, o2, h, n3, s3, a3);
  }
  _writeFeatureSet(e2, t2, s3, r, i2, a3, o2) {
    const n3 = t2.getSize(), l = this._schema.mesh.matcher.symbologyType, c2 = new E(e2.key.id, { features: n3, records: n3, metrics: 0 }, l, a3, l !== S.HEATMAP, o2), f2 = { viewingMode: "", scale: e2.scale }, u = t2.getCursor();
    for (; u.next(); )
      try {
        const t3 = u.getDisplayId(), a4 = null != r ? r.get(t3) : null;
        i2.writeCursor(c2, u, s3, f2, e2.level, a4, this._resourceManagerProxy);
      } catch (g) {
      }
    const m = e2.tileInfoView.tileInfo.isWrappable;
    return c2.serialize(m);
  }
  _handleError(e2, t2, s3) {
    if (!b(t2)) {
      const r = { tileKey: e2.id, error: t2.message };
      return this.remoteClient.invoke("tileRenderer.onTileError", r, { signal: s3.signal });
    }
    return Promise.resolve();
  }
  _getLabelingSchemaForScale(e2) {
    const t2 = this._schema.mesh.labels;
    if (null == t2)
      return null;
    if ("subtype" === t2.type) {
      const s4 = { type: "subtype", classes: {} };
      let r = false;
      for (const i2 in t2.classes) {
        const a3 = t2.classes[i2].filter((t3) => _(t3, e2.scale));
        r = r || !!a3.length, s4.classes[i2] = a3;
      }
      return r ? s4 : null;
    }
    const s3 = t2.classes.filter((t3) => _(t3, e2.scale));
    return s3.length ? { type: "simple", classes: s3 } : null;
  }
  _getLabels(e2, t2) {
    if ("subtype" === t2.type) {
      const r = this.service.subtypeField;
      n(r, "Expected to find subtype Field");
      const i2 = e2.readAttribute(r);
      return null == i2 ? [] : t2.classes[i2] ?? [];
    }
    return t2.classes;
  }
  _getLabelInfos(e2, s3) {
    const r = this._getLabelingSchemaForScale(e2);
    if (null == r)
      return null;
    const i2 = /* @__PURE__ */ new Map(), a3 = s3.getCursor();
    for (; a3.next(); ) {
      const e3 = a3.getDisplayId(), s4 = [], o2 = p2(e3), n3 = o2 && 1 !== a3.readAttribute("cluster_count") ? "aggregate" : "feature", l = this._getLabels(a3, r);
      for (const r2 of l) {
        if (r2.target !== n3)
          continue;
        const i3 = a3.getStorage(), l2 = o2 && "feature" === n3 ? i3.getComputedStringAtIndex(a3.readAttribute("referenceId"), r2.fieldIndex) : i3.getComputedStringAtIndex(e3, r2.fieldIndex);
        if (!l2)
          continue;
        const c2 = i(l2.toString()), d = c2[0], h = c2[1];
        this._store.getMosaicItem(r2.symbol, n2(d)).then((e4) => {
          s4[r2.index] = { glyphs: e4.glyphMosaicItems ?? [], rtl: h, index: r2.index };
        });
      }
      i2.set(e3, s4);
    }
    return i2;
  }
};
S2 = e([c("esri.views.2d.layers.features.processors.SymbolProcessor")], S2);
var w = S2;
export {
  w as default
};
//# sourceMappingURL=SymbolProcessor-ICTKQB2B.js.map
