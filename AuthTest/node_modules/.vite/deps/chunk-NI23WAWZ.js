import {
  a,
  l
} from "./chunk-OPV4AZKI.js";
import {
  st
} from "./chunk-747B2TEO.js";
import {
  t
} from "./chunk-5WG7GACT.js";
import {
  m,
  n as n2,
  n2 as n3
} from "./chunk-W4QVNWBV.js";
import {
  p
} from "./chunk-IPCIO3PX.js";
import {
  o,
  r
} from "./chunk-KBJ5Z4R2.js";
import {
  n
} from "./chunk-WGO3VFQP.js";
import {
  has
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/views/2d/layers/features/support/StaticBitSet.js
var t2 = class _t {
  static fromBuffer(e, s) {
    return new _t(e, s);
  }
  static create(e, s = 4294967295) {
    const r2 = new Uint32Array(Math.ceil(e / 32));
    return new _t(r2, s);
  }
  constructor(t3, e) {
    this._mask = 0, this._buf = t3, this._mask = e;
  }
  _getIndex(t3) {
    return Math.floor(t3 / 32);
  }
  has(t3) {
    const e = this._mask & t3;
    return !!(this._buf[this._getIndex(e)] & 1 << e % 32);
  }
  hasRange(t3, e) {
    let s = t3, r2 = e;
    for (; s % 32 && s !== r2; ) {
      if (this.has(s))
        return true;
      s++;
    }
    for (; r2 % 32 && s !== r2; ) {
      if (this.has(s))
        return true;
      r2--;
    }
    if (s === r2)
      return false;
    for (let h2 = s / 32; h2 !== r2 / 32; h2++) {
      if (this._buf[h2])
        return true;
    }
    return false;
  }
  set(t3) {
    const e = this._mask & t3, s = this._getIndex(e), r2 = 1 << e % 32;
    this._buf[s] |= r2;
  }
  setRange(t3, e) {
    let s = t3, r2 = e;
    for (; s % 32 && s !== r2; )
      this.set(s++);
    for (; r2 % 32 && s !== r2; )
      this.set(r2--);
    if (s !== r2)
      for (let h2 = s / 32; h2 !== r2 / 32; h2++)
        this._buf[h2] = 4294967295;
  }
  unset(t3) {
    const e = this._mask & t3, s = this._getIndex(e), r2 = 1 << e % 32;
    this._buf[s] &= 4294967295 ^ r2;
  }
  resize(t3) {
    const e = this._buf, s = new Uint32Array(Math.ceil(t3 / 32));
    s.set(e), this._buf = s;
  }
  or(t3) {
    for (let e = 0; e < this._buf.length; e++)
      this._buf[e] |= t3._buf[e];
    return this;
  }
  and(t3) {
    for (let e = 0; e < this._buf.length; e++)
      this._buf[e] &= t3._buf[e];
    return this;
  }
  xor(t3) {
    for (let e = 0; e < this._buf.length; e++)
      this._buf[e] ^= t3._buf[e];
    return this;
  }
  ior(t3) {
    for (let e = 0; e < this._buf.length; e++)
      this._buf[e] |= ~t3._buf[e];
    return this;
  }
  iand(t3) {
    for (let e = 0; e < this._buf.length; e++)
      this._buf[e] &= ~t3._buf[e];
    return this;
  }
  ixor(t3) {
    for (let e = 0; e < this._buf.length; e++)
      this._buf[e] ^= ~t3._buf[e];
    return this;
  }
  any() {
    for (let t3 = 0; t3 < this._buf.length; t3++)
      if (this._buf[t3])
        return true;
    return false;
  }
  copy(t3) {
    for (let e = 0; e < this._buf.length; e++)
      this._buf[e] = t3._buf[e];
    return this;
  }
  clone() {
    return new _t(this._buf.slice(), this._mask);
  }
  clear() {
    for (let t3 = 0; t3 < this._buf.length; t3++)
      this._buf[t3] = 0;
  }
  forEachSet(t3) {
    for (let e = 0; e < this._buf.length; e++) {
      let s = this._buf[e], r2 = 32 * e;
      if (s)
        for (; s; ) {
          1 & s && t3(r2), s >>>= 1, r2++;
        }
    }
  }
  countSet() {
    let t3 = 0;
    return this.forEachSet((e) => {
      t3++;
    }), t3;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReader.js
var c = 0;
var h = has("featurelayer-simplify-thresholds") ?? [0.5, 0.5, 0.5, 0.5];
var y = h[0];
var f = h[1];
var p2 = h[2];
var g = h[3];
var _ = has("featurelayer-simplify-payload-size-factors") ?? [1, 2, 4];
var x = _[0];
var A = _[1];
var T = _[2];
var I = has("featurelayer-simplify-mobile-factor") ?? 2;
var b = has("esri-mobile");
var S = class {
  constructor(e, t3) {
    this.type = "FeatureSetReader", this.arcadeDeclaredClass = "esri.arcade.Feature", this.seen = false, this.instance = 0, this._tx = 0, this._ty = 0, this._sx = 1, this._sy = 1, this._deleted = null, this._joined = [], this._objectIdToIndex = null, this._contextTimeZone = null, this._level = 0, this.instance = e, this._layerSchema = t3;
  }
  static createInstance() {
    return c++, c = c > 65535 ? 0 : c, c;
  }
  get isEmpty() {
    return null != this._deleted && this._deleted.countSet() === this.getSize();
  }
  get contextTimeZone() {
    return this._contextTimeZone;
  }
  set contextTimeZone(e) {
    this._contextTimeZone = e;
  }
  set level(e) {
    this._level = e;
  }
  getAreaSimplificationThreshold(e, t3) {
    let r2 = 1;
    const s = b ? I : 1;
    t3 > 4e6 ? r2 = T * s : t3 > 1e6 ? r2 = A * s : t3 > 5e5 ? r2 = x * s : t3 > 1e5 && (r2 = s);
    let i = 0;
    e > 4e3 ? i = g * r2 : e > 2e3 ? i = p2 * r2 : e > 100 ? i = f : e > 15 && (i = y);
    let n4 = 8;
    return this._level < 4 ? n4 = 1 : this._level < 5 ? n4 = 2 : this._level < 6 && (n4 = 4), i * n4;
  }
  createQuantizedExtrudedGeometry(e, t3) {
    return "esriGeometryPolyline" === this.geometryType ? this._createQuantizedExtrudedLine(e, t3) : this._createQuantizedExtrudedQuad(e, t3);
  }
  _createQuantizedExtrudedQuad(e, t3) {
    return new t([5], [e - 1, t3, 1, -1, 1, 1, -1, 1, -1, -1]);
  }
  _createQuantizedExtrudedLine(e, t3) {
    return new t([2], [e - 1, t3 + 1, 1, -1]);
  }
  parseTimestampOffset(e) {
    return e;
  }
  setArcadeSpatialReference(e) {
    this._arcadeSpatialReference = e;
  }
  attachStorage(e) {
    this._storage = e;
  }
  getQuantizationTransform() {
    throw new Error("Unable to find transform for featureSet");
  }
  getStorage() {
    return this._storage;
  }
  getComputedNumeric(e) {
    return this.getComputedNumericAtIndex(0);
  }
  setComputedNumeric(e, t3) {
    return this.setComputedNumericAtIndex(t3, 0);
  }
  getComputedString(e) {
    return this.getComputedStringAtIndex(0);
  }
  setComputedString(e, t3) {
    return this.setComputedStringAtIndex(0, t3);
  }
  getComputedNumericAtIndex(e) {
    return this._storage.getComputedNumericAtIndex(this.getDisplayId(), e);
  }
  setComputedNumericAtIndex(e, t3) {
    this._storage.setComputedNumericAtIndex(this.getDisplayId(), e, t3);
  }
  getComputedStringAtIndex(e) {
    return this._storage.getComputedStringAtIndex(this.getDisplayId(), e);
  }
  setComputedStringAtIndex(e, t3) {
    return this._storage.setComputedStringAtIndex(this.getDisplayId(), e, t3);
  }
  transform(e, t3, r2, s) {
    const i = this.copy();
    return i._tx += e, i._ty += t3, i._sx *= r2, i._sy *= s, i;
  }
  readAttributeAsTimestamp(e) {
    const t3 = this.readAttribute(e);
    return "string" == typeof t3 ? new Date(t3).getTime() : "number" == typeof t3 || null == t3 ? t3 : null;
  }
  readAttribute(e, t3 = false) {
    const r2 = this._readAttribute(e, t3);
    if (void 0 !== r2)
      return r2;
    for (const s of this._joined) {
      s.setIndex(this.getIndex());
      const r3 = s._readAttribute(e, t3);
      if (void 0 !== r3)
        return r3;
    }
  }
  readAttributes() {
    const e = this._readAttributes();
    for (const t3 of this._joined) {
      t3.setIndex(this.getIndex());
      const r2 = t3._readAttributes();
      for (const t4 of Object.keys(r2))
        e[t4] = r2[t4];
    }
    return e;
  }
  joinAttributes(e) {
    this._joined.push(e);
  }
  readArcadeFeature() {
    return this;
  }
  hasField(e) {
    return this.fields.has(e);
  }
  geometry() {
    const e = this.readHydratedGeometry(), t3 = st(e, this.geometryType, this.hasZ, this.hasM), r2 = p(t3);
    return r2 && (r2.spatialReference = this._arcadeSpatialReference), r2;
  }
  autocastArcadeDate(t3, r2) {
    return r2 && r2 instanceof Date ? this.isUnknownDateTimeField(t3) ? m.unknownDateJSToArcadeDate(r2) : m.dateJSAndZoneToArcadeDate(r2, this.contextTimeZone ?? o) : r2;
  }
  isUnknownDateTimeField(e) {
    return this._layerSchema.fieldsIndex.getTimeZone(e) === r;
  }
  field(t3) {
    let i = this.fields.get(t3);
    if (i)
      switch (i.type) {
        case "date-only":
        case "esriFieldTypeDateOnly":
          return n2.fromReader(this.readAttribute(t3, false));
        case "time-only":
        case "esriFieldTypeTimeOnly":
          return n3.fromReader(this.readAttribute(t3, false));
        case "esriFieldTypeTimestampOffset":
        case "timestamp-offset":
          return m.fromReaderAsTimeStampOffset(this.readAttribute(t3, false));
        case "date":
        case "esriFieldTypeDate":
          return this.autocastArcadeDate(t3, this.readAttribute(t3, true));
        default:
          return this.readAttribute(t3, false);
      }
    for (const n4 of this._joined)
      if (n4.setIndex(this.getIndex()), i = n4.fields.get(t3), i)
        switch (i.type) {
          case "date-only":
          case "esriFieldTypeDateOnly":
            return n2.fromReader(n4._readAttribute(t3, false));
          case "time-only":
          case "esriFieldTypeTimeOnly":
            return n3.fromReader(n4._readAttribute(t3, false));
          case "esriFieldTypeTimestampOffset":
          case "timestamp-offset":
            return m.fromReaderAsTimeStampOffset(n4._readAttribute(t3, false));
          case "date":
          case "esriFieldTypeDate":
            return this.autocastArcadeDate(t3, n4._readAttribute(t3, true));
          default:
            return this.readAttribute(t3, false);
        }
    throw new Error(`Field ${t3} does not exist`);
  }
  setField(e, t3) {
    throw new Error("Unable to update feature attribute values, feature is readonly");
  }
  keys() {
    return this.fields.fields.map((e) => e.name);
  }
  castToText(e = false) {
    if (!e)
      return JSON.stringify(this.readLegacyFeature());
    const t3 = this.readLegacyFeature();
    if (!t3)
      return JSON.stringify(null);
    const r2 = { geometry: t3.geometry, attributes: { ...t3.attributes ?? {} } };
    for (const s in r2.attributes) {
      const e2 = r2.attributes[s];
      e2 instanceof Date && (r2.attributes[s] = e2.getTime());
    }
    return JSON.stringify(r2);
  }
  gdbVersion() {
    return null;
  }
  fullSchema() {
    return this._layerSchema;
  }
  castAsJson(e = null) {
    var _a;
    return { attributes: this._readAttributes(), geometry: true === (e == null ? void 0 : e.keepGeometryType) ? this.geometry() : ((_a = this.geometry()) == null ? void 0 : _a.toJSON()) ?? null };
  }
  castAsJsonAsync(e = null, t3 = null) {
    return Promise.resolve(this.castAsJson(t3));
  }
  removeIds(e) {
    if (null == this._objectIdToIndex) {
      const e2 = /* @__PURE__ */ new Map(), r3 = this.getCursor();
      for (; r3.next(); ) {
        const s = r3.getObjectId();
        n(s), e2.set(s, r3.getIndex());
      }
      this._objectIdToIndex = e2;
    }
    const r2 = this._objectIdToIndex;
    for (const t3 of e)
      r2.has(t3) && this.removeAtIndex(r2.get(t3));
  }
  removeAtIndex(e) {
    null == this._deleted && (this._deleted = t2.create(this.getSize())), this._deleted.set(e);
  }
  readGeometryForDisplay() {
    return this.readUnquantizedGeometry(true);
  }
  readLegacyGeometryForDisplay() {
    return this.readLegacyGeometry(true);
  }
  *features() {
    const e = this.getCursor();
    for (; e.next(); )
      yield e.readOptimizedFeature();
  }
  _getExists() {
    return null == this._deleted || !this._deleted.has(this.getIndex());
  }
  _computeCentroid() {
    if ("esriGeometryPolygon" !== this.geometryType)
      return null;
    const e = this.readUnquantizedGeometry();
    if (!e || e.hasIndeterminateRingOrder)
      return null;
    const t3 = a.fromOptimized(e, this.geometryType);
    t3.yFactor *= -1;
    const r2 = l(t3);
    return r2 ? (r2[1] *= -1, new t([], r2)) : null;
  }
  copyInto(e) {
    e.seen = this.seen, e._storage = this._storage, e._arcadeSpatialReference = this._arcadeSpatialReference, e._joined = this._joined, e._tx = this._tx, e._ty = this._ty, e._sx = this._sx, e._sy = this._sy, e._deleted = this._deleted, e._objectIdToIndex = this._objectIdToIndex, e.contextTimeZone = this.contextTimeZone;
  }
};

export {
  t2 as t,
  S
};
//# sourceMappingURL=chunk-NI23WAWZ.js.map
