import {
  Z
} from "./chunk-XA2SWBL3.js";
import {
  a,
  d
} from "./chunk-NYTJIWNN.js";
import {
  L
} from "./chunk-7Y57Y6IH.js";
import {
  m,
  y
} from "./chunk-6BFXMZEZ.js";
import {
  r
} from "./chunk-BEALJUHO.js";
import {
  be
} from "./chunk-GAWSWBHO.js";
import {
  i
} from "./chunk-3DSKWYU4.js";
import {
  u
} from "./chunk-EIY2DYTV.js";
import {
  x2 as x
} from "./chunk-QNOCEWCR.js";
import {
  f as f2
} from "./chunk-QWPLZ3QH.js";
import {
  G,
  f
} from "./chunk-HLGIRLYQ.js";

// node_modules/@arcgis/core/statistics/utils.js
var t = "<Null>";
var l = "equal-interval";
var i2 = 1;
var a2 = 5;
var o = 10;
var r2 = /\s*(\+|-)?((\d+(\.\d+)?)|(\.\d+))\s*/gi;
var u2 = /* @__PURE__ */ new Set(["esriFieldTypeDate", "esriFieldTypeInteger", "esriFieldTypeSmallInteger", "esriFieldTypeSingle", "esriFieldTypeDouble", "esriFieldTypeLong", "esriFieldTypeOID", "esriFieldTypeBigInteger"]);
var s = /* @__PURE__ */ new Set(["esriFieldTypeTimeOnly", "esriFieldTypeDateOnly"]);
var m2 = ["min", "max", "avg", "stddev", "count", "sum", "variance", "nullcount", "median"];
function c(n) {
  return null == n || "string" == typeof n && !n ? t : n;
}
function f3(n) {
  const e = null != n.normalizationField || null != n.normalizationType, t2 = null != n.minValue || null != n.maxValue, l2 = !!n.sqlExpression && n.supportsSQLExpression;
  return !e && !t2 && !l2;
}
function d2(n) {
  const e = n.returnDistinct ? [...new Set(n.values)] : n.values, t2 = e.filter((n2) => null != n2).sort(), l2 = t2.length, i3 = { count: l2, min: t2[0], max: t2[l2 - 1] };
  return n.supportsNullCount && (i3.nullcount = e.length - l2), n.percentileParams && (i3.median = v(e, n.percentileParams)), i3;
}
function p(n) {
  const { values: e, useSampleStdDev: t2, supportsNullCount: l2 } = n;
  let i3 = Number.POSITIVE_INFINITY, a3 = Number.NEGATIVE_INFINITY, o2 = null, r3 = null, u3 = null, s3 = null, m3 = 0;
  const c2 = null == n.minValue ? -1 / 0 : n.minValue, f4 = null == n.maxValue ? 1 / 0 : n.maxValue;
  for (const p2 of e)
    Number.isFinite(p2) ? p2 >= c2 && p2 <= f4 && (o2 = null === o2 ? p2 : o2 + p2, i3 = Math.min(i3, p2), a3 = Math.max(a3, p2), m3++) : "string" == typeof p2 && m3++;
  if (m3 && null != o2) {
    r3 = o2 / m3;
    let n2 = 0;
    for (const t3 of e)
      Number.isFinite(t3) && t3 >= c2 && t3 <= f4 && (n2 += (t3 - r3) ** 2);
    s3 = t2 ? m3 > 1 ? n2 / (m3 - 1) : 0 : m3 > 0 ? n2 / m3 : 0, u3 = Math.sqrt(s3);
  } else
    i3 = null, a3 = null;
  const d3 = { avg: r3, count: m3, max: a3, min: i3, stddev: u3, sum: o2, variance: s3 };
  return l2 && (d3.nullcount = e.length - m3), n.percentileParams && (d3.median = v(e, n.percentileParams)), d3;
}
function v(n, e) {
  const { fieldType: t2, value: l2, orderBy: i3, isDiscrete: a3 } = e, o2 = T(t2, "desc" === i3);
  if (0 === (n = [...n].filter((n2) => null != n2).sort((n2, e2) => o2(n2, e2))).length)
    return null;
  if (l2 <= 0)
    return n[0];
  if (l2 >= 1)
    return n[n.length - 1];
  const r3 = (n.length - 1) * l2, u3 = Math.floor(r3), s3 = u3 + 1, m3 = r3 % 1, c2 = n[u3], f4 = n[s3];
  return s3 >= n.length || a3 || "string" == typeof c2 || "string" == typeof f4 ? c2 : c2 * (1 - m3) + f4 * m3;
}
function T(n, e) {
  if (n) {
    if (u2.has(n))
      return S(e);
    if (s.has(n))
      return z(e, false);
    if ("esriFieldTypeTimestampOffset" === n)
      return x2(e);
    const t3 = z(e, true);
    if ("esriFieldTypeString" === n)
      return t3;
    if ("esriFieldTypeGUID" === n || "esriFieldTypeGlobalID" === n)
      return (n2, e2) => t3(M(n2), M(e2));
  }
  const t2 = e ? 1 : -1, l2 = S(e), i3 = z(e, true);
  return (n2, e2) => "number" == typeof n2 && "number" == typeof e2 ? l2(n2, e2) : "string" == typeof n2 && "string" == typeof e2 ? i3(n2, e2) : t2;
}
var g = (n, e) => null == n ? null == e ? 0 : 1 : null == e ? -1 : null;
var h = (n, e) => null == n ? null == e ? 0 : -1 : null == e ? 1 : null;
function V(n) {
  return n ? g : h;
}
var b = (n, e) => h(n, e) ?? (n === e ? 0 : new Date(n).getTime() - new Date(e).getTime());
var y2 = (n, e) => g(n, e) ?? (n === e ? 0 : new Date(e).getTime() - new Date(n).getTime());
function x2(n) {
  return n ? y2 : b;
}
var F = (n, e) => h(n, e) ?? (n === e ? 0 : n < e ? -1 : 1);
var D = (n, e) => g(n, e) ?? (n === e ? 0 : n < e ? 1 : -1);
function z(n, e) {
  if (!e)
    return n ? D : F;
  const t2 = V(n);
  return n ? (n2, e2) => {
    const l2 = t2(n2, e2);
    return null != l2 ? l2 : (n2 = n2.toUpperCase()) > (e2 = e2.toUpperCase()) ? -1 : n2 < e2 ? 1 : 0;
  } : (n2, e2) => {
    const l2 = t2(n2, e2);
    return null != l2 ? l2 : (n2 = n2.toUpperCase()) < (e2 = e2.toUpperCase()) ? -1 : n2 > e2 ? 1 : 0;
  };
}
var I = (n, e) => g(n, e) ?? e - n;
var N = (n, e) => h(n, e) ?? n - e;
function S(n) {
  return n ? I : N;
}
function M(n) {
  return n.substr(24, 12) + n.substr(19, 4) + n.substr(16, 2) + n.substr(14, 2) + n.substr(11, 2) + n.substr(9, 2) + n.substr(6, 2) + n.substr(4, 2) + n.substr(2, 2) + n.substr(0, 2);
}
function C(n, e) {
  let t2;
  for (t2 in n)
    m2.includes(t2) && (Number.isFinite(n[t2]) || (n[t2] = null));
  return e ? (["avg", "stddev", "variance"].forEach((e2) => {
    null != n[e2] && (n[e2] = Math.ceil(n[e2] ?? 0));
  }), n) : n;
}
function k(n) {
  const e = {};
  for (let t2 of n)
    (null == t2 || "string" == typeof t2 && "" === t2.trim()) && (t2 = null), null == e[t2] ? e[t2] = { count: 1, data: t2 } : e[t2].count++;
  return { count: e };
}
function w(n) {
  return "coded-value" !== (n == null ? void 0 : n.type) ? [] : n.codedValues.map((n2) => n2.code);
}
function $(n, e, t2, l2) {
  const i3 = n.count, a3 = [];
  if (t2 && e) {
    const n2 = [], t3 = w(e[0]);
    for (const i4 of t3)
      if (e[1]) {
        const t4 = w(e[1]);
        for (const a4 of t4)
          if (e[2]) {
            const t5 = w(e[2]);
            for (const e2 of t5)
              n2.push(`${c(i4)}${l2}${c(a4)}${l2}${c(e2)}`);
          } else
            n2.push(`${c(i4)}${l2}${c(a4)}`);
      } else
        n2.push(i4);
    for (const e2 of n2)
      i3.hasOwnProperty(e2) || (i3[e2] = { data: e2, count: 0 });
  }
  for (const o2 in i3) {
    const n2 = i3[o2];
    a3.push({ value: n2.data, count: n2.count, label: n2.label });
  }
  return { uniqueValueInfos: a3 };
}
function B(n, e, t2, l2) {
  let i3 = null;
  switch (e) {
    case "log":
      0 !== n && (i3 = Math.log(n) * Math.LOG10E);
      break;
    case "percent-of-total":
      Number.isFinite(l2) && 0 !== l2 && (i3 = n / l2 * 100);
      break;
    case "field":
      Number.isFinite(t2) && 0 !== t2 && (i3 = n / t2);
      break;
    case "natural-log":
      n > 0 && (i3 = Math.log(n));
      break;
    case "square-root":
      n > 0 && (i3 = n ** 0.5);
  }
  return i3;
}
function E(n, t2) {
  const l2 = q({ field: t2.field, normalizationType: t2.normalizationType, normalizationField: t2.normalizationField, classificationMethod: t2.classificationMethod, standardDeviationInterval: t2.standardDeviationInterval, breakCount: t2.numClasses || a2 });
  return n = O(n, t2.minValue, t2.maxValue), a({ definition: l2, values: n, normalizationTotal: t2.normalizationTotal });
}
function O(n, e, t2) {
  const l2 = e ?? -1 / 0, i3 = t2 ?? 1 / 0;
  return n.filter((n2) => Number.isFinite(n2) && n2 >= l2 && n2 <= i3);
}
function q(e) {
  const { breakCount: t2, field: a3, normalizationField: o2, normalizationType: r3 } = e, u3 = e.classificationMethod || l, s3 = "standard-deviation" === u3 ? e.standardDeviationInterval || i2 : void 0;
  return new d({ breakCount: t2, classificationField: a3, classificationMethod: u3, normalizationField: "field" === r3 ? o2 : void 0, normalizationType: r3, standardDeviationInterval: s3 });
}
function P(n, e) {
  var _a, _b;
  let t2 = n.classBreaks;
  const l2 = t2.length, i3 = (_a = t2[0]) == null ? void 0 : _a.minValue, a3 = (_b = t2[l2 - 1]) == null ? void 0 : _b.maxValue, o2 = "standard-deviation" === e, u3 = r2;
  return t2 = t2.map((n2) => {
    const e2 = n2.label, t3 = { minValue: n2.minValue, maxValue: n2.maxValue, label: e2 };
    if (o2 && e2) {
      const n3 = e2.match(u3), l3 = (n3 == null ? void 0 : n3.map((n4) => +n4.trim())) ?? [];
      2 === l3.length ? (t3.minStdDev = l3[0], t3.maxStdDev = l3[1], l3[0] < 0 && l3[1] > 0 && (t3.hasAvg = true)) : 1 === l3.length && (e2.includes("<") ? (t3.minStdDev = null, t3.maxStdDev = l3[0]) : e2.includes(">") && (t3.minStdDev = l3[0], t3.maxStdDev = null));
    }
    return t3;
  }), { minValue: i3, maxValue: a3, classBreakInfos: t2, normalizationTotal: n.normalizationTotal };
}
function U(n, e) {
  const t2 = G2(n, e);
  if (null == t2.min && null == t2.max)
    return { bins: [], minValue: t2.min, maxValue: t2.max, normalizationTotal: e.normalizationTotal };
  const l2 = t2.intervals, i3 = t2.min ?? 0, a3 = t2.max ?? 0, o2 = l2.map((n2, e2) => ({ minValue: l2[e2][0], maxValue: l2[e2][1], count: 0 }));
  for (const r3 of n)
    if (null != r3 && r3 >= i3 && r3 <= a3) {
      const n2 = L2(l2, r3);
      n2 > -1 && o2[n2].count++;
    }
  return { bins: o2, minValue: i3, maxValue: a3, normalizationTotal: e.normalizationTotal };
}
function G2(n, e) {
  const { field: t2, classificationMethod: l2, standardDeviationInterval: i3, normalizationType: a3, normalizationField: r3, normalizationTotal: u3, minValue: s3, maxValue: m3 } = e, c2 = e.numBins || o;
  let d3 = null, v2 = null, T2 = null;
  if ((!l2 || "equal-interval" === l2) && !a3) {
    if (null != s3 && null != m3)
      d3 = s3, v2 = m3;
    else {
      const e2 = p({ values: n, minValue: s3, maxValue: m3, useSampleStdDev: !a3, supportsNullCount: f3({ normalizationType: a3, normalizationField: r3, minValue: s3, maxValue: m3 }) });
      d3 = e2.min ?? null, v2 = e2.max ?? null;
    }
    T2 = j(d3 ?? 0, v2 ?? 0, c2);
  } else {
    const { classBreaks: e2 } = E(n, { field: t2, normalizationType: a3, normalizationField: r3, normalizationTotal: u3, classificationMethod: l2, standardDeviationInterval: i3, minValue: s3, maxValue: m3, numClasses: c2 });
    d3 = e2[0].minValue, v2 = e2[e2.length - 1].maxValue, T2 = e2.map((n2) => [n2.minValue, n2.maxValue]);
  }
  return { min: d3, max: v2, intervals: T2 };
}
function L2(n, e) {
  let t2 = -1;
  for (let l2 = n.length - 1; l2 >= 0; l2--) {
    if (e >= n[l2][0]) {
      t2 = l2;
      break;
    }
  }
  return t2;
}
function j(n, e, t2) {
  const l2 = (e - n) / t2, i3 = [];
  let a3, o2 = n;
  for (let r3 = 1; r3 <= t2; r3++)
    a3 = o2 + l2, a3 = Number(a3.toFixed(16)), i3.push([o2, r3 === t2 ? e : a3]), o2 = a3;
  return i3;
}

// node_modules/@arcgis/core/smartMapping/statistics/support/utils.js
var $2 = null;
var g2 = /^(?<hh>([0-1][0-9])|([2][0-3])):(?<mm>[0-5][0-9])(:(?<ss>[0-5][0-9]))?([.](?<ms>\d+))?$/;
function I2(e, t2, n) {
  return e.x < 0 ? e.x += t2 : e.x > n && (e.x -= t2), e;
}
function j2(e, t2, n, r3) {
  const l2 = f(n) ? G(n) : null, u3 = l2 ? Math.round((l2.valid[1] - l2.valid[0]) / t2.scale[0]) : null;
  return e.map((e2) => {
    const n2 = new x(e2.geometry);
    return L(t2, n2, n2, n2.hasZ, n2.hasM), e2.geometry = l2 ? I2(n2, u3 ?? 0, r3[0]) : n2, e2;
  });
}
function x3(e, n = 18, r3, o2, i3, s3) {
  const l2 = new Float64Array(i3 * s3);
  n = Math.round(u(n));
  let u3 = Number.POSITIVE_INFINITY, a3 = Number.NEGATIVE_INFINITY, c2 = 0, d3 = 0, p2 = 0, h2 = 0;
  const y3 = y(o2, r3);
  for (const { geometry: t2, attributes: m3 } of e) {
    const { x: e2, y: r4 } = t2, o3 = Math.max(0, e2 - n), $4 = Math.max(0, r4 - n), g3 = Math.min(s3, r4 + n), I3 = Math.min(i3, e2 + n), j3 = +y3(m3);
    for (let t3 = $4; t3 < g3; t3++)
      for (let s4 = o3; s4 < I3; s4++) {
        const o4 = t3 * i3 + s4, m4 = m(s4 - e2, t3 - r4, n), y4 = l2[o4];
        c2 = l2[o4] += m4 * j3;
        const $5 = c2 - y4;
        d3 += $5, p2 += $5 * $5, c2 < u3 && (u3 = c2), c2 > a3 && (a3 = c2), h2++;
      }
  }
  if (!h2)
    return { mean: 0, stddev: 0, min: 0, max: 0, mid: 0, count: 0 };
  const $3 = (a3 - u3) / 2;
  return { mean: d3 / h2, stdDev: Math.sqrt((p2 - d3 * d3 / h2) / h2), min: u3, max: a3, mid: $3, count: h2 };
}
function w2(e) {
  const t2 = g2.exec(e);
  if (!t2)
    return null;
  const { hh: r3, mm: o2, ss: i3, ms: s3 } = t2.groups;
  return Number(r3) * r.hours + Number(o2) * r.minutes + Number(i3) * r.seconds + Number(s3 || 0);
}
async function b2(e, t2, n = true) {
  if (!t2)
    return [];
  const { field: o2, field2: i3, field3: s3, fieldDelimiter: u3, fieldInfos: a3, timeZone: f4 } = e, m3 = o2 && (a3 == null ? void 0 : a3.find((e2) => e2.name.toLowerCase() === o2.toLowerCase())), y3 = !!m3 && be(m3), g3 = !!m3 && Z(m3), I3 = e.valueExpression, j3 = e.normalizationType, x4 = e.normalizationField, b3 = e.normalizationTotal, F2 = [], N2 = e.viewInfoParams;
  let v2 = null, E2 = null;
  if (I3) {
    if (!$2) {
      const { arcadeUtils: e2 } = await i();
      $2 = e2;
    }
    $2.hasGeometryOperations(I3) && await $2.enableGeometryOperations(), v2 = $2.createFunction(I3), E2 = N2 ? $2.getViewInfo({ viewingMode: N2.viewingMode, scale: N2.scale, spatialReference: new f2(N2.spatialReference) }) : null;
  }
  const U2 = e.fieldInfos, M2 = !(t2[0] && "declaredClass" in t2[0] && "esri.Graphic" === t2[0].declaredClass) && U2 ? { fields: U2 } : null;
  return t2.forEach((e2) => {
    const t3 = e2.attributes;
    let r3;
    if (I3) {
      const t4 = M2 ? { ...e2, layer: M2 } : e2, n2 = $2.createExecContext(t4, E2, f4);
      r3 = $2.executeFunction(v2, n2);
    } else
      t3 && (r3 = t3[o2], i3 ? (r3 = `${c(r3)}${u3}${c(t3[i3])}`, s3 && (r3 = `${r3}${u3}${c(t3[s3])}`)) : "string" == typeof r3 && n && (g3 ? r3 = r3 ? new Date(r3).getTime() : null : y3 && (r3 = r3 ? w2(r3) : null)));
    if (j3 && "number" == typeof r3 && isFinite(r3)) {
      const e3 = t3 && parseFloat(t3[x4]);
      r3 = B(r3, j3, e3, b3);
    }
    F2.push(r3);
  }), F2;
}

export {
  c,
  f3 as f,
  d2 as d,
  p,
  v,
  T,
  C,
  k,
  $,
  B,
  E,
  P,
  U,
  j2 as j,
  x3 as x,
  w2 as w,
  b2 as b
};
//# sourceMappingURL=chunk-MMRDHWTI.js.map
