import {
  n as n5
} from "./chunk-4OLZTDWK.js";
import {
  n as n6
} from "./chunk-SKLWU2B3.js";
import {
  n as n4
} from "./chunk-2RN2AAP7.js";
import {
  E as E2
} from "./chunk-ED5W63C6.js";
import {
  n as n3,
  r as r2,
  u as u3
} from "./chunk-AMSVADDY.js";
import {
  o as o2
} from "./chunk-CMGHBCKF.js";
import {
  g as g2
} from "./chunk-F6MD5VOH.js";
import {
  n
} from "./chunk-WYBZLWIA.js";
import {
  l,
  v as v2
} from "./chunk-MKW4ORPJ.js";
import {
  A,
  O2 as O,
  P,
  _2 as _,
  e2 as e,
  g,
  n as n2,
  o,
  p,
  q,
  r2 as r,
  s as s2,
  t as t2,
  u,
  u2,
  v,
  x,
  z
} from "./chunk-YTH6VA7N.js";
import {
  E,
  a,
  a2
} from "./chunk-GINTRQSD.js";
import {
  t2 as t
} from "./chunk-SBW6NNVI.js";
import {
  s2 as s
} from "./chunk-WJ3HJKNC.js";

// node_modules/@arcgis/core/core/ObjectStack.js
var s3 = class {
  constructor(t4) {
    this._allocator = t4, this._items = [], this._itemsPtr = 0, this._grow();
  }
  get() {
    return 0 === this._itemsPtr && t(() => this._reset()), this._itemsPtr === this._items.length && this._grow(), this._items[this._itemsPtr++];
  }
  _reset() {
    const t4 = Math.min(3 * Math.max(8, this._itemsPtr), this._itemsPtr + 3 * i);
    this._items.length = Math.min(t4, this._items.length), this._itemsPtr = 0;
  }
  _grow() {
    for (let t4 = 0; t4 < Math.max(8, Math.min(this._items.length, i)); t4++)
      this._items.push(this._allocator());
  }
};
var i = 1024;

// node_modules/@arcgis/core/core/VectorStack.js
var c = class _c {
  constructor(t4, e3, s4) {
    this._itemByteSize = t4, this._itemCreate = e3, this._buffers = new Array(), this._items = new Array(), this._itemsPtr = 0, this._itemsPerBuffer = Math.ceil(s4 / this._itemByteSize);
  }
  get() {
    0 === this._itemsPtr && t(() => this._reset());
    const t4 = Math.floor(this._itemsPtr / this._itemsPerBuffer);
    for (; this._buffers.length <= t4; ) {
      const t5 = new ArrayBuffer(this._itemsPerBuffer * this._itemByteSize);
      for (let e3 = 0; e3 < this._itemsPerBuffer; ++e3)
        this._items.push(this._itemCreate(t5, e3 * this._itemByteSize));
      this._buffers.push(t5);
    }
    return this._items[this._itemsPtr++];
  }
  _reset() {
    const t4 = 2 * (Math.floor(this._itemsPtr / this._itemsPerBuffer) + 1);
    for (; this._buffers.length > t4; )
      this._buffers.pop(), this._items.length = this._buffers.length * this._itemsPerBuffer;
    this._itemsPtr = 0;
  }
  static createVec2f64(t4 = a3) {
    return new _c(16, o2, t4);
  }
  static createVec3f64(t4 = a3) {
    return new _c(24, u, t4);
  }
  static createVec4f64(t4 = a3) {
    return new _c(32, u3, t4);
  }
  static createMat3f64(t4 = a3) {
    return new _c(72, n4, t4);
  }
  static createMat4f64(t4 = a3) {
    return new _c(128, n5, t4);
  }
  static createQuatf64(t4 = a3) {
    return new _c(32, n6, t4);
  }
  get test() {
    return { size: this._buffers.length * this._itemsPerBuffer * this._itemByteSize };
  }
};
var a3 = 4 * E2.KILOBYTES;

// node_modules/@arcgis/core/geometry/support/vectorStacks.js
var t3 = c.createVec2f64();
var c2 = c.createVec3f64();
var r3 = c.createVec4f64();
var a4 = c.createMat3f64();
var f = c.createMat4f64();
var o3 = c.createQuatf64();

// node_modules/@arcgis/core/geometry/support/ray.js
function d(i2) {
  return i2 ? m(t2(i2.origin), t2(i2.direction)) : m(n2(), n2());
}
function m(i2, n7) {
  return { origin: i2, direction: n7 };
}
function p2(i2, n7) {
  const r4 = S.get();
  return r4.origin = i2, r4.direction = n7, r4;
}
function h2(i2, n7, o4 = d()) {
  return r(o4.origin, i2), e(o4.direction, n7, i2), o4;
}
function q2(i2, n7, r4) {
  const o4 = P(i2.direction, e(r4, n7, i2.origin));
  return u2(r4, i2.origin, g(r4, i2.direction, o4)), r4;
}
var S = new s3(() => d());

// node_modules/@arcgis/core/geometry/support/vector.js
function e2(o4, s4) {
  const c3 = P(o4, s4) / (s2(o4) * s2(s4));
  return -l(c3);
}
var m2 = n2();
var h3 = n2();

// node_modules/@arcgis/core/chunks/sphere.js
var w = E3();
function E3() {
  return n3();
}
var L = E;
var O2 = E;
function T(t4, n7 = E3()) {
  return a2(n7, t4);
}
function k(t4, n7) {
  return r2(t4[0], t4[1], t4[2], n7);
}
function z2(t4) {
  return t4;
}
function N(t4) {
  t4[0] = t4[1] = t4[2] = t4[3] = 0;
}
function Z(t4, n7) {
  return t4[0] = t4[1] = t4[2] = 0, t4[3] = n7, t4;
}
function B(t4) {
  return t4[3];
}
function U(t4) {
  return t4;
}
function V(t4, n7, r4, o4) {
  return r2(t4, n7, r4, o4);
}
function X(t4, n7, r4) {
  return t4 !== r4 && r(r4, t4), r4[3] = t4[3] + n7, r4;
}
function Y(n7, r4, o4) {
  return s.getLogger("esri.geometry.support.sphere").error("sphere.setExtent is not yet supported"), n7 === o4 ? o4 : T(n7, o4);
}
function D(t4, n7, r4) {
  if (null == n7)
    return false;
  if (!H(t4, n7, G))
    return false;
  let { t0: o4, t1: e3 } = G;
  if ((o4 < 0 || e3 < o4 && e3 > 0) && (o4 = e3), o4 < 0)
    return false;
  if (r4) {
    const { origin: t5, direction: e4 } = n7;
    r4[0] = t5[0] + e4[0] * o4, r4[1] = t5[1] + e4[1] * o4, r4[2] = t5[2] + e4[2] * o4;
  }
  return true;
}
function F(t4, n7, r4) {
  const o4 = h2(n7, r4);
  if (!H(t4, o4, G))
    return [];
  const { origin: e3, direction: s4 } = o4, { t0: i2, t1: c3 } = G, a5 = (n8) => {
    const r5 = n2();
    return q(r5, e3, s4, n8), $(t4, r5, r5);
  };
  return Math.abs(i2 - c3) < a() ? [a5(i2)] : [a5(i2), a5(c3)];
}
var G = { t0: 0, t1: 0 };
function H(t4, n7, r4) {
  const { origin: o4, direction: e3 } = n7, s4 = I;
  s4[0] = o4[0] - t4[0], s4[1] = o4[1] - t4[1], s4[2] = o4[2] - t4[2];
  const i2 = e3[0] * e3[0] + e3[1] * e3[1] + e3[2] * e3[2];
  if (0 === i2)
    return false;
  const c3 = 2 * (e3[0] * s4[0] + e3[1] * s4[1] + e3[2] * s4[2]), a5 = c3 * c3 - 4 * i2 * (s4[0] * s4[0] + s4[1] * s4[1] + s4[2] * s4[2] - t4[3] * t4[3]);
  if (a5 < 0)
    return false;
  const u4 = Math.sqrt(a5);
  return r4.t0 = (-c3 - u4) / (2 * i2), r4.t1 = (-c3 + u4) / (2 * i2), true;
}
var I = n2();
function J(t4, n7) {
  return D(t4, n7, null);
}
function K(t4, n7, r4) {
  if (D(t4, n7, r4))
    return r4;
  const o4 = Q(t4, n7, c2.get());
  return u2(r4, n7.origin, g(c2.get(), n7.direction, x(n7.origin, o4) / s2(n7.direction))), r4;
}
function Q(t4, n7, r4) {
  const e3 = c2.get(), s4 = f.get();
  _(e3, n7.origin, n7.direction);
  const c3 = B(t4);
  _(r4, e3, n7.origin), g(r4, r4, 1 / s2(r4) * c3);
  const m3 = nt(t4, n7.origin), p3 = e2(n7.origin, r4);
  return g2(s4, p3 + m3, e3), O(r4, r4, s4), r4;
}
function W(t4, n7, r4) {
  return D(t4, n7, r4) ? r4 : (q2(n7, U(t4), r4), $(t4, r4, r4));
}
function $(t4, n7, r4) {
  const o4 = e(c2.get(), n7, U(t4)), e3 = g(c2.get(), o4, t4[3] / s2(o4));
  return u2(r4, e3, U(t4));
}
function tt(t4, n7) {
  const r4 = e(c2.get(), n7, U(t4)), o4 = v(r4), e3 = t4[3] * t4[3];
  return Math.sqrt(Math.abs(o4 - e3));
}
function nt(t4, r4) {
  const o4 = e(c2.get(), r4, U(t4)), e3 = s2(o4), s4 = B(t4), i2 = s4 + Math.abs(s4 - e3);
  return l(s4 / i2);
}
var rt = n2();
function ot(t4, n7, o4, e3) {
  const s4 = e(rt, n7, U(t4));
  switch (o4) {
    case n.X: {
      const t5 = v2(s4, rt)[2];
      return o(e3, -Math.sin(t5), Math.cos(t5), 0);
    }
    case n.Y: {
      const t5 = v2(s4, rt), n8 = t5[1], o5 = t5[2], i2 = Math.sin(n8);
      return o(e3, -i2 * Math.cos(o5), -i2 * Math.sin(o5), Math.cos(n8));
    }
    case n.Z:
      return z(e3, s4);
    default:
      return;
  }
}
function et(t4, n7) {
  const r4 = e(at, n7, U(t4));
  return s2(r4) - t4[3];
}
function st(t4, n7, r4, o4) {
  const e3 = et(t4, n7), c3 = ot(t4, n7, n.Z, at), a5 = g(at, c3, r4 - e3);
  return u2(o4, n7, a5);
}
function it(t4, n7) {
  const r4 = p(U(t4), n7), o4 = B(t4);
  return r4 <= o4 * o4;
}
function ct(t4, n7, r4 = E3()) {
  const o4 = x(t4, n7), e3 = t4[3], s4 = n7[3];
  return o4 + s4 < e3 ? (a2(r4, t4), r4) : o4 + e3 < s4 ? (a2(r4, n7), r4) : (A(r4, t4, n7, (o4 + s4 - e3) / (2 * o4)), r4[3] = (o4 + e3 + s4) / 2, r4);
}
var at = n2();
var ut = E3();
var ft = Object.freeze(Object.defineProperty({ __proto__: null, NullSphere: w, altitudeAt: et, angleToSilhouette: nt, axisAt: ot, clear: N, closestPoint: W, closestPointOnSilhouette: Q, containsPoint: it, copy: T, create: E3, distanceToSilhouette: tt, elevate: X, equals: O2, exactEquals: L, fromCenterAndRadius: k, fromRadius: Z, fromValues: V, getCenter: U, getRadius: B, intersectLine: F, intersectRay: D, intersectRayClosestSilhouette: K, intersectsRay: J, projectPoint: $, setAltitudeAt: st, setExtent: Y, tmpSphere: ut, union: ct, wrap: z2 }, Symbol.toStringTag, { value: "Module" }));

export {
  s3 as s,
  c2 as c,
  d,
  p2 as p,
  E3 as E,
  T,
  B,
  U,
  J,
  it
};
//# sourceMappingURL=chunk-WM2YJJQZ.js.map
