import {
  C,
  D,
  O,
  R as R2,
  S as S3,
  S2 as S4,
  T,
  U,
  a as a2,
  b as b4,
  c as c3,
  c2 as c4,
  i as i4,
  j as j5,
  j2 as j6,
  k as k3,
  l,
  m as m4,
  n as n2,
  o as o6,
  o2 as o7,
  r as r2,
  s as s5,
  w,
  y as y4
} from "./chunk-WWNPMJR4.js";
import {
  i as i3
} from "./chunk-XJLKESB7.js";
import "./chunk-QLCCKKQG.js";
import {
  o as o5
} from "./chunk-LVN3FGME.js";
import "./chunk-F3LMPTMS.js";
import {
  j as j4
} from "./chunk-KQ7MCWUF.js";
import {
  a
} from "./chunk-P5VIVFJT.js";
import "./chunk-SA3C7GIT.js";
import "./chunk-P3R45ANF.js";
import {
  t as t2
} from "./chunk-PIEUUBJ5.js";
import {
  u as u2
} from "./chunk-OTTMOIDW.js";
import {
  m as m2
} from "./chunk-P5GW5DPX.js";
import "./chunk-WDO2BXGR.js";
import "./chunk-SHFNNIVW.js";
import "./chunk-IYYYQK4Y.js";
import "./chunk-QN7I7LNY.js";
import "./chunk-64EQFPYJ.js";
import "./chunk-HKYMYCLL.js";
import "./chunk-ICVVQFO6.js";
import {
  d
} from "./chunk-O3E2OZKN.js";
import "./chunk-EA6ZJZL6.js";
import "./chunk-VKTTTBW2.js";
import "./chunk-3RBII4KE.js";
import "./chunk-SEKLTVY5.js";
import "./chunk-7YZ4X2DS.js";
import "./chunk-UPGPT5OX.js";
import "./chunk-VA52CKTT.js";
import "./chunk-T3Y5GTKO.js";
import "./chunk-XN6LAULS.js";
import "./chunk-CKGVKMVG.js";
import "./chunk-CSWPLQ7Q.js";
import "./chunk-KWSMYM7P.js";
import "./chunk-RP5SAUAF.js";
import "./chunk-6BFXMZEZ.js";
import "./chunk-AMSVADDY.js";
import {
  f as f3
} from "./chunk-6B7VJB6C.js";
import "./chunk-GAJBN4TM.js";
import {
  R
} from "./chunk-LOGPPZUD.js";
import "./chunk-HYU6N3H3.js";
import {
  b as b3
} from "./chunk-WETX22HQ.js";
import {
  c as c2
} from "./chunk-B3RXTW72.js";
import {
  k as k2
} from "./chunk-DCYI44X2.js";
import "./chunk-JHJVOI7Q.js";
import "./chunk-TWNBDJHC.js";
import {
  S as S2,
  j2 as j3,
  m as m3,
  y as y3
} from "./chunk-4NU7FZD7.js";
import "./chunk-WYZCKLOR.js";
import "./chunk-S6NERLXF.js";
import "./chunk-MLRHWRJQ.js";
import "./chunk-H4ZZ5S37.js";
import "./chunk-G557TGXY.js";
import "./chunk-WOGT6UK2.js";
import "./chunk-RHT6WWRD.js";
import {
  f as f4,
  i
} from "./chunk-EUGXS5RE.js";
import "./chunk-IRNKV32L.js";
import "./chunk-IATM3RCE.js";
import "./chunk-BEALJUHO.js";
import "./chunk-GRHSIT57.js";
import "./chunk-PJQIAD5D.js";
import "./chunk-GAWSWBHO.js";
import "./chunk-SZAJDZCO.js";
import "./chunk-3DSKWYU4.js";
import {
  n
} from "./chunk-ZZYUEH57.js";
import "./chunk-VTWXDFFD.js";
import {
  p
} from "./chunk-IPCIO3PX.js";
import "./chunk-EIY2DYTV.js";
import {
  i as i2
} from "./chunk-WJ4LS3YG.js";
import "./chunk-F6MD5VOH.js";
import {
  o as o4
} from "./chunk-V2RPSCV3.js";
import {
  y as y2
} from "./chunk-AOJ6OCPK.js";
import "./chunk-LMT5JII2.js";
import "./chunk-A43TI6AT.js";
import {
  S
} from "./chunk-2D3PORS4.js";
import {
  F,
  b as b2
} from "./chunk-4HKQSEUR.js";
import "./chunk-V3U4F2NL.js";
import "./chunk-ZB6PGKG5.js";
import {
  m3 as m,
  u
} from "./chunk-OIIDE5GZ.js";
import "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import {
  v as v2
} from "./chunk-TBSVVR6M.js";
import "./chunk-6TJWLWLO.js";
import "./chunk-H7BKONNV.js";
import "./chunk-K6C6RVSV.js";
import "./chunk-KBJ5Z4R2.js";
import {
  V
} from "./chunk-JUZJCTW2.js";
import "./chunk-423VNHLR.js";
import "./chunk-FN47E7YK.js";
import "./chunk-XZS3Q5K4.js";
import {
  j as j7
} from "./chunk-WZPOQGKL.js";
import "./chunk-CCXEAKIM.js";
import {
  M
} from "./chunk-Y5D433JZ.js";
import {
  x2 as x
} from "./chunk-QNOCEWCR.js";
import {
  o as o3
} from "./chunk-WURET5CW.js";
import {
  f as f2,
  r
} from "./chunk-QWPLZ3QH.js";
import {
  N,
  j as j2
} from "./chunk-HLGIRLYQ.js";
import "./chunk-N2K4VRZH.js";
import "./chunk-WL4VPODY.js";
import "./chunk-OMPEZIP5.js";
import {
  s as s4
} from "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import {
  I,
  j,
  qt
} from "./chunk-R5DM4YAB.js";
import {
  f
} from "./chunk-NSRXJNTS.js";
import {
  o3 as o2,
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c,
  v
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  b
} from "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  o,
  s,
  s2,
  s3,
  t
} from "./chunk-WJ3HJKNC.js";
import {
  k
} from "./chunk-4V6374PV.js";
import "./chunk-A34O4XB5.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/support/RouteStopSymbols.js
var p2 = class extends f {
  constructor(o8) {
    super(o8), this.break = new y3({ color: [255, 255, 255], size: 12, outline: { color: [0, 122, 194], width: 3 } }), this.first = new y3({ color: [0, 255, 0], size: 20, outline: { color: [255, 255, 255], width: 4 } }), this.unlocated = new y3({ color: [255, 0, 0], size: 12, outline: { color: [255, 255, 255], width: 3 } }), this.last = new y3({ color: [255, 0, 0], size: 20, outline: { color: [255, 255, 255], width: 4 } }), this.middle = new y3({ color: [51, 51, 51], size: 12, outline: { color: [0, 122, 194], width: 3 } }), this.waypoint = new y3({ color: [255, 255, 255], size: 12, outline: { color: [0, 122, 194], width: 3 } });
  }
};
e([y({ types: j3 })], p2.prototype, "break", void 0), e([y({ types: j3 })], p2.prototype, "first", void 0), e([y({ types: j3 })], p2.prototype, "unlocated", void 0), e([y({ types: j3 })], p2.prototype, "last", void 0), e([y({ types: j3 })], p2.prototype, "middle", void 0), e([y({ types: j3 })], p2.prototype, "waypoint", void 0), p2 = e([c("esri.layers.support.RouteStopSymbols")], p2);
var l2 = p2;

// node_modules/@arcgis/core/layers/support/RouteSymbols.js
var c5 = class extends f {
  constructor(o8) {
    super(o8), this.directionLines = new m3({ color: [0, 122, 194], width: 6 }), this.directionPoints = new y3({ color: [255, 255, 255], size: 6, outline: { color: [0, 122, 194], width: 2 } }), this.pointBarriers = new y3({ style: "x", size: 10, outline: { color: [255, 0, 0], width: 3 } }), this.polygonBarriers = new S2({ color: [255, 170, 0, 0.6], outline: { width: 7.5, color: [255, 0, 0, 0.6] } }), this.polylineBarriers = new m3({ width: 7.5, color: [255, 85, 0, 0.7] }), this.routeInfo = new m3({ width: 8, color: [20, 89, 127] }), this.stops = new l2();
  }
};
e([y({ types: j3 })], c5.prototype, "directionLines", void 0), e([y({ types: j3 })], c5.prototype, "directionPoints", void 0), e([y({ types: j3 })], c5.prototype, "pointBarriers", void 0), e([y({ types: j3 })], c5.prototype, "polygonBarriers", void 0), e([y({ types: j3 })], c5.prototype, "polylineBarriers", void 0), e([y({ types: j3 })], c5.prototype, "routeInfo", void 0), e([y({ type: l2 })], c5.prototype, "stops", void 0), c5 = e([c("esri.layers.support.RouteSymbols")], c5);
var n3 = c5;

// node_modules/@arcgis/core/rest/support/NetworkAttribute.js
var u3 = class extends f {
  constructor(t4) {
    super(t4), this.dataType = null, this.name = null, this.parameterNames = null, this.restrictionUsageParameterName = null, this.timeNeutralAttributeName = null, this.trafficSupport = null, this.units = null, this.usageType = null;
  }
};
e([y({ type: String })], u3.prototype, "dataType", void 0), e([o4(U, { ignoreUnknown: false })], u3.prototype, "name", void 0), e([y({ type: [String] })], u3.prototype, "parameterNames", void 0), e([y({ type: String })], u3.prototype, "restrictionUsageParameterName", void 0), e([o4(y4, { ignoreUnknown: false })], u3.prototype, "timeNeutralAttributeName", void 0), e([y({ type: String })], u3.prototype, "trafficSupport", void 0), e([o4(s5)], u3.prototype, "units", void 0), e([o4(R2)], u3.prototype, "usageType", void 0), u3 = e([c("esri.rest.support.NetworkAttribute")], u3);
var m5 = u3;

// node_modules/@arcgis/core/rest/support/NetworkDataset.js
var p3 = class extends f {
  constructor(t4) {
    super(t4), this.buildTime = null, this.name = null, this.networkAttributes = null, this.networkSources = null, this.state = null;
  }
};
e([y({ type: Number })], p3.prototype, "buildTime", void 0), e([y({ type: String })], p3.prototype, "name", void 0), e([y({ type: [m5] })], p3.prototype, "networkAttributes", void 0), e([y()], p3.prototype, "networkSources", void 0), e([y({ type: String })], p3.prototype, "state", void 0), p3 = e([c("esri.rest.support.NetworkDataset")], p3);
var i5 = p3;

// node_modules/@arcgis/core/rest/support/NetworkServiceDescription.js
var c6 = class extends f {
  constructor(t4) {
    super(t4), this.accumulateAttributeNames = null, this.attributeParameterValues = null, this.currentVersion = null, this.defaultTravelMode = null, this.directionsLanguage = null, this.directionsLengthUnits = null, this.directionsSupportedLanguages = null, this.directionsTimeAttribute = null, this.hasZ = null, this.impedance = null, this.networkDataset = null, this.supportedTravelModes = null;
  }
  readAccumulateAttributes(t4) {
    return null == t4 ? null : t4.map((t5) => U.fromJSON(t5));
  }
  writeAccumulateAttributes(t4, e2, r3) {
    (t4 == null ? void 0 : t4.length) && (e2[r3] = t4.map((t5) => U.toJSON(t5)));
  }
  readDefaultTravelMode(t4, e2) {
    var _a, _b;
    const r3 = ((_a = e2.supportedTravelModes) == null ? void 0 : _a.find(({ id: t5 }) => t5 === e2.defaultTravelMode)) ?? ((_b = e2.supportedTravelModes) == null ? void 0 : _b.find(({ itemId: t5 }) => t5 === e2.defaultTravelMode));
    return r3 ? j5.fromJSON(r3) : null;
  }
};
e([y()], c6.prototype, "accumulateAttributeNames", void 0), e([o3("accumulateAttributeNames")], c6.prototype, "readAccumulateAttributes", null), e([r("accumulateAttributeNames")], c6.prototype, "writeAccumulateAttributes", null), e([y()], c6.prototype, "attributeParameterValues", void 0), e([y()], c6.prototype, "currentVersion", void 0), e([y()], c6.prototype, "defaultTravelMode", void 0), e([o3("defaultTravelMode", ["defaultTravelMode", "supportedTravelModes"])], c6.prototype, "readDefaultTravelMode", null), e([y()], c6.prototype, "directionsLanguage", void 0), e([o4(r2)], c6.prototype, "directionsLengthUnits", void 0), e([y()], c6.prototype, "directionsSupportedLanguages", void 0), e([o4(y4, { ignoreUnknown: false })], c6.prototype, "directionsTimeAttribute", void 0), e([y()], c6.prototype, "hasZ", void 0), e([o4(U, { ignoreUnknown: false })], c6.prototype, "impedance", void 0), e([y({ type: i5 })], c6.prototype, "networkDataset", void 0), e([y({ type: [j5] })], c6.prototype, "supportedTravelModes", void 0), c6 = e([c("esri.rest.support.NetworkServiceDescription")], c6);
var m6 = c6;

// node_modules/@arcgis/core/rest/networkService.js
var l3 = s2.getLogger("esri.rest.networkService");
function u4(e2, r3, t4, o8) {
  o8[t4] = [r3.length, r3.length + e2.length], e2.forEach((e3) => {
    r3.push(e3.geometry);
  });
}
function f5(e2, r3) {
  for (let t4 = 0; t4 < r3.length; t4++) {
    const o8 = e2[r3[t4]];
    if (o8 && o8.length)
      for (const e3 of o8)
        e3.z = void 0;
  }
  l3.warnOnce("The remote Network Analysis service is powered by a network dataset which is not Z-aware.\nZ-coordinates of the input geometry are ignored.");
}
function c7(e2, r3) {
  for (let t4 = 0; t4 < r3.length; t4++) {
    const o8 = e2[r3[t4]];
    if (o8 && o8.length) {
      for (const e3 of o8)
        if (null != e3 && e3.hasZ)
          return true;
    }
  }
  return false;
}
async function d2(t4, o8, s7) {
  if (!t4)
    throw new s3("network-service:missing-url", "Url to Network service is missing");
  const n6 = i({ f: "json", token: o8 }, s7), { data: l6 } = await j(t4, n6), u7 = l6.currentVersion >= 10.4 ? p4(t4, o8, s7) : v3(t4, s7), { defaultTravelMode: f6, supportedTravelModes: c17 } = await u7;
  return l6.defaultTravelMode = f6, l6.supportedTravelModes = c17, m6.fromJSON(l6);
}
async function v3(r3, t4) {
  var _a, _b, _c;
  const i9 = i({ f: "json" }, t4), { data: l6 } = await j(r3.replace(/\/rest\/.*$/i, "/info"), i9);
  if (!(l6 == null ? void 0 : l6.owningSystemUrl))
    return { supportedTravelModes: [], defaultTravelMode: null };
  const { owningSystemUrl: u7 } = l6, f6 = qt(u7) + "/sharing/rest/portals/self", { data: c17 } = await j(f6, i9), d3 = t("helperServices.routingUtilities.url", c17);
  if (!d3)
    return { supportedTravelModes: [], defaultTravelMode: null };
  const v4 = f4(u7), p9 = /\/solve$/i.test(v4.path) ? "Route" : /\/solveclosestfacility$/i.test(v4.path) ? "ClosestFacility" : "ServiceAreas", m10 = i({ f: "json", serviceName: p9 }, t4), h = qt(d3) + "/GetTravelModes/execute", g = await j(h, m10), w2 = [];
  let T2 = null;
  if ((_b = (_a = g == null ? void 0 : g.data) == null ? void 0 : _a.results) == null ? void 0 : _b.length) {
    const e2 = g.data.results;
    for (const r4 of e2)
      if ("supportedTravelModes" === r4.paramName) {
        if ((_c = r4.value) == null ? void 0 : _c.features) {
          for (const { attributes: e3 } of r4.value.features)
            if (e3) {
              const r5 = JSON.parse(e3.TravelMode);
              w2.push(r5);
            }
        }
      } else
        "defaultTravelMode" === r4.paramName && (T2 = r4.value);
  }
  return { supportedTravelModes: w2, defaultTravelMode: T2 };
}
async function p4(t4, o8, n6) {
  try {
    const r3 = i({ f: "json", token: o8 }, n6), i9 = qt(t4) + "/retrieveTravelModes", { data: { supportedTravelModes: l6, defaultTravelMode: u7 } } = await j(i9, r3);
    return { supportedTravelModes: l6, defaultTravelMode: u7 };
  } catch (i9) {
    throw new s3("network-service:retrieveTravelModes", "Could not get to the NAServer's retrieveTravelModes.", { error: i9 });
  }
}

// node_modules/@arcgis/core/rest/support/GPMessage.js
var p5 = new s4({ esriJobMessageTypeInformative: "informative", esriJobMessageTypeProcessDefinition: "process-definition", esriJobMessageTypeProcessStart: "process-start", esriJobMessageTypeProcessStop: "process-stop", esriJobMessageTypeWarning: "warning", esriJobMessageTypeError: "error", esriJobMessageTypeEmpty: "empty", esriJobMessageTypeAbort: "abort" });
var i6 = class extends f {
  constructor(e2) {
    super(e2), this.description = null, this.type = null;
  }
};
e([y({ type: String, json: { write: true } })], i6.prototype, "description", void 0), e([y({ type: String, json: { read: p5.read, write: p5.write } })], i6.prototype, "type", void 0), i6 = e([c("esri.rest.support.GPMessage")], i6);
var a3 = i6;

// node_modules/@arcgis/core/rest/support/NAMessage.js
var p6 = new s4({ 0: "informative", 1: "process-definition", 2: "process-start", 3: "process-stop", 50: "warning", 100: "error", 101: "empty", 200: "abort" });
var c8 = class extends a3 {
  constructor(r3) {
    super(r3), this.type = null;
  }
};
e([y({ type: String, json: { read: p6.read, write: p6.write } })], c8.prototype, "type", void 0), c8 = e([c("esri.rest.support.NAMessage")], c8);
var a4 = c8;

// node_modules/@arcgis/core/rest/support/DirectionsString.js
var c9 = class extends f {
  constructor(r3) {
    super(r3);
  }
};
e([y({ json: { read: { source: "string" } } })], c9.prototype, "text", void 0), e([o4(b4, { name: "stringType" })], c9.prototype, "type", void 0), c9 = e([c("esri.rest.support.DirectionsString")], c9);
var i7 = c9;

// node_modules/@arcgis/core/rest/support/DirectionsEvent.js
var a5 = class extends f {
  constructor(r3) {
    super(r3), this.arriveTime = null, this.arriveTimeOffset = null, this.geometry = null, this.strings = null;
  }
  readArriveTimeOffset(r3, e2) {
    return n2(e2.ETA, e2.arriveTimeUTC);
  }
  readGeometry(r3, e2) {
    return x.fromJSON(e2.point);
  }
};
e([y({ type: Date, json: { read: { source: "arriveTimeUTC" } } })], a5.prototype, "arriveTime", void 0), e([y()], a5.prototype, "arriveTimeOffset", void 0), e([o3("arriveTimeOffset", ["arriveTimeUTC", "ETA"])], a5.prototype, "readArriveTimeOffset", null), e([y({ type: x })], a5.prototype, "geometry", void 0), e([o3("geometry", ["point"])], a5.prototype, "readGeometry", null), e([y({ type: [i7] })], a5.prototype, "strings", void 0), a5 = e([c("esri.rest.support.DirectionsEvent")], a5);
var c10 = a5;

// node_modules/@arcgis/core/rest/support/DirectionsFeature.js
function i8(r3) {
  if (null == r3 || "" === r3)
    return null;
  let e2 = 0, t4 = 0, s7 = 0, o8 = 0;
  const p9 = [];
  let n6, c17, i9, a7, m10, l6, u7, f6, y6 = 0, d3 = 0, h = 0;
  if (m10 = r3.match(/((\+|\-)[^\+\-\|]+|\|)/g), m10 || (m10 = []), 0 === parseInt(m10[y6], 32)) {
    y6 = 2;
    const r4 = parseInt(m10[y6], 32);
    y6++, l6 = parseInt(m10[y6], 32), y6++, 1 & r4 && (d3 = m10.indexOf("|") + 1, u7 = parseInt(m10[d3], 32), d3++), 2 & r4 && (h = m10.indexOf("|", d3) + 1, f6 = parseInt(m10[h], 32), h++);
  } else
    l6 = parseInt(m10[y6], 32), y6++;
  for (; y6 < m10.length && "|" !== m10[y6]; ) {
    n6 = parseInt(m10[y6], 32) + e2, y6++, e2 = n6, c17 = parseInt(m10[y6], 32) + t4, y6++, t4 = c17;
    const r4 = [n6 / l6, c17 / l6];
    d3 && (a7 = parseInt(m10[d3], 32) + s7, d3++, s7 = a7, r4.push(a7 / u7)), h && (i9 = parseInt(m10[h], 32) + o8, h++, o8 = i9, r4.push(i9 / f6)), p9.push(r4);
  }
  return { paths: [p9], hasZ: d3 > 0, hasM: h > 0 };
}
var a6 = class extends c2 {
  constructor(r3) {
    super(r3), this.events = null, this.strings = null;
  }
  readGeometry(r3, e2) {
    const t4 = i8(e2.compressedGeometry);
    return null != t4 ? m.fromJSON(t4) : null;
  }
};
e([y({ type: [c10] })], a6.prototype, "events", void 0), e([o3("geometry", ["compressedGeometry"])], a6.prototype, "readGeometry", null), e([y({ type: [i7] })], a6.prototype, "strings", void 0), a6 = e([c("esri.rest.support.DirectionsFeature")], a6);
var m7 = a6;

// node_modules/@arcgis/core/rest/support/DirectionsFeatureSet.js
function u5(e2, t4) {
  if (0 === e2.length)
    return new m({ spatialReference: t4 });
  const r3 = [];
  for (const n6 of e2)
    for (const e3 of n6.paths)
      r3.push(...e3);
  const o8 = [];
  r3.forEach((e3, t5) => {
    0 !== t5 && e3[0] === r3[t5 - 1][0] && e3[1] === r3[t5 - 1][1] || o8.push(e3);
  });
  const { hasM: s7, hasZ: a7 } = e2[0];
  return new m({ hasM: s7, hasZ: a7, paths: [o8], spatialReference: t4 });
}
var m8 = class extends d {
  constructor(e2) {
    super(e2), this.extent = null, this.features = [], this.geometryType = "polyline", this.routeId = null, this.routeName = null, this.totalDriveTime = null, this.totalLength = null, this.totalTime = null;
  }
  readFeatures(e2, t4) {
    if (!e2)
      return [];
    const r3 = t4.summary.envelope.spatialReference ?? t4.spatialReference, o8 = r3 && f2.fromJSON(r3);
    return e2.map((e3) => {
      const t5 = m7.fromJSON(e3);
      if (null != t5.geometry && (t5.geometry.spatialReference = o8), null != t5.events)
        for (const r4 of t5.events)
          null != r4.geometry && (r4.geometry.spatialReference = o8);
      return t5;
    });
  }
  get mergedGeometry() {
    if (!this.features)
      return null;
    return u5(this.features.map(({ geometry: e2 }) => e2), this.extent.spatialReference);
  }
  get strings() {
    return this.features.flatMap(({ strings: e2 }) => e2).filter(k);
  }
};
e([y({ type: M, json: { read: { source: "summary.envelope" } } })], m8.prototype, "extent", void 0), e([y({ nonNullable: true })], m8.prototype, "features", void 0), e([o3("features")], m8.prototype, "readFeatures", null), e([y()], m8.prototype, "geometryType", void 0), e([y({ readOnly: true })], m8.prototype, "mergedGeometry", null), e([y()], m8.prototype, "routeId", void 0), e([y()], m8.prototype, "routeName", void 0), e([y({ value: null, readOnly: true })], m8.prototype, "strings", null), e([y({ json: { read: { source: "summary.totalDriveTime" } } })], m8.prototype, "totalDriveTime", void 0), e([y({ json: { read: { source: "summary.totalLength" } } })], m8.prototype, "totalLength", void 0), e([y({ json: { read: { source: "summary.totalTime" } } })], m8.prototype, "totalTime", void 0), m8 = e([c("esri.rest.support.DirectionsFeatureSet")], m8);
var c11 = m8;

// node_modules/@arcgis/core/rest/support/RouteResult.js
var n4 = class extends f {
  constructor(t4) {
    super(t4), this.directionLines = null, this.directionPoints = null, this.directions = null, this.route = null, this.routeName = null, this.stops = null, this.traversedEdges = null, this.traversedJunctions = null, this.traversedTurns = null;
  }
};
e([y({ type: d, json: { write: true } })], n4.prototype, "directionLines", void 0), e([y({ type: d, json: { write: true } })], n4.prototype, "directionPoints", void 0), e([y({ type: c11, json: { write: true } })], n4.prototype, "directions", void 0), e([y({ type: c2, json: { write: true } })], n4.prototype, "route", void 0), e([y({ type: String, json: { write: true } })], n4.prototype, "routeName", void 0), e([y({ type: [c2], json: { write: true } })], n4.prototype, "stops", void 0), e([y({ type: d, json: { write: true } })], n4.prototype, "traversedEdges", void 0), e([y({ type: d, json: { write: true } })], n4.prototype, "traversedJunctions", void 0), e([y({ type: d, json: { write: true } })], n4.prototype, "traversedTurns", void 0), n4 = e([c("esri.rest.support.RouteResult")], n4);
var u6 = n4;

// node_modules/@arcgis/core/rest/support/RouteSolveResult.js
function n5(r3) {
  return r3 ? d.fromJSON(r3).features.filter(k) : [];
}
var c12 = class extends f {
  constructor(r3) {
    super(r3), this.messages = null, this.pointBarriers = null, this.polylineBarriers = null, this.polygonBarriers = null, this.routeResults = null;
  }
  readPointBarriers(r3, o8) {
    return n5(o8.barriers);
  }
  readPolylineBarriers(r3) {
    return n5(r3);
  }
  readPolygonBarriers(r3) {
    return n5(r3);
  }
};
e([y({ type: [a4] })], c12.prototype, "messages", void 0), e([y({ type: [c2] })], c12.prototype, "pointBarriers", void 0), e([o3("pointBarriers", ["barriers"])], c12.prototype, "readPointBarriers", null), e([y({ type: [c2] })], c12.prototype, "polylineBarriers", void 0), e([o3("polylineBarriers")], c12.prototype, "readPolylineBarriers", null), e([y({ type: [c2] })], c12.prototype, "polygonBarriers", void 0), e([o3("polygonBarriers")], c12.prototype, "readPolygonBarriers", null), e([y({ type: [u6] })], c12.prototype, "routeResults", void 0), c12 = e([c("esri.rest.support.RouteSolveResult")], c12);
var y5 = c12;

// node_modules/@arcgis/core/rest/route.js
function c13(e2) {
  return e2 instanceof d;
}
async function l4(f6, p9, l6) {
  const y6 = [], d3 = [], g = {}, h = {}, R4 = f4(f6), { path: v4 } = R4;
  c13(p9.stops) && u4(p9.stops.features, d3, "stops.features", g), c13(p9.pointBarriers) && u4(p9.pointBarriers.features, d3, "pointBarriers.features", g), c13(p9.polylineBarriers) && u4(p9.polylineBarriers.features, d3, "polylineBarriers.features", g), c13(p9.polygonBarriers) && u4(p9.polygonBarriers.features, d3, "polygonBarriers.features", g);
  const B = await R(d3);
  for (const e2 in g) {
    const r3 = g[e2];
    y6.push(e2), h[e2] = B.slice(r3[0], r3[1]);
  }
  if (c7(h, y6)) {
    let e2 = null;
    try {
      e2 = await d2(v4, p9.apiKey, l6);
    } catch {
    }
    e2 && !e2.hasZ && f5(h, y6);
  }
  for (const e2 in h)
    h[e2].forEach((t4, s7) => {
      o2(p9, e2)[s7].geometry = t4;
    });
  const E = { ...l6, query: { ...R4.query, ...o7(p9), f: "json" } }, T2 = v4.endsWith("/solve") ? v4 : `${v4}/solve`, { data: b5 } = await j(T2, E);
  return m9(b5);
}
function m9(e2) {
  const { barriers: r3, directionLines: t4, directionPoints: s7, directions: o8, messages: a7, polygonBarriers: i9, polylineBarriers: n6, routes: u7, stops: f6, traversedEdges: c17, traversedJunctions: l6, traversedTurns: m10 } = e2, y6 = (e3) => {
    const r4 = g.find((r5) => r5.routeName === e3);
    if (null != r4)
      return r4;
    const t5 = { routeId: g.length + 1, routeName: e3 };
    return g.push(t5), t5;
  }, d3 = (e3) => {
    const r4 = g.find((r5) => r5.routeId === e3);
    if (null != r4)
      return r4;
    const t5 = { routeId: e3, routeName: null };
    return g.push(t5), t5;
  }, g = [];
  u7 == null ? void 0 : u7.features.forEach((e3, r4) => {
    e3.geometry.spatialReference = u7.spatialReference ?? void 0;
    const t5 = e3.attributes.Name, s8 = r4 + 1;
    g.push({ routeId: s8, routeName: t5, route: e3 });
  }), o8 == null ? void 0 : o8.forEach((e3) => {
    const { routeName: r4 } = e3;
    y6(r4).directions = e3;
  });
  const h = ((f6 == null ? void 0 : f6.features.every((e3) => null == e3.attributes.RouteName)) ?? false) && g.length > 0 ? g[0].routeName : null;
  return f6 == null ? void 0 : f6.features.forEach((e3) => {
    var _a;
    e3.geometry && ((_a = e3.geometry).spatialReference ?? (_a.spatialReference = f6.spatialReference ?? void 0));
    const r4 = h ?? e3.attributes.RouteName, t5 = y6(r4);
    t5.stops ?? (t5.stops = []), t5.stops.push(e3);
  }), t4 == null ? void 0 : t4.features.forEach((e3) => {
    const r4 = e3.attributes.RouteID, s8 = d3(r4), { geometryType: o9, spatialReference: a8 } = t4;
    s8.directionLines ?? (s8.directionLines = { features: [], geometryType: o9, spatialReference: a8 }), s8.directionLines.features.push(e3);
  }), s7 == null ? void 0 : s7.features.forEach((e3) => {
    const r4 = e3.attributes.RouteID, t5 = d3(r4), { geometryType: o9, spatialReference: a8 } = s7;
    t5.directionPoints ?? (t5.directionPoints = { features: [], geometryType: o9, spatialReference: a8 }), t5.directionPoints.features.push(e3);
  }), c17 == null ? void 0 : c17.features.forEach((e3) => {
    const r4 = e3.attributes.RouteID, t5 = d3(r4), { geometryType: s8, spatialReference: o9 } = c17;
    t5.traversedEdges ?? (t5.traversedEdges = { features: [], geometryType: s8, spatialReference: o9 }), t5.traversedEdges.features.push(e3);
  }), l6 == null ? void 0 : l6.features.forEach((e3) => {
    const r4 = e3.attributes.RouteID, t5 = d3(r4), { geometryType: s8, spatialReference: o9 } = l6;
    t5.traversedJunctions ?? (t5.traversedJunctions = { features: [], geometryType: s8, spatialReference: o9 }), t5.traversedJunctions.features.push(e3);
  }), m10 == null ? void 0 : m10.features.forEach((e3) => {
    const r4 = e3.attributes.RouteID, t5 = d3(r4);
    t5.traversedTurns ?? (t5.traversedTurns = { features: [] }), t5.traversedTurns.features.push(e3);
  }), y5.fromJSON({ routeResults: g, barriers: r3, polygonBarriers: i9, polylineBarriers: n6, messages: a7 });
}

// node_modules/@arcgis/core/rest/support/commonProperties.js
var t3 = { type: String, json: { read: { source: "token" }, write: { target: "token" } } };

// node_modules/@arcgis/core/rest/support/DataLayer.js
var l5 = class extends i2(f) {
  constructor(o8) {
    super(o8), this.doNotLocateOnRestrictedElements = null, this.geometry = null, this.geometryType = null, this.name = null, this.spatialRelationship = null, this.type = "layer", this.where = null;
  }
};
e([y({ type: Boolean, json: { write: true } })], l5.prototype, "doNotLocateOnRestrictedElements", void 0), e([y({ types: n, json: { read: p, write: true } })], l5.prototype, "geometry", void 0), e([o4(w)], l5.prototype, "geometryType", void 0), e([y({ type: String, json: { name: "layerName", write: true } })], l5.prototype, "name", void 0), e([o4(S3, { name: "spatialRel" })], l5.prototype, "spatialRelationship", void 0), e([y({ type: String, json: { write: true } })], l5.prototype, "type", void 0), e([y({ type: String, json: { write: true } })], l5.prototype, "where", void 0), l5 = e([c("esri.rest.support.DataLayer")], l5);
var c14 = l5;

// node_modules/@arcgis/core/rest/support/NetworkFeatureSet.js
var s6;
var c15 = s6 = class extends d {
  constructor(e2) {
    super(e2), this.doNotLocateOnRestrictedElements = null;
  }
  clone() {
    return new s6({ doNotLocateOnRestrictedElements: this.doNotLocateOnRestrictedElements, ...this.cloneProperties() });
  }
};
e([y({ type: Boolean, json: { write: true } })], c15.prototype, "doNotLocateOnRestrictedElements", void 0), c15 = s6 = e([c("esri.rest.support.NetworkFeatureSet")], c15);
var p7 = c15;

// node_modules/@arcgis/core/rest/support/NetworkUrl.js
var p8 = class extends i2(f) {
  constructor(o8) {
    super(o8), this.doNotLocateOnRestrictedElements = null, this.url = null;
  }
};
e([y({ type: Boolean, json: { write: true } })], p8.prototype, "doNotLocateOnRestrictedElements", void 0), e([y({ type: String, json: { write: true } })], p8.prototype, "url", void 0), p8 = e([c("esri.rest.support.NetworkUrl")], p8);
var c16 = p8;

// node_modules/@arcgis/core/rest/support/RouteParameters.js
var N2;
var P = N2 = class extends i2(f) {
  constructor(t4) {
    super(t4), this.accumulateAttributes = null, this.apiKey = null, this.attributeParameterValues = null, this.directionsLanguage = null, this.directionsLengthUnits = null, this.directionsOutputType = null, this.directionsStyleName = null, this.directionsTimeAttribute = null, this.findBestSequence = null, this.geometryPrecision = null, this.geometryPrecisionM = null, this.geometryPrecisionZ = null, this.ignoreInvalidLocations = null, this.impedanceAttribute = null, this.outputGeometryPrecision = null, this.outputGeometryPrecisionUnits = null, this.outputLines = "true-shape", this.outSpatialReference = null, this.overrides = null, this.pointBarriers = null, this.polygonBarriers = null, this.polylineBarriers = null, this.preserveFirstStop = null, this.preserveLastStop = null, this.preserveObjectID = null, this.restrictionAttributes = null, this.restrictUTurns = null, this.returnBarriers = false, this.returnDirections = false, this.returnPolygonBarriers = false, this.returnPolylineBarriers = false, this.returnRoutes = true, this.returnStops = false, this.returnTraversedEdges = null, this.returnTraversedJunctions = null, this.returnTraversedTurns = null, this.returnZ = true, this.startTime = null, this.startTimeIsUTC = true, this.stops = null, this.timeWindowsAreUTC = null, this.travelMode = null, this.useHierarchy = null, this.useTimeWindows = null;
  }
  static from(t4) {
    return v(N2, t4);
  }
  readAccumulateAttributes(t4) {
    return null == t4 ? null : t4.map((t5) => U.fromJSON(t5));
  }
  writeAccumulateAttributes(t4, e2, r3) {
    (t4 == null ? void 0 : t4.length) && (e2[r3] = t4.map((t5) => U.toJSON(t5)));
  }
  writePointBarriers(t4, e2, r3) {
    D2(t4, e2, r3);
  }
  writePolygonBarrier(t4, e2, r3) {
    D2(t4, e2, r3);
  }
  writePolylineBarrier(t4, e2, r3) {
    D2(t4, e2, r3);
  }
  readRestrictionAttributes(t4) {
    return null == t4 ? null : t4.map((t5) => D.fromJSON(t5));
  }
  writeRestrictionAttributes(t4, e2, r3) {
    (t4 == null ? void 0 : t4.length) && (e2[r3] = t4.map((t5) => D.toJSON(t5)));
  }
  readStartTime(t4, e2) {
    const { startTime: r3 } = e2;
    return null == r3 ? null : "now" === r3 ? "now" : new Date(r3);
  }
  writeStartTime(t4, e2) {
    null != t4 && (e2.startTime = "now" === t4 ? "now" : t4.getTime());
  }
  readStops(t4, e2) {
    return C2(e2.stops);
  }
  writeStops(t4, e2, r3) {
    D2(t4, e2, r3);
  }
};
e([y({ type: [String], json: { name: "accumulateAttributeNames", write: true } })], P.prototype, "accumulateAttributes", void 0), e([o3("accumulateAttributes")], P.prototype, "readAccumulateAttributes", null), e([r("accumulateAttributes")], P.prototype, "writeAccumulateAttributes", null), e([y(t3)], P.prototype, "apiKey", void 0), e([y({ json: { write: true } })], P.prototype, "attributeParameterValues", void 0), e([y({ type: String, json: { write: true } })], P.prototype, "directionsLanguage", void 0), e([o4(r2)], P.prototype, "directionsLengthUnits", void 0), e([o4(a2)], P.prototype, "directionsOutputType", void 0), e([o4(k3)], P.prototype, "directionsStyleName", void 0), e([o4(y4, { name: "directionsTimeAttributeName", ignoreUnknown: false })], P.prototype, "directionsTimeAttribute", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "findBestSequence", void 0), e([y({ type: Number, json: { write: true } })], P.prototype, "geometryPrecision", void 0), e([y({ type: Number, json: { write: true } })], P.prototype, "geometryPrecisionM", void 0), e([y({ type: Number, json: { write: true } })], P.prototype, "geometryPrecisionZ", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "ignoreInvalidLocations", void 0), e([o4(U, { name: "impedanceAttributeName", ignoreUnknown: false })], P.prototype, "impedanceAttribute", void 0), e([y({ type: Number, json: { write: true } })], P.prototype, "outputGeometryPrecision", void 0), e([o4(i4)], P.prototype, "outputGeometryPrecisionUnits", void 0), e([o4(o6)], P.prototype, "outputLines", void 0), e([y({ type: f2, json: { name: "outSR", write: true } })], P.prototype, "outSpatialReference", void 0), e([y({ json: { write: true } })], P.prototype, "overrides", void 0), e([y({ json: { name: "barriers", write: true } })], P.prototype, "pointBarriers", void 0), e([r("pointBarriers")], P.prototype, "writePointBarriers", null), e([y({ json: { write: true } })], P.prototype, "polygonBarriers", void 0), e([r("polygonBarriers")], P.prototype, "writePolygonBarrier", null), e([y({ json: { write: true } })], P.prototype, "polylineBarriers", void 0), e([r("polylineBarriers")], P.prototype, "writePolylineBarrier", null), e([y({ type: Boolean, json: { write: true } })], P.prototype, "preserveFirstStop", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "preserveLastStop", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "preserveObjectID", void 0), e([y({ type: [String], json: { name: "restrictionAttributeNames", write: true } })], P.prototype, "restrictionAttributes", void 0), e([o3("restrictionAttributes")], P.prototype, "readRestrictionAttributes", null), e([r("restrictionAttributes")], P.prototype, "writeRestrictionAttributes", null), e([o4(l)], P.prototype, "restrictUTurns", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "returnBarriers", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "returnDirections", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "returnPolygonBarriers", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "returnPolylineBarriers", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "returnRoutes", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "returnStops", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "returnTraversedEdges", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "returnTraversedJunctions", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "returnTraversedTurns", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "returnZ", void 0), e([y({ type: Date, json: { type: Number, write: true } })], P.prototype, "startTime", void 0), e([o3("startTime")], P.prototype, "readStartTime", null), e([r("startTime")], P.prototype, "writeStartTime", null), e([y({ type: Boolean, json: { write: true } })], P.prototype, "startTimeIsUTC", void 0), e([y({ json: { write: true } })], P.prototype, "stops", void 0), e([o3("stops")], P.prototype, "readStops", null), e([r("stops")], P.prototype, "writeStops", null), e([y({ type: Boolean, json: { write: true } })], P.prototype, "timeWindowsAreUTC", void 0), e([y({ type: j5, json: { write: true } })], P.prototype, "travelMode", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "useHierarchy", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "useTimeWindows", void 0), P = N2 = e([c("esri.rest.support.RouteParameters")], P);
var O2 = P;
function U2(t4) {
  return t4 && "type" in t4;
}
function J(t4) {
  return t4 && "features" in t4 && "doNotLocateOnRestrictedElements" in t4;
}
function L(t4) {
  return t4 && "url" in t4;
}
function R3(t4) {
  return t4 && "features" in t4;
}
function C2(t4) {
  return U2(t4) ? c14.fromJSON(t4) : L(t4) ? c16.fromJSON(t4) : J(t4) ? p7.fromJSON(t4) : R3(t4) ? d.fromJSON(t4) : null;
}
function D2(t4, e2, o8) {
  null != t4 && (e2[o8] = V.isCollection(t4) ? { features: t4.toArray().map((t5) => t5.toJSON()) } : t4.toJSON());
}

// node_modules/@arcgis/core/layers/RouteLayer.js
function z(e2) {
  return e2.length ? e2 : null;
}
function H(e2) {
  switch (e2) {
    case "esriGeometryPoint":
      return { type: "esriSMS", style: "esriSMSCircle", size: 12, color: [0, 0, 0, 0], outline: H("esriGeometryPolyline") };
    case "esriGeometryPolyline":
      return { type: "esriSLS", style: "esriSLSSolid", width: 1, color: [0, 0, 0, 0] };
    case "esriGeometryPolygon":
      return { type: "esriSFS", style: "esriSFSNull", outline: H("esriGeometryPolyline") };
  }
}
function K(e2) {
  return "layers" in e2;
}
function Q(e2) {
  return "esri.rest.support.FeatureSet" === e2.declaredClass;
}
function Y(e2) {
  return "esri.rest.support.NetworkFeatureSet" === e2.declaredClass;
}
function Z(e2, t4, r3) {
  var _a, _b, _c, _d, _e, _f;
  const o8 = (_a = t4.networkDataset) == null ? void 0 : _a.networkAttributes, i9 = (o8 == null ? void 0 : o8.filter(({ usageType: e3 }) => "cost" === e3)) ?? [], s7 = r3.travelMode ?? t4.defaultTravelMode;
  if (null == s7)
    return void ue.warn("route-layer:missing-travel-mode", "The routing service must have a default travel mode or one must be specified in the route parameter.");
  const { timeAttributeName: n6, distanceAttributeName: a7 } = s7, u7 = i9.find(({ name: e3 }) => e3 === n6), p9 = i9.find(({ name: e3 }) => e3 === a7), c17 = ((_b = r3.travelMode) == null ? void 0 : _b.impedanceAttributeName) ?? r3.impedanceAttribute ?? t4.impedance, m10 = u7 == null ? void 0 : u7.units, y6 = p9 == null ? void 0 : p9.units;
  if (!m10 || !y6)
    throw new s3("routelayer:unknown-impedance-units", "the units of either the distance or time impedance are unknown");
  const f6 = r3.directionsLanguage ?? t4.directionsLanguage, d3 = r3.accumulateAttributes ?? t4.accumulateAttributeNames ?? [], h = new Set(i9.filter(({ name: e3 }) => e3 === n6 || e3 === a7 || e3 === c17 || null != e3 && d3.includes(e3)).map(({ name: e3 }) => e3)), w2 = (e3) => {
    for (const t5 in e3)
      h.has(t5) || delete e3[t5];
  };
  for (const l6 of e2.pointBarriers)
    null != l6.costs && (l6.addedCost = l6.costs[c17] ?? 0, w2(l6.costs));
  for (const l6 of e2.polygonBarriers)
    null != l6.costs && (l6.scaleFactor = l6.costs[c17] ?? 1, w2(l6.costs));
  for (const l6 of e2.polylineBarriers)
    null != l6.costs && (l6.scaleFactor = l6.costs[c17] ?? 1, w2(l6.costs));
  const { routeInfo: S5 } = e2, { findBestSequence: g, preserveFirstStop: b5, preserveLastStop: v4, startTimeIsUTC: B, timeWindowsAreUTC: P2 } = r3;
  S5.analysisSettings = new c4({ accumulateAttributes: d3, directionsLanguage: f6, findBestSequence: g, preserveFirstStop: b5, preserveLastStop: v4, startTimeIsUTC: B, timeWindowsAreUTC: P2, travelMode: s7 }), S5.totalDuration = X(((_c = S5.totalCosts) == null ? void 0 : _c[n6]) ?? 0, m10), S5.totalDistance = ee(((_d = S5.totalCosts) == null ? void 0 : _d[a7]) ?? 0, y6), S5.totalLateDuration = X(((_e = S5.totalViolations) == null ? void 0 : _e[n6]) ?? 0, m10), S5.totalWaitDuration = X(((_f = S5.totalWait) == null ? void 0 : _f[n6]) ?? 0, m10), null != S5.totalCosts && w2(S5.totalCosts), null != S5.totalViolations && w2(S5.totalViolations), null != S5.totalWait && w2(S5.totalWait);
  for (const l6 of e2.stops)
    null != l6.serviceCosts && (l6.serviceDuration = X(l6.serviceCosts[n6] ?? 0, m10), l6.serviceDistance = ee(l6.serviceCosts[a7] ?? 0, y6), w2(l6.serviceCosts)), null != l6.cumulativeCosts && (l6.cumulativeDuration = X(l6.cumulativeCosts[n6] ?? 0, m10), l6.cumulativeDistance = ee(l6.cumulativeCosts[a7] ?? 0, y6), w2(l6.cumulativeCosts)), null != l6.violations && (l6.lateDuration = X(l6.violations[n6] ?? 0, m10), w2(l6.violations)), null != l6.wait && (l6.waitDuration = X(l6.wait[n6] ?? 0, m10), w2(l6.wait));
}
async function $(e2) {
  const t4 = f2.WGS84;
  return await F(e2.spatialReference, t4), b2(e2, t4);
}
function X(e2, t4) {
  switch (t4) {
    case "seconds":
      return e2 / 60;
    case "hours":
      return 60 * e2;
    case "days":
      return 60 * e2 * 24;
    default:
      return e2;
  }
}
function ee(e2, t4) {
  return "decimal-degrees" === t4 || "points" === t4 || "unknown" === t4 ? e2 : j2(e2, t4, "meters");
}
function te(e2) {
  const { attributes: t4, geometry: r3, popupTemplate: o8, symbol: i9 } = e2.toGraphic().toJSON();
  return { attributes: t4, geometry: r3, popupInfo: o8, symbol: i9 };
}
var re = V.ofType(m4);
var oe = V.ofType(c3);
var ie = V.ofType(C);
var se = V.ofType(T);
var ne = V.ofType(j6);
var le = V.ofType(O);
var ae = "esri.layers.RouteLayer";
var ue = s2.getLogger(ae);
var pe = class extends a(t2(u2(j4(m2(b3))))) {
  constructor(e2) {
    super(e2), this._cachedServiceDescription = null, this._featureCollection = null, this._type = "Feature Collection", this.defaultSymbols = new n3(), this.directionLines = null, this.directionPoints = null, this.featureCollectionType = "route", this.legendEnabled = false, this.maxScale = 0, this.minScale = 0, this.pointBarriers = new ie(), this.polygonBarriers = new se(), this.polylineBarriers = new ne(), this.routeInfo = null, this.spatialReference = f2.WGS84, this.stops = new le(), this.type = "route";
    const t4 = () => {
      this._setStopSymbol(this.stops);
    };
    this.addHandles(v2(() => this.stops, "change", t4, { sync: true, onListenerAdd: t4 }));
  }
  writeFeatureCollectionWebmap(e2, t4, r3, o8) {
    const i9 = [this._writePolygonBarriers(), this._writePolylineBarriers(), this._writePointBarriers(), this._writeRouteInfo(), this._writeDirectionLines(), this._writeDirectionPoints(), this._writeStops()].filter((e3) => !!e3), s7 = i9.map((e3, t5) => t5), n6 = "web-map" === o8.origin ? "featureCollection.layers" : "layers";
    o(n6, i9, t4), t4.opacity = this.opacity, t4.visibility = this.visible, t4.visibleLayers = s7;
  }
  readDirectionLines(e2, t4) {
    return this._getNetworkFeatures(t4, "DirectionLines", (e3) => m4.fromGraphic(e3));
  }
  readDirectionPoints(e2, t4) {
    return this._getNetworkFeatures(t4, "DirectionPoints", (e3) => c3.fromGraphic(e3));
  }
  get fullExtent() {
    var _a;
    const e2 = new M({ xmin: -180, ymin: -90, xmax: 180, ymax: 90, spatialReference: f2.WGS84 });
    if (null != ((_a = this.routeInfo) == null ? void 0 : _a.geometry))
      return this.routeInfo.geometry.extent ?? e2;
    if (null == this.stops)
      return e2;
    const t4 = this.stops.filter((e3) => null != e3.geometry);
    if (t4.length < 2)
      return e2;
    const { spatialReference: r3 } = t4.at(0).geometry;
    if (null == r3)
      return e2;
    const o8 = t4.toArray().map((e3) => {
      const t5 = e3.geometry;
      return [t5.x, t5.y];
    });
    return new u({ points: o8, spatialReference: r3 }).extent;
  }
  readMaxScale(e2, t4) {
    var _a;
    const r3 = K(t4) ? t4.layers : (_a = t4.featureCollection) == null ? void 0 : _a.layers, o8 = r3 == null ? void 0 : r3.find((e3) => null != e3.layerDefinition.maxScale);
    return (o8 == null ? void 0 : o8.layerDefinition.maxScale) ?? 0;
  }
  readMinScale(e2, t4) {
    var _a;
    const r3 = K(t4) ? t4.layers : (_a = t4.featureCollection) == null ? void 0 : _a.layers, o8 = r3 == null ? void 0 : r3.find((e3) => null != e3.layerDefinition.minScale);
    return (o8 == null ? void 0 : o8.layerDefinition.minScale) ?? 0;
  }
  readPointBarriers(e2, t4) {
    return this._getNetworkFeatures(t4, "Barriers", (e3) => C.fromGraphic(e3));
  }
  readPolygonBarriers(e2, t4) {
    return this._getNetworkFeatures(t4, "PolygonBarriers", (e3) => T.fromGraphic(e3));
  }
  readPolylineBarriers(e2, t4) {
    return this._getNetworkFeatures(t4, "PolylineBarriers", (e3) => j6.fromGraphic(e3));
  }
  readRouteInfo(e2, t4) {
    const r3 = this._getNetworkFeatures(t4, "RouteInfo", (e3) => S4.fromGraphic(e3));
    return r3.length > 0 ? r3.at(0) : null;
  }
  readSpatialReference(e2, t4) {
    var _a, _b;
    const r3 = K(t4) ? t4.layers : (_a = t4.featureCollection) == null ? void 0 : _a.layers;
    if (!(r3 == null ? void 0 : r3.length))
      return f2.WGS84;
    const { layerDefinition: o8, featureSet: i9 } = r3[0], s7 = i9.features[0], n6 = ((_b = s7 == null ? void 0 : s7.geometry) == null ? void 0 : _b.spatialReference) ?? i9.spatialReference ?? o8.spatialReference ?? o8.extent.spatialReference ?? N;
    return f2.fromJSON(n6);
  }
  readStops(e2, t4) {
    return this._getNetworkFeatures(t4, "Stops", (e3) => O.fromGraphic(e3), (e3) => this._setStopSymbol(e3));
  }
  get title() {
    var _a;
    return null != ((_a = this.routeInfo) == null ? void 0 : _a.name) ? this.routeInfo.name : "Route";
  }
  set title(e2) {
    this._overrideIfSome("title", e2);
  }
  get url() {
    return s.routeServiceUrl;
  }
  set url(e2) {
    null != e2 ? this._set("url", y2(e2, ue)) : this._set("url", s.routeServiceUrl);
  }
  load(e2) {
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Feature Collection"] }, e2)), Promise.resolve(this);
  }
  removeAll() {
    this.removeResult(), this.pointBarriers.removeAll(), this.polygonBarriers.removeAll(), this.polylineBarriers.removeAll(), this.stops.removeAll();
  }
  removeResult() {
    null != this.directionLines && (this.directionLines.removeAll(), this._set("directionLines", null)), null != this.directionPoints && (this.directionPoints.removeAll(), this._set("directionPoints", null)), null != this.routeInfo && this._set("routeInfo", null);
  }
  async save() {
    await this.load();
    const { fullExtent: e2, portalItem: t4 } = this;
    if (!t4)
      throw new s3("routelayer:portal-item-not-set", "save() requires to the layer to have a portal item");
    if (!t4.id)
      throw new s3("routelayer:portal-item-not-saved", "Please use saveAs() first to save the routelayer");
    if ("Feature Collection" !== t4.type)
      throw new s3("routelayer:portal-item-wrong-type", 'Portal item needs to have type "Feature Collection"');
    if (null == this.routeInfo)
      throw new s3("routelayer:route-unsolved", "save() requires a solved route");
    const { portal: r3 } = t4;
    await r3.signIn(), r3.user || await t4.reload();
    const { itemUrl: o8, itemControl: i9 } = t4;
    if ("admin" !== i9 && "update" !== i9)
      throw new s3("routelayer:insufficient-permissions", "To save this layer, you need to be the owner or an administrator of your organization");
    const s7 = { messages: [], origin: "portal-item", portal: r3, url: o8 ? I(o8) : void 0, writtenProperties: [] }, n6 = this.write(void 0, s7);
    return t4.extent = await $(e2), t4.title = this.title, await t4.update({ data: n6 }), t4;
  }
  async saveAs(e2, t4 = {}) {
    var _a;
    if (await this.load(), null == this.routeInfo)
      throw new s3("routelayer:route-unsolved", "saveAs() requires a solved route");
    const r3 = S.from(e2).clone();
    r3.extent ?? (r3.extent = await $(this.fullExtent)), r3.id = null, r3.portal ?? (r3.portal = j7.getDefault()), r3.title ?? (r3.title = this.title), r3.type = "Feature Collection", r3.typeKeywords = ["Data", "Feature Collection", f3.MULTI_LAYER, "Route Layer"];
    const { portal: o8 } = r3, i9 = { messages: [], origin: "portal-item", portal: o8, url: null, writtenProperties: [] };
    await o8.signIn();
    const s7 = t4 == null ? void 0 : t4.folder, n6 = this.write(void 0, i9);
    return await ((_a = o8.user) == null ? void 0 : _a.addItem({ item: r3, folder: s7, data: n6 })), this.portalItem = r3, i3(i9), i9.portalItem = r3, r3;
  }
  async solve(e2, t4) {
    const r3 = (e2 == null ? void 0 : e2.stops) ?? this.stops, o8 = (e2 == null ? void 0 : e2.pointBarriers) ?? z(this.pointBarriers), i9 = (e2 == null ? void 0 : e2.polylineBarriers) ?? z(this.polylineBarriers), s7 = (e2 == null ? void 0 : e2.polygonBarriers) ?? z(this.polygonBarriers);
    if (null == r3)
      throw new s3("routelayer:undefined-stops", "the route layer must have stops defined in the route parameters.");
    if ((Q(r3) || Y(r3)) && r3.features.length < 2 || V.isCollection(r3) && r3.length < 2)
      throw new s3("routelayer:insufficent-stops", "the route layer must have two or more stops to solve a route.");
    if (V.isCollection(r3))
      for (const n6 of r3)
        n6.routeName = null;
    const a7 = e2 == null ? void 0 : e2.apiKey, u7 = this.url, c17 = await this._getServiceDescription(u7, a7, t4), m10 = (e2 == null ? void 0 : e2.travelMode) ?? c17.defaultTravelMode, y6 = (e2 == null ? void 0 : e2.accumulateAttributes) ?? [];
    null != m10 && (y6.push(m10.distanceAttributeName), m10.timeAttributeName && y6.push(m10.timeAttributeName));
    const f6 = { startTime: /* @__PURE__ */ new Date() }, d3 = { accumulateAttributes: y6, directionsOutputType: "featuresets", ignoreInvalidLocations: true, pointBarriers: o8, polylineBarriers: i9, polygonBarriers: s7, preserveFirstStop: true, preserveLastStop: true, returnBarriers: !!o8, returnDirections: true, returnPolygonBarriers: !!s7, returnPolylineBarriers: !!i9, returnRoutes: true, returnStops: true, stops: r3 }, h = e2 ? O2.from(e2) : new O2();
    for (const n6 in f6)
      null == h[n6] && (h[n6] = f6[n6]);
    let w2;
    h.set(d3);
    try {
      w2 = await l4(u7, h, t4);
    } catch (g) {
      throw b(g) ? g : new s3("routelayer:failed-route-request", "the routing request failed", { error: g });
    }
    const S5 = this._toRouteLayerSolution(w2);
    return this._isOverridden("title") || (this.title = S5.routeInfo.name ?? "Route"), Z(S5, c17, h), S5;
  }
  update(e2) {
    const { stops: t4, directionLines: r3, directionPoints: o8, pointBarriers: i9, polylineBarriers: s7, polygonBarriers: n6, routeInfo: l6 } = e2;
    this.set({ stops: t4, pointBarriers: i9, polylineBarriers: s7, polygonBarriers: n6 }), this._set("directionLines", r3), this._set("directionPoints", o8), this._set("routeInfo", l6), null != l6.geometry && (this.spatialReference = l6.geometry.spatialReference);
  }
  _getNetworkFeatures(e2, t4, s7, l6) {
    var _a;
    const a7 = K(e2) ? e2.layers : (_a = e2.featureCollection) == null ? void 0 : _a.layers, u7 = a7 == null ? void 0 : a7.find((e3) => e3.layerDefinition.name === t4);
    if (null == u7)
      return new V();
    const { layerDefinition: p9, popupInfo: c17, featureSet: m10 } = u7, y6 = p9.drawingInfo.renderer, { features: f6 } = m10, d3 = m10.spatialReference ?? p9.spatialReference ?? p9.extent.spatialReference ?? N, h = y6 && o5(y6), w2 = f2.fromJSON(d3), S5 = f6.map((e3) => {
      const i9 = c2.fromJSON(e3);
      null != i9.geometry && null != e3.geometry && null == e3.geometry.spatialReference && (i9.geometry.spatialReference = w2);
      const n6 = s7(i9);
      return n6.symbol ?? (n6.symbol = (h == null ? void 0 : h.getSymbol(i9)) ?? this._getNetworkSymbol(t4)), n6.popupTemplate ?? (n6.popupTemplate = c17 && k2.fromJSON(c17)), n6;
    });
    return l6 && S5.some((e3) => !e3.symbol) && l6(S5), new V(S5);
  }
  _getNetworkSymbol(e2) {
    switch (e2) {
      case "Barriers":
        return this.defaultSymbols.pointBarriers;
      case "DirectionPoints":
        return this.defaultSymbols.directionPoints;
      case "DirectionLines":
        return this.defaultSymbols.directionLines;
      case "PolylineBarriers":
        return this.defaultSymbols.polylineBarriers;
      case "PolygonBarriers":
        return this.defaultSymbols.polygonBarriers;
      case "RouteInfo":
        return this.defaultSymbols.routeInfo;
      case "Stops":
        return null;
    }
  }
  async _getServiceDescription(e2, t4, r3) {
    if (null != this._cachedServiceDescription && this._cachedServiceDescription.url === e2)
      return this._cachedServiceDescription.serviceDescription;
    const o8 = await d2(e2, t4, r3);
    return this._cachedServiceDescription = { serviceDescription: o8, url: e2 }, o8;
  }
  _setStopSymbol(e2) {
    if (!e2 || 0 === e2.length)
      return;
    if (null == this.defaultSymbols.stops)
      return;
    if (e2.every(({ symbol: e3 }) => null != e3))
      return;
    const { first: t4, last: r3, middle: o8, unlocated: i9, waypoint: s7, break: n6 } = this.defaultSymbols.stops;
    if (null == this.routeInfo || 1 === e2.length)
      return void e2.forEach((i10, s8) => {
        switch (s8) {
          case 0:
            i10.symbol = t4;
            break;
          case e2.length - 1:
            i10.symbol = r3;
            break;
          default:
            i10.symbol = o8;
        }
      });
    const l6 = e2.map(({ sequence: e3 }) => e3).filter((e3) => null != e3), a7 = Math.min(...l6), u7 = Math.max(...l6);
    for (const p9 of e2)
      p9.sequence !== a7 ? p9.sequence !== u7 ? "ok" === p9.status || "not-located-on-closest" === p9.status ? "waypoint" !== p9.locationType ? "break" !== p9.locationType ? p9.symbol = o8 : p9.symbol = n6 : p9.symbol = s7 : p9.symbol = i9 : p9.symbol = r3 : p9.symbol = t4;
  }
  _toRouteLayerSolution(e2) {
    var _a, _b, _c, _d, _e, _f, _g;
    const t4 = (_a = e2.routeResults[0].stops) == null ? void 0 : _a.map((e3) => O.fromJSON(e3.toJSON()));
    this._setStopSymbol(t4);
    const r3 = new le(t4), o8 = new se((_b = e2.polygonBarriers) == null ? void 0 : _b.map((e3) => {
      const t5 = T.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.polygonBarriers, t5;
    })), i9 = new ne((_c = e2.polylineBarriers) == null ? void 0 : _c.map((e3) => {
      const t5 = j6.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.polylineBarriers, t5;
    })), s7 = new ie((_d = e2.pointBarriers) == null ? void 0 : _d.map((e3) => {
      const t5 = C.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.pointBarriers, t5;
    })), n6 = (_e = e2.routeResults[0].route) == null ? void 0 : _e.toJSON(), l6 = S4.fromJSON(n6);
    l6.symbol = this.defaultSymbols.routeInfo;
    const a7 = new oe((_f = e2.routeResults[0].directionPoints) == null ? void 0 : _f.features.map((e3) => {
      const t5 = c3.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.directionPoints, t5;
    }));
    return { directionLines: new re((_g = e2.routeResults[0].directionLines) == null ? void 0 : _g.features.map((e3) => {
      const t5 = m4.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.directionLines, t5;
    })), directionPoints: a7, pointBarriers: s7, polygonBarriers: o8, polylineBarriers: i9, routeInfo: l6, stops: r3 };
  }
  _writeDirectionLines() {
    return this._writeNetworkFeatures(this.directionLines, this.defaultSymbols.directionLines, "esriGeometryPolyline", m4.fields, m4.popupInfo, "DirectionLines", "Direction Lines");
  }
  _writeDirectionPoints() {
    return this._writeNetworkFeatures(this.directionPoints, this.defaultSymbols.directionPoints, "esriGeometryPoint", c3.fields, c3.popupInfo, "DirectionPoints", "Direction Points");
  }
  _writeNetworkFeatures(e2, t4, r3, o8, i9, s7, n6) {
    if (!(e2 == null ? void 0 : e2.length))
      return null;
    const l6 = this.spatialReference.toJSON(), { fullExtent: a7, maxScale: u7, minScale: p9 } = this;
    return { featureSet: { features: e2.toArray().map((e3) => te(e3)), geometryType: r3, spatialReference: l6 }, layerDefinition: { capabilities: "Query,Update,Editing", drawingInfo: { renderer: { type: "simple", symbol: null != t4 ? t4.toJSON() : H(r3) } }, extent: a7.toJSON(), fields: o8, geometryType: r3, hasM: false, hasZ: false, maxScale: u7, minScale: p9, name: s7, objectIdField: "ObjectID", spatialReference: l6, title: n6, type: "Feature Layer", typeIdField: "" }, popupInfo: i9 };
  }
  _writePointBarriers() {
    return this._writeNetworkFeatures(this.pointBarriers, this.defaultSymbols.pointBarriers, "esriGeometryPoint", C.fields, C.popupInfo, "Barriers", "Point Barriers");
  }
  _writePolygonBarriers() {
    return this._writeNetworkFeatures(this.polygonBarriers, this.defaultSymbols.polygonBarriers, "esriGeometryPolygon", T.fields, T.popupInfo, "PolygonBarriers", "Polygon Barriers");
  }
  _writePolylineBarriers() {
    return this._writeNetworkFeatures(this.polylineBarriers, this.defaultSymbols.polylineBarriers, "esriGeometryPolyline", j6.fields, j6.popupInfo, "PolylineBarriers", "Line Barriers");
  }
  _writeRouteInfo() {
    return this._writeNetworkFeatures(null != this.routeInfo ? new V([this.routeInfo]) : null, this.defaultSymbols.routeInfo, "esriGeometryPolyline", S4.fields, S4.popupInfo, "RouteInfo", "Route Details");
  }
  _writeStops() {
    var _a, _b, _c;
    const e2 = this._writeNetworkFeatures(this.stops, null, "esriGeometryPoint", O.fields, O.popupInfo, "Stops", "Stops");
    if (null == e2)
      return null;
    const { stops: t4 } = this.defaultSymbols, r3 = (_a = t4 == null ? void 0 : t4.first) == null ? void 0 : _a.toJSON(), o8 = (_b = t4 == null ? void 0 : t4.middle) == null ? void 0 : _b.toJSON(), i9 = (_c = t4 == null ? void 0 : t4.last) == null ? void 0 : _c.toJSON();
    return e2.layerDefinition.drawingInfo.renderer = { type: "uniqueValue", field1: "Sequence", defaultSymbol: o8, uniqueValueInfos: [{ value: "1", symbol: r3, label: "First Stop" }, { value: `${this.stops.length}`, symbol: i9, label: "Last Stop" }] }, e2;
  }
};
e([y({ readOnly: true, json: { read: false, origins: { "portal-item": { write: { allowNull: true, ignoreOrigin: true } }, "web-map": { write: { overridePolicy() {
  return { allowNull: true, ignoreOrigin: null == this.portalItem };
} } } } } })], pe.prototype, "_featureCollection", void 0), e([r(["web-map", "portal-item"], "_featureCollection")], pe.prototype, "writeFeatureCollectionWebmap", null), e([y({ readOnly: true, json: { read: false, origins: { "web-map": { write: { target: "type", overridePolicy() {
  return { ignoreOrigin: null != this.portalItem };
} } } } } })], pe.prototype, "_type", void 0), e([y({ nonNullable: true, type: n3 })], pe.prototype, "defaultSymbols", void 0), e([y({ readOnly: true })], pe.prototype, "directionLines", void 0), e([o3(["web-map", "portal-item"], "directionLines", ["layers", "featureCollection.layers"])], pe.prototype, "readDirectionLines", null), e([y({ readOnly: true })], pe.prototype, "directionPoints", void 0), e([o3(["web-map", "portal-item"], "directionPoints", ["layers", "featureCollection.layers"])], pe.prototype, "readDirectionPoints", null), e([y({ readOnly: true, json: { read: false, origins: { "web-map": { write: { ignoreOrigin: true } } } } })], pe.prototype, "featureCollectionType", void 0), e([y({ readOnly: true })], pe.prototype, "fullExtent", null), e([y({ json: { origins: { "web-map": { name: "featureCollection.showLegend" } }, write: true } })], pe.prototype, "legendEnabled", void 0), e([y({ type: ["show", "hide"] })], pe.prototype, "listMode", void 0), e([y({ type: Number, nonNullable: true, json: { write: false } })], pe.prototype, "maxScale", void 0), e([o3(["web-map", "portal-item"], "maxScale", ["layers", "featureCollection.layers"])], pe.prototype, "readMaxScale", null), e([y({ type: Number, nonNullable: true, json: { write: false } })], pe.prototype, "minScale", void 0), e([o3(["web-map", "portal-item"], "minScale", ["layers", "featureCollection.layers"])], pe.prototype, "readMinScale", null), e([y({ type: ["ArcGISFeatureLayer"], value: "ArcGISFeatureLayer" })], pe.prototype, "operationalLayerType", void 0), e([y({ nonNullable: true, type: V.ofType(C) })], pe.prototype, "pointBarriers", void 0), e([o3(["web-map", "portal-item"], "pointBarriers", ["layers", "featureCollection.layers"])], pe.prototype, "readPointBarriers", null), e([y({ nonNullable: true, type: V.ofType(T) })], pe.prototype, "polygonBarriers", void 0), e([o3(["web-map", "portal-item"], "polygonBarriers", ["layers", "featureCollection.layers"])], pe.prototype, "readPolygonBarriers", null), e([y({ nonNullable: true, type: V.ofType(j6) })], pe.prototype, "polylineBarriers", void 0), e([o3(["web-map", "portal-item"], "polylineBarriers", ["layers", "featureCollection.layers"])], pe.prototype, "readPolylineBarriers", null), e([y({ readOnly: true })], pe.prototype, "routeInfo", void 0), e([o3(["web-map", "portal-item"], "routeInfo", ["layers", "featureCollection.layers"])], pe.prototype, "readRouteInfo", null), e([y({ type: f2 })], pe.prototype, "spatialReference", void 0), e([o3(["web-map", "portal-item"], "spatialReference", ["layers", "featureCollection.layers"])], pe.prototype, "readSpatialReference", null), e([y({ nonNullable: true, type: V.ofType(O) })], pe.prototype, "stops", void 0), e([o3(["web-map", "portal-item"], "stops", ["layers", "featureCollection.layers"])], pe.prototype, "readStops", null), e([y()], pe.prototype, "title", null), e([y({ readOnly: true, json: { read: false } })], pe.prototype, "type", void 0), e([y()], pe.prototype, "url", null), pe = e([c(ae)], pe);
var ce = pe;
export {
  ce as default
};
//# sourceMappingURL=RouteLayer-CZ6NFOPM.js.map
