import {
  B,
  ae
} from "./chunk-TSXG5IIW.js";
import "./chunk-CPGPJ736.js";
import {
  E,
  N
} from "./chunk-O5L3AGFQ.js";
import {
  p
} from "./chunk-4WCNO4FQ.js";
import "./chunk-7SYCRLSC.js";
import {
  m
} from "./chunk-A427XTHR.js";
import "./chunk-QAQNFI3S.js";
import {
  W
} from "./chunk-EBN2STNO.js";
import "./chunk-3ON6HO7Q.js";
import "./chunk-KMTPMPRR.js";
import "./chunk-K4NVR6KM.js";
import {
  j,
  x
} from "./chunk-57KRYRCY.js";
import {
  rt,
  st
} from "./chunk-747B2TEO.js";
import "./chunk-4NEWABLH.js";
import "./chunk-FW2Y26A2.js";
import "./chunk-5WG7GACT.js";
import "./chunk-MMRDHWTI.js";
import "./chunk-XA2SWBL3.js";
import "./chunk-NYTJIWNN.js";
import "./chunk-7Y57Y6IH.js";
import "./chunk-WND35VNG.js";
import "./chunk-PUYNEESA.js";
import "./chunk-GXVWD6F2.js";
import "./chunk-W4QVNWBV.js";
import "./chunk-XN6LAULS.js";
import {
  Z
} from "./chunk-CKGVKMVG.js";
import "./chunk-CSWPLQ7Q.js";
import "./chunk-KWSMYM7P.js";
import "./chunk-RP5SAUAF.js";
import "./chunk-6BFXMZEZ.js";
import "./chunk-AMSVADDY.js";
import "./chunk-GAJBN4TM.js";
import "./chunk-LOGPPZUD.js";
import "./chunk-HYU6N3H3.js";
import "./chunk-EC5POYCL.js";
import "./chunk-X5VYGREB.js";
import "./chunk-RHT6WWRD.js";
import "./chunk-EUGXS5RE.js";
import "./chunk-IRNKV32L.js";
import "./chunk-KVSZM7R6.js";
import "./chunk-KX2F2CD3.js";
import "./chunk-UNONG753.js";
import "./chunk-OFRZSMZB.js";
import "./chunk-IATM3RCE.js";
import "./chunk-BEALJUHO.js";
import "./chunk-GRHSIT57.js";
import "./chunk-PJQIAD5D.js";
import "./chunk-GAWSWBHO.js";
import "./chunk-SZAJDZCO.js";
import "./chunk-3DSKWYU4.js";
import "./chunk-ZZYUEH57.js";
import "./chunk-VTWXDFFD.js";
import "./chunk-IPCIO3PX.js";
import "./chunk-EIY2DYTV.js";
import "./chunk-F6MD5VOH.js";
import "./chunk-V2RPSCV3.js";
import "./chunk-AOJ6OCPK.js";
import "./chunk-LMT5JII2.js";
import "./chunk-A43TI6AT.js";
import "./chunk-2D3PORS4.js";
import "./chunk-4HKQSEUR.js";
import "./chunk-V3U4F2NL.js";
import "./chunk-ZB6PGKG5.js";
import "./chunk-OIIDE5GZ.js";
import "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import "./chunk-TBSVVR6M.js";
import {
  d
} from "./chunk-6TJWLWLO.js";
import "./chunk-H7BKONNV.js";
import "./chunk-K6C6RVSV.js";
import {
  i
} from "./chunk-KBJ5Z4R2.js";
import "./chunk-JUZJCTW2.js";
import "./chunk-423VNHLR.js";
import "./chunk-FN47E7YK.js";
import "./chunk-XZS3Q5K4.js";
import "./chunk-WZPOQGKL.js";
import "./chunk-CCXEAKIM.js";
import "./chunk-Y5D433JZ.js";
import "./chunk-QNOCEWCR.js";
import "./chunk-WURET5CW.js";
import "./chunk-QWPLZ3QH.js";
import {
  d2
} from "./chunk-HLGIRLYQ.js";
import "./chunk-N2K4VRZH.js";
import "./chunk-WL4VPODY.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import "./chunk-LXXF7K7W.js";
import "./chunk-SBW6NNVI.js";
import "./chunk-62CXLI6S.js";
import {
  b,
  s as s3
} from "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import "./chunk-4V6374PV.js";
import "./chunk-A34O4XB5.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/graphics/sources/WFSSourceWorker.js
var F = class {
  constructor() {
    this._queryEngine = null, this._customParameters = null;
  }
  destroy() {
    var _a;
    (_a = this._queryEngine) == null ? void 0 : _a.destroy(), this._queryEngine = null;
  }
  async load(e, r) {
    const { getFeatureUrl: a, getFeatureOutputFormat: i2, fields: o, geometryType: n, featureType: l, objectIdField: c, customParameters: m2 } = e, { spatialReference: y, getFeatureSpatialReference: g } = ae(a, l, e.spatialReference);
    this._featureType = l, this._customParameters = m2, this._getFeatureUrl = a, this._getFeatureOutputFormat = i2, this._getFeatureSpatialReference = g;
    try {
      await x(g, y);
    } catch {
      throw new s2("unsupported-projection", "Projection not supported", { inSpatialReference: g, outSpatialReference: y });
    }
    s3(r);
    const F2 = Z.fromLayerJSON({ fields: o, dateFieldsTimeReference: o.some((e2) => "esriFieldTypeDate" === e2.type) ? { timeZoneIANA: i } : null }), w = await this._snapshotFeatures({ fieldsIndex: F2, geometryType: n, objectIdField: c, spatialReference: y }, r.signal);
    return this._queryEngine = new W({ fieldsIndex: F2, geometryType: n, hasM: false, hasZ: false, objectIdField: c, spatialReference: y, timeInfo: null, featureStore: new m({ geometryType: n, hasM: false, hasZ: false }) }), this._queryEngine.featureStore.addMany(w), { extent: (await this._queryEngine.fetchRecomputedExtents()).fullExtent };
  }
  async applyEdits() {
    throw new s2("wfs-source:editing-not-supported", "applyEdits() is not supported on WFSLayer");
  }
  async queryFeatures(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQuery(e, t.signal);
  }
  async queryFeatureCount(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e, t.signal);
  }
  async queryObjectIds(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForIds(e, t.signal);
  }
  async queryExtent(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e, t.signal);
  }
  async querySnapping(e, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForSnapping(e, t.signal);
  }
  async refresh(s4) {
    var _a;
    return this._customParameters = s4, (_a = this._snapshotTask) == null ? void 0 : _a.abort(), this._snapshotTask = d((e) => this._snapshotFeatures(this._queryEngine, e)), this._snapshotTask.promise.then((e) => {
      this._queryEngine.featureStore.clear(), e && this._queryEngine.featureStore.addMany(e);
    }, (e) => {
      this._queryEngine.featureStore.clear(), b(e) || s.getLogger("esri.layers.WFSLayer").error(new s2("wfs-layer:getfeature-error", "An error occurred during the GetFeature request", { error: e }));
    }), await this._waitSnapshotComplete(), { extent: (await this._queryEngine.fetchRecomputedExtents()).fullExtent };
  }
  async _waitSnapshotComplete() {
    if (this._snapshotTask && !this._snapshotTask.finished) {
      try {
        await this._snapshotTask.promise;
      } catch {
      }
      return this._waitSnapshotComplete();
    }
  }
  async _snapshotFeatures({ objectIdField: e, geometryType: t, spatialReference: r, fieldsIndex: a }, u) {
    const p2 = await B(this._getFeatureUrl ?? "", this._featureType.typeName, this._getFeatureSpatialReference, this._getFeatureOutputFormat, { customParameters: this._customParameters, signal: u });
    E(p2, this._getFeatureSpatialReference.wkid), s3(u);
    const h = N(p2, { geometryType: t, hasZ: false, objectIdField: e });
    if (!d2(r, this._getFeatureSpatialReference))
      for (const s4 of h)
        null != s4.geometry && (s4.geometry = rt(j(st(s4.geometry, t, false, false), this._getFeatureSpatialReference, r)));
    let f = 1;
    for (const s4 of h) {
      const t2 = {};
      p(a, t2, s4.attributes, true), s4.attributes = t2, null == t2[e] && (s4.objectId = t2[e] = f++);
    }
    return h;
  }
};
export {
  F as default
};
//# sourceMappingURL=WFSSourceWorker-RCLF3RSU.js.map
