import {
  i as i8,
  r as r5
} from "./chunk-3XN3CFM5.js";
import {
  c as c4
} from "./chunk-DSGGSKRZ.js";
import {
  V,
  l
} from "./chunk-MUSQVDUI.js";
import {
  c as c5,
  i as i5,
  r as r3
} from "./chunk-GSATUKJ4.js";
import {
  f,
  p
} from "./chunk-TJGMKUCX.js";
import {
  G,
  R,
  k as k2,
  o as o5,
  t as t2
} from "./chunk-UMP4LYVN.js";
import {
  C as C2,
  N,
  O,
  P,
  U,
  Z,
  b as b3,
  f as f2,
  w as w3
} from "./chunk-LJAHTUH5.js";
import {
  S as S2,
  g,
  i as i3,
  s2 as s5
} from "./chunk-HR42LBYN.js";
import {
  a as a2,
  c as c3,
  i as i7,
  n as n3,
  o as o4,
  r as r4,
  s as s4
} from "./chunk-NS7I2ZSY.js";
import {
  e as e6,
  t as t5
} from "./chunk-XI27PUTI.js";
import {
  e as e5,
  t as t3
} from "./chunk-PHDOV32N.js";
import {
  E,
  S
} from "./chunk-TREPTI6V.js";
import {
  w as w2,
  x
} from "./chunk-Z26DT4RT.js";
import {
  e as e3,
  i as i4,
  o as o3
} from "./chunk-BUMLJETN.js";
import {
  a as a3
} from "./chunk-OPV4AZKI.js";
import {
  o as o2
} from "./chunk-46VITINB.js";
import {
  $,
  a,
  ae,
  b as b2,
  be,
  c as c2,
  ce,
  de,
  fe,
  ge,
  h,
  i as i2,
  je,
  ke,
  le,
  me,
  ne,
  pe,
  q,
  ue,
  ve,
  w,
  we,
  xe,
  ye
} from "./chunk-XFC7DZXI.js";
import {
  t
} from "./chunk-5WG7GACT.js";
import {
  r,
  s as s3,
  y
} from "./chunk-S6MJEC4A.js";
import {
  e
} from "./chunk-CSWPLQ7Q.js";
import {
  e as e2
} from "./chunk-GJ4KNHRS.js";
import {
  n as n2
} from "./chunk-B7TIRUHV.js";
import {
  e as e4,
  h as h2,
  i as i6,
  n
} from "./chunk-EY7PGBJG.js";
import {
  n as n4,
  t as t4
} from "./chunk-6M5DUIJQ.js";
import {
  r as r2,
  z
} from "./chunk-NDKHIQMD.js";
import {
  n as n5
} from "./chunk-3DSKWYU4.js";
import {
  o,
  u
} from "./chunk-EIY2DYTV.js";
import {
  i
} from "./chunk-MKW4ORPJ.js";
import {
  C,
  b,
  c2 as c
} from "./chunk-RFPH3ZTZ.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import {
  k
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/heuristics.js
var i9 = /* @__PURE__ */ new Map();
function t6(r13, t10, c12) {
  const { indicesPerRecord: s8, multiplier: o11, verticesPerRecord: d9 } = i9.get(r13);
  return { recordBytes: c12 * de * Uint32Array.BYTES_PER_ELEMENT, indexBytes: o11 * s8 * c12 * Uint32Array.BYTES_PER_ELEMENT, vertexBytes: o11 * d9 * c12 * t10 };
}
i9.set(E.MARKER, { multiplier: 1, indicesPerRecord: 6, verticesPerRecord: 4 }), i9.set(E.LINE, { multiplier: 1, indicesPerRecord: 24, verticesPerRecord: 8 }), i9.set(E.FILL, { multiplier: 1, indicesPerRecord: 10, verticesPerRecord: 10 }), i9.set(E.TEXT, { multiplier: 8, indicesPerRecord: 6, verticesPerRecord: 4 }), i9.set(E.LABEL, { multiplier: 8, indicesPerRecord: 6, verticesPerRecord: 4 });

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Writer.js
var t7 = 1.25;
var e7 = class {
  get length() {
    return this._pos;
  }
  constructor(t10, e11) {
    this._pos = 0;
    const r13 = e11 ? this._roundToNearest(e11, t10.BYTES_PER_ELEMENT) : 40;
    this._array = new ArrayBuffer(r13), this._buffer = new t10(this._array), this._ctor = t10, this._i16View = new Int16Array(this._array);
  }
  _roundToNearest(t10, e11) {
    const r13 = Math.round(t10);
    return 1 === e11 ? r13 : r13 + (e11 - r13 % e11);
  }
  _ensureSize(e11) {
    if (this._pos + e11 >= this._buffer.length) {
      const r13 = this._roundToNearest((this._array.byteLength + e11 * this._buffer.BYTES_PER_ELEMENT) * t7, this._buffer.BYTES_PER_ELEMENT), s8 = new ArrayBuffer(r13), i16 = new this._ctor(s8);
      i16.set(this._buffer, 0), this._array = s8, this._buffer = i16, this._i16View = new Int16Array(this._array);
    }
  }
  ensureSize(t10) {
    this._ensureSize(t10);
  }
  writeF32(t10) {
    this._ensureSize(1);
    const e11 = this._pos;
    return new Float32Array(this._array, 4 * this._pos, 1)[0] = t10, this._pos++, e11;
  }
  push(t10) {
    this._ensureSize(1);
    const e11 = this._pos;
    return this._buffer[this._pos++] = t10, e11;
  }
  writeFixed(t10) {
    this._buffer[this._pos++] = t10;
  }
  setValue(t10, e11) {
    this._buffer[t10] = e11;
  }
  i1616Add(t10, e11, r13) {
    this._i16View[2 * t10] += e11, this._i16View[2 * t10 + 1] += r13;
  }
  getValue(t10) {
    return this._buffer[t10];
  }
  incr(t10) {
    if (this._buffer.length < t10)
      throw new Error("Increment index overflows the target buffer");
    this._buffer[t10]++;
  }
  decr(t10) {
    this._buffer[t10]--;
  }
  writeRegion(t10) {
    this._ensureSize(t10.length);
    const e11 = this._pos;
    return this._buffer.set(t10, this._pos), this._pos += t10.length, e11;
  }
  writeManyFrom(t10, e11, r13) {
    this._ensureSize(r13 - e11);
    for (let s8 = e11; s8 !== r13; s8++)
      this.writeFixed(t10._buffer[s8]);
  }
  buffer() {
    const t10 = this._array.slice(0, 4 * this._pos);
    return this.destroy(), t10;
  }
  toArray() {
    return [...this._buffer];
  }
  seek(t10) {
    this._pos = t10;
  }
  destroy() {
    this._array = null, this._buffer = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/VertexDataWriter.js
var r6 = class {
  constructor(e11, r13, i16) {
    this._start = { index: 0, vertex: 0 };
    const h7 = t6(e11, r13, i16), c12 = r13 / 4;
    this.geometryType = e11, this._records = new e7(Int32Array, h7.recordBytes), this._indices = new e7(Uint32Array, h7.indexBytes), this._vertices = new e7(Uint32Array, h7.vertexBytes), this._metrics = new e7(Float32Array, 0), this._strideInt = c12;
  }
  serialize(e11) {
    const t10 = this._records.buffer(), s8 = this._indices.buffer(), r13 = this._vertices.buffer(), i16 = this._metrics.length ? this._metrics.buffer() : null, h7 = 4 * this._strideInt;
    return e11.push(t10, s8, r13), { stride: h7, records: t10, indices: s8, vertices: r13, metrics: i16 };
  }
  get strideInt() {
    return this._strideInt;
  }
  get recordCount() {
    return this._records.length / de;
  }
  get vertexCount() {
    return this._vertices.length / this._strideInt;
  }
  get indexCount() {
    return this._indices.length;
  }
  get indexWriter() {
    return this._indices;
  }
  get vertexWriter() {
    return this._vertices;
  }
  get metricWriter() {
    return this._metrics;
  }
  vertexEnsureSize(e11) {
    this._vertices.ensureSize(e11);
  }
  indexEnsureSize(e11) {
    this._indices.ensureSize(e11);
  }
  recordStart() {
    this._start.index = this._indices.length, this._start.vertex = this._vertices.length;
  }
  recordEnd(e11, t10, s8, r13, i16, h7, c12, n10) {
    this._records.push(e11), this._records.push(t10 ?? 0), this._records.push(s8), this._records.push(r13), this._records.push(i16), this._records.push(h7), this._records.push(c12), this._records.writeF32(n10);
  }
  writeIndex(e11) {
    this._indices.push(e11);
  }
  writeVertex(e11) {
    this._vertices.push(e11);
  }
  writeVertexF32(e11) {
    this._vertices.writeF32(e11);
  }
  copyLastFrom(t10, s8, r13) {
    const i16 = t10._records.length - de, h7 = t10._records.getValue(i16), c12 = t10._records.getValue(i16 + 1), n10 = t10._records.getValue(i16 + 2), _5 = t10._records.getValue(i16 + 4), d9 = t10._records.getValue(i16 + 6), o11 = t10._records.getValue(i16 + 7), u10 = this._vertices.length, l6 = (t10._start.vertex - this._vertices.length) / this._strideInt, g7 = this._indices.length, p10 = this.vertexCount;
    for (let e11 = t10._start.index; e11 !== t10._indices.length; e11++) {
      const s9 = t10._indices.getValue(e11);
      this._indices.push(s9 - l6);
    }
    for (let e11 = t10._start.vertex; e11 !== t10._vertices.length; e11++) {
      const s9 = t10._vertices.getValue(e11);
      this._vertices.push(s9);
    }
    for (let e11 = u10; e11 <= this._vertices.length; e11 += this._strideInt)
      this._vertices.i1616Add(e11, s8, r13);
    this._records.push(h7), this._records.push(c12), this._records.push(n10), this._records.push(g7), this._records.push(_5), this._records.push(p10), this._records.push(d9), this._records.push(o11);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/MeshData.js
var u2 = 1;
var c6 = 2;
var o6 = 4;
var _ = 8;
var l2 = 16;
var d = 32;
var p2 = 64;
var g2 = 128;
function x2(e11) {
  switch (e11) {
    case u2:
    case _:
    case d:
      return -1;
    case c6:
    case p2:
      return 0;
    case o6:
    case l2:
    case g2:
      return 1;
  }
}
function f3(e11) {
  switch (e11) {
    case u2:
    case c6:
    case o6:
      return -1;
    case _:
    case l2:
      return 0;
    case d:
    case p2:
    case g2:
      return 1;
  }
}
var m = u2 | _ | d;
var y2 = o6 | l2 | g2;
var w4 = u2 | c6 | o6;
var v = d | p2 | g2;
var E2 = class {
  constructor(e11, t10, r13, i16, s8, n10 = 0) {
    this._hasAggregate = false, this.hasRecords = false, this._data = { self: /* @__PURE__ */ new Map(), neighbors: new Array() }, this._version = 0, this._current = { geometryType: 0, writer: null, overlaps: 0, start: 0, insertAfter: 0, sortKey: 0, id: 0, materialKey: 0, indexStart: 0, vertStart: 0, isDotDensity: false, bufferingEnabled: false, metricBoxLenPointer: 0 }, this.hint = t10, this.tileKey = e11, this._hasAggregate = i16, this._pixelBufferEnabled = s8, this._version = n10, this._symbologyType = r13;
  }
  get hasAggregates() {
    return this._hasAggregate;
  }
  get hasPixelBufferEnabled() {
    return this._pixelBufferEnabled;
  }
  serialize(t10) {
    const r13 = [];
    return r13.push(this._serializeTileVertexData(this.tileKey, this.tileKey, this._data.self)), this._data.neighbors.forEach((i16, s8) => {
      const n10 = 1 << s8, a9 = x2(n10), u10 = f3(n10), c12 = o2(new e2(this.tileKey), a9, u10, t10), o11 = this._serializeTileVertexData(this.tileKey, c12.id, i16.vertexData);
      o11.message.bufferIds = i16.displayIds, r13.push(o11);
    }), r13;
  }
  _serializeTileVertexData(e11, t10, r13) {
    var _a, _b, _c, _d, _e;
    const i16 = new Array();
    return { message: { tileKeyOrigin: e11, tileKey: t10, data: { [E.MARKER]: (_a = r13.get(E.MARKER)) == null ? void 0 : _a.serialize(i16), [E.FILL]: (_b = r13.get(E.FILL)) == null ? void 0 : _b.serialize(i16), [E.LINE]: (_c = r13.get(E.LINE)) == null ? void 0 : _c.serialize(i16), [E.TEXT]: (_d = r13.get(E.TEXT)) == null ? void 0 : _d.serialize(i16), [E.LABEL]: (_e = r13.get(E.LABEL)) == null ? void 0 : _e.serialize(i16) }, version: this._version }, transferList: i16 };
  }
  featureStart(e11, t10) {
    this._current.insertAfter = e11, this._current.sortKey = t10;
  }
  featureEnd() {
  }
  recordStart(e11, t10, r13, i16) {
    this._current.writer = this._getVertexWriter(r13), this._current.overlaps = 0, this._current.indexStart = this._current.writer.indexCount, this._current.vertStart = this._current.writer.vertexCount, this._current.bufferingEnabled = i16, this._current.id = e11, this._current.materialKey = t10, this._current.geometryType = r13, this._current.isDotDensity = false, this._current.writer.recordStart();
  }
  recordCount() {
    return this._current.writer.recordCount;
  }
  vertexCount() {
    return this._current.writer.vertexCount;
  }
  indexCount() {
    return this._current.writer.indexCount;
  }
  vertexEnsureSize(e11) {
    this._current.writer.vertexEnsureSize(e11);
  }
  indexEnsureSize(e11) {
    this._current.writer.indexEnsureSize(e11);
  }
  vertexBounds(e11, t10, r13, i16) {
    this._current.bufferingEnabled && this._addOverlap(e11, t10, r13, i16);
  }
  vertexWrite(e11) {
    this._current.writer.writeVertex(e11);
  }
  vertexWriteF32(e11) {
    this._current.writer.writeVertexF32(e11);
  }
  vertexEnd() {
  }
  vertexWriter() {
    return this._current.writer.vertexWriter;
  }
  indexWrite(e11) {
    this._current.writer.writeIndex(e11);
  }
  indexWriter() {
    return this._current.writer.indexWriter;
  }
  metricWriter() {
    return this._current.writer.metricWriter;
  }
  metricStart(e11, t10, r13, n10, a9, h7, u10, c12) {
    this._current.writer = this._getVertexWriter(E.LABEL);
    const o11 = this._current.writer.metricWriter;
    o11.push(f(e11)), o11.push(t10), o11.push(r13), o11.push(n10), o11.push(a9), o11.push(h7), o11.push(u10), o11.push(c12), o11.push(255), this._current.metricBoxLenPointer = o11.push(0);
  }
  metricEnd() {
    const e11 = this._current.writer.metricWriter;
    0 === e11.getValue(this._current.metricBoxLenPointer) && e11.seek(e11.length - 10);
  }
  metricBoxWrite(e11, t10, r13, i16) {
    const s8 = this._current.writer.metricWriter;
    s8.incr(this._current.metricBoxLenPointer), s8.push(0), s8.push(0), s8.push(e11), s8.push(t10), s8.push(r13), s8.push(i16);
  }
  recordEnd() {
    const e11 = this._current.vertStart, r13 = this._current.writer.vertexCount - e11;
    if (!r13)
      return false;
    this.hasRecords = true;
    const i16 = this._current.indexStart, h7 = this._current.writer.indexCount - i16;
    if (this._current.writer.recordEnd(this._current.id, this._current.materialKey, this._current.insertAfter, i16, h7, e11, r13, this._current.sortKey), !this._pixelBufferEnabled || this._hasAggregate || 0 === this._current.overlaps || this._current.geometryType === E.LABEL)
      return true;
    const u10 = this._current.writer;
    for (let s8 = 0; s8 < 8; s8++) {
      const e12 = 1 << s8;
      if (!!(this._current.overlaps & e12)) {
        this._data.neighbors[s8] || (this._data.neighbors[s8] = { vertexData: /* @__PURE__ */ new Map(), displayIds: /* @__PURE__ */ new Set() });
        const r14 = this._data.neighbors[s8], i17 = this._current.geometryType;
        if (!r14.vertexData.has(i17)) {
          const e13 = R(i17, this._symbologyType).geometry, s9 = new r6(i17, e13, fe);
          r14.vertexData.set(i17, s9);
        }
        const h8 = r14.vertexData.get(this._current.geometryType), c12 = 8, o11 = 512 * -x2(e12) * c12, _5 = 512 * -f3(e12) * c12;
        h8 == null ? void 0 : h8.copyLastFrom(u10, o11, _5), r14.displayIds.add(this._current.id);
      }
    }
    return true;
  }
  _addOverlap(e11, t10, i16, s8) {
    const n10 = 255 ^ ((e11 < 0 + i16 ? y2 : e11 >= c2 - i16 ? m : y2 | m) | (t10 < 0 + s8 ? v : t10 >= c2 - s8 ? w4 : v | w4));
    this._current.overlaps |= n10;
  }
  _getVertexWriter(e11) {
    if (!this._data.self.has(e11)) {
      const t10 = this._data.self, r13 = R(e11, this._symbologyType).geometry;
      t10.set(e11, new r6(e11, r13, this.hint.records));
    }
    return this._data.self.get(e11);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/textUtils.js
function n6(n10) {
  if (null == n10)
    return [];
  const r13 = new Array(n10.length);
  for (let t10 = 0; t10 < n10.length; t10++)
    r13[t10] = n10.charCodeAt(t10);
  return r13;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/util.js
var n7 = 0;
var o7 = 100;
function t8(n10, o11, t10) {
  return n10[0] = o11[0] - t10[0], n10[1] = o11[1] - t10[1], n10;
}
function i10(n10, o11) {
  return Math.sqrt(n10 * n10 + o11 * o11);
}
function r7(n10) {
  const o11 = i10(n10[0], n10[1]);
  n10[0] /= o11, n10[1] /= o11;
}
function u3(n10, o11) {
  return i10(n10[0] - o11[0], n10[1] - o11[1]);
}
function c7(n10 = 2) {
  return 1 / Math.max(n10, 1);
}
function v2(t10, i16) {
  return [!!(t10 == null ? void 0 : t10.minScale) && i16.scaleToZoom(t10.minScale) || n7, !!(t10 == null ? void 0 : t10.maxScale) && i16.scaleToZoom(t10.maxScale) || o7];
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/bufcut.js
function e8(e11, t10, r13, i16, u10, o11, l6) {
  D = 0;
  const f9 = (i16 - r13) * o11, p10 = u10 && u10.length, c12 = p10 ? (u10[0] - r13) * o11 : f9;
  let v6, s8, h7, d9, Z4, a9 = n8(t10, r13, i16, 0, c12, o11, true);
  if (a9 && a9.next !== a9.prev) {
    if (p10 && (a9 = y3(t10, r13, i16, u10, a9, o11)), f9 > 80 * o11) {
      v6 = h7 = t10[0 + r13 * o11], s8 = d9 = t10[1 + r13 * o11];
      for (let e12 = o11; e12 < c12; e12 += o11) {
        const n10 = t10[e12 + r13 * o11], x10 = t10[e12 + 1 + r13 * o11];
        v6 = Math.min(v6, n10), s8 = Math.min(s8, x10), h7 = Math.max(h7, n10), d9 = Math.max(d9, x10);
      }
      Z4 = Math.max(h7 - v6, d9 - s8), Z4 = 0 !== Z4 ? 1 / Z4 : 0;
    }
    x3(a9, e11, o11, v6, s8, Z4, l6, 0);
  }
}
function n8(e11, n10, t10, x10, r13, i16, l6) {
  let y9;
  if (l6 === Z2(e11, n10, t10, x10, r13, i16) > 0)
    for (let o11 = x10; o11 < r13; o11 += i16)
      y9 = u4(o11 + n10 * i16, e11[o11 + n10 * i16], e11[o11 + 1 + n10 * i16], y9);
  else
    for (let o11 = r13 - i16; o11 >= x10; o11 -= i16)
      y9 = u4(o11 + n10 * i16, e11[o11 + n10 * i16], e11[o11 + 1 + n10 * i16], y9);
  return y9 && M(y9, y9.next) && (o8(y9), y9 = y9.next), y9;
}
function t9(e11, n10 = e11) {
  if (!e11)
    return e11;
  let t10, x10 = e11;
  do {
    if (t10 = false, x10.steiner || !M(x10, x10.next) && 0 !== s6(x10.prev, x10, x10.next))
      x10 = x10.next;
    else {
      if (o8(x10), x10 = n10 = x10.prev, x10 === x10.next)
        break;
      t10 = true;
    }
  } while (t10 || x10 !== n10);
  return n10;
}
function x3(e11, n10, u10, l6, y9, f9, p10, v6) {
  if (!e11)
    return;
  !v6 && f9 && (e11 = c8(e11, l6, y9, f9));
  let s8 = e11;
  for (; e11.prev !== e11.next; ) {
    const c12 = e11.prev, h7 = e11.next;
    if (f9 ? i11(e11, l6, y9, f9) : r8(e11))
      n10.push(c12.index / u10 + p10), n10.push(e11.index / u10 + p10), n10.push(h7.index / u10 + p10), o8(e11), e11 = h7.next, s8 = h7.next;
    else if ((e11 = h7) === s8) {
      v6 ? 1 === v6 ? x3(e11 = b4(e11, n10, u10, p10), n10, u10, l6, y9, f9, p10, 2) : 2 === v6 && g3(e11, n10, u10, l6, y9, f9, p10) : x3(t9(e11), n10, u10, l6, y9, f9, p10, 1);
      break;
    }
  }
}
function r8(e11) {
  const n10 = e11.prev, t10 = e11, x10 = e11.next;
  if (s6(n10, t10, x10) >= 0)
    return false;
  let r13 = e11.next.next;
  const i16 = r13;
  let u10 = 0;
  for (; r13 !== e11.prev && (0 === u10 || r13 !== i16); ) {
    if (u10++, a4(n10.x, n10.y, t10.x, t10.y, x10.x, x10.y, r13.x, r13.y) && s6(r13.prev, r13, r13.next) >= 0)
      return false;
    r13 = r13.next;
  }
  return true;
}
function i11(e11, n10, t10, x10) {
  const r13 = e11.prev, i16 = e11, u10 = e11.next;
  if (s6(r13, i16, u10) >= 0)
    return false;
  const o11 = r13.x < i16.x ? r13.x < u10.x ? r13.x : u10.x : i16.x < u10.x ? i16.x : u10.x, l6 = r13.y < i16.y ? r13.y < u10.y ? r13.y : u10.y : i16.y < u10.y ? i16.y : u10.y, y9 = r13.x > i16.x ? r13.x > u10.x ? r13.x : u10.x : i16.x > u10.x ? i16.x : u10.x, f9 = r13.y > i16.y ? r13.y > u10.y ? r13.y : u10.y : i16.y > u10.y ? i16.y : u10.y, p10 = z2(o11, l6, n10, t10, x10), c12 = z2(y9, f9, n10, t10, x10);
  let v6 = e11.prevZ, h7 = e11.nextZ;
  for (; v6 && v6.z >= p10 && h7 && h7.z <= c12; ) {
    if (v6 !== e11.prev && v6 !== e11.next && a4(r13.x, r13.y, i16.x, i16.y, u10.x, u10.y, v6.x, v6.y) && s6(v6.prev, v6, v6.next) >= 0)
      return false;
    if (v6 = v6.prevZ, h7 !== e11.prev && h7 !== e11.next && a4(r13.x, r13.y, i16.x, i16.y, u10.x, u10.y, h7.x, h7.y) && s6(h7.prev, h7, h7.next) >= 0)
      return false;
    h7 = h7.nextZ;
  }
  for (; v6 && v6.z >= p10; ) {
    if (v6 !== e11.prev && v6 !== e11.next && a4(r13.x, r13.y, i16.x, i16.y, u10.x, u10.y, v6.x, v6.y) && s6(v6.prev, v6, v6.next) >= 0)
      return false;
    v6 = v6.prevZ;
  }
  for (; h7 && h7.z <= c12; ) {
    if (h7 !== e11.prev && h7 !== e11.next && a4(r13.x, r13.y, i16.x, i16.y, u10.x, u10.y, h7.x, h7.y) && s6(h7.prev, h7, h7.next) >= 0)
      return false;
    h7 = h7.nextZ;
  }
  return true;
}
function u4(e11, n10, t10, x10) {
  const r13 = q2.create(e11, n10, t10);
  return x10 ? (r13.next = x10.next, r13.prev = x10, x10.next.prev = r13, x10.next = r13) : (r13.prev = r13, r13.next = r13), r13;
}
function o8(e11) {
  e11.next.prev = e11.prev, e11.prev.next = e11.next, e11.prevZ && (e11.prevZ.nextZ = e11.nextZ), e11.nextZ && (e11.nextZ.prevZ = e11.prevZ);
}
function l3(e11) {
  let n10 = e11, t10 = e11;
  do {
    (n10.x < t10.x || n10.x === t10.x && n10.y < t10.y) && (t10 = n10), n10 = n10.next;
  } while (n10 !== e11);
  return t10;
}
function y3(e11, t10, x10, r13, i16, u10) {
  const o11 = new Array();
  for (let y9 = 0, f9 = r13.length; y9 < f9; y9++) {
    const i17 = n8(e11, t10, x10, r13[y9] * u10, y9 < f9 - 1 ? r13[y9 + 1] * u10 : x10 * u10, u10, false);
    i17 === i17.next && (i17.steiner = true), o11.push(l3(i17));
  }
  o11.sort(m2);
  for (const n10 of o11)
    i16 = f4(n10, i16);
  return i16;
}
function f4(e11, n10) {
  const x10 = p3(e11, n10);
  if (!x10)
    return n10;
  const r13 = j(x10, e11);
  return t9(r13, r13.next), t9(x10, x10.next);
}
function p3(e11, n10) {
  let t10 = n10;
  const x10 = e11.x, r13 = e11.y;
  let i16, u10 = -1 / 0;
  do {
    if (r13 <= t10.y && r13 >= t10.next.y && t10.next.y !== t10.y) {
      const e12 = t10.x + (r13 - t10.y) * (t10.next.x - t10.x) / (t10.next.y - t10.y);
      if (e12 <= x10 && e12 > u10) {
        if (u10 = e12, e12 === x10) {
          if (r13 === t10.y)
            return t10;
          if (r13 === t10.next.y)
            return t10.next;
        }
        i16 = t10.x < t10.next.x ? t10 : t10.next;
      }
    }
    t10 = t10.next;
  } while (t10 !== n10);
  if (!i16)
    return null;
  if (x10 === u10)
    return i16.prev;
  const o11 = i16, l6 = i16.x, y9 = i16.y;
  let f9, p10 = 1 / 0;
  for (t10 = i16.next; t10 !== o11; )
    x10 >= t10.x && t10.x >= l6 && x10 !== t10.x && a4(r13 < y9 ? x10 : u10, r13, l6, y9, r13 < y9 ? u10 : x10, r13, t10.x, t10.y) && (f9 = Math.abs(r13 - t10.y) / (x10 - t10.x), (f9 < p10 || f9 === p10 && t10.x > i16.x) && w5(t10, e11) && (i16 = t10, p10 = f9)), t10 = t10.next;
  return i16;
}
function c8(e11, n10, t10, x10) {
  let r13;
  for (; r13 !== e11; r13 = r13.next) {
    if (r13 = r13 || e11, null === r13.z && (r13.z = z2(r13.x, r13.y, n10, t10, x10)), r13.prev.next !== r13 || r13.next.prev !== r13)
      return r13.prev.next = r13, r13.next.prev = r13, c8(e11, n10, t10, x10);
    r13.prevZ = r13.prev, r13.nextZ = r13.next;
  }
  return e11.prevZ.nextZ = null, e11.prevZ = null, v3(e11);
}
function v3(e11) {
  let n10, t10 = 1;
  for (; ; ) {
    let x10, r13 = e11;
    e11 = null, n10 = null;
    let i16 = 0;
    for (; r13; ) {
      i16++, x10 = r13;
      let u10 = 0;
      for (; u10 < t10 && x10; u10++)
        x10 = x10.nextZ;
      let o11 = t10;
      for (; u10 > 0 || o11 > 0 && x10; ) {
        let t11;
        0 === u10 ? (t11 = x10, x10 = x10.nextZ, o11--) : 0 !== o11 && x10 ? r13.z <= x10.z ? (t11 = r13, r13 = r13.nextZ, u10--) : (t11 = x10, x10 = x10.nextZ, o11--) : (t11 = r13, r13 = r13.nextZ, u10--), n10 ? n10.nextZ = t11 : e11 = t11, t11.prevZ = n10, n10 = t11;
      }
      r13 = x10;
    }
    if (n10.nextZ = null, t10 *= 2, i16 < 2)
      return e11;
  }
}
function s6(e11, n10, t10) {
  return (n10.y - e11.y) * (t10.x - n10.x) - (n10.x - e11.x) * (t10.y - n10.y);
}
function h3(e11, n10, t10, x10) {
  return !!(M(e11, n10) && M(t10, x10) || M(e11, x10) && M(t10, n10)) || s6(e11, n10, t10) > 0 != s6(e11, n10, x10) > 0 && s6(t10, x10, e11) > 0 != s6(t10, x10, n10) > 0;
}
function d2(e11, n10) {
  let t10 = e11;
  do {
    if (t10.index !== e11.index && t10.next.index !== e11.index && t10.index !== n10.index && t10.next.index !== n10.index && h3(t10, t10.next, e11, n10))
      return true;
    t10 = t10.next;
  } while (t10 !== e11);
  return false;
}
function Z2(e11, n10, t10, x10, r13, i16) {
  let u10 = 0;
  for (let o11 = x10, l6 = r13 - i16; o11 < r13; o11 += i16)
    u10 += (e11[l6 + n10 * i16] - e11[o11 + n10 * i16]) * (e11[o11 + 1 + n10 * i16] + e11[l6 + 1 + n10 * i16]), l6 = o11;
  return u10;
}
function a4(e11, n10, t10, x10, r13, i16, u10, o11) {
  return (r13 - u10) * (n10 - o11) - (e11 - u10) * (i16 - o11) >= 0 && (e11 - u10) * (x10 - o11) - (t10 - u10) * (n10 - o11) >= 0 && (t10 - u10) * (i16 - o11) - (r13 - u10) * (x10 - o11) >= 0;
}
function w5(e11, n10) {
  return s6(e11.prev, e11, e11.next) < 0 ? s6(e11, n10, e11.next) >= 0 && s6(e11, e11.prev, n10) >= 0 : s6(e11, n10, e11.prev) < 0 || s6(e11, e11.next, n10) < 0;
}
function z2(e11, n10, t10, x10, r13) {
  return (e11 = 1431655765 & ((e11 = 858993459 & ((e11 = 252645135 & ((e11 = 16711935 & ((e11 = 32767 * (e11 - t10) * r13) | e11 << 8)) | e11 << 4)) | e11 << 2)) | e11 << 1)) | (n10 = 1431655765 & ((n10 = 858993459 & ((n10 = 252645135 & ((n10 = 16711935 & ((n10 = 32767 * (n10 - x10) * r13) | n10 << 8)) | n10 << 4)) | n10 << 2)) | n10 << 1)) << 1;
}
function M(e11, n10) {
  return e11.x === n10.x && e11.y === n10.y;
}
function m2(e11, n10) {
  return e11.x - n10.x;
}
function b4(e11, n10, t10, x10) {
  let r13 = e11;
  do {
    const i16 = r13.prev, u10 = r13.next.next;
    !M(i16, u10) && h3(i16, r13, r13.next, u10) && w5(i16, u10) && w5(u10, i16) && (n10.push(i16.index / t10 + x10), n10.push(r13.index / t10 + x10), n10.push(u10.index / t10 + x10), o8(r13), o8(r13.next), r13 = e11 = u10), r13 = r13.next;
  } while (r13 !== e11);
  return r13;
}
function g3(e11, n10, r13, i16, u10, o11, l6) {
  let y9 = e11;
  do {
    let e12 = y9.next.next;
    for (; e12 !== y9.prev; ) {
      if (y9.index !== e12.index && k3(y9, e12)) {
        let f9 = j(y9, e12);
        return y9 = t9(y9, y9.next), f9 = t9(f9, f9.next), x3(y9, n10, r13, i16, u10, o11, l6, 0), void x3(f9, n10, r13, i16, u10, o11, l6, 0);
      }
      e12 = e12.next;
    }
    y9 = y9.next;
  } while (y9 !== e11);
}
function k3(e11, n10) {
  return e11.next.index !== n10.index && e11.prev.index !== n10.index && !d2(e11, n10) && w5(e11, n10) && w5(n10, e11) && A(e11, n10);
}
function A(e11, n10) {
  let t10 = e11, x10 = false;
  const r13 = (e11.x + n10.x) / 2, i16 = (e11.y + n10.y) / 2;
  do {
    t10.y > i16 != t10.next.y > i16 && t10.next.y !== t10.y && r13 < (t10.next.x - t10.x) * (i16 - t10.y) / (t10.next.y - t10.y) + t10.x && (x10 = !x10), t10 = t10.next;
  } while (t10 !== e11);
  return x10;
}
function j(e11, n10) {
  const t10 = q2.create(e11.index, e11.x, e11.y), x10 = q2.create(n10.index, n10.x, n10.y), r13 = e11.next, i16 = n10.prev;
  return e11.next = n10, n10.prev = e11, t10.next = r13, r13.prev = t10, x10.next = t10, t10.prev = x10, i16.next = x10, x10.prev = i16, x10;
}
var q2 = class _q {
  constructor() {
    this.index = 0, this.x = 0, this.y = 0, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  static create(e11, n10, t10) {
    const x10 = D < B.length ? B[D++] : new _q();
    return x10.index = e11, x10.x = n10, x10.y = t10, x10.prev = null, x10.next = null, x10.z = null, x10.prevZ = null, x10.nextZ = null, x10.steiner = false, x10;
  }
};
var B = new Array();
var C3 = 8096;
var D = 0;
for (let E4 = 0; E4 < C3; E4++)
  B.push(new q2());

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/templateUtils.js
var i13 = 1e-5;
var f5 = new e5(0, 0, 0, 1, 0);
var c9 = new e5(0, 0, 0, 1, 0);
function u5(t10, e11, n10) {
  let o11 = 0;
  for (let r13 = 1; r13 < n10; r13++) {
    const n11 = t10[2 * (e11 + r13 - 1)], s8 = t10[2 * (e11 + r13 - 1) + 1];
    o11 += (t10[2 * (e11 + r13)] - n11) * (t10[2 * (e11 + r13) + 1] + s8);
  }
  return o11;
}
function h4(t10, e11, n10, o11, r13) {
  let s8 = 0;
  const l6 = 2;
  for (let i16 = n10; i16 < o11; i16 += 3) {
    const n11 = (t10[i16] - r13) * l6, o12 = (t10[i16 + 1] - r13) * l6, f9 = (t10[i16 + 2] - r13) * l6;
    s8 += Math.abs((e11[n11] - e11[f9]) * (e11[o12 + 1] - e11[n11 + 1]) - (e11[n11] - e11[o12]) * (e11[f9 + 1] - e11[n11 + 1]));
  }
  return s8;
}
function a5(t10, e11) {
  const { coords: n10, lengths: o11, hasIndeterminateRingOrder: r13 } = e11, s8 = 0, f9 = t10;
  if (r13)
    return false;
  let c12 = 0;
  for (let a9 = 0; a9 < o11.length; ) {
    let t11 = a9, e12 = o11[a9], r14 = u5(n10, c12, e12);
    const g7 = [];
    for (; ++t11 < o11.length; ) {
      const s9 = o11[t11], l6 = u5(n10, c12 + e12, s9);
      if (!(l6 > 0))
        break;
      r14 += l6, g7.push(c12 + e12), e12 += s9;
    }
    const p10 = f9.length;
    e8(f9, n10, c12, c12 + e12, g7, 2, s8);
    const m6 = h4(f9, n10, p10, f9.length, s8), d9 = Math.abs(r14);
    if (Math.abs((m6 - d9) / Math.max(1e-7, d9)) > i13)
      return f9.length = 0, false;
    a9 = t11, c12 += e12;
  }
  return true;
}
function p4(t10) {
  const { coords: n10, lengths: o11 } = t10, { buffer: r13 } = r3(n10, o11);
  return r13;
}
function m3(t10, e11, n10) {
  let o11 = 0;
  for (let r13 = 0; r13 < t10.lengths.length; r13++) {
    const s8 = t10.lengths[r13];
    for (let r14 = 0; r14 < s8; r14++) {
      const s9 = t10.coords[2 * (r14 + o11)], l6 = t10.coords[2 * (r14 + o11) + 1];
      if (s9 < e11 || s9 > n10 || l6 < e11 || l6 > n10)
        return true;
    }
    o11 += s8;
  }
  return false;
}
function d3(t10, e11) {
  if (null == t10)
    return null;
  if (!m3(t10, -128, c2 + 128))
    return t10;
  f5.setPixelMargin(e11), f5.reset(t3.Polygon);
  let n10 = 0;
  for (let o11 = 0; o11 < t10.lengths.length; o11++) {
    const e12 = t10.lengths[o11];
    let r13 = t10.coords[2 * (0 + n10)], s8 = t10.coords[2 * (0 + n10) + 1];
    f5.moveTo(r13, s8);
    for (let o12 = 1; o12 < e12; o12++)
      r13 = t10.coords[2 * (o12 + n10)], s8 = t10.coords[2 * (o12 + n10) + 1], f5.lineTo(r13, s8);
    f5.close(), n10 += e12;
  }
  const l6 = f5.result(false);
  if (!l6)
    return null;
  const i16 = [], c12 = [];
  for (const o11 of l6) {
    let t11 = 0;
    for (const e12 of o11)
      c12.push(e12.x), c12.push(e12.y), t11++;
    i16.push(t11);
  }
  return new t(i16, c12);
}
function x4(t10, e11) {
  c9.setPixelMargin(e11);
  const n10 = c9, r13 = -e11, l6 = c2 + e11;
  let i16 = [], f9 = false;
  if (!t10.nextPath())
    return null;
  let u10 = true;
  for (; u10; ) {
    t10.seekPathStart();
    const e12 = [];
    if (!t10.pathSize)
      return null;
    n10.reset(t3.LineString), t10.nextPoint();
    let s8 = t10.x, c12 = t10.y;
    if (f9)
      n10.moveTo(s8, c12);
    else {
      if (s8 < r13 || s8 > l6 || c12 < r13 || c12 > l6) {
        f9 = true;
        continue;
      }
      e12.push({ x: s8, y: c12 });
    }
    let h7 = false;
    for (; t10.nextPoint(); )
      if (s8 = t10.x, c12 = t10.y, f9)
        n10.lineTo(s8, c12);
      else {
        if (s8 < r13 || s8 > l6 || c12 < r13 || c12 > l6) {
          h7 = true;
          break;
        }
        e12.push({ x: s8, y: c12 });
      }
    if (h7)
      f9 = true;
    else {
      if (f9) {
        const t11 = n10.resultWithStarts();
        if (t11)
          for (const e13 of t11)
            i16.push(e13);
      } else
        i16.push({ line: e12, start: 0 });
      u10 = t10.nextPath(), f9 = false;
    }
  }
  return i16 = i16.filter((t11) => t11.line.length > 1), 0 === i16.length ? null : i16;
}
f5.setExtent(c2), c9.setExtent(c2);

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseLineTemplate.js
var d4 = 8;
var x5 = 16;
var f6 = 65535;
var p5 = (r13) => class extends r13 {
  constructor(...e11) {
    super(...e11), this.tessellationProperties = {}, this._tessellationOptions = { halfWidth: 0, pixelCoordRatio: 1, offset: 0 }, this.geometryType = E.LINE;
  }
  writeGeometry(e11, t10, i16, r14) {
    this._writeGeometry(e11, t10, i16, r14);
  }
  _initializeTessellator(e11) {
    const i16 = C2.load(this._materialKey), r14 = w3.load(this._materialKey), s8 = this._tessellationOptions, h7 = i16.vvSizeFieldStops || i16.vvSizeMinMaxValue || i16.vvSizeScaleStops || i16.vvSizeUnitValue, m6 = this.tessellationProperties._halfWidth < $ && !e11 && !h7;
    this.tessellationProperties.minMaxZoom = this._minMaxZoom, s8.wrapDistance = f6, s8.textured = this._isDashed || this._hasPattern, s8.offset = this.tessellationProperties.offset, s8.halfWidth = this.tessellationProperties._halfWidth;
    const d9 = m6 ? 0 : 1, x10 = O(r14) ? v4 : _2;
    this._lineTessellator = new c5(x10(this.tessellationProperties, d9, d9), u6(this.tessellationProperties), m6);
  }
  _write(e11, t10, i16, r14) {
    const s8 = "esriGeometryPoint" === t10.geometryType;
    e11.recordStart(t10.getDisplayId(), this._materialKey, this.geometryType, s8), this._writeGeometry(e11, t10, r14, s8), e11.recordEnd();
  }
  _writeGeometry(t10, i16, r14, s8) {
    const o11 = r14 || a3.fromFeatureSetReaderCIM(i16);
    if (!o11)
      return;
    const n10 = this._getLines(o11, s8);
    null != n10 && this._writeVertices(t10, i16, n10);
  }
  _getLines(e11, t10) {
    return x4(e11, t10 ? 256 : 16);
  }
  _writeVertices(e11, t10, i16) {
    const r14 = t10.getDisplayId(), s8 = e11.vertexCount(), o11 = this.tessellationProperties, h7 = this._tessellationOptions;
    o11.out = e11, o11.id = r14, o11.indexCount = 0, o11.vertexCount = 0, o11.offset = s8, h7.capType = this._capType, h7.joinType = this._joinType;
    const m6 = w3.load(this._materialKey);
    this.tessellationProperties.key = O(m6) ? m6 : C2.load(this._materialKey);
    for (const { line: n10, start: l6 } of i16)
      h7.initialDistance = l6 % f6, this._lineTessellator.tessellate(n10, h7);
  }
};
var _2 = (e11, t10, i16) => (o11, n10, l6, a9, h7, m6, f9, p10, _5, v6, u10) => {
  const W2 = w2(u10, Math.ceil(x5 * e11._halfWidth)), c12 = x(Math.round(x5 * f9), Math.round(x5 * p10), Math.round(x5 * _5), Math.round(x5 * v6)), y9 = x(x5 * h7, x5 * m6, 0, e11._bitset), M3 = e11.out;
  return M3.vertexBounds(o11, n10, t10, i16), M3.vertexWrite(w2(d4 * o11, d4 * n10)), M3.vertexWrite(e11.id), M3.vertexWrite(e11._fillColor), M3.vertexWrite(c12), M3.vertexWrite(W2), M3.vertexWrite(e11._tl), M3.vertexWrite(e11._br), M3.vertexWrite(y9), M3.vertexWrite(w2(Math.ceil(x5 * e11._halfReferenceWidth), 0)), M3.vertexWrite(e11.minMaxZoom), M3.vertexEnd(), e11.offset + e11.vertexCount++;
};
var v4 = (e11, t10, i16) => (o11, n10, l6, a9, m6, f9, p10, _5, v6, u10, W2) => {
  const c12 = w2(x5 * e11._halfWidth, x5 * e11._halfReferenceWidth), y9 = x(x5 * p10 + 128, x5 * _5 + 128, x5 * v6 + 128, x5 * u10 + 128), M3 = e11.out, C6 = e11._bitset << 24 | e11.id;
  M3.vertexBounds(o11, n10, t10, i16), M3.vertexWrite(w2(d4 * o11, d4 * n10)), M3.vertexWrite(C6), M3.vertexWrite(e11._fillColor);
  const P4 = b3(e11.key);
  return P4 || (M3.vertexWrite(0), M3.vertexWrite(0)), M3.vertexWrite(0), M3.vertexWrite(c12), M3.vertexWrite(y9), P4 || M3.vertexWrite(e11.minMaxZoom), M3.vertexEnd(), e11.offset + e11.vertexCount++;
};
var u6 = (e11) => (t10, i16, r13) => {
  const s8 = e11.out;
  s8.indexWrite(t10), s8.indexWrite(i16), s8.indexWrite(r13), e11.indexCount += 3;
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLMeshTemplate.js
var r9 = class {
  constructor() {
    this._materialKey = null;
  }
  bindFeature(e11, t10, r13) {
  }
  write(r13, s8, i16, f9) {
    if (this._effects && this._effects.length > 0) {
      let i17 = a3.fromFeatureSetReaderCIM(s8);
      if (i17) {
        i17.invertY();
        const e11 = l.executeEffects(this._effects, i17, r13.tileKey, f9.geometryEngine);
        for (; i17 = e11.next(); )
          i17.invertY(), this._write(r13, s8, f9, i17);
      }
    } else
      this._write(r13, s8, f9);
  }
  _write(e11, t10, r13, s8) {
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLLineTemplate.js
var K = class _K extends p5(r9) {
  constructor(e11, t10, i16, r13, s8, o11, p10, f9, d9, y9, S5, _5, j4, g7, w9, K3, P4, x10, b6, O2) {
    super();
    const T = C2.load(e11);
    t10 && (T.sdf = t10.sdf, T.pattern = true, T.textureBinding = t10.textureBinding), this._capType = r13, this._joinType = s8, this._miterLimitCosine = c7(o11), this.tessellationProperties._fillColor = p10, this.tessellationProperties._tl = f9, this.tessellationProperties._br = d9, this._hasPattern = y9, this._isDashed = S5, this._zOrder = P4, this._effects = x10 || null, this._minMaxZoom = w2(Math.round(b6 * me), Math.round(O2 * me)), this._materialKey = T.data;
    const M3 = (j4 ? pe : 0) | (g7 ? ke : 0) | (_5 ? je : 0) | (w9 ? ge : 0);
    this.tessellationProperties._bitset = M3, this.tessellationProperties._halfWidth = 0.5 * i16, this.tessellationProperties._halfReferenceWidth = 0.5 * K3, this.tessellationProperties.offset = 0, this._initializeTessellator(false);
  }
  static fromCIMLine(e11, r13, l6) {
    const n10 = e11.color, a9 = e11.scaleFactor || 1, m6 = !!e11.dashTemplate;
    let c12 = e11.cap;
    m6 && c12 === e3.ROUND && (c12 = e3.SQUARE);
    const p10 = e11.join, f9 = u(e11.width) * a9, u10 = u(e11.referenceWidth), d9 = u(e11.miterLimit), y9 = n10 && t2(n10) || 0, [L4, _5] = v2(e11.scaleInfo, l6), j4 = false;
    if (!r13)
      return new _K(e11.materialKey, r13, f9, c12, p10, d9, y9, 0, 0, false, m6, e11.scaleDash ?? false, e11.colorLocked ?? false, j4, e11.sampleAlphaOnly, u10, e11.zOrder, e11.effects, L4, _5);
    const { rect: g7, width: w9, height: P4 } = r13, x10 = g7.x + ae, b6 = g7.y + ae, O2 = x10 + w9, T = b6 + P4, M3 = w2(x10, b6), W2 = w2(O2, T), z6 = false;
    return new _K(e11.materialKey, r13, f9, c12, p10, d9, y9, M3, W2, true, m6, e11.scaleDash ?? false, e11.colorLocked ?? false, z6, e11.sampleAlphaOnly, u10, e11.zOrder, e11.effects, L4, _5);
  }
  static fromFillOutline(e11) {
    var _a;
    const t10 = w3.load(e11.materialKey);
    return O(t10) && e11.outline && "esriSLSSolid" === ((_a = e11.outline) == null ? void 0 : _a.style) ? _K.fromSimpleLine({ hash: "", materialKey: e11.materialKey, ...e11.outline }, null, true) : null;
  }
  static fromSimpleLine(e11, i16, s8 = false) {
    const { color: l6 } = e11, n10 = "esriSLSSolid" !== e11.style && "esriSLSNull" !== e11.style, a9 = k2(e11.cap || "round"), m6 = G(e11.join || "round");
    let c12 = l6 && "esriSLSNull" !== e11.style && o5(l6) || 0;
    "esriSLSNull" === e11.style && (c12 = 0);
    const u10 = u(e11.width), d9 = e11.miterLimit;
    if (!i16)
      return new _K(e11.materialKey, i16, u10, a9, m6, d9, c12, 0, 0, false, n10, true, false, s8, false, u10, 0, null, n7, o7);
    const { rect: y9, width: L4, height: S5 } = i16, g7 = y9.x + ae, w9 = y9.y + ae, P4 = g7 + L4, x10 = w9 + S5, b6 = w2(g7, w9), O2 = w2(P4, x10);
    return new _K(e11.materialKey, i16, u10, a9, m6, d9, c12, b6, O2, true, n10, true, false, s8, false, u10, 0, null, n7, o7);
  }
  static fromPictureLineSymbol(t10, i16, r13, s8) {
    return s.getLogger("esri.views.2d.engine.webgl.WGLLineTemplate").error("PictureLineSymbol support does not exist!"), null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseFillTemplate.js
var y4 = 100;
var p6 = 1;
var x6 = (x10) => class extends x10 {
  constructor(...t10) {
    super(...t10), this.forceLibtess = false, this._bitset = 0, this._lineTemplate = null, this.geometryType = E.FILL;
  }
  _maybeAddLineTemplate(e11) {
    this._lineTemplate = K.fromFillOutline(e11);
  }
  _write(e11, t10, r13, i16) {
    const l6 = "esriGeometryPoint" === t10.geometryType, n10 = w3.load(this._materialKey);
    e11.recordStart(t10.getDisplayId(), this._materialKey, this.geometryType, l6), this._writeGeometry(e11, t10, n10, i16, l6), O(n10) && null != this._lineTemplate && this._lineTemplate.writeGeometry(e11, t10, i16, l6), e11.recordEnd();
  }
  _writeGeometry(e11, t10, r13, i16, s8) {
    const o11 = this._getGeometry(t10, i16, s8);
    if (null == o11)
      return;
    const l6 = [];
    if (!(o11.maxLength > y4) && !this.forceLibtess && a5(l6, o11))
      return void (l6.length && this._writeVertices(e11, t10, o11.coords, o11.lengths, r13, l6));
    const a9 = p4(o11);
    this._writeVertices(e11, t10, a9, [a9.length / 2], r13);
  }
  _writeVertex(e11, i16, s8, o11, n10, m6) {
    const a9 = w2(p6 * o11, p6 * n10);
    if (e11.vertexBounds(o11, n10, 0, 0), e11.vertexWrite(a9), e11.vertexWrite(i16), s8.symbologyType === S.DOT_DENSITY)
      e11.vertexWriteF32(1 / Math.abs(m6.readGeometryArea()));
    else {
      e11.vertexWrite(this.fillColor);
      const t10 = b3(s8);
      t10 || (e11.vertexWrite(this.tl), e11.vertexWrite(this.br)), e11.vertexWrite(this.aux21), e11.vertexWrite(this.aux22), e11.vertexWrite(this.aux3), t10 || e11.vertexWrite(this._minMaxZoom);
    }
  }
  _writeVertices(e11, t10, r13, s8, o11, l6) {
    const n10 = t10.getDisplayId(), m6 = this._bitset << 24 | n10, a9 = s8.reduce((e12, t11) => e12 + t11), h7 = R(o11.geometryType, o11.symbologyType).geometry / 4, y9 = e11.vertexCount();
    e11.vertexEnsureSize(h7 * a9);
    let p10 = 0;
    if (l6)
      for (const i16 of l6) {
        const s9 = r13[2 * i16], l7 = r13[2 * i16 + 1];
        this._writeVertex(e11, m6, o11, s9, l7, t10), p10++;
      }
    else
      for (let i16 = 0; i16 < r13.length; i16 += 2) {
        const s9 = Math.round(r13[i16]), l7 = Math.round(r13[i16 + 1]);
        this._writeVertex(e11, m6, o11, s9, l7, t10), p10++;
      }
    e11.indexEnsureSize(p10);
    for (let i16 = 0; i16 < p10; i16++)
      e11.indexWrite(i16 + y9);
  }
  _getGeometry(e11, t10, r13) {
    const i16 = (t10 == null ? void 0 : t10.asOptimized()) || e11.readGeometryForDisplay();
    if (!i16)
      return null;
    return d3(i16, r13 ? 256 : 8);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicMeshTemplate.js
var i14 = s.getLogger("esri.views.2d.engine.webgl.WGLDynamicMeshTemplate");
var r10 = class extends r9 {
  constructor(e11) {
    super(), this._ongoingMaterialRequestMap = /* @__PURE__ */ new Map(), this._materialCache = /* @__PURE__ */ new Map(), this._dynamicPropertyMap = /* @__PURE__ */ new Map(), this._cimLayer = e11;
  }
  async analyze(e11, s8, r13, n10, l6) {
    if (l6 && 0 === l6.length)
      return null;
    const o11 = l6 && l6.length > 0, m6 = s8.readLegacyFeature(), c12 = s8.getObjectId(), h7 = this._materialCache, u10 = this._cimLayer.materialHash;
    if (!u10)
      return i14.error("A Dynamic mesh template must have a material hash value or function!"), null;
    const p10 = "function" == typeof u10 ? u10(m6, r13, n10, c12) : u10, g7 = h7.get(p10);
    if (null != g7)
      return g7;
    const y9 = this._ongoingMaterialRequestMap.get(p10);
    if (y9)
      return y9;
    const M3 = this._cimLayer, d9 = V(M3.cim, this._cimLayer.materialOverrides);
    d9.mosaicHash = p10;
    const { type: f9, url: _5 } = M3, b6 = { cim: d9, type: f9, mosaicHash: p10, url: _5, size: null, dashTemplate: null, text: null, fontName: null, objectId: c12, animatedSymbolProperties: null };
    switch (f9) {
      case "marker":
        b6.size = t5(M3.size, m6, r13, n10), b6.animatedSymbolProperties = t5(M3.animatedSymbolProperties, m6, r13, n10);
        break;
      case "line":
        b6.dashTemplate = M3.dashTemplate;
        break;
      case "text":
        b6.text = t5(M3.text, m6, r13, n10), b6.fontName = t5(M3.fontName, m6, r13, n10);
    }
    const L4 = e11.getMosaicItem(b6, l6).then((e12) => (o11 || (this._ongoingMaterialRequestMap.delete(p10), h7.set(p10, e12)), e12)).catch((e12) => (this._ongoingMaterialRequestMap.delete(p10), i14.error(".analyze()", e12.message), null));
    return o11 || this._ongoingMaterialRequestMap.set(p10, L4), L4;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Result.js
function e9(e11, n10) {
  if (e11 && "name" in e11) {
    const o11 = e11;
    return n10 && n10.error(new s2(o11.name, o11.message, o11.details)), false;
  }
  return true;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicFillTemplate.js
var j2 = class _j extends x6(r10) {
  constructor(l6, h7, n10) {
    var _a;
    if (super(l6), this._minMaxZoom = w2(Math.round(h7 * me), Math.round(n10 * me)), e6(l6.color)) {
      const t10 = (t11, e11, i16) => {
        const o11 = l6.color(t11, e11, i16);
        return o11 && t2(o11) || 0;
      };
      this._dynamicPropertyMap.set("fillColor", t10);
    } else {
      const t10 = l6.color;
      this.fillColor = t10 && t2(t10) || 0;
    }
    const c12 = "CIMMarkerPlacementInsidePolygon" === ((_a = l6.cim.placement) == null ? void 0 : _a.type) && l6.cim.placement.shiftOddRows ? 2 : 1, f9 = l6.height;
    if (e6(f9)) {
      const t10 = (t11, e11, s8) => f9(t11, e11, s8) * c12;
      this._dynamicPropertyMap.set("_height", t10);
    } else
      this._height = (f9 || 0) * c12;
    const y9 = l6.offsetX;
    if (e6(y9)) {
      const e11 = (e12, s8, i16) => u(y9(e12, s8, i16));
      this._dynamicPropertyMap.set("_offsetX", e11);
    } else
      this._offsetX = u(y9 || 0);
    const d9 = l6.offsetY;
    if (e6(d9)) {
      const e11 = (e12, s8, i16) => u(-d9(e12, s8, i16));
      this._dynamicPropertyMap.set("_offsetY", e11);
    } else
      this._offsetY = u(-d9 || 0);
    const u10 = l6.scaleX;
    e6(u10) ? this._dynamicPropertyMap.set("_scaleX", u10) : this._scaleX = u10 || 1;
    const M3 = l6.angle;
    if (e6(M3)) {
      const t10 = (t11, e11, s8) => c4(M3(t11, e11, s8));
      this._dynamicPropertyMap.set("_angle", t10);
    } else
      this._angle = c4(M3) || 0;
    if (null != l6.effects) {
      const t10 = l6.effects;
      e6(t10) ? this._dynamicPropertyMap.set("_effects", t10) : this._effects = t10;
    }
    this._cimFillLayer = l6, this._bitset = (l6.colorLocked ? pe : 0) | (l6.applyRandomOffset ? ue : 0) | (l6.sampleAlphaOnly ? ge : 0) | (l6.hasUnresolvedReplacementColor ? ve : 0), this._fillMaterialKey = l6.materialKey;
  }
  static fromCIMFill(t10, e11) {
    const [s8, i16] = v2(t10.scaleInfo, e11);
    return new _j(t10, s8, i16);
  }
  bindFeature(e11, s8, i16) {
    const o11 = e11.readLegacyFeature();
    this._dynamicPropertyMap.forEach((t10, e12) => {
      this[e12] = t10(o11, s8, i16);
    });
    const r13 = w3.load(this._fillMaterialKey), a9 = this._materialCache, m6 = (0, this._cimFillLayer.materialHash)(o11, s8, i16), p10 = a9.get(m6);
    let u10 = null;
    if (p10 && e9(p10.spriteMosaicItem) && (u10 = p10.spriteMosaicItem), u10) {
      const { rect: e12, width: s9, height: i17 } = u10, o12 = e12.x + ae, a10 = e12.y + ae, m7 = o12 + s9, p11 = a10 + i17;
      let d9 = u(this._height);
      d9 <= 0 && (d9 = p11 - a10), d9 < i2 && (d9 *= h, this._bitset |= ye), d9 = Math.round(d9);
      let M3 = u(this._height / i17 * s9);
      M3 <= 0 && (M3 = m7 - o12), M3 < i2 && (M3 *= h, this._bitset |= be), M3 = Math.round(M3);
      const g7 = this._scaleX, x10 = 1;
      this.tl = w2(o12, a10), this.br = w2(m7, p11), this.aux21 = w2(M3, d9), this.aux22 = w2(this._offsetX, this._offsetY), this.aux3 = x(g7 * h, x10 * h, this._angle, 0), r13.sdf = u10.sdf, r13.pattern = true, r13.textureBinding = u10.textureBinding;
    } else
      this.tl = 0, this.br = 0, this.aux21 = 0, this.aux22 = 0, this.aux3 = 0, r13.sdf = false, r13.pattern = false, r13.textureBinding = 0;
    this._materialKey = r13.data;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicLineTemplate.js
var d5 = class _d extends p5(r10) {
  constructor(a9, n10, m6) {
    super(a9), this._minMaxZoom = w2(Math.round(n10 * me), Math.round(m6 * me)), this._cimLineLayer = a9;
    let p10 = 0;
    e6(a9.width) || (p10 = 0.5 * u(a9.width));
    const _5 = (i16, s8, r13) => e6(a9.width) ? 0.5 * u(a9.width(i16, s8, r13)) : p10;
    this._dynamicPropertyMap.set("_halfWidth", _5), e6(a9.cap) ? this._dynamicPropertyMap.set("_capType", a9.cap) : this._capType = a9.cap, e6(a9.join) ? this._dynamicPropertyMap.set("_joinType", a9.join) : this._joinType = a9.join;
    const f9 = a9.color;
    if (e6(f9)) {
      const t10 = (t11, e11, s8) => t2(f9(t11, e11, s8));
      this._dynamicPropertyMap.set("_fillColor", t10);
    } else
      this._fillColor = f9 && t2(f9) || 0;
    const d9 = a9.miterLimit;
    if (e6(d9)) {
      const t10 = (t11, e11, i16) => c7(d9(t11, e11, i16));
      this._dynamicPropertyMap.set("_miterLimitCosine", t10);
    } else
      this._miterLimitCosine = c7(d9);
    if (null != a9.effects) {
      const t10 = a9.effects;
      e6(t10) ? this._dynamicPropertyMap.set("_effects", t10) : this._effects = t10;
    }
    this._scaleFactor = a9.scaleFactor || 1, this._isDashed = null != a9.dashTemplate;
    const y9 = a9.colorLocked ? pe : 0, P4 = a9.scaleDash ? je : 0, u10 = a9.sampleAlphaOnly ? ge : 0;
    this.tessellationProperties._bitset = y9 | P4 | u10, this._materialKey = a9.materialKey, this._initializeTessellator(true);
  }
  static fromCIMLine(t10, e11) {
    const [i16, s8] = v2(t10.scaleInfo, e11);
    return new _d(t10, i16, s8);
  }
  bindFeature(t10, e11, i16) {
    const s8 = t10.readLegacyFeature();
    this._dynamicPropertyMap.forEach((t11, r14) => {
      this[r14] = t11(s8, e11, i16);
    }), this._halfWidth *= this._scaleFactor;
    const r13 = this._materialCache, o11 = (0, this._cimLineLayer.materialHash)(s8, e11, i16), l6 = r13.get(o11);
    let c12 = null;
    if (l6 && e9(l6.spriteMosaicItem) && (c12 = l6.spriteMosaicItem), c12) {
      this._hasPattern = true;
      const { rect: t11, width: e12, height: i17 } = c12, s9 = t11.x + ae, r14 = t11.y + ae, o12 = s9 + e12, l7 = r14 + i17;
      this.tessellationProperties._tl = w2(s9, r14), this.tessellationProperties._br = w2(o12, l7);
    } else
      this._hasPattern = false, this.tessellationProperties._tl = 0, this.tessellationProperties._br = 0;
    this.tessellationProperties._fillColor = this._fillColor, this.tessellationProperties._halfWidth = this._halfWidth, this.tessellationProperties.offset = 0, this.tessellationProperties._halfReferenceWidth = this.tessellationProperties._halfWidth;
    const m6 = C2.load(this._materialKey);
    c12 && (m6.sdf = c12.sdf, m6.pattern = true, m6.textureBinding = c12.textureBinding), this._materialKey = m6.data;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/CIMMarkerPlacementHelper.js
var e10 = class {
  static getPlacement(e11, r13, n10, s8, c12, o11) {
    const a9 = g(n10);
    if (!a9)
      return null;
    -1 === r13 && e11.invertY();
    return a9.execute(e11, n10, s8, c12, o11);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseMarkerTemplate.js
var g4 = 3.14159265359 / 180;
var u7 = 8;
var y5 = (y9) => class extends y9 {
  constructor(...t10) {
    super(...t10), this.angle = 0, this.xOffset = 0, this.yOffset = 0, this.width = 0, this.height = 0, this.boundsType = "square", this._anchorX = 0, this._anchorY = 0, this._computedWidth = 0, this._computedHeight = 0, this._allowBorrowing = true, this._vertexBoundsScaleX = 1, this._vertexBoundsScaleY = 1, this.geometryType = E.MARKER;
  }
  _write(t10, e11, i16, r13) {
    const s8 = e11.getDisplayId();
    t10.recordStart(s8, this._materialKey, this.geometryType, true), this._writeGeometry(t10, e11, s8, i16, r13), t10.recordEnd();
  }
  _writeGeometry(t10, e11, i16, r13, s8) {
    if (null != this._markerPlacement)
      return this._writePlacedMarkers(t10, e11, r13, s8);
    if (this._allowBorrowing = true, !s8 && "esriGeometryPoint" === e11.geometryType) {
      const r14 = e11.getX(), s9 = e11.getY();
      if (!t10.hasAggregates && t10.hasPixelBufferEnabled && (r14 < 0 || r14 >= 513 || s9 < 0 || s9 >= 513))
        return;
      return this._writeVertices(t10, i16, this._getPos(r14, s9), r14, s9);
    }
    const o11 = s8 ? s8.asOptimized() : "esriGeometryPolygon" === e11.geometryType ? e11.readCentroid() : e11.readGeometryForDisplay();
    if (null != o11) {
      if (o11.isPoint) {
        const [e12, r14] = o11.coords;
        if (!t10.hasAggregates && t10.hasPixelBufferEnabled && (e12 < 0 || e12 >= 512 || r14 < 0 || r14 >= 512))
          return;
        return this._writeVertices(t10, i16, this._getPos(e12, r14), e12, r14);
      }
      o11.forEachVertex((e12, r14) => {
        const s9 = 2 * c2;
        e12 < -s9 || e12 >= s9 || r14 < -s9 || r14 >= s9 || this._writeVertices(t10, i16, this._getPos(e12, r14), e12, r14);
      });
    }
  }
  _writePlacedMarkers(e11, i16, r13, s8) {
    const h7 = s8 || a3.fromFeatureSetReaderCIM(i16);
    if (!h7)
      return;
    const n10 = -1, a9 = e10.getPlacement(h7, n10, this._markerPlacement, u(1), e11.tileKey, r13.geometryEngine);
    if (!a9)
      return;
    this._allowBorrowing = "esriGeometryPolygon" !== i16.geometryType;
    const _5 = i16.getDisplayId(), l6 = n4(), c12 = n2(), d9 = -128, v6 = 640;
    let W2 = a9.next();
    for (; null != W2; ) {
      const t10 = W2.tx, i17 = -W2.ty;
      t10 >= d9 && t10 <= v6 && i17 >= d9 && i17 <= v6 && (this._applyTransformation(c12, l6, -W2.getAngle() / g4), this._writeVertices(e11, _5, this._getPos(t10, i17), t10, i17)), W2 = a9.next();
    }
  }
  _writeVertices(t10, e11, i16, r13, s8) {
    const o11 = N.load(this._materialKey);
    return o11.symbologyType === S.HEATMAP ? this._writeHeatmapVertices(t10, e11, i16) : this._writeMarkerVertices(t10, e11, o11, i16, r13, s8);
  }
  _writeMarkerVertices(t10, e11, i16, r13, s8, o11) {
    const h7 = i16.vvRotation, n10 = t10.vertexCount();
    let a9 = this._computedWidth * this._vertexBoundsScaleX, x10 = this._computedHeight * this._vertexBoundsScaleY;
    if (this.angle) {
      const t11 = Math.max(a9, x10);
      a9 = t11, x10 = t11;
    }
    if (h7) {
      const t11 = Math.max(this.xOffset, this.yOffset);
      a9 += t11, x10 += t11;
    }
    this._allowBorrowing && t10.vertexBounds(s8 + this.xOffset, o11 - this.yOffset, a9, x10), t10.vertexWrite(r13), t10.vertexWrite(this._offsetUpperLeft), t10.vertexWrite(this._texUpperLeft), t10.vertexWrite(this._bitestAndDistRatio), t10.vertexWrite(e11), t10.vertexWrite(this._fillColor), t10.vertexWrite(this._outlineColor), t10.vertexWrite(this._sizeOutlineWidth), t10.vertexWrite(this._minMaxZoom), t10.vertexEnd(), t10.vertexWrite(r13), t10.vertexWrite(this._offsetUpperRight), t10.vertexWrite(this._texUpperRight), t10.vertexWrite(this._bitestAndDistRatio), t10.vertexWrite(e11), t10.vertexWrite(this._fillColor), t10.vertexWrite(this._outlineColor), t10.vertexWrite(this._sizeOutlineWidth), t10.vertexWrite(this._minMaxZoom), t10.vertexEnd(), t10.vertexWrite(r13), t10.vertexWrite(this._offsetBottomLeft), t10.vertexWrite(this._texBottomLeft), t10.vertexWrite(this._bitestAndDistRatio), t10.vertexWrite(e11), t10.vertexWrite(this._fillColor), t10.vertexWrite(this._outlineColor), t10.vertexWrite(this._sizeOutlineWidth), t10.vertexWrite(this._minMaxZoom), t10.vertexEnd(), t10.vertexWrite(r13), t10.vertexWrite(this._offsetBottomRight), t10.vertexWrite(this._texBottomRight), t10.vertexWrite(this._bitestAndDistRatio), t10.vertexWrite(e11), t10.vertexWrite(this._fillColor), t10.vertexWrite(this._outlineColor), t10.vertexWrite(this._sizeOutlineWidth), t10.vertexWrite(this._minMaxZoom), t10.vertexEnd(), this._writeIndices(t10, n10);
  }
  _writeHeatmapVertices(t10, e11, i16) {
    const r13 = t10.vertexCount();
    t10.vertexWrite(i16), t10.vertexWrite(this._offsetUpperLeft), t10.vertexWrite(e11), t10.vertexEnd(), t10.vertexWrite(i16), t10.vertexWrite(this._offsetUpperRight), t10.vertexWrite(e11), t10.vertexEnd(), t10.vertexWrite(i16), t10.vertexWrite(this._offsetBottomLeft), t10.vertexWrite(e11), t10.vertexEnd(), t10.vertexWrite(i16), t10.vertexWrite(this._offsetBottomRight), t10.vertexWrite(e11), t10.vertexEnd(), this._writeIndices(t10, r13);
  }
  _writeIndices(t10, e11) {
    t10.indexWrite(e11 + 0), t10.indexWrite(e11 + 1), t10.indexWrite(e11 + 2), t10.indexWrite(e11 + 1), t10.indexWrite(e11 + 3), t10.indexWrite(e11 + 2);
  }
  _applyTransformation(t10, o11, x10 = 0) {
    x10 ? h2(t10, g4 * x10) : n(t10), i6(t10, t10, t4(this.xOffset, -this.yOffset)), this.angle && e4(t10, t10, g4 * this.angle);
    const f9 = this._computedWidth, m6 = this._computedHeight, _5 = -(0.5 + this._anchorX) * f9, l6 = -(0.5 - this._anchorY) * m6;
    r2(o11, _5, l6), z(o11, o11, t10), this._offsetUpperLeft = w2(16 * o11[0], 16 * o11[1]), r2(o11, _5 + f9, l6), z(o11, o11, t10), this._offsetUpperRight = w2(16 * o11[0], 16 * o11[1]), r2(o11, _5, l6 + m6), z(o11, o11, t10), this._offsetBottomLeft = w2(16 * o11[0], 16 * o11[1]), r2(o11, _5 + f9, l6 + m6), z(o11, o11, t10), this._offsetBottomRight = w2(16 * o11[0], 16 * o11[1]);
  }
  _computeSize(t10, e11, i16, r13, s8, o11, h7, n10) {
    const a9 = t10 * i16, x10 = e11 * i16;
    if (!!o11.sdf && !h7) {
      const i17 = n10 && t10 > e11 ? a9 : t10, s9 = e11, o12 = r13 + 2 * 1;
      t10 = Math.min(i17 + o12, a9), e11 = Math.min(s9 + o12, x10);
    } else
      t10 = a9, e11 = x10;
    const f9 = ce / Math.max(a9, x10), m6 = 0.5 * (a9 - t10) * f9, l6 = 0.5 * (x10 - e11) * f9, d9 = o11.rect.x + ae + m6, v6 = o11.rect.y + ae + l6, p10 = d9 + o11.width - 2 * m6, g7 = v6 + o11.height - 2 * l6, u10 = Math.floor(d9), y10 = Math.floor(v6), w9 = Math.ceil(p10), M3 = Math.ceil(g7);
    t10 *= (w9 - u10) / (p10 - d9), e11 *= (M3 - y10) / (g7 - v6), this._texUpperLeft = w2(u10, y10), this._texUpperRight = w2(w9, y10), this._texBottomLeft = w2(u10, M3), this._texBottomRight = w2(w9, M3), this._anchorX *= a9 / t10, this._anchorY *= x10 / e11, t10 *= s8, e11 *= s8, this._computedWidth = t10, this._computedHeight = e11;
  }
  _getPos(t10, e11) {
    return w2(Math.round(u7 * t10), Math.round(u7 * e11));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicMarkerTemplate.js
var k4 = n4();
var P2 = n2();
var L = class _L extends y5(r10) {
  constructor(t10, e11, i16) {
    super(t10), this._cimMarkerLayer = t10, this._minMaxZoom = w2(Math.round(e11 * me), Math.round(i16 * me));
    const r13 = t10.color;
    if (e6(r13)) {
      const t11 = (t12, e12, s8) => t2(r13(t12, e12, s8));
      this._dynamicPropertyMap.set("_fillColor", t11);
    } else
      this._fillColor = t2(r13);
    const y9 = t10.outlineColor;
    if (e6(y9)) {
      const t11 = (t12, e12, s8) => t2(y9(t12, e12, s8));
      this._dynamicPropertyMap.set("_outlineColor", t11);
    } else
      this._outlineColor = t2(y9);
    const p10 = t10.size;
    if (e6(p10)) {
      const t11 = (t12, e12, i17) => u(p10(t12, e12, i17));
      this._dynamicPropertyMap.set("_size", t11);
    } else
      this._size = u(p10) || 0;
    const M3 = t10.scaleX;
    e6(M3) ? this._dynamicPropertyMap.set("_scaleX", M3) : this._scaleX = M3;
    const d9 = t10.offsetX;
    if (e6(d9)) {
      const t11 = (t12, e12, i17) => u(d9(t12, e12, i17));
      this._dynamicPropertyMap.set("xOffset", t11);
    } else
      this.xOffset = u(d9) || 0;
    const u10 = t10.offsetY;
    if (e6(u10)) {
      const t11 = (t12, e12, i17) => u(u10(t12, e12, i17));
      this._dynamicPropertyMap.set("yOffset", t11);
    } else
      this.yOffset = u(u10) || 0;
    const g7 = t10.outlineWidth;
    if (e6(g7)) {
      const t11 = (t12, e12, i17) => u(g7(t12, e12, i17));
      this._dynamicPropertyMap.set("_outlineWidth", t11);
    } else
      this._outlineWidth = u(g7) || 0;
    const k7 = t10.rotation;
    if (e6(k7) ? this._dynamicPropertyMap.set("_angle", k7) : this._angle = k7 || 0, null != t10.effects) {
      const e12 = t10.effects;
      e6(e12) ? this._dynamicPropertyMap.set("_effects", e12) : this._effects = e12;
    }
    if (null != t10.markerPlacement) {
      const e12 = t10.markerPlacement;
      e6(e12) ? this._dynamicPropertyMap.set("_markerPlacement", e12) : this._markerPlacement = e12;
    }
    this._scaleFactor = t10.scaleFactor ?? 1, this._bitSet = (t10.alignment === i4.MAP ? ne : le) | (t10.colorLocked ? pe : 0) | (t10.scaleSymbolsProportionally ? xe : 0), this._materialKey = t10.materialKey;
  }
  static fromCIMMarker(t10, e11) {
    const [s8, i16] = v2(t10.scaleInfo, e11);
    return new _L(t10, s8, i16);
  }
  bindFeature(i16, r13, o11) {
    const a9 = i16.readLegacyFeature(), n10 = i16.getObjectId();
    this._dynamicPropertyMap.forEach((t10, e11) => {
      this[e11] = t10(a9, r13, o11);
    });
    const c12 = this._cimMarkerLayer.materialHash, h7 = "function" == typeof c12 ? c12(a9, r13, o11, n10) : c12, m6 = this._materialCache.get(h7);
    if (!m6 || !e9(m6.spriteMosaicItem) || !m6.spriteMosaicItem)
      return void s.getLogger("esri.views.2d.engine.webgl.WGLDynamicMarkerTemplate").error(new s2("mapview-cim", "Encountered an error when binding feature"));
    const l6 = m6.spriteMosaicItem, f9 = this._cimMarkerLayer.sizeRatio, M3 = l6.width / l6.height * this._scaleX, d9 = N.load(this._materialKey);
    d9.sdf = l6.sdf, d9.pattern = true, d9.textureBinding = l6.textureBinding, this._materialKey = d9.data;
    const u10 = this._cimMarkerLayer.rotateClockwise ? this._angle : -this._angle, L4 = this._size, j4 = L4 * M3, b6 = this.xOffset, z6 = this.yOffset;
    this.xOffset *= this._scaleFactor, this.yOffset *= this._scaleFactor;
    const x10 = this._cimMarkerLayer.scaleSymbolsProportionally && this._cimMarkerLayer.frameHeight ? this._size / u(this._cimMarkerLayer.frameHeight) : 1, O2 = this._outlineWidth * x10, w9 = u(this._cimMarkerLayer.referenceSize);
    let C6 = 0, W2 = 0;
    const F2 = this._cimMarkerLayer.anchorPoint;
    F2 && (this._cimMarkerLayer.isAbsoluteAnchorPoint ? this._size && (C6 = u(F2.x) / (this._size * M3), W2 = u(F2.y) / this._size) : (C6 = F2.x, W2 = F2.y)), this._anchorX = C6, this._anchorY = W2, this._sizeOutlineWidth = x(Math.round(Math.min(Math.sqrt(128 * j4), 255)), Math.round(Math.min(Math.sqrt(128 * L4), 255)), Math.round(Math.min(Math.sqrt(128 * O2), 255)), Math.round(Math.min(Math.sqrt(128 * w9), 255))), this.angle = u10;
    const S5 = Math.round(64 * f9);
    this._bitestAndDistRatio = w2(this._bitSet, S5), this._computeSize(j4, L4, f9, O2, this._scaleFactor, l6, d9.hasSizeVV(), true), this._applyTransformation(P2, k4), this.xOffset = b6, this.yOffset = z6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseTextTemplate.js
var a6 = 8;
var x7 = w2(4, 4);
var _3 = w2(16, 4);
var c10 = w2(4, 2);
var l4 = w2(4, 6);
var u8 = [c10, c10, l4, l4];
var g5 = [c10, l4, c10, l4];
var m4 = [l4, l4, x7, x7];
var f7 = [x7, x7, l4, l4];
var y6 = [l4, x7, l4, x7];
var p7 = [x7, l4, x7, l4];
var w6 = (x10) => class extends x10 {
  constructor(...e11) {
    super(...e11), this._isCIM = false, this._vertexBoundsScale = 1, this.geometryType = E.TEXT, this._aux = x(0, 0, this._referenceSize, this._bitset);
  }
  bindTextInfo(e11, t10) {
    this._shapingInfo = (e11 == null ? void 0 : e11.length) ? S2(e11, t10, { scale: this._scale, angle: this._angle, xOffset: this._xOffset, yOffset: this._yOffset, hAlign: this._xAlignD, vAlign: this._yAlignD, maxLineWidth: Math.max(32, Math.min(this._lineWidth, 512)), lineHeight: w * Math.max(0.25, Math.min(this._lineHeight, 4)), decoration: this._decoration, isCIM: this._isCIM, hasBackground: !!this._backgroundColor, borderLineSize: this._borderLineSize }) : null;
  }
  _write(e11, t10, r13, i16) {
    const o11 = t10.getDisplayId();
    this._writeGeometry(e11, t10, o11, r13, i16);
  }
  _writeGeometry(e11, t10, r13, i16, o11) {
    const s8 = this._shapingInfo;
    if (null == s8)
      return;
    if (this._textPlacement)
      return this._writePlacedText(e11, r13, s8, i16, t10, o11);
    const n10 = o11 ? o11.asOptimized() : "esriGeometryPolygon" === t10.geometryType ? t10.readCentroid() : t10.readGeometryForDisplay();
    if (null != n10) {
      if (n10.isPoint) {
        const [t11, i17] = n10.coords;
        if (!e11.hasAggregates && e11.hasPixelBufferEnabled && (t11 < 0 || t11 >= 512 || i17 < 0 || i17 >= 512))
          return;
        return this._writeGlyphs(e11, r13, { x: t11, y: i17 }, s8);
      }
      n10.forEachVertex((t11, i17) => this._writeGlyphs(e11, r13, { x: t11, y: i17 }, s8));
    }
  }
  _writePlacedText(i16, o11, s8, n10, h7, d9) {
    const a9 = this._textPlacement, x11 = d9 || a3.fromFeatureSetReaderCIM(h7);
    if (!x11)
      return;
    const _5 = -1, c12 = e10.getPlacement(x11, _5, a9, u(1), i16.tileKey, n10.geometryEngine);
    if (!c12)
      return;
    const l6 = s8.bounds, u10 = Math.sqrt(l6.height * l6.height + l6.width * l6.width);
    let g7, m6, f9;
    for (; g7 = c12.next(); )
      if (m6 = g7.tx, f9 = -g7.ty, m6 + u10 >= 0 && m6 - u10 < 512 && f9 + u10 >= 0 && f9 - u10 < 512) {
        const e11 = -g7.getAngle();
        s8.setRotation(e11), this._writeGlyphs(i16, o11, { x: m6, y: f9 }, s8), s8.setRotation(-e11);
      }
  }
  _writeGlyphs(e11, t10, r13, i16) {
    const o11 = U.load(this._materialKey), s8 = w2(Math.round(a6 * r13.x), Math.round(a6 * r13.y)), d9 = this._vertexBoundsScale, { bounds: x11, background: _5, glyphs: c12 } = i16;
    c12.length > 0 && (this._borderLineColor || this._backgroundColor) && (o11.textureBinding = c12[0].textureBinding, e11.recordStart(t10, o11.data, this.geometryType, true), this._writeBackgroundGeometry(e11, t10, r13, x11, _5), e11.recordEnd());
    const l6 = 2 * Math.max(x11.width, x11.height);
    for (const n10 of i16.glyphs)
      o11.textureBinding = n10.textureBinding, e11.recordStart(t10, o11.data, this.geometryType, true), e11.vertexBounds(r13.x + x11.x + this._xOffset, r13.y + x11.y - this._yOffset, l6 * d9, l6 * d9), this._writeVertices(e11, t10, s8, n10), e11.recordEnd();
  }
  _writeGlyph(e11, t10, r13, i16, o11) {
    const s8 = U.load(this._materialKey), d9 = w2(Math.round(a6 * r13), Math.round(a6 * i16));
    s8.textureBinding = o11.textureBinding, e11.recordStart(t10, s8.data, this.geometryType, true);
    const x11 = o11.bounds, _5 = this._vertexBoundsScale;
    e11.vertexBounds(r13 + x11.x * _5, i16 + x11.y * _5, x11.width * _5, x11.height * _5), this._writeVertices(e11, t10, d9, o11), e11.recordEnd();
  }
  _writeVertices(e11, t10, r13, i16) {
    const o11 = e11.vertexCount();
    this._writeVertexCommon(e11, t10, r13, i16), e11.vertexWrite(i16.offsets.upperLeft), e11.vertexWrite(i16.texcoords.upperLeft), e11.vertexEnd(), this._writeVertexCommon(e11, t10, r13, i16), e11.vertexWrite(i16.offsets.upperRight), e11.vertexWrite(i16.texcoords.upperRight), e11.vertexEnd(), this._writeVertexCommon(e11, t10, r13, i16), e11.vertexWrite(i16.offsets.lowerLeft), e11.vertexWrite(i16.texcoords.lowerLeft), e11.vertexEnd(), this._writeVertexCommon(e11, t10, r13, i16), e11.vertexWrite(i16.offsets.lowerRight), e11.vertexWrite(i16.texcoords.lowerRight), e11.vertexEnd(), e11.indexWrite(o11 + 0), e11.indexWrite(o11 + 1), e11.indexWrite(o11 + 2), e11.indexWrite(o11 + 1), e11.indexWrite(o11 + 3), e11.indexWrite(o11 + 2);
  }
  _writeVertexCommon(e11, t10, r13, i16) {
    const o11 = this._color, n10 = this._haloColor, h7 = x(0, 0, this._referenceSize, this._bitset), d9 = x(0, 0, this._size, this._haloSize);
    e11.vertexWrite(r13), e11.vertexWrite(t10), e11.vertexWrite(o11), e11.vertexWrite(n10), e11.vertexWrite(d9), e11.vertexWrite(h7), e11.vertexWrite(this._minMaxZoom);
  }
  _writeBackgroundVertex(e11, t10, r13, i16, o11, n10) {
    const h7 = x(0, 1, this._referenceSize, this._bitset), d9 = x(0, 0, this._size, this._haloSize), a9 = x(0, 0, 0, 0);
    e11.vertexWrite(r13), e11.vertexWrite(t10), e11.vertexWrite(i16), e11.vertexWrite(a9), e11.vertexWrite(d9), e11.vertexWrite(h7), e11.vertexWrite(this._minMaxZoom), e11.vertexWrite(o11), e11.vertexWrite(n10), e11.vertexEnd();
  }
  _writeBackgroundQuad(e11, t10, r13, i16, o11, s8) {
    const n10 = e11.vertexCount();
    this._writeBackgroundVertex(e11, t10, r13, i16, o11.upperLeft, s8[0]), this._writeBackgroundVertex(e11, t10, r13, i16, o11.upperRight, s8[1]), this._writeBackgroundVertex(e11, t10, r13, i16, o11.lowerLeft, s8[2]), this._writeBackgroundVertex(e11, t10, r13, i16, o11.lowerRight, s8[3]), e11.indexWrite(n10 + 0), e11.indexWrite(n10 + 1), e11.indexWrite(n10 + 2), e11.indexWrite(n10 + 1), e11.indexWrite(n10 + 3), e11.indexWrite(n10 + 2);
  }
  _writeBackgroundGeometry(e11, t10, r13, i16, o11) {
    const s8 = w2(Math.round(a6 * r13.x), Math.round(a6 * r13.y)), { x: h7, y: d9, width: x11, height: c12 } = i16, l6 = 2 * Math.max(x11, c12);
    if (e11.vertexBounds(r13.x + h7 + this._xOffset, r13.y + d9 - this._yOffset, l6 * this._vertexBoundsScale, l6 * this._vertexBoundsScale), this._backgroundColor) {
      const r14 = [_3, _3, _3, _3];
      this._writeBackgroundQuad(e11, t10, s8, this._backgroundColor, o11.main, r14);
    }
    if (this._borderLineColor || this._backgroundColor) {
      const r14 = !!this._borderLineColor && !!this._borderLineSize && this._borderLineSize > 0, [i17, n10, h8, d10, a9] = r14 ? [u8, u8, g5, g5, this._borderLineColor] : [m4, f7, y6, p7, this._backgroundColor];
      this._writeBackgroundQuad(e11, t10, s8, a9, o11.top, i17), this._writeBackgroundQuad(e11, t10, s8, a9, o11.bot, n10), this._writeBackgroundQuad(e11, t10, s8, a9, o11.left, h8), this._writeBackgroundQuad(e11, t10, s8, a9, o11.right, d10);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicTextTemplate.js
var y7 = 5;
function p8(t10, e11, i16, s8) {
  return "string" == typeof t10.text ? t10.text : "function" == typeof t10.text ? t10.text(e11, i16, s8) ?? "" : "";
}
var d6 = class _d extends w6(r10) {
  constructor(s8, o11, n10) {
    super(s8), this._horizontalAlignment = "center", this._verticalAlignment = "middle", this._textToGlyphs = /* @__PURE__ */ new Map(), this._minMaxZoom = w2(Math.round(o11 * me), Math.round(n10 * me));
    const c12 = s8.scaleFactor || 1;
    this._cimTextLayer = s8;
    const m6 = s8.color;
    if (e6(m6)) {
      const t10 = (t11, e11, i16) => t2(m6(t11, e11, i16));
      this._dynamicPropertyMap.set("_color", t10);
    } else
      this._color = t2(m6);
    const _5 = s8.outlineColor;
    if (e6(_5)) {
      const t10 = (t11, e11, i16) => t2(_5(t11, e11, i16));
      this._dynamicPropertyMap.set("_haloColor", t10);
    } else
      this._haloColor = t2(_5);
    let f9;
    e6(s8.size) || (f9 = Math.min(Math.round(u(s8.size * s8.sizeRatio)), 127));
    const p10 = (e11, o12, r13) => e6(s8.size) ? Math.min(Math.round(u(s8.size(e11, o12, r13) * s8.sizeRatio)), 127) : f9;
    if (this._dynamicPropertyMap.set("_size", p10), e6(s8.outlineSize)) {
      const e11 = (e12, i16, o12) => Math.min(Math.floor(y7 * u(s8.outlineSize(e12, i16, o12) * s8.sizeRatio)), 127);
      this._dynamicPropertyMap.set("_haloSize", e11);
    } else
      this._haloSize = Math.min(Math.floor(y7 * u(s8.outlineSize * s8.sizeRatio)), 127);
    let d9;
    e6(s8.offsetX) || (d9 = Math.round(u(s8.offsetX * s8.sizeRatio)));
    const M3 = (e11, o12, r13) => e6(s8.offsetX) ? Math.round(u(s8.offsetX(e11, o12, r13) * s8.sizeRatio)) : d9;
    let u10;
    this._dynamicPropertyMap.set("_xOffset", M3), e6(s8.offsetY) || (u10 = Math.round(u(s8.offsetY * s8.sizeRatio)));
    const g7 = (e11, o12, r13) => e6(s8.offsetY) ? Math.round(u(s8.offsetY(e11, o12, r13) * s8.sizeRatio)) : u10;
    if (this._dynamicPropertyMap.set("_yOffset", g7), e6(s8.angle) ? this._dynamicPropertyMap.set("_angle", s8.angle) : this._angle = s8.angle, e6(s8.horizontalAlignment) ? this._dynamicPropertyMap.set("_horizontalAlignment", s8.horizontalAlignment) : this._horizontalAlignment = s8.horizontalAlignment, e6(s8.verticalAlignment) ? this._dynamicPropertyMap.set("_verticalAlignment", s8.verticalAlignment) : this._verticalAlignment = s8.verticalAlignment, null != s8.effects) {
      const t10 = s8.effects;
      e6(t10) ? this._dynamicPropertyMap.set("_effects", t10) : this._effects = t10;
    }
    if (null != s8.markerPlacement) {
      const t10 = s8.markerPlacement;
      e6(t10) ? this._dynamicPropertyMap.set("_markerPlacement", t10) : this._textPlacement = t10;
    }
    e6(s8.text) ? this._dynamicPropertyMap.set("_text", s8.text) : this._text = s8.text, this._backgroundColor = s8.backgroundColor && t2(s8.backgroundColor), this._borderLineColor = s8.borderLineColor && t2(s8.borderLineColor), this._borderLineSize = s8.borderLineWidth, this._scaleFactor = c12;
    const z6 = Math.min(Math.round(u(s8.referenceSize * s8.sizeRatio)), 127);
    this._referenceSize = Math.round(Math.sqrt(256 * z6)), this._materialKey = s8.materialKey;
    const x10 = P.load(this._materialKey);
    x10.sdf = true, this._bitset = (s8.alignment === i4.MAP ? 1 : 0) | (s8.colorLocked ? 1 : 0) << 1, this._materialKey = x10.data, this._decoration = "none", this._lineHeight = 1, this._lineWidth = 512, this._isCIM = true;
  }
  static fromCIMText(t10, e11) {
    const [i16, s8] = v2(t10.scaleInfo, e11);
    return new _d(t10, i16, s8);
  }
  async analyze(t10, e11, i16, s8) {
    const o11 = e11.readLegacyFeature(), r13 = p8(this._cimTextLayer, o11, i16, s8), n10 = await super.analyze(t10, e11, i16, s8, n6(r13));
    return (n10 == null ? void 0 : n10.glyphMosaicItems) && this._textToGlyphs.set(r13, n10.glyphMosaicItems), n10;
  }
  bindFeature(t10, e11, i16) {
    const r13 = t10.readLegacyFeature();
    if (this._dynamicPropertyMap.forEach((t11, s8) => {
      this[s8] = t11(r13, e11, i16);
    }), !this._text || 0 === this._text.length)
      return void (this._shapingInfo = null);
    this._size *= this._scaleFactor, this._scale = this._size / b2, this._xOffset *= this._scaleFactor, this._yOffset *= this._scaleFactor, this._xAlignD = r4(this._horizontalAlignment ?? "center"), this._yAlignD = n3(this._verticalAlignment ?? "baseline");
    const a9 = this._textToGlyphs.get(this._text) ?? [];
    this.bindTextInfo(a9, false);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLFillTemplate.js
var K2 = class _K extends x6(r9) {
  constructor(t10, e11, l6, o11, r13, i16, s8, a9, n10, m6, c12, f9, d9, u10, M3, j4) {
    super(), this._effects = u10 || void 0;
    const w9 = w3.load(t10);
    e11 && (w9.sdf = e11.sdf, w9.pattern = true, w9.textureBinding = e11.textureBinding), this.fillColor = l6, this.tl = o11, this.br = r13, this.aux21 = w2(i16, s8), this.aux22 = w2(a9, n10), this.aux3 = x(m6, c12, f9, 0), this._bitset = d9, this._minMaxZoom = w2(Math.round(M3 * me), Math.round(j4 * me)), this._materialKey = w9.data;
  }
  static fromCIMFill(e11, h7, d9) {
    const y9 = e11.color, x10 = y9 && t2(y9) || 0, j4 = e11.materialKey, [w9, g7] = v2(e11.scaleInfo, d9);
    let F2 = (e11.colorLocked ? pe : 0) | (e11.applyRandomOffset ? ue : 0) | (e11.sampleAlphaOnly ? ge : 0) | (e11.hasUnresolvedReplacementColor ? ve : 0);
    if (!h7)
      return new _K(j4, null, x10, 0, 0, 0, 0, 0, 0, 0, 0, 0, F2, e11.effects, w9, g7);
    const { rect: _5, width: b6, height: L4 } = h7, C6 = e11.scaleX || 1, T = _5.x + ae, A3 = _5.y + ae, B3 = T + b6, G3 = A3 + L4, I = u(e11.height);
    let R2 = C6 * I;
    "CIMHatchFill" === e11.cim.type && (R2 *= b6 / L4);
    let S5 = I;
    S5 <= 0 && (S5 = G3 - A3), S5 < i2 && (S5 *= h, F2 |= ye), S5 = Math.round(S5);
    let U2 = R2;
    U2 <= 0 && (U2 = B3 - T), U2 < i2 && (U2 *= h, F2 |= be), U2 = Math.round(U2);
    const v6 = u(e11.offsetX || 0), O2 = u(-e11.offsetY || 0), W2 = w2(T, A3), X = w2(B3, G3);
    return new _K(j4, h7, x10, W2, X, U2, S5, v6, O2, h, h, c4(e11.angle), F2, e11.effects, w9, g7);
  }
  static fromSimpleFill(t10, l6, r13 = false) {
    const { color: i16 } = t10, s8 = i16 && "esriSFSNull" !== t10.style && o5(i16) || 0;
    let h7 = r13 ? pe : 0;
    const d9 = t10.materialKey;
    let u10;
    if (l6) {
      const { rect: t11, width: e11, height: o11, pixelRatio: r14 } = l6, i17 = t11.x + ae, y9 = t11.y + ae, x10 = i17 + e11, M3 = y9 + o11, g7 = w2(i17, y9), F2 = w2(x10, M3);
      let _5 = e11 / r14;
      _5 < i2 && (_5 *= h, h7 |= be), _5 = Math.round(_5);
      let b6 = o11 / r14;
      b6 < i2 && (b6 *= h, h7 |= ye), b6 = Math.round(b6), u10 = new _K(d9, l6, s8, g7, F2, _5, b6, 0, 0, h, h, 0, h7, null, n7, o7);
    } else
      u10 = new _K(d9, null, s8, 0, 0, 0, 0, 0, 0, 0, 0, 0, h7, null, n7, o7);
    return u10._maybeAddLineTemplate(t10), u10;
  }
  static fromPictureFill(e11, l6, r13 = false) {
    const i16 = a, { rect: s8, width: h7, height: u10 } = l6, y9 = s8.x + ae, x10 = s8.y + ae, M3 = y9 + h7, g7 = x10 + u10, F2 = w2(y9, x10), _5 = w2(M3, g7);
    let b6 = r13 ? pe : 0, L4 = u(e11.width);
    L4 < i2 && (L4 *= h, b6 |= be), L4 = Math.round(L4);
    let C6 = u(e11.height);
    C6 < i2 && (C6 *= h, b6 |= ye), C6 = Math.round(C6);
    const T = u(e11.xoffset), A3 = u(-e11.yoffset), B3 = e11.materialKey, G3 = new _K(B3, l6, i16, F2, _5, L4, C6, T, A3, h * e11.xscale, h * e11.yscale, 0, b6, null, n7, o7);
    return G3._maybeAddLineTemplate(e11), G3;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLMarkerTemplate.js
var z3 = class _z extends y5(r9) {
  constructor(t10, r13, s8, a9, d9, p10, y9, V2, _5, g7, z6, b6, k7, w9, B3, j4, C6, P4, v6, E4, T, A3, L4, R2) {
    super(), this.angle = a9, this.height = y9, this.width = p10, this.xOffset = r13 * v6, this.yOffset = s8 * v6, this._markerPlacement = E4 || void 0, this._effects = T || void 0, this._anchorX = j4, this._anchorY = C6, this._minMaxZoom = w2(Math.round(A3 * me), Math.round(L4 * me));
    const K3 = (w9 === i4.MAP ? ne : le) | (z6 ? pe : 0) | (k7 ? we : 0) | (b6 ? xe : 0), W2 = B3 && B3.sdf, X = N.load(t10);
    X.sdf = W2, X.pattern = true, X.textureBinding = B3.textureBinding, this._materialKey = X.data, this._fillColor = d9, this._outlineColor = _5, this._sizeOutlineWidth = x(Math.round(Math.min(Math.sqrt(128 * p10), 255)), Math.round(Math.min(Math.sqrt(128 * y9), 255)), Math.round(Math.min(Math.sqrt(128 * g7), 255)), Math.round(Math.min(Math.sqrt(128 * V2), 255))), X.symbologyType === S.PIE_CHART ? (p10 *= P4 * v6, y9 *= P4 * v6, this._computedWidth = p10, this._computedHeight = y9, this._texUpperLeft = w2(0, 1), this._texUpperRight = w2(1, 1), this._texBottomLeft = w2(0, 0), this._texBottomRight = w2(1, 0)) : this._computeSize(p10, y9, P4, g7, v6, B3, X.hasSizeVV(), R2);
    const q3 = Math.round(64 * P4);
    this._bitestAndDistRatio = w2(K3, q3);
    const Y = n4(), H = n2();
    this._applyTransformation(H, Y);
  }
  static fromCIMMarker(e11, o11, r13) {
    const a9 = o11 && o11.width || 1, n10 = o11 && o11.height || 1, l6 = e11.size, h7 = a9 / n10 * e11.scaleX, m6 = e11.scaleSymbolsProportionally && e11.frameHeight ? l6 / e11.frameHeight : 1, c12 = t2(e11.color), u10 = t2(e11.outlineColor), d9 = u(l6), f9 = d9 * h7, M3 = u(e11.offsetX || 0), S5 = u(e11.offsetY || 0), x10 = u(e11.outlineWidth || 0) * m6, y9 = e11.alignment || i4.SCREEN, V2 = u(e11.referenceSize), [_5, g7] = v2(e11.scaleInfo, r13);
    let b6 = e11.rotation || 0;
    e11.rotateClockwise || (b6 = -b6);
    let k7 = 0, w9 = 0;
    const B3 = e11.anchorPoint;
    B3 && (e11.isAbsoluteAnchorPoint ? l6 && (k7 = B3.x / (l6 * h7), w9 = B3.y / l6) : (k7 = B3.x, w9 = B3.y));
    const j4 = new _z(e11.materialKey, M3, S5, b6, c12, f9, d9, V2, u10, x10, e11.colorLocked, e11.scaleSymbolsProportionally, false, y9, o11, k7, w9, e11.sizeRatio, e11.scaleFactor ?? 1, e11.markerPlacement, e11.effects, _5, g7, true);
    return j4._vertexBoundsScaleX = e11.maxVVSize ? e11.maxVVSize / f9 : 1, j4._vertexBoundsScaleY = e11.maxVVSize ? e11.maxVVSize / d9 : 1, j4;
  }
  static fromPictureMarker(e11, o11) {
    const r13 = Math.round(u(e11.width)), s8 = Math.round(u(e11.height)), a9 = a, n10 = Math.round(u(e11.xoffset || 0)), l6 = Math.round(u(e11.yoffset || 0)), h7 = new _z(e11.materialKey, n10, l6, e11.angle, a9, r13, s8, s8, 0, 0, false, false, false, i4.SCREEN, o11, 0, 0, 1, 1, null, null, n7, o7, false);
    return h7._vertexBoundsScaleX = e11.maxVVSize ? e11.maxVVSize / e11.width : 1, h7._vertexBoundsScaleY = e11.maxVVSize ? e11.maxVVSize / e11.height : 1, h7;
  }
  static fromSimpleMarker(e11, o11) {
    const r13 = e11.style, s8 = o5(e11.color), n10 = Math.round(u(e11.size));
    let l6 = n10;
    "esriSMSTriangle" === r13 && (l6 *= o11.height / o11.width);
    const h7 = Math.round(u(e11.xoffset || 0)), m6 = Math.round(u(e11.yoffset || 0)), c12 = e11.outline, u10 = 0 | ((c12 == null ? void 0 : c12.color) && o5(c12.color)), d9 = 0 | ((c12 == null ? void 0 : c12.width) && Math.round(u(c12.width))), f9 = new _z(e11.materialKey, h7, m6, e11.angle ?? 0, s8, n10, l6, l6, u10, d9, false, false, "esriSMSCross" === r13 || "esriSMSX" === r13, i4.SCREEN, o11, 0, 0, 2, 1, null, null, n7, o7, false);
    return f9.boundsType = "esriSMSCircle" === r13 ? "circle" : "square", f9._vertexBoundsScaleX = e11.maxVVSize ? e11.maxVVSize / e11.size : 1, f9._vertexBoundsScaleY = e11.maxVVSize ? e11.maxVVSize / e11.size : 1, f9;
  }
  static fromLineSymbolMarker(e11, o11) {
    const s8 = o5(e11.color), n10 = 6, l6 = Math.round(u(n10 * e11.lineWidth)), h7 = l6, m6 = "cross" === e11.style || "x" === e11.style;
    let c12;
    switch (e11.placement) {
      case "begin-end":
        c12 = o3.Both;
        break;
      case "begin":
        c12 = o3.JustBegin;
        break;
      case "end":
        c12 = o3.JustEnd;
        break;
      default:
        c12 = o3.None;
    }
    const u10 = { type: "CIMMarkerPlacementAtExtremities", angleToLine: true, offset: 0, extremityPlacement: c12, offsetAlongLine: 0 }, d9 = new _z(e11.materialKey, 0, 0, 0, s8, l6, h7, h7 / n10, s8, m6 ? Math.round(u(e11.lineWidth)) : 0, false, false, m6, i4.MAP, o11, 0, 0, 2, 1, u10, null, n7, o7, false);
    return d9.boundsType = "circle" === e11.style ? "circle" : "square", d9;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLTextTemplate.js
var z4 = 5;
var g6 = class _g extends w6(r9) {
  constructor(e11, l6, a9, d9, _5, u10, b6, x10, g7, C6, M3, p10, S5, j4, L4, y9, T, V2, k7, A3, v6, W2, I, K3) {
    super(), this._xOffset = u(S5), this._yOffset = u(j4), this._decoration = C6 || "none", this._backgroundColor = W2, this._borderLineColor = I, this._borderLineSize = K3, this._color = _5, this._haloColor = u10, this._haloSize = Math.min(Math.floor(z4 * u(o(a9))), 127), this._size = Math.min(Math.round(u(l6)), 127);
    const R2 = Math.min(Math.round(u(d9 || l6)), 127);
    this._referenceSize = Math.round(Math.sqrt(256 * R2)), this._scale = this._size / b2, this._angle = p10, this._justify = s4(b6 || "center"), this._xAlignD = r4(b6 || "center"), this._yAlignD = n3(x10 || "baseline"), this._baseline = "baseline" === (x10 || "baseline"), this._bitset = (g7 === i4.MAP ? 1 : 0) | (M3 ? 1 : 0) << 1;
    const B3 = U.load(e11);
    B3.sdf = true, this._materialKey = B3.data, this._lineWidth = u(L4) || 512, this._lineHeight = y9 || 1, this._textPlacement = T, this._effects = V2, this._isCIM = k7 ?? false, this._minMaxZoom = w2(Math.round(A3 * me), Math.round(v6 * me));
  }
  static fromText(o11, t10) {
    var _a, _b;
    const r13 = (_a = o11.font) == null ? void 0 : _a.size, n10 = new _g(o11.materialKey, r13, o11.haloSize || 0, r13, o11.color && o5(o11.color) || 0, o11.haloColor && o5(o11.haloColor) || 0, o11.horizontalAlignment, o11.verticalAlignment, i4.SCREEN, (_b = o11.font) == null ? void 0 : _b.decoration, false, o11.angle || 0, o11.xoffset || 0, o11.yoffset || 0, o11.lineWidth || 0, o11.lineHeight || 0, null, null, false, n7, o7, o11.backgroundColor && o5(o11.backgroundColor), o11.borderLineColor && o5(o11.borderLineColor), o11.borderLineSize), [, s8] = i3(o11.text);
    return n10.bindTextInfo(t10 ?? [], s8), n10._vertexBoundsScale = o11.maxVVSize && r13 ? o11.maxVVSize / r13 : 1, n10;
  }
  static fromCIMText(o11, t10, i16) {
    const r13 = o11.scaleFactor || 1, n10 = o11.size * o11.sizeRatio * r13, [s8, l6] = v2(o11.scaleInfo, i16), m6 = new _g(o11.materialKey, n10, o11.outlineSize * o11.sizeRatio, o11.referenceSize, t2(o11.color), t2(o11.outlineColor), o11.horizontalAlignment, o11.verticalAlignment, o11.alignment, o11.decoration, o11.colorLocked ?? false, o11.angle, o11.offsetX * o11.sizeRatio * r13, o11.offsetY * o11.sizeRatio * r13, o11.lineWidth || 512, 1, o11.markerPlacement, o11.effects, true, s8, l6, o11.backgroundColor ? t2(o11.backgroundColor) : void 0, o11.borderLineColor ? t2(o11.borderLineColor) : void 0, o11.borderLineWidth), [, h7] = i3(o11.text);
    return m6.bindTextInfo(t10, h7), m6._vertexBoundsScale = o11.maxVVSize ? o11.maxVVSize / n10 : 1, m6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Lock.js
var r11 = class {
  constructor() {
    this._resolver = null;
  }
  isHeld() {
    return !!this._resolver;
  }
  async acquire() {
    this._resolver ? (await this._resolver.promise, await this.acquire()) : this._resolver = C();
  }
  release() {
    const e11 = this._resolver;
    this._resolver = null, e11 == null ? void 0 : e11.resolve();
  }
};
async function s7(e11, r13, s8) {
  try {
    await e11.acquire(), await r13(s8), e11.release();
  } catch (t10) {
    throw e11.release(), t10;
  }
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLTemplateStore.js
var S3 = s.getLogger("esri.views.2d.engine.webgl.mesh.templates.WGLTemplateStore");
var w7 = { sortKey: null, templates: new Array() };
var k5 = { isOutline: false, placement: null, symbologyType: S.DEFAULT, vvFlags: 0 };
var C4 = { ...r, hash: JSON.stringify(r), materialKey: f2(E.MARKER, k5) };
var L2 = { ...s3, hash: JSON.stringify(s3), materialKey: f2(E.LINE, k5) };
var b5 = { ...y, hash: JSON.stringify(y), materialKey: f2(E.FILL, k5) };
function E3(e11, t10) {
  const r13 = e11.length;
  return e11.push(null), t10.then((t11) => e11[r13] = t11), e11;
}
function G2(e11) {
  return null != e11 && !!(1 & e11);
}
function j3(e11) {
  return "worker:port-closed" === e11.name;
}
var x8 = class {
  constructor(e11, t10) {
    this._idCounter = 1, this._templateIdCounter = 1, this._idToTemplateGroup = /* @__PURE__ */ new Map(), this._symbolToTemplate = /* @__PURE__ */ new Map(), this._fetchQueue = [], this._idToResolver = /* @__PURE__ */ new Map(), this._cimTemplateCache = /* @__PURE__ */ new Map(), this._cimAnalyses = [], this._lock = new r11(), this._fetchResource = e11, this._tileInfo = t10;
  }
  get _markerError() {
    return this._errorTemplates.marker[0];
  }
  get _fillError() {
    return this._errorTemplates.fill[0];
  }
  get _lineError() {
    return this._errorTemplates.line[0];
  }
  get _textError() {
    return this._errorTemplates.line[0];
  }
  createTemplateGroup(e11, t10, r13 = null) {
    this._initErrorTemplates();
    const s8 = e11.hash, i16 = this._symbolToTemplate.get(s8);
    if (null != i16)
      return i16;
    const a9 = new Array(), o11 = { sortKey: r13, templates: a9 };
    t10 && this._createMeshTemplates(a9, t10, true), this._createMeshTemplates(a9, e11, false);
    const l6 = this._createGroupId("expanded-cim" === e11.type && F(e11));
    return this._idToTemplateGroup.set(l6, o11), this._symbolToTemplate.set(s8, l6), l6;
  }
  getTemplateGroup(e11) {
    return this._idToTemplateGroup.get(e11) ?? w7;
  }
  getDynamicTemplateGroup(e11) {
    return this._idToTemplateGroup.has(e11) ? (G2(e11) || S3.error("mapview-template-store", `Id ${e11} does not refer to a dynamic template`), this._idToTemplateGroup.get(e11)) : w7;
  }
  getMosaicItem(e11, t10) {
    const r13 = this._createTemplateId(), s8 = new Promise((e12) => this._idToResolver.set(r13, e12));
    return this._fetchQueue.push({ symbol: e11, id: r13, glyphIds: t10 }), s8;
  }
  finalize(e11) {
    return this._fetchQueue.length || this._lock.isHeld() ? s7(this._lock, this._fetchAllQueuedResources.bind(this), e11) : Promise.resolve();
  }
  _initErrorTemplates() {
    this._errorTemplates || (this._errorTemplates = { fill: this._createMeshTemplates([], b5, false), marker: this._createMeshTemplates([], C4, false), line: this._createMeshTemplates([], L2, false) });
  }
  _fetchAllQueuedResources(t10) {
    if (!this._fetchQueue.length)
      return Promise.resolve();
    const s8 = this._fetchQueue, i16 = this._cimAnalyses;
    return this._fetchQueue = [], this._cimAnalyses = [], Promise.all(i16).then(() => this._fetchResource(s8, t10).then((e11) => {
      for (const { id: t11, mosaicItem: r13 } of e11) {
        this._idToResolver.get(t11)(r13), this._idToResolver.delete(t11);
      }
    })).catch((t11) => {
      b(t11) ? this._fetchQueue = this._fetchQueue.concat(s8) : j3(t11) || S3.error(new s2("mapview-template-store", "Unable to fetch requested texture resources", t11));
    });
  }
  _createGroupId(e11) {
    return this._idCounter++ << 1 | (e11 ? 1 : 0);
  }
  _createTemplateId() {
    return this._templateIdCounter++;
  }
  async _createSMS(e11) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(e11);
    return e9(t10, S3) ? z3.fromSimpleMarker(e11, t10) : this._markerError;
  }
  async _createPMS(e11) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(e11);
    return e9(t10, S3) ? z3.fromPictureMarker(e11, t10) : this._markerError;
  }
  async _createSFS(e11, t10) {
    const { spriteMosaicItem: r13 } = await this.getMosaicItem(e11);
    return e9(r13, S3) ? K2.fromSimpleFill(e11, r13, t10) : this._fillError;
  }
  async _createPFS(e11, t10) {
    const { spriteMosaicItem: r13 } = await this.getMosaicItem(e11);
    return e9(r13, S3) ? K2.fromPictureFill(e11, r13, t10) : this._fillError;
  }
  async _createSLS(e11, t10) {
    const { spriteMosaicItem: r13 } = await this.getMosaicItem(e11);
    return e9(r13, S3) ? K.fromSimpleLine(e11, r13) : this._lineError;
  }
  async _createLMS(e11) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(e11);
    return e9(t10, S3) ? z3.fromLineSymbolMarker(e11, t10) : this._markerError;
  }
  async _createTS(e11) {
    const { glyphMosaicItems: t10 } = await this.getMosaicItem(e11);
    return g6.fromText(e11, t10 ?? []);
  }
  async _createCIMText(e11) {
    const { glyphMosaicItems: t10 } = await this.getMosaicItem(r5(e11), n6(e11.text));
    return e9(t10, S3) ? g6.fromCIMText(e11, t10, this._tileInfo) : this._textError;
  }
  async _createCIMFill(e11) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(r5(e11));
    return e9(t10, S3) ? K2.fromCIMFill(e11, t10, this._tileInfo) : this._fillError;
  }
  async _createCIMLine(e11) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(r5(e11));
    return e9(t10, S3) ? K.fromCIMLine(e11, t10, this._tileInfo) : this._lineError;
  }
  async _createCIMMarker(e11) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(r5(e11));
    return e9(t10, S3) ? z3.fromCIMMarker(e11, t10, this._tileInfo) : this._markerError;
  }
  async _createCIM(e11) {
    const t10 = e11.templateHash;
    let r13 = this._cimTemplateCache.get(t10);
    if (null != r13)
      return r13;
    switch (e11.type) {
      case "marker":
        r13 = await this._createCIMMarker(e11);
        break;
      case "line":
        r13 = await this._createCIMLine(e11);
        break;
      case "fill":
        r13 = await this._createCIMFill(e11);
        break;
      case "text":
        r13 = await this._createCIMText(e11);
    }
    return this._cimTemplateCache.set(t10, r13), r13;
  }
  async _createDynamicCIM(e11) {
    const t10 = e11.templateHash;
    let r13 = this._cimTemplateCache.get(t10);
    if (null != r13)
      return r13;
    switch (e11.type) {
      case "marker":
        r13 = L.fromCIMMarker(e11, this._tileInfo);
        break;
      case "line":
        r13 = d5.fromCIMLine(e11, this._tileInfo);
        break;
      case "fill":
        r13 = j2.fromCIMFill(e11, this._tileInfo);
        break;
      case "text":
        r13 = d6.fromCIMText(e11, this._tileInfo);
    }
    return this._cimTemplateCache.set(t10, r13), r13;
  }
  _createPrimitiveMeshTemplates(e11, t10, r13) {
    switch (t10.type) {
      case "esriSMS":
        return E3(e11, this._createSMS(t10));
      case "esriPMS":
        return E3(e11, this._createPMS(t10));
      case "esriSFS":
        return E3(e11, this._createSFS(t10, r13));
      case "line-marker":
        return E3(e11, this._createLMS(t10));
      case "esriPFS":
        return E3(e11, this._createPFS(t10, r13));
      case "esriSLS":
        return E3(e11, this._createSLS(t10, false));
      case "esriTS":
        return E3(e11, this._createTS(t10));
      default:
        return S3.error("Unable to create mesh template for unknown symbol type {: $ }{symbol.type}"), e11;
    }
  }
  _createMeshTemplates(e11, t10, r13) {
    if (t10.type.includes("3d"))
      return S3.error("3D symbols are not supported with MapView"), e11;
    if ("expanded-cim" === t10.type) {
      for (const r14 of t10.layers)
        "function" == typeof r14.materialHash ? E3(e11, this._createDynamicCIM(r14)) : E3(e11, this._createCIM(r14));
      return e11;
    }
    if ("composite-symbol" === t10.type) {
      for (const s8 of t10.layers)
        this._createPrimitiveMeshTemplates(e11, s8, r13);
      return e11;
    }
    return "cim" === t10.type || "label" === t10.type || "web-style" === t10.type ? e11 : this._createPrimitiveMeshTemplates(e11, t10, r13);
  }
};
var F = (e11) => {
  if (!e11.layers)
    return false;
  for (const t10 of e11.layers)
    if ("function" == typeof t10.materialHash)
      return true;
  return false;
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/segmentUtils.js
function n9(t10, e11) {
  return t10[e11 + 1];
}
function i15(t10) {
  return t10.length - 1;
}
function r12(t10) {
  let e11 = 0;
  for (let s8 = 0; s8 < i15(t10); s8++)
    e11 += h5(t10, s8);
  return e11;
}
function h5(t10, e11, s8 = 1) {
  const [i16, r13] = n9(t10, e11);
  return Math.sqrt(i16 * i16 + r13 * r13) * s8;
}
var a7 = class _a {
  constructor(t10, e11, s8, n10, i16) {
    this._segments = t10, this._index = e11, this._distance = s8, this._xStart = n10, this._yStart = i16, this._done = false;
  }
  static create(t10) {
    return new _a(t10, 0, 0, t10[0][0], t10[0][1]);
  }
  clone() {
    return new _a(this._segments, this._index, this._distance, this.xStart, this.yStart);
  }
  equals(t10) {
    return this._index === t10._index || t10._index === this._index - 1 && (0 === this._distance || 1 === t10._distance) || t10._index === this._index + 1 && (1 === this._distance || 0 === t10._distance);
  }
  leq(t10) {
    return this._index < t10._index || this._index === t10._index && this._distance <= t10._distance;
  }
  geq(t10) {
    return this._index > t10._index || this._index === t10._index && this._distance >= t10._distance;
  }
  get _segment() {
    return this._segments[this._index + 1];
  }
  get angle() {
    const t10 = this.dy, e11 = (0 * t10 + -1 * -this.dx) / (1 * this.length);
    let s8 = Math.acos(e11);
    return t10 > 0 && (s8 = 2 * Math.PI - s8), s8;
  }
  get xStart() {
    return this._xStart;
  }
  get yStart() {
    return this._yStart;
  }
  get x() {
    return this.xStart + this.distance * this.dx;
  }
  get y() {
    return this.yStart + this.distance * this.dy;
  }
  get dx() {
    return this._segment[0];
  }
  get dy() {
    return this._segment[1];
  }
  get xMidpoint() {
    return this.xStart + 0.5 * this.dx;
  }
  get yMidpoint() {
    return this.yStart + 0.5 * this.dy;
  }
  get xEnd() {
    return this.xStart + this.dx;
  }
  get yEnd() {
    return this.yStart + this.dy;
  }
  get length() {
    const { dx: t10, dy: e11 } = this;
    return Math.sqrt(t10 * t10 + e11 * e11);
  }
  get remainingLength() {
    return this.length * (1 - this._distance);
  }
  get backwardLength() {
    return this.length * this._distance;
  }
  get distance() {
    return this._distance;
  }
  get done() {
    return this._done;
  }
  hasPrev() {
    return this._index - 1 >= 0;
  }
  hasNext() {
    return this._index + 1 < i15(this._segments);
  }
  next() {
    return this.hasNext() ? (this._xStart += this.dx, this._yStart += this.dy, this._distance = 0, this._index += 1, this) : null;
  }
  prev() {
    return this.hasPrev() ? (this._index -= 1, this._xStart -= this.dx, this._yStart -= this.dy, this._distance = 1, this) : (this._done = true, null);
  }
  _seekBackwards(t10, e11) {
    const s8 = this.backwardLength;
    if (t10 <= s8)
      return this._distance = (s8 - t10) / this.length, this;
    let n10 = this.backwardLength;
    for (; this.prev(); ) {
      if (n10 + this.length > t10)
        return this._seekBackwards(t10 - n10);
      n10 += this.length;
    }
    return this._distance = 0, e11 ? this : null;
  }
  seek(t10, e11 = false) {
    if (t10 < 0)
      return this._seekBackwards(Math.abs(t10), e11);
    if (t10 <= this.remainingLength)
      return this._distance = (this.backwardLength + t10) / this.length, this;
    let s8 = this.remainingLength;
    for (; this.next(); ) {
      if (s8 + this.length > t10)
        return this.seek(t10 - s8, e11);
      s8 += this.length;
    }
    return this._distance = 1, e11 ? this : null;
  }
};
function d7(t10, e11, s8, n10 = true) {
  const i16 = r12(t10), h7 = a7.create(t10), d9 = i16 / 2;
  if (!n10)
    return h7.seek(d9), void s8(h7.clone(), 0, d9 + 0 * e11, i16);
  const c12 = Math.max((i16 - e11) / 2, 0), u10 = Math.floor(c12 / e11), o11 = d9 - u10 * e11;
  h7.seek(o11);
  for (let r13 = -u10; r13 <= u10; r13++)
    h7.x < 512 && h7.x >= 0 && h7.y < 512 && h7.y >= 0 && s8(h7.clone(), r13, d9 + r13 * e11, i16), h7.seek(e11);
}
function o9(t10, e11) {
  const s8 = e11;
  for (let n10 = 0; n10 < t10.length; n10++) {
    let e12 = t10[n10];
    _4(e12, s8);
    const i16 = [];
    i16.push(e12[0]);
    for (let t11 = 1; t11 < e12.length; t11++) {
      const [s9, n11] = e12[t11 - 1], [r13, h7] = e12[t11], a9 = Math.round(r13 - s9), d9 = Math.round(h7 - n11);
      i16.push([a9, d9]);
    }
    t10[n10] = i16, e12 = i16;
  }
  return t10;
}
function _4(n10, i16) {
  const r13 = 1e-6;
  if (i16 <= 0)
    return;
  const h7 = n10.length;
  if (h7 < 3)
    return;
  const a9 = [];
  let d9 = 0;
  a9.push(0);
  for (let e11 = 1; e11 < h7; e11++)
    d9 += u3(n10[e11], n10[e11 - 1]), a9.push(d9);
  i16 = Math.min(i16, 0.2 * d9);
  const c12 = [];
  c12.push(n10[0][0]), c12.push(n10[0][1]);
  const u10 = n10[h7 - 1][0], o11 = n10[h7 - 1][1], _5 = t8([0, 0], n10[0], n10[1]);
  r7(_5), n10[0][0] += i16 * _5[0], n10[0][1] += i16 * _5[1], t8(_5, n10[h7 - 1], n10[h7 - 2]), r7(_5), n10[h7 - 1][0] += i16 * _5[0], n10[h7 - 1][1] += i16 * _5[1];
  for (let t10 = 1; t10 < h7; t10++)
    a9[t10] += i16;
  a9[h7 - 1] += i16;
  const l6 = 0.5 * i16;
  for (let t10 = 1; t10 < h7 - 1; t10++) {
    let e11 = 0, s8 = 0, d10 = 0;
    for (let h8 = t10 - 1; h8 >= 0 && !(a9[h8 + 1] < a9[t10] - l6); h8--) {
      const c13 = l6 + a9[h8 + 1] - a9[t10], u11 = a9[h8 + 1] - a9[h8], o12 = a9[t10] - a9[h8] < l6 ? 1 : c13 / u11;
      if (Math.abs(o12) < r13)
        break;
      const _6 = o12 * o12, g7 = o12 * c13 - 0.5 * _6 * u11, x10 = o12 * u11 / i16, f9 = n10[h8 + 1], y9 = n10[h8][0] - f9[0], k7 = n10[h8][1] - f9[1];
      e11 += x10 / g7 * (f9[0] * o12 * c13 + 0.5 * _6 * (c13 * y9 - u11 * f9[0]) - _6 * o12 * u11 * y9 / 3), s8 += x10 / g7 * (f9[1] * o12 * c13 + 0.5 * _6 * (c13 * k7 - u11 * f9[1]) - _6 * o12 * u11 * k7 / 3), d10 += x10;
    }
    for (let c13 = t10 + 1; c13 < h7 && !(a9[c13 - 1] > a9[t10] + l6); c13++) {
      const h8 = l6 - a9[c13 - 1] + a9[t10], u11 = a9[c13] - a9[c13 - 1], o12 = a9[c13] - a9[t10] < l6 ? 1 : h8 / u11;
      if (Math.abs(o12) < r13)
        break;
      const _6 = o12 * o12, g7 = o12 * h8 - 0.5 * _6 * u11, x10 = o12 * u11 / i16, f9 = n10[c13 - 1], y9 = n10[c13][0] - f9[0], k7 = n10[c13][1] - f9[1];
      e11 += x10 / g7 * (f9[0] * o12 * h8 + 0.5 * _6 * (h8 * y9 - u11 * f9[0]) - _6 * o12 * u11 * y9 / 3), s8 += x10 / g7 * (f9[1] * o12 * h8 + 0.5 * _6 * (h8 * k7 - u11 * f9[1]) - _6 * o12 * u11 * k7 / 3), d10 += x10;
    }
    c12.push(e11 / d10), c12.push(s8 / d10);
  }
  c12.push(u10), c12.push(o11);
  for (let t10 = 0, e11 = 0; t10 < h7; t10++)
    n10[t10][0] = c12[e11++], n10[t10][1] = c12[e11++];
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLLabelTemplate.js
var x9 = s.getLogger("esri.views.2d.engine.webgl.WGLLabelTemplate");
var L3 = (t10, i16 = "mapview-labeling") => x9.error(new s2(i16, t10));
var S4 = 1;
var v5 = 0;
var P3 = 4;
var w8 = 25;
function M2(e11, t10) {
  const o11 = !!e11.minScale && t10.scaleToZoom(e11.minScale) || 0;
  return i(o11, 0, 25.5);
}
function Z3(e11, t10) {
  const o11 = !!e11.maxScale && t10.scaleToZoom(e11.maxScale) || 255;
  return i(o11, 0, 25.5);
}
function k6(e11) {
  const t10 = /* @__PURE__ */ new Map();
  return (i16) => (t10.has(i16) || t10.set(i16, e11(i16)), t10.get(i16));
}
var A2 = k6((e11) => {
  let t10 = 0;
  if (0 === e11)
    return 1 / 0;
  for (; !(e11 % 2); )
    t10++, e11 /= 2;
  return t10;
});
var B2 = (e11) => Math.floor(127 * e11 + 127);
var z5 = (e11) => Math.floor(e11 * me);
var C5 = (e11) => Math.round(e11 * (254 / 360));
var W = class _W extends g6 {
  constructor(e11, t10, i16, r13) {
    var _a, _b, _c;
    super(e11, (_a = i16.font) == null ? void 0 : _a.size, i16.haloSize || 0, (_b = i16.font) == null ? void 0 : _b.size, i16.color && o5(i16.color) || 0, i16.haloColor && o5(i16.haloColor) || 0, i16.horizontalAlignment, i16.verticalAlignment, i7(t10.labelPlacement) ? i4.MAP : i4.SCREEN, (_c = i16.font) == null ? void 0 : _c.decoration, false, i16.angle || 0, i16.xoffset, i16.yoffset, i16.lineWidth, i16.lineHeight, null, null, false, null, null, i16.backgroundColor && o5(i16.backgroundColor), i16.borderLineColor && o5(i16.borderLineColor), i16.borderLineSize), this._outLineLabelAngle = 0, this._refPlacementPadding = 0, this._refPlacementDirX = 0, this._refPlacementDirY = 0, this._refOffsetX = 0, this._refOffsetY = 0, this._zoomLevel = 0, this.geometryType = E.LABEL, this._allowOverrun = t10.allowOverrun ?? false, this._repeatLabel = t10.repeatLabel ?? true, this._labelPosition = t10.labelPosition ?? "curved";
    const n10 = M2(t10, r13), h7 = Z3(t10, r13), c12 = t10.labelPlacement, [g7, f9] = a2(c12);
    this._xAlignD = g7, this._yAlignD = f9, this._minZoom = n10, this._maxZoom = h7, this._minBackgroundZoom = n10, this._maxBackgroundZoom = h7, this._refPlacementPadding = u(i16.haloSize) + q, this._repeatLabelDistance = t10.repeatLabelDistance ? u(t10.repeatLabelDistance) : 128;
    const p10 = Z.load(e11);
    p10.sdf = true, this._materialKey = p10.data;
  }
  static fromLabelClass(e11, t10) {
    if ("esriServerLinePlacementCenterAlong" === e11.labelPlacement) {
      const t11 = e11.symbol;
      t11.xoffset = 0, t11.yoffset = 0, t11.angle = 0, t11.font.decoration = "none";
    }
    return new _W(e11.materialKey, e11, e11.symbol, t10);
  }
  get _shapedBox() {
    return this._shapingInfo.bounds;
  }
  setZoomLevel(e11) {
    this._zoomLevel = e11;
  }
  bindReferenceTemplate(e11) {
    let t10 = c3(this._xAlignD), i16 = o4(this._yAlignD);
    if (this._refOffsetX = 0, this._refOffsetY = 0, null == e11)
      return void (this._refSymbolAndPlacementOffset = x(0, 0, B2(t10), B2(i16)));
    if ("circle" === e11.boundsType && (t10 || i16)) {
      const e12 = Math.sqrt(t10 * t10 + i16 * i16);
      t10 /= e12, i16 /= e12;
    }
    const o11 = Math.max(e11.height, e11.width), r13 = this._refPlacementPadding * P3;
    this._refSymbolAndPlacementOffset = x(r13, o11, B2(t10), B2(i16)), this._referenceSize = o11, this._refPlacementDirX = t10, this._refPlacementDirY = i16, this._refOffsetX = e11.xOffset, this._refOffsetY = e11.yOffset;
  }
  _write(e11, t10) {
    if (null == this._shapingInfo)
      return;
    const i16 = this._shapingInfo, o11 = t10.getDisplayId(), r13 = "esriGeometryPolygon" === t10.geometryType ? t10.readLegacyCentroid() : t10.readLegacyGeometry();
    if (r13)
      switch (this._current = { out: e11, inId: o11, inShaping: i16, zoomLevel: this._zoomLevel }, "esriGeometryPolyline" === t10.geometryType && "curved" === this._labelPosition && (this._borderLineColor || this._backgroundColor) && x9.warnOnce("TextSymbol properties 'borderLineColor', 'borderLineSize', and 'backgroundColor' are not supported in curved labels"), t10.geometryType) {
        case "esriGeometryPolyline":
          this._placeLineLabels(r13);
          break;
        case "esriGeometryPoint":
        case "esriGeometryPolygon":
          this._placePointLabels(r13);
          break;
        default:
          L3(`Geometry of type ${t10.geometryType} is not supported`);
      }
  }
  _isVisible(e11, t10) {
    const i16 = z5(this._current.zoomLevel);
    return z5(e11) <= i16 && i16 <= z5(t10);
  }
  _placePointLabels(e11) {
    const { out: t10, inId: i16, inShaping: o11 } = this._current;
    this._writeGlyphs(t10, i16, e11, o11);
  }
  _placeLineLabels(e11) {
    const t10 = o9(e11.paths, this._current.inShaping.bounds.width), i16 = this._placeSubdivGlyphs.bind(this), o11 = (this._shapedBox.width + this._repeatLabelDistance) / (1 << S4);
    for (const r13 of t10)
      d7(r13, o11, i16, this._repeatLabel);
  }
  _placeSubdivGlyphs(e11, t10, i16, o11) {
    const r13 = A2(t10), n10 = this._shapedBox.width / (1 << S4), s8 = Math.sqrt(this._repeatLabelDistance) / (1 << S4), a9 = Math.min(i16, o11 - i16), l6 = this._current.inShaping.isMultiline ? w8 : Math.log2(a9 / (s8 + n10 / 2)), h7 = 0 === t10 ? l6 : Math.min(r13, l6), c12 = Math.max(this._minZoom, this._current.zoomLevel + S4 - h7), m6 = this._current.zoomLevel - c12, _5 = this._shapedBox.width / 2 * 2 ** m6;
    this._current.inShaping.isMultiline ? 0 === t10 && this._placeStraight(e11, c12) : this._allowOverrun && m6 < 0 ? this._placeStraightAlong(e11, this._minZoom) : "parallel" === this._labelPosition ? this._placeStraightAlong(e11, c12) : "curved" === this._labelPosition && this._placeCurved(e11, c12, _5);
  }
  _placeStraight(e11, t10) {
    const { out: i16, inId: o11, inShaping: r13 } = this._current, n10 = Math.ceil(e11.angle * (180 / Math.PI) % 360), s8 = Math.ceil((e11.angle * (180 / Math.PI) + 180) % 360);
    this._outLineLabelAngle = C5(n10), this._writeGlyphs(i16, o11, e11, r13, t10), this._outLineLabelAngle = C5(s8), this._writeGlyphs(i16, o11, e11, r13, t10);
  }
  _placeCurved(e11, t10, i16) {
    const { out: o11, inId: r13 } = this._current;
    o11.metricStart(r13, t10, e11.x, e11.y, 0, 0, 0, 0);
    const n10 = e11.clone(), s8 = e11.angle * (180 / Math.PI) % 360, a9 = (e11.angle * (180 / Math.PI) + 180) % 360;
    this._outLineLabelAngle = C5(s8), this._placeFirst(n10, t10, 1), this._placeBack(e11, n10, t10, i16, 1), this._placeForward(e11, n10, t10, i16, 1), this._outLineLabelAngle = C5(a9), this._placeFirst(n10, t10, 0), this._placeBack(e11, n10, t10, i16, 0), this._placeForward(e11, n10, t10, i16, 0), o11.metricEnd();
  }
  _placeStraightAlong(e11, t10) {
    const { out: i16, inId: o11, inShaping: s8 } = this._current;
    i16.metricStart(o11, t10, e11.x, e11.y, 0, 0, 0, 0);
    const a9 = e11.clone(), l6 = e11.angle * (180 / Math.PI) % 360, h7 = (e11.angle * (180 / Math.PI) + 180) % 360, c12 = s8.glyphs.length > 0 && (this._borderLineColor || this._backgroundColor);
    if (this._maxBackgroundZoom = w8, this._minBackgroundZoom = Math.max(t10, 0), c12) {
      const t11 = Z.load(this._materialKey);
      t11.textureBinding = s8.glyphs[0].textureBinding;
      const a10 = h2(n2(), -e11.angle), [c13, m6] = s8.shapeBackground(a10);
      this._outLineLabelAngle = C5(l6), i16.recordStart(o11, t11.data, this.geometryType, true), this._writeBackgroundGeometry(i16, o11, e11, c13, m6), i16.recordEnd(), this._outLineLabelAngle = C5(h7), i16.recordStart(o11, t11.data, this.geometryType, true), this._writeBackgroundGeometry(i16, o11, e11, c13, m6), i16.recordEnd();
    }
    this._outLineLabelAngle = C5(l6), this._placeFirst(a9, t10, 1, true), this._outLineLabelAngle = C5(h7), this._placeFirst(a9, t10, 0, true), i16.metricEnd();
  }
  _placeBack(e11, t10, i16, o11, r13) {
    const n10 = e11.clone();
    let s8 = e11.backwardLength + v5;
    for (; n10.prev() && !(s8 >= o11); )
      this._placeOnSegment(n10, t10, s8, i16, -1, r13), s8 += n10.length + v5;
  }
  _placeForward(e11, t10, i16, o11, r13) {
    const n10 = e11.clone();
    let s8 = e11.remainingLength + v5;
    for (; n10.next() && !(s8 >= o11); )
      this._placeOnSegment(n10, t10, s8, i16, 1, r13), s8 += n10.length + v5;
  }
  _placeFirst(e11, t10, i16, o11 = false) {
    const r13 = e11, n10 = this._current.inShaping, s8 = n10.glyphs, a9 = this._current.zoomLevel, { out: l6, inId: h7 } = this._current;
    for (const c12 of s8) {
      const s9 = c12.x > n10.bounds.x ? i16 : 1 - i16, m6 = s9 * e11.remainingLength + (1 - s9) * e11.backwardLength, _5 = Math.abs(c12.x + c12.width / 2 - n10.bounds.x), g7 = Math.max(0, a9 + Math.log2(_5 / (m6 + v5))), d9 = Math.max(t10, o11 ? 0 : g7);
      if (c12.maxZoom = w8, c12.angle = e11.angle + (1 - i16) * Math.PI, c12.minZoom = d9, this._writeGlyph(l6, h7, r13.x, r13.y, c12), i16 && this._isVisible(c12.minZoom, c12.maxZoom)) {
        const e12 = c12.bounds;
        l6.metricBoxWrite(e12.center[0], e12.center[1], e12.width, e12.height);
      }
    }
  }
  _placeOnSegment(e11, t10, i16, o11, r13, n10) {
    const s8 = this._current.inShaping.glyphs, { out: a9, inId: l6 } = this._current, h7 = this._current.inShaping, c12 = this._current.zoomLevel, m6 = e11.dx / e11.length, _5 = e11.dy / e11.length, g7 = { x: e11.x + i16 * -r13 * m6, y: e11.y + i16 * -r13 * _5 };
    for (const d9 of s8) {
      const s9 = d9.x > h7.bounds.x ? n10 : 1 - n10;
      if (!(s9 && 1 === r13 || !s9 && -1 === r13))
        continue;
      const m7 = Math.abs(d9.x + d9.width / 2 - h7.bounds.x), _6 = Math.max(0, c12 + Math.log2(m7 / i16) - 0.1), f9 = Math.max(o11, c12 + Math.log2(m7 / (i16 + e11.length + v5)));
      if (0 !== _6 && (d9.angle = e11.angle + (1 - n10) * Math.PI, d9.minZoom = f9, d9.maxZoom = _6, this._writeGlyph(a9, l6, g7.x, g7.y, d9), n10 && this._isVisible(d9.minZoom, d9.maxZoom))) {
        const i17 = d9.bounds, o12 = e11.x - t10.x, r14 = e11.y - t10.y;
        a9.metricBoxWrite(i17.center[0] + o12, i17.center[1] + r14, i17.width, i17.height);
      }
    }
  }
  _writeGlyphs(e11, t10, i16, o11, r13 = this._minZoom) {
    if (i16.x < 0 || i16.x >= 512 || i16.y < 0 || i16.y >= 512)
      return;
    if (o11.glyphs.length > 0 && (this._borderLineColor || this._backgroundColor)) {
      const r14 = Z.load(this._materialKey);
      r14.textureBinding = o11.glyphs[0].textureBinding, e11.recordStart(t10, r14.data, this.geometryType, true), this._writeBackgroundGeometry(e11, t10, i16, o11.bounds, o11.background), e11.recordEnd();
    }
    const n10 = i16.x + this._refOffsetX, s8 = i16.y - this._refOffsetY;
    for (const c12 of o11.glyphs)
      c12.minZoom = r13, c12.maxZoom = this._maxZoom, this._writeGlyph(e11, t10, n10, s8, c12);
    const a9 = this._refPlacementDirX, l6 = this._refPlacementDirY, h7 = o11.boundsT;
    e11.metricStart(t10, r13, n10, s8, a9, l6, this._referenceSize, this._materialKey), e11.metricBoxWrite(h7.center[0], h7.center[1], h7.width, h7.height), e11.metricEnd();
  }
  _writeVertexCommon(e11, t10, i16, o11) {
    const r13 = this._color, n10 = this._haloColor, s8 = x(0, 0, this._size, this._haloSize), a9 = Math.max(o11.minZoom, this._minZoom), l6 = Math.min(o11.maxZoom, this._maxZoom), h7 = x(z5(a9), z5(l6), this._outLineLabelAngle, 0);
    e11.vertexWrite(i16), e11.vertexWrite(t10), e11.vertexWrite(r13), e11.vertexWrite(n10), e11.vertexWrite(s8), e11.vertexWrite(this._refSymbolAndPlacementOffset), e11.vertexWrite(h7);
  }
  _writeBackgroundVertex(e11, t10, i16, o11, r13, n10) {
    const s8 = x(0, 0, this._size, this._haloSize), a9 = x(0, 0, 0, 0), l6 = x(z5(this._minBackgroundZoom), z5(this._maxBackgroundZoom), this._outLineLabelAngle, 1);
    e11.vertexWrite(i16), e11.vertexWrite(t10), e11.vertexWrite(o11), e11.vertexWrite(a9), e11.vertexWrite(s8), e11.vertexWrite(this._refSymbolAndPlacementOffset), e11.vertexWrite(l6), e11.vertexWrite(r13), e11.vertexWrite(n10), e11.vertexEnd();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/factories/WGLMeshFactory.js
var a8 = class {
  constructor(e11, t10, r13) {
    this._geometryType = e11, this._idField = t10, this._templateStore = r13;
  }
  update(e11, t10) {
    null != e11.mesh.labels && (this._labelTemplates = this._createLabelTemplates(e11.mesh.labels, t10)), this._schema = e11;
  }
  _createLabelTemplates(e11, t10) {
    const r13 = /* @__PURE__ */ new Map();
    if ("simple" === e11.type) {
      for (const s8 of e11.classes) {
        const e12 = W.fromLabelClass(s8, t10);
        r13.set(s8.index, e12);
      }
      return r13;
    }
    for (const s8 in e11.classes) {
      const i16 = e11.classes[s8];
      for (const e12 of i16) {
        const s9 = W.fromLabelClass(e12, t10);
        r13.set(e12.index, s9);
      }
    }
    return r13;
  }
  get templates() {
    return this._templateStore;
  }
  async analyze(l6, s8, a9, o11, n10, p10, m6) {
    if (c(m6))
      return;
    let f9;
    "dictionary" === (a9 == null ? void 0 : a9.type) && (f9 = await a9.analyze(this._idField, l6.copy(), s8, n10, p10, m6));
    let u10 = 0;
    for (; l6.next(); ) {
      let e11 = null;
      if (e11 = f9 ? f9[u10++] : null != o11 && p(l6.getDisplayId()) && 1 !== l6.readAttribute("cluster_count") ? o11.match(this._idField, l6, this._geometryType, n10, p10) : a9.match(this._idField, l6, this._geometryType, n10, p10), l6.setGroupId(e11), G2(e11)) {
        const t10 = this._templateStore.getDynamicTemplateGroup(e11).templates;
        for (const e12 of t10)
          e12 && e12.analyze && e12.analyze(this._templateStore, l6, n10, p10);
      }
    }
    return await i5(), this._templateStore.finalize(m6);
  }
  async analyzeGraphics(r13, l6, s8, a9, o11, n10) {
    if (c(n10))
      return;
    const p10 = r13.getCursor();
    for (s8 && await s8.analyze(this._idField, p10.copy(), l6, a9, o11, n10); p10.next(); ) {
      let e11 = p10.getGroupId();
      if (null != e11 && -1 !== e11 || (e11 = s8 == null ? void 0 : s8.match(this._idField, p10, p10.geometryType, a9, o11), p10.setGroupId(e11)), G2(e11)) {
        const t10 = this._templateStore.getDynamicTemplateGroup(e11).templates;
        for (const e12 of t10)
          e12 && e12.analyze && e12.analyze(this._templateStore, p10, a9, o11);
      }
      p10.setGroupId(e11);
    }
    return await i5(), this._templateStore.finalize(n10);
  }
  writeGraphic(e11, t10, r13, l6) {
    const s8 = t10.getGroupId(), a9 = t10.getDisplayId(), o11 = this._templateStore.getTemplateGroup(s8);
    if (e11.featureStart(t10.insertAfter, 0), null != a9) {
      if (G2(s8))
        for (const e12 of o11.templates)
          e12 && e12.bindFeature(t10, null, null);
      if (o11) {
        for (const s9 of o11.templates)
          s9 && s9.write(e11, t10, r13, l6);
        e11.featureEnd();
      }
    }
  }
  writeCursor(e11, t10, r13, l6, s8, a9, o11) {
    const n10 = t10.getGroupId(), p10 = t10.getDisplayId(), m6 = this._templateStore.getTemplateGroup(n10), f9 = m6.templates, u10 = this._getSortKeyValue(t10, m6);
    if (e11.featureStart(0, u10), null == p10)
      return;
    if (!f9)
      return;
    if (G2(n10))
      for (const i16 of f9)
        i16.bindFeature(t10, r13, l6);
    for (const i16 of f9)
      i16.write(e11, t10, s8, o11);
    if (!!f9.length && null != a9) {
      const r14 = a9 && this._findLabelRef(f9);
      this._writeLabels(e11, t10, a9, r14, s8, o11);
    }
    e11.featureEnd();
  }
  _getSortKeyValue(e11, t10) {
    const r13 = this._schema.mesh.sortKey;
    if (null == r13)
      return 0;
    let l6 = 0;
    return l6 = true === r13.byRenderer && null != t10.sortKey ? t10.sortKey : null != r13.fieldIndex ? e11.getComputedNumericAtIndex(r13.fieldIndex) : null != r13.field ? e11.readAttribute(r13.field) : e11.readAttribute(this._idField), l6 *= "asc" === r13.order ? 1 : -1, null == l6 || isNaN(l6) ? 0 : l6;
  }
  _findLabelRef(e11) {
    for (const t10 of e11)
      if (t10 instanceof z3)
        return t10;
    return null;
  }
  _writeLabels(e11, t10, r13, l6, s8, i16) {
    for (const a9 of r13)
      if (null != a9 && a9) {
        const { glyphs: r14, rtl: o11, index: n10 } = a9, p10 = this._labelTemplates.get(n10);
        if (!p10)
          continue;
        p10.setZoomLevel(s8), p10.bindReferenceTemplate(l6), p10.bindTextInfo(r14, o11), p10.write(e11, t10, null, i16);
      }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Matcher.js
var l5 = s.getLogger("esri/views/2d/engine/webgl/util/Matcher");
async function o10(e11, t10, s8, r13) {
  switch (e11.type) {
    case "simple":
    case "heatmap":
      return u9.fromBasicRenderer(e11, t10, s8, r13);
    case "map":
      return d8.fromUVRenderer(e11, t10, s8, r13);
    case "interval":
      return m5.fromCBRenderer(e11, t10, s8, r13);
    case "dictionary":
      return y8.fromDictionaryRenderer(e11, t10, s8, r13);
    case "pie-chart":
      return c11.fromPieChartRenderer(e11, t10, s8, r13);
    case "subtype":
      return c11.fromSubtypes(e11, t10, s8, r13);
  }
}
var u9 = class _u {
  constructor() {
    this.type = "feature", this._defaultResult = null;
  }
  static async fromBasicRenderer(e11, t10, s8, r13) {
    const i16 = new _u();
    if (e11.symbol) {
      const a9 = await i8(e11.symbol, s8, r13), l6 = t10.createTemplateGroup(a9, null);
      i16.setDefault(l6);
    }
    return i16;
  }
  static async fromPieChartRenderer(e11, t10, s8, r13) {
    const i16 = new _u();
    if (e11.markerSymbol) {
      const a9 = await i8(e11.markerSymbol, s8, r13);
      let l6;
      e11.fillSymbol && (l6 = await i8(e11.fillSymbol, s8, r13));
      const o11 = t10.createTemplateGroup(a9, l6);
      i16.setDefault(o11);
    }
    return i16;
  }
  size() {
    return 1;
  }
  getDefault() {
    return this._defaultResult;
  }
  setDefault(e11) {
    this._defaultResult = e11;
  }
  match(e11, t10, s8, r13, i16) {
    return this.getDefault();
  }
  async analyze(e11, t10, s8, r13, i16, a9) {
    return null;
  }
};
var c11 = class _c extends u9 {
  constructor(e11, t10) {
    super(), this._subMatchers = e11, this._subtypeField = t10;
  }
  static async fromSubtypes(e11, t10, s8, r13) {
    const i16 = /* @__PURE__ */ new Map(), a9 = [];
    for (const n10 in e11.renderers) {
      const l6 = parseInt(n10, 10), u10 = o10(e11.renderers[n10], t10, s8, r13).then((e12) => i16.set(l6, e12));
      a9.push(u10);
    }
    return await Promise.all(a9), new _c(i16, e11.subtypeField);
  }
  match(e11, t10, s8, r13, i16) {
    const a9 = t10.readAttribute(this._subtypeField), n10 = this._subMatchers.get(a9);
    return n10 ? n10.match(e11, t10, s8, r13, i16) : null;
  }
};
var m5 = class _m extends u9 {
  constructor(e11, t10, s8, r13) {
    super(), this.type = "interval", this._intervals = [], this._isMaxInclusive = t10, this._fieldIndex = r13, this._field = e11, this._normalizationInfo = s8;
  }
  static async fromCBRenderer(e11, t10, s8, r13) {
    const { isMaxInclusive: i16, normalizationField: a9, normalizationTotal: l6, normalizationType: o11 } = e11, u10 = e11.field, c12 = new _m(u10, i16, { normalizationField: a9, normalizationTotal: l6, normalizationType: o11 }, e11.fieldIndex), d9 = await i8(e11.backgroundFillSymbol, s8, r13);
    await Promise.all(e11.intervals.map(async (e12) => {
      const i17 = await i8(e12.symbol, s8, r13), a10 = t10.createTemplateGroup(i17, d9), l7 = { min: e12.min, max: e12.max };
      c12.add(l7, a10);
    }));
    const h7 = await i8(e11.defaultSymbol, s8, r13);
    if (h7) {
      const e12 = t10.createTemplateGroup(h7, d9);
      c12.setDefault(e12);
    }
    return c12;
  }
  add(e11, t10) {
    this._intervals.push({ interval: e11, result: t10 }), this._intervals.sort((e12, t11) => e12.interval.min - t11.interval.min);
  }
  size() {
    return super.size() + this._intervals.length;
  }
  match(e11, t10, s8, r13, i16) {
    if (null == this._fieldIndex && !this._field)
      return this.getDefault();
    const a9 = null != this._fieldIndex ? t10.getComputedNumericAtIndex(this._fieldIndex) : this._getValueFromField(t10);
    if (null == a9 || isNaN(a9) || a9 === 1 / 0 || a9 === -1 / 0)
      return this.getDefault();
    for (let n10 = 0; n10 < this._intervals.length; n10++) {
      const { interval: e12, result: t11 } = this._intervals[n10], s9 = a9 >= e12.min, r14 = this._isMaxInclusive ? a9 <= e12.max : a9 < e12.max;
      if (s9 && r14)
        return t11;
    }
    return this.getDefault();
  }
  _needsNormalization() {
    const e11 = this._normalizationInfo;
    return e11 && (e11.normalizationField || e11.normalizationTotal || e11.normalizationType);
  }
  _getValueFromField(e11) {
    const t10 = e11.readAttribute(this._field);
    if (!this._needsNormalization() || null == t10)
      return t10;
    const { normalizationField: s8, normalizationTotal: r13, normalizationType: i16 } = this._normalizationInfo, a9 = e11.readAttribute(s8) ?? 1;
    if (i16)
      switch (i16) {
        case "esriNormalizeByField":
          return a9 ? t10 / a9 : void 0;
        case "esriNormalizeByLog":
          return Math.log(t10) * Math.LOG10E;
        case "esriNormalizeByPercentOfTotal":
          return t10 / r13 * 100;
        default:
          return void l5.error(`Found unknown normalization type: ${i16}`);
      }
    else
      l5.error("Normalization is required, but no type was set!");
  }
};
var d8 = class _d extends u9 {
  constructor(e11, t10, s8) {
    super(), this.type = "map", this._nullResult = null, this._resultsMap = /* @__PURE__ */ new Map(), this._fields = [], this._fieldsIndex = s8, this._fields = e11, this._seperator = t10 || "";
  }
  static async fromUVRenderer(e11, t10, s8, r13) {
    const i16 = e11.fieldDelimiter, a9 = [e11.field];
    e11.field2 && a9.push(e11.field2), e11.field3 && a9.push(e11.field3);
    const l6 = await i8(e11.backgroundFillSymbol, s8, r13), o11 = new _d(a9, i16, e11.fieldIndex);
    await Promise.all(e11.map.map(async (e12, i17) => {
      const a10 = await i8(e12.symbol, s8, r13), u11 = i17 + 1, c12 = t10.createTemplateGroup(a10, l6, u11);
      "<Null>" === e12.value ? o11.setNullResult(c12) : o11.add(e12.value, c12);
    }));
    const u10 = await i8(e11.defaultSymbol, s8, r13);
    if (u10) {
      const e12 = Number.MAX_SAFE_INTEGER, s9 = t10.createTemplateGroup(u10, l6, e12);
      o11.setDefault(s9);
    }
    return o11;
  }
  setNullResult(e11) {
    this._nullResult = e11;
  }
  add(e11, t10) {
    this._resultsMap.set(e11.toString(), t10);
  }
  size() {
    return super.size() + this._resultsMap.size;
  }
  match(e11, t10, s8, r13, i16) {
    if (null == this._fieldsIndex && !this._fields)
      return this.getDefault();
    const a9 = null != this._fieldsIndex ? t10.getComputedStringAtIndex(this._fieldsIndex) : this._getValueFromFields(t10);
    if (null !== this._nullResult && (null == a9 || "" === a9 || "<Null>" === a9))
      return this._nullResult;
    if (null == a9)
      return this.getDefault();
    const n10 = a9.toString();
    return this._resultsMap.has(n10) ? this._resultsMap.get(n10) : this.getDefault();
  }
  _getValueFromFields(e11) {
    const t10 = [];
    for (const s8 of this._fields) {
      const r13 = e11.readAttribute(s8);
      null == r13 || "" === r13 ? t10.push("<Null>") : t10.push(r13);
    }
    return t10.join(this._seperator);
  }
};
async function h6(e11, t10) {
  const s8 = e11 || 1;
  if ("number" == typeof s8)
    return (e12, t11, r14) => s8;
  const r13 = await n5(s8, t10.spatialReference, t10.fields);
  return (e12, s9, i16) => s5(r13, e12, { $view: i16 }, t10.geometryType, s9) || 1;
}
var f8;
async function p9() {
  return f8 || (f8 = import("./createSymbolSchema-46DWD7BQ.js")), f8;
}
var y8 = class _y extends u9 {
  constructor(e11, t10, s8, i16, a9, n10) {
    super(), this.type = "dictionary", this._groupIdCache = new e(100), this._loader = e11, this._fieldMap = e11.fieldMap, this._symbolFields = e11.getSymbolFields(), this._templates = t10, this._info = s8, this._scaleFn = i16, this._schemaUtilsModule = a9, this._symbolOptions = n10;
  }
  static async fromDictionaryRenderer(e11, t10, s8, r13) {
    const [{ DictionaryLoader: i16 }, a9] = await Promise.all([import("./DictionaryLoader-U3U3X52C.js"), p9()]), n10 = new i16(e11.url, e11.config, e11.fieldMap);
    await n10.fetchResources({ spatialReference: s8.spatialReference, fields: s8.fields });
    const l6 = await h6(e11.scaleExpression, s8);
    return new _y(n10, t10, s8, l6, a9, e11.symbolOptions);
  }
  async _analyzeFeature(e11, s8, r13, i16, a9) {
    const o11 = e11.readLegacyFeature(), u10 = this._scaleFn(o11, r13, i16), c12 = this._attributeHash(o11) + "-" + u10, m6 = this._groupIdCache.get(c12);
    if (m6)
      return m6;
    const d9 = { ...i16, spatialReference: this._info.spatialReference, abortOptions: a9, fields: this._info.fields }, h7 = await this._loader.getSymbolAsync(o11, d9), f9 = this._schemaUtilsModule.createSymbolSchema(h7, this._symbolOptions), p10 = i8(f9, this._info, s8, a9).then((e12) => {
      if ("expanded-cim" !== (e12 == null ? void 0 : e12.type))
        return l5.error(new s2("mapview-bad-type", `Found unexpected type ${e12 == null ? void 0 : e12.type} in dictionary response`)), null;
      e12.hash += "-" + u10;
      for (const t10 of e12.layers)
        t10.scaleFactor = u10, t10.templateHash += "-" + u10;
      return this._templates.createTemplateGroup(e12, null);
    });
    return this._groupIdCache.put(c12, p10, 1), p10;
  }
  async analyze(t10, s8, r13, i16, a9, n10) {
    const l6 = s8.getCursor(), o11 = [];
    for (; l6.next(); )
      o11.push(this._analyzeFeature(l6, r13, i16, a9, n10));
    return Promise.all(o11).then((t11) => t11.filter(k));
  }
  match(e11, t10, s8, r13, i16) {
    return null;
  }
  _attributeHash(e11) {
    var _a;
    let t10 = "";
    for (const s8 of this._symbolFields) {
      const r13 = (_a = this._fieldMap) == null ? void 0 : _a[s8];
      r13 && (t10 += e11.attributes[r13] + "-");
    }
    return t10;
  }
};

export {
  e7 as e,
  E2 as E,
  e9 as e2,
  n6 as n,
  x8 as x,
  a8 as a,
  o10 as o
};
//# sourceMappingURL=chunk-JNWIDZDW.js.map
