import {
  l
} from "./chunk-4LVXP3AZ.js";
import {
  t
} from "./chunk-3U7MSH5S.js";
import {
  a
} from "./chunk-6DA3YN7V.js";
import {
  s as s2
} from "./chunk-6B7VJB6C.js";
import {
  p
} from "./chunk-A43TI6AT.js";
import {
  S
} from "./chunk-2D3PORS4.js";
import {
  s3 as s
} from "./chunk-WJ3HJKNC.js";

// node_modules/@arcgis/core/layers/support/LayerLoadContext.js
var e = class {
  constructor() {
    this._serviceMetadatas = /* @__PURE__ */ new Map();
  }
  async fetchServiceMetadata(e2, s4) {
    const a3 = this._serviceMetadatas.get(e2);
    if (a3)
      return a3;
    const r2 = await t(e2, s4);
    return this._serviceMetadatas.set(e2, r2), r2;
  }
};

// node_modules/@arcgis/core/portal/support/loadUtils.js
function t2(e2) {
  const t3 = { id: e2.id, name: e2.name };
  return "Oriented Imagery Layer" === e2.type && (t3.layerType = "OrientedImageryLayer"), t3;
}
async function a2(e2, a3, r2) {
  var _a, _b;
  if (null == (e2 == null ? void 0 : e2.layers) || null == (e2 == null ? void 0 : e2.tables)) {
    const l3 = await r2.fetchServiceMetadata(a3);
    (e2 = e2 || {}).layers = e2.layers || ((_a = l3 == null ? void 0 : l3.layers) == null ? void 0 : _a.map(t2)), e2.tables = e2.tables || ((_b = l3 == null ? void 0 : l3.tables) == null ? void 0 : _b.map(t2));
  }
  return e2;
}
function r(e2) {
  const t3 = e2.layers;
  if (t3 == null ? void 0 : t3.length)
    return t3[0].id;
  const a3 = e2.tables;
  return (a3 == null ? void 0 : a3.length) ? a3[0].id : null;
}
function l2(e2) {
  var _a, _b;
  return (((_a = e2 == null ? void 0 : e2.layers) == null ? void 0 : _a.length) ?? 0) + (((_b = e2 == null ? void 0 : e2.tables) == null ? void 0 : _b.length) ?? 0);
}
function n(e2) {
  var _a;
  const t3 = [];
  return (_a = e2 == null ? void 0 : e2.layers) == null ? void 0 : _a.forEach((e3) => {
    "SubtypeGroupLayer" === e3.layerType && t3.push(e3.id);
  }), t3;
}
function s3(e2) {
  var _a;
  return (_a = e2 == null ? void 0 : e2.layers) == null ? void 0 : _a.filter(({ layerType: e3 }) => "OrientedImageryLayer" === e3).map(({ id: e3 }) => e3);
}
async function i(a3, r2, l3) {
  var _a, _b;
  if (!(a3 == null ? void 0 : a3.url))
    return r2 ?? {};
  if (r2 ?? (r2 = {}), !r2.layers) {
    const e2 = await l3.fetchServiceMetadata(a3.url);
    r2.layers = (_a = e2.layers) == null ? void 0 : _a.map(t2);
  }
  const { serverUrl: n2, portalItem: s4 } = await l(a3.url, { sceneLayerItem: a3 }).catch(() => ({ serverUrl: null, portalItem: null }));
  if (null == n2)
    return r2.tables = [], r2;
  if (!r2.tables && s4) {
    const e2 = await s4.fetchData();
    if (e2 == null ? void 0 : e2.tables)
      r2.tables = e2.tables.map(t2);
    else {
      const e3 = await l3.fetchServiceMetadata(n2);
      r2.tables = (_b = e3 == null ? void 0 : e3.tables) == null ? void 0 : _b.map(t2);
    }
  }
  if (r2.tables)
    for (const e2 of r2.tables)
      e2.url = `${n2}/${e2.id}`;
  return r2;
}

// node_modules/@arcgis/core/portal/support/portalLayers.js
async function p2(e2) {
  !e2.portalItem || e2.portalItem instanceof S || (e2 = { ...e2, portalItem: new S(e2.portalItem) });
  const a3 = await f(e2.portalItem);
  return new (0, a3.constructor)({ portalItem: e2.portalItem, ...a3.properties });
}
async function f(e2) {
  await e2.load();
  const a3 = new e();
  return d(await L(e2, a3));
}
async function L(a3, r2) {
  switch (a3.type) {
    case "Map Service":
      return w(a3, r2);
    case "Feature Service":
      return S2(a3, r2);
    case "Feature Collection":
      return I(a3);
    case "Scene Service":
      return N(a3, r2);
    case "Image Service":
      return v(a3, r2);
    case "Stream Service":
      return M();
    case "Vector Tile Service":
      return h();
    case "GeoJson":
      return T();
    case "CSV":
      return g();
    case "KML":
      return j();
    case "WFS":
      return F();
    case "WMTS":
      return b();
    case "WMS":
      return G();
    case "Feed":
      return C();
    case "Group Layer":
      return U();
    default:
      throw new s("portal:unknown-item-type", "Unknown item type '${type}'", { type: a3.type });
  }
}
async function d(e2) {
  const a3 = e2.className, r2 = a[a3];
  return { constructor: await r2(), properties: e2.properties };
}
async function w(e2, a3) {
  return await V(e2, a3) ? { className: "TileLayer" } : { className: "MapImageLayer" };
}
async function S2(e2, a3) {
  const r2 = await W(e2, a3);
  if ("object" == typeof r2) {
    const e3 = {};
    return null != r2.id && (e3.layerId = r2.id), { className: r2.className || "FeatureLayer", properties: e3 };
  }
  return { className: "GroupLayer" };
}
async function N(e2, r2) {
  var _a;
  const n2 = await W(e2, r2, async () => {
    try {
      if (!e2.url)
        return [];
      const { serverUrl: t3 } = await l(e2.url, { sceneLayerItem: e2 }), n3 = await r2.fetchServiceMetadata(t3);
      return (n3 == null ? void 0 : n3.tables) ?? [];
    } catch {
      return [];
    }
  });
  if ("object" == typeof n2) {
    const a3 = {};
    let s4;
    if (null != n2.id ? (a3.layerId = n2.id, s4 = `${e2.url}/layers/${n2.id}`) : s4 = e2.url, (_a = e2.typeKeywords) == null ? void 0 : _a.length) {
      for (const r3 of Object.keys(p))
        if (e2.typeKeywords.includes(r3))
          return { className: p[r3] };
    }
    const c = await r2.fetchServiceMetadata(s4);
    return { className: p[c == null ? void 0 : c.layerType] || "SceneLayer", properties: a3 };
  }
  if (false === n2) {
    const a3 = await r2.fetchServiceMetadata(e2.url);
    if ("Voxel" === (a3 == null ? void 0 : a3.layerType))
      return { className: "VoxelLayer" };
  }
  return { className: "GroupLayer" };
}
async function I(e2) {
  await e2.load();
  const a3 = s2(e2, "Map Notes"), r2 = s2(e2, "Markup");
  if (a3 || r2)
    return { className: "MapNotesLayer" };
  if (s2(e2, "Route Layer"))
    return { className: "RouteLayer" };
  const t3 = await e2.fetchData();
  return 1 === l2(t3) ? { className: "FeatureLayer" } : { className: "GroupLayer" };
}
async function v(e2, a3) {
  var _a, _b, _c;
  await e2.load();
  const r2 = ((_a = e2.typeKeywords) == null ? void 0 : _a.map((e3) => e3.toLowerCase())) ?? [];
  if (r2.includes("elevation 3d layer"))
    return { className: "ElevationLayer" };
  if (r2.includes("tiled imagery"))
    return { className: "ImageryTileLayer" };
  const t3 = await e2.fetchData(), n2 = t3 == null ? void 0 : t3.layerType;
  if ("ArcGISTiledImageServiceLayer" === n2)
    return { className: "ImageryTileLayer" };
  if ("ArcGISImageServiceLayer" === n2)
    return { className: "ImageryLayer" };
  const s4 = await a3.fetchServiceMetadata(e2.url), c = (_b = s4.cacheType) == null ? void 0 : _b.toLowerCase(), o = (_c = s4.capabilities) == null ? void 0 : _c.toLowerCase().includes("tilesonly");
  return "map" === c || o ? { className: "ImageryTileLayer" } : { className: "ImageryLayer" };
}
function M() {
  return { className: "StreamLayer" };
}
function h() {
  return { className: "VectorTileLayer" };
}
function T() {
  return { className: "GeoJSONLayer" };
}
function g() {
  return { className: "CSVLayer" };
}
function j() {
  return { className: "KMLLayer" };
}
function F() {
  return { className: "WFSLayer" };
}
function G() {
  return { className: "WMSLayer" };
}
function b() {
  return { className: "WMTSLayer" };
}
function C() {
  return { className: "StreamLayer" };
}
function U() {
  return { className: "GroupLayer" };
}
async function V(e2, a3) {
  return (await a3.fetchServiceMetadata(e2.url)).tileInfo;
}
async function W(e2, a3, r2) {
  const t3 = e2.url;
  if (!t3 || /\/\d+$/.test(t3))
    return {};
  await e2.load();
  let n2 = await e2.fetchData();
  if ("Feature Service" === e2.type) {
    const e3 = await a2(n2, t3, a3), r3 = K(e3);
    if ("object" == typeof r3) {
      const a4 = n(e3), t4 = s3(e3);
      r3.className = null != r3.id && a4.includes(r3.id) ? "SubtypeGroupLayer" : null != r3.id && (t4 == null ? void 0 : t4.includes(r3.id)) ? "OrientedImageryLayer" : "FeatureLayer";
    }
    return r3;
  }
  "Scene Service" === e2.type && (n2 = await i(e2, n2, a3));
  if (l2(n2) > 0)
    return K(n2);
  const s4 = await a3.fetchServiceMetadata(t3);
  return r2 && (s4.tables = await r2()), K(s4);
}
function K(e2) {
  return 1 === l2(e2) && { id: r(e2) };
}

export {
  e,
  t2 as t,
  a2 as a,
  r,
  l2 as l,
  n,
  s3 as s,
  i,
  p2 as p,
  L
};
//# sourceMappingURL=chunk-JSBCPI3K.js.map
