import {
  o
} from "./chunk-WURET5CW.js";
import {
  f as f2,
  r
} from "./chunk-QWPLZ3QH.js";
import {
  G,
  d2 as d,
  k,
  s as s3,
  s3 as s4
} from "./chunk-HLGIRLYQ.js";
import {
  s as s2
} from "./chunk-OMPEZIP5.js";
import {
  f
} from "./chunk-NSRXJNTS.js";
import {
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  a2,
  c
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  a,
  s2 as s
} from "./chunk-WJ3HJKNC.js";

// node_modules/@arcgis/core/geometry/Geometry.js
var c2 = class extends f {
  constructor(...e2) {
    super(...e2), this.type = null, this.hasM = false, this.hasZ = false, this.spatialReference = f2.WGS84;
  }
  get cache() {
    return this.commitProperty("spatialReference"), {};
  }
  get extent() {
    return null;
  }
  readSpatialReference(e2, r2) {
    if (e2 instanceof f2)
      return e2;
    if (null != e2) {
      const t2 = new f2();
      return t2.read(e2, r2), t2;
    }
    return e2;
  }
  clone() {
    return console.warn(".clone() is not implemented for " + this.declaredClass), null;
  }
  clearCache() {
    this.notifyChange("cache");
  }
  getCacheValue(e2) {
    return this.cache[e2];
  }
  setCacheValue(e2, r2) {
    this.cache[e2] = r2;
  }
};
e([y()], c2.prototype, "type", void 0), e([y({ readOnly: true })], c2.prototype, "cache", null), e([y({ readOnly: true })], c2.prototype, "extent", null), e([y({ type: Boolean, json: { write: { overridePolicy: (e2) => ({ enabled: e2 }) } } })], c2.prototype, "hasM", void 0), e([y({ type: Boolean, json: { write: { overridePolicy: (e2) => ({ enabled: e2 }) } } })], c2.prototype, "hasZ", void 0), e([y({ type: f2, json: { write: true }, value: f2.WGS84 })], c2.prototype, "spatialReference", void 0), e([o("spatialReference")], c2.prototype, "readSpatialReference", null), c2 = e([c("esri.geometry.Geometry")], c2);
var p = c2;

// node_modules/@arcgis/core/geometry/support/webMercatorUtils.js
var a3 = 57.29577951308232;
var o2 = 0.017453292519943;
function u(n) {
  return n * a3;
}
function l(n) {
  return n * o2;
}
function f3(n) {
  return Math.PI / 2 - 2 * Math.atan(Math.exp(-n / s3.radius));
}
function c3(n) {
  return null != n.wkid || null != n.wkt;
}
var h = [0, 0];
function m(n, t2, e2, i, r2) {
  const s5 = n, a4 = r2;
  if (a4.spatialReference = e2, "x" in s5 && "x" in a4)
    [a4.x, a4.y] = t2(s5.x, s5.y, h, i);
  else if ("xmin" in s5 && "xmin" in a4)
    [a4.xmin, a4.ymin] = t2(s5.xmin, s5.ymin, h, i), [a4.xmax, a4.ymax] = t2(s5.xmax, s5.ymax, h, i);
  else if ("paths" in s5 && "paths" in a4 || "rings" in s5 && "rings" in a4) {
    const n2 = "paths" in s5 ? s5.paths : s5.rings, e3 = [];
    let r3;
    for (let s6 = 0; s6 < n2.length; s6++) {
      const a5 = n2[s6];
      r3 = [], e3.push(r3);
      for (let n3 = 0; n3 < a5.length; n3++)
        r3.push(t2(a5[n3][0], a5[n3][1], [0, 0], i)), a5[n3].length > 2 && r3[n3].push(a5[n3][2]), a5[n3].length > 3 && r3[n3].push(a5[n3][3]);
    }
    "paths" in a4 ? a4.paths = e3 : a4.rings = e3;
  } else if ("points" in s5 && "points" in a4) {
    const n2 = s5.points, e3 = [];
    for (let r3 = 0; r3 < n2.length; r3++)
      e3[r3] = t2(n2[r3][0], n2[r3][1], [0, 0], i), n2[r3].length > 2 && e3[r3].push(n2[r3][2]), n2[r3].length > 3 && e3[r3].push(n2[r3][3]);
    a4.points = e3;
  }
  return r2;
}
function x(n, t2) {
  const e2 = n && (c3(n) ? n : n.spatialReference), a4 = t2 && (c3(t2) ? t2 : t2.spatialReference);
  return !(n && "type" in n && "mesh" === n.type || t2 && "type" in t2 && "mesh" === t2.type || !e2 || !a4) && (!!d(a4, e2) || (s4(a4) && k(e2) || s4(e2) && k(a4)));
}
function g(e2, a4) {
  if (null == e2)
    return null;
  const o3 = e2.spatialReference, u2 = a4 && (c3(a4) ? a4 : a4.spatialReference);
  return x(o3, u2) ? d(o3, u2) ? a(e2) : s4(u2) ? m(e2, M, f2.WebMercator, false, a(e2)) : k(u2) ? m(e2, y2, f2.WGS84, false, a(e2)) : null : null;
}
function M(n, t2, i = [0, 0]) {
  t2 > 89.99999 ? t2 = 89.99999 : t2 < -89.99999 && (t2 = -89.99999);
  const r2 = l(t2);
  return i[0] = l(n) * s3.radius, i[1] = s3.halfSemiMajorAxis * Math.log((1 + Math.sin(r2)) / (1 - Math.sin(r2))), i;
}
function y2(n, t2, i = [0, 0], r2 = false) {
  const s5 = u(n / s3.radius);
  return i[0] = r2 ? s5 : s5 - 360 * Math.floor((s5 + 180) / 360), i[1] = u(Math.PI / 2 - 2 * Math.atan(Math.exp(-t2 / s3.radius))), i;
}
function d2(e2, i = false, r2 = a(e2)) {
  return m(e2, M, f2.WebMercator, i, r2);
}
function R(e2, i = false, r2 = a(e2)) {
  return m(e2, y2, f2.WGS84, i, r2);
}

// node_modules/@arcgis/core/geometry/support/pointUtils.js
function t(t2, n) {
  const s5 = t2.x - n.x, r2 = t2.y - n.y, a4 = t2.hasZ && n.hasZ ? t2.z - n.z : 0;
  return Math.sqrt(s5 * s5 + r2 * r2 + a4 * a4);
}

// node_modules/@arcgis/core/geometry/Point.js
var y3;
var m2 = [0, 0];
function f4(e2) {
  return e2 && ("esri.geometry.SpatialReference" === e2.declaredClass || null != e2.wkid);
}
var g2 = y3 = class extends p {
  static copy(e2, t2) {
    t2._set("x", e2._get("x")), t2._set("y", e2._get("y")), t2._set("z", e2._get("z")), t2._set("m", e2._get("m"));
    const r2 = e2._get("spatialReference");
    t2._set("spatialReference", Object.isFrozen(r2) ? r2 : r2.clone());
  }
  constructor(...e2) {
    super(...e2), this.x = 0, this.y = 0, this.z = void 0, this.m = void 0, this.type = "point";
  }
  normalizeCtorArgs(e2, r2, i, s5, o3) {
    let a4;
    if (Array.isArray(e2))
      a4 = e2, o3 = r2, e2 = a4[0], r2 = a4[1], i = a4[2], s5 = a4[3];
    else if (e2 && "object" == typeof e2) {
      if (a4 = e2, e2 = null != a4.x ? a4.x : a4.longitude, r2 = null != a4.y ? a4.y : a4.latitude, i = a4.z, s5 = a4.m, (o3 = a4.spatialReference) && "esri.geometry.SpatialReference" !== o3.declaredClass && (o3 = new f2(o3)), null != a4.longitude || null != a4.latitude) {
        if (null == a4.longitude)
          s.getLogger(this).warn(".longitude=", "Latitude was defined without longitude");
        else if (null == a4.latitude)
          s.getLogger(this).warn(".latitude=", "Longitude was defined without latitude");
        else if (!a4.declaredClass && o3 && o3.isWebMercator) {
          const t2 = M(a4.longitude, a4.latitude, m2);
          e2 = t2[0], r2 = t2[1];
        }
      }
    } else
      f4(i) ? (o3 = i, i = null) : f4(s5) && (o3 = s5, s5 = null);
    const l2 = { x: e2, y: r2 };
    return null == l2.x && null != l2.y ? s.getLogger(this).warn(".y=", "Y coordinate was defined without an X coordinate") : null == l2.y && null != l2.x && s.getLogger(this).warn(".x=", "X coordinate was defined without a Y coordinate"), null != o3 && (l2.spatialReference = o3), null != i && (l2.z = i), null != s5 && (l2.m = s5), l2;
  }
  get cache() {
    return this.commitProperty("x"), this.commitProperty("y"), this.commitProperty("z"), this.commitProperty("m"), this.commitProperty("spatialReference"), {};
  }
  get hasM() {
    return void 0 !== this.m;
  }
  set hasM(e2) {
    e2 !== (void 0 !== this._get("m")) && (this._set("m", e2 ? 0 : void 0), this._set("hasM", e2));
  }
  get hasZ() {
    return void 0 !== this.z;
  }
  set hasZ(e2) {
    e2 !== (void 0 !== this._get("z")) && (this._set("z", e2 ? 0 : void 0), this._set("hasZ", e2));
  }
  get latitude() {
    const { spatialReference: e2, x: t2, y: r2 } = this;
    if (e2) {
      if (e2.isWebMercator)
        return y2(t2, r2, m2)[1];
      if (e2.isGeographic)
        return r2;
    }
    return null;
  }
  set latitude(e2) {
    const { spatialReference: t2, x: r2 } = this;
    null != e2 && t2 && (t2.isWebMercator ? this._set("y", M(r2, e2, m2)[1]) : t2.isGeographic && this._set("y", e2), this._set("latitude", e2));
  }
  get longitude() {
    const { x: e2, y: t2, spatialReference: r2 } = this;
    if (r2) {
      if (r2.isWebMercator)
        return y2(e2, t2, m2)[0];
      if (r2.isGeographic)
        return e2;
    }
    return null;
  }
  set longitude(e2) {
    const { y: t2, spatialReference: r2 } = this;
    null != e2 && r2 && (r2.isWebMercator ? this._set("x", M(e2, t2, m2)[0]) : r2.isGeographic && this._set("x", e2), this._set("longitude", e2));
  }
  writeX(e2, t2, r2) {
    t2[r2] = isNaN(e2) ? "NaN" : e2;
  }
  readX(e2) {
    return "string" == typeof e2 ? NaN : e2;
  }
  clone() {
    const e2 = new y3();
    return e2.x = this.x, e2.y = this.y, e2.z = this.z, e2.m = this.m, e2.spatialReference = this.spatialReference, e2;
  }
  copy(e2) {
    return y3.copy(e2, this), this;
  }
  equals(e2) {
    if (null == e2)
      return false;
    const { x: t2, y: r2, z: i, m: s5, spatialReference: o3 } = this, { z: a4, m: l2 } = e2;
    let { x: n, y: u2, spatialReference: c4 } = e2;
    if (!o3.equals(c4))
      if (o3.isWebMercator && c4.isWGS84)
        [n, u2] = M(n, u2), c4 = o3;
      else {
        if (!o3.isWGS84 || !c4.isWebMercator)
          return false;
        [n, u2] = y2(n, u2), c4 = o3;
      }
    return t2 === n && r2 === u2 && i === a4 && s5 === l2 && o3.wkid === c4.wkid;
  }
  offset(e2, t2, r2) {
    return this.x += e2, this.y += t2, null != r2 && (this.z = (this.z ?? 0) + r2), this;
  }
  normalize() {
    if (!this.spatialReference)
      return this;
    const e2 = G(this.spatialReference);
    if (!e2)
      return this;
    let t2 = this.x;
    const [r2, i] = e2.valid, s5 = 2 * i;
    let o3;
    return t2 > i ? (o3 = Math.ceil(Math.abs(t2 - i) / s5), t2 -= o3 * s5) : t2 < r2 && (o3 = Math.ceil(Math.abs(t2 - r2) / s5), t2 += o3 * s5), this._set("x", t2), this;
  }
  distance(e2) {
    return t(this, e2);
  }
  toArray() {
    const e2 = this.hasZ, t2 = this.hasM;
    return e2 && t2 ? [this.x, this.y, this.z, this.m] : e2 ? [this.x, this.y, this.z] : t2 ? [this.x, this.y, this.m] : [this.x, this.y];
  }
  toJSON(e2) {
    return this.write({}, e2);
  }
};
e([y({ readOnly: true })], g2.prototype, "cache", null), e([y({ type: Boolean, json: { read: false, write: { enabled: false, overridePolicy: null } } })], g2.prototype, "hasM", null), e([y({ type: Boolean, json: { read: false, write: { enabled: false, overridePolicy: null } } })], g2.prototype, "hasZ", null), e([y({ type: Number })], g2.prototype, "latitude", null), e([y({ type: Number })], g2.prototype, "longitude", null), e([y({ type: Number, json: { type: [Number, String], write: { isRequired: true, allowNull: true } } }), s2((e2) => isNaN(e2) ? e2 : a2(e2))], g2.prototype, "x", void 0), e([r("x")], g2.prototype, "writeX", null), e([o("x")], g2.prototype, "readX", null), e([y({ type: Number, json: { write: true } })], g2.prototype, "y", void 0), e([y({ type: Number, json: { write: { overridePolicy() {
  return { enabled: this.hasZ };
} } } })], g2.prototype, "z", void 0), e([y({ type: Number, json: { write: { overridePolicy() {
  return { enabled: this.hasM };
} } } })], g2.prototype, "m", void 0), g2 = y3 = e([c("esri.geometry.Point")], g2), g2.prototype.toJSON.isDefaultToJSON = true;
var x2 = g2;

export {
  p,
  f3 as f,
  x,
  g,
  M,
  y2 as y,
  d2 as d,
  R,
  x2
};
//# sourceMappingURL=chunk-QNOCEWCR.js.map
