import {
  S,
  _ as _3
} from "./chunk-BNTQULGG.js";
import {
  i as i5
} from "./chunk-A6KO3R3G.js";
import {
  T,
  a as a3,
  e2 as e7
} from "./chunk-T56C4ORZ.js";
import {
  c as c2,
  s as s4
} from "./chunk-2CJ4SBZD.js";
import {
  d as d2,
  e as e9,
  p
} from "./chunk-AALPUTPM.js";
import {
  a as a4,
  a2 as a5,
  a3 as a6,
  a4 as a7,
  e as e8,
  o as o5,
  s as s5
} from "./chunk-55WTSNPL.js";
import {
  n as n7,
  o as o4
} from "./chunk-RN5RTM2J.js";
import {
  n as n6
} from "./chunk-T73MCNAU.js";
import {
  e as e6,
  r as r6
} from "./chunk-V76ETMKA.js";
import {
  o as o3,
  r as r7
} from "./chunk-5JIGIHKI.js";
import {
  a as a2,
  i as i4,
  s as s3
} from "./chunk-NB4VIBDC.js";
import {
  s as s2
} from "./chunk-YNB3DCUM.js";
import {
  e as e3
} from "./chunk-GLBAW5CR.js";
import {
  B,
  D,
  E as E2,
  G as G2,
  L,
  P,
  U,
  _ as _2
} from "./chunk-RCLKRKWR.js";
import {
  e as e5,
  o as o2
} from "./chunk-4OLZTDWK.js";
import {
  e as e4
} from "./chunk-2RN2AAP7.js";
import {
  n as n3,
  r as r4
} from "./chunk-AMSVADDY.js";
import {
  n as n4
} from "./chunk-CMGHBCKF.js";
import {
  g as g2
} from "./chunk-YVNEJWNQ.js";
import {
  r as r5
} from "./chunk-NDKHIQMD.js";
import {
  n as n5
} from "./chunk-TWNBDJHC.js";
import {
  A as A2,
  G,
  i as i3
} from "./chunk-IRNKV32L.js";
import {
  i as i2
} from "./chunk-F6MD5VOH.js";
import {
  M,
  i,
  s
} from "./chunk-MKW4ORPJ.js";
import {
  O2 as O,
  _2 as _,
  e2,
  f,
  n as n2,
  o,
  r as r2,
  u2 as u,
  z
} from "./chunk-YTH6VA7N.js";
import {
  r2 as r3
} from "./chunk-GINTRQSD.js";
import {
  A,
  d
} from "./chunk-TBSVVR6M.js";
import {
  g,
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c,
  l
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  E
} from "./chunk-RFPH3ZTZ.js";
import {
  r,
  t
} from "./chunk-WGO3VFQP.js";
import {
  n
} from "./chunk-CQS47VN5.js";
import {
  a
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js
var o6;
!function(o22) {
  o22[o22.Color = 0] = "Color", o22[o22.Depth = 1] = "Depth", o22[o22.Normal = 2] = "Normal", o22[o22.Shadow = 3] = "Shadow", o22[o22.ShadowHighlight = 4] = "ShadowHighlight", o22[o22.ShadowExcludeHighlight = 5] = "ShadowExcludeHighlight", o22[o22.Highlight = 6] = "Highlight", o22[o22.Alpha = 7] = "Alpha", o22[o22.ObjectAndLayerIdColor = 8] = "ObjectAndLayerIdColor", o22[o22.CompositeColor = 9] = "CompositeColor", o22[o22.COUNT = 10] = "COUNT";
}(o6 || (o6 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl.js
function t2(t16, s14) {
  switch (s14.normalType) {
    case a8.Compressed:
      t16.attributes.add(e3.NORMALCOMPRESSED, "vec2"), t16.vertex.code.add(o4`vec3 normalModel() {
float z = 1.0 - abs(normalCompressed.x) - abs(normalCompressed.y);
return vec3(normalCompressed + sign(normalCompressed) * min(z, 0.0), z);
}`);
      break;
    case a8.Attribute:
      t16.attributes.add(e3.NORMAL, "vec3"), t16.vertex.code.add(o4`vec3 normalModel() {
return normal;
}`);
      break;
    case a8.ScreenDerivative:
      t16.fragment.code.add(o4`vec3 screenDerivativeNormal(vec3 positionView) {
return normalize(cross(dFdx(positionView), dFdy(positionView)));
}`);
      break;
    default:
      n5(s14.normalType);
    case a8.COUNT:
    case a8.Ground:
  }
}
var a8;
!function(e26) {
  e26[e26.Attribute = 0] = "Attribute", e26[e26.Compressed = 1] = "Compressed", e26[e26.Ground = 2] = "Ground", e26[e26.ScreenDerivative = 3] = "ScreenDerivative", e26[e26.COUNT = 4] = "COUNT";
}(a8 || (a8 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js
var d3;
function o7(o22, v6) {
  switch (v6.textureCoordinateType) {
    case d3.Default:
      return o22.attributes.add(e3.UV0, "vec2"), o22.varyings.add("vuv0", "vec2"), void o22.vertex.code.add(o4`void forwardTextureCoordinates() {
vuv0 = uv0;
}`);
    case d3.Compressed:
      return o22.attributes.add(e3.UV0, "vec2"), o22.varyings.add("vuv0", "vec2"), void o22.vertex.code.add(o4`vec2 getUV0() {
return uv0 / 16384.0;
}
void forwardTextureCoordinates() {
vuv0 = getUV0();
}`);
    case d3.Atlas:
      return o22.attributes.add(e3.UV0, "vec2"), o22.varyings.add("vuv0", "vec2"), o22.attributes.add(e3.UVREGION, "vec4"), o22.varyings.add("vuvRegion", "vec4"), void o22.vertex.code.add(o4`void forwardTextureCoordinates() {
vuv0 = uv0;
vuvRegion = uvRegion;
}`);
    default:
      n5(v6.textureCoordinateType);
    case d3.None:
      return void o22.vertex.code.add(o4`void forwardTextureCoordinates() {}`);
    case d3.COUNT:
      return;
  }
}
!function(e26) {
  e26[e26.None = 0] = "None", e26[e26.Default = 1] = "Default", e26[e26.Atlas = 2] = "Atlas", e26[e26.Compressed = 3] = "Compressed", e26[e26.COUNT = 4] = "COUNT";
}(d3 || (d3 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js
var e10 = class extends a5 {
  constructor(r18, e26) {
    super(r18, "vec3", a4.Pass, (s14, o22, t16) => s14.setUniform3fv(r18, e26(o22, t16)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/TextureAtlasLookup.glsl.js
function e11(e26) {
  e26.fragment.code.add(o4`vec4 textureAtlasLookup(sampler2D tex, vec2 textureCoordinates, vec4 atlasRegion) {
vec2 atlasScale = atlasRegion.zw - atlasRegion.xy;
vec2 uvAtlas = fract(textureCoordinates) * atlasScale + atlasRegion.xy;
float maxdUV = 0.125;
vec2 dUVdx = clamp(dFdx(textureCoordinates), -maxdUV, maxdUV) * atlasScale;
vec2 dUVdy = clamp(dFdy(textureCoordinates), -maxdUV, maxdUV) * atlasScale;
return textureGrad(tex, uvAtlas, dUVdx, dUVdy);
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTextureCoordinates.glsl.js
function s6(s14, a16) {
  switch (s14.include(o7, a16), a16.textureCoordinateType) {
    case d3.Default:
    case d3.Compressed:
      return void s14.fragment.code.add(o4`vec4 textureLookup(sampler2D tex, vec2 uv) {
return texture(tex, uv);
}`);
    case d3.Atlas:
      return s14.include(e11), void s14.fragment.code.add(o4`vec4 textureLookup(sampler2D tex, vec2 uv) {
return textureAtlasLookup(tex, uv, vuvRegion);
}`);
    default:
      n5(a16.textureCoordinateType);
    case d3.None:
    case d3.COUNT:
      return;
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Float3DrawUniform.js
var o8 = class extends a5 {
  constructor(r18, o22) {
    super(r18, "vec3", a4.Draw, (e26, s14, t16, i16) => e26.setUniform3fv(r18, o22(s14, t16, i16)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/GLMaterial.js
var t3 = class {
  constructor(e26) {
    this._material = e26.material, this._techniqueRepository = e26.techniqueRep, this._output = e26.output;
  }
  dispose() {
    this._techniqueRepository.release(this._technique);
  }
  get technique() {
    return this._technique;
  }
  get _stippleTextureRepository() {
    return this._techniqueRepository.constructionContext.stippleTextureRepository;
  }
  get _markerTextureRepository() {
    return this._techniqueRepository.constructionContext.markerTextureRepository;
  }
  ensureTechnique(e26, t16) {
    return this._technique = this._techniqueRepository.releaseAndAcquire(e26, this._material.getConfiguration(this._output, t16), this._technique), this._technique;
  }
  ensureResources(t16) {
    return a2.LOADED;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/GLTextureMaterial.js
var r8 = class extends t3 {
  constructor(t16) {
    super(t16), this._numLoading = 0, this._disposed = false, this._textureRepository = t16.textureRepository, this._textureId = t16.textureId, this._acquire(t16.textureId, (t17) => this._texture = t17), this._acquire(t16.normalTextureId, (t17) => this._textureNormal = t17), this._acquire(t16.emissiveTextureId, (t17) => this._textureEmissive = t17), this._acquire(t16.occlusionTextureId, (t17) => this._textureOcclusion = t17), this._acquire(t16.metallicRoughnessTextureId, (t17) => this._textureMetallicRoughness = t17);
  }
  dispose() {
    this._texture = t(this._texture), this._textureNormal = t(this._textureNormal), this._textureEmissive = t(this._textureEmissive), this._textureOcclusion = t(this._textureOcclusion), this._textureMetallicRoughness = t(this._textureMetallicRoughness), this._disposed = true;
  }
  ensureResources(t16) {
    return 0 === this._numLoading ? a2.LOADED : a2.LOADING;
  }
  get textureBindParameters() {
    return new l2(null != this._texture ? this._texture.glTexture : null, null != this._textureNormal ? this._textureNormal.glTexture : null, null != this._textureEmissive ? this._textureEmissive.glTexture : null, null != this._textureOcclusion ? this._textureOcclusion.glTexture : null, null != this._textureMetallicRoughness ? this._textureMetallicRoughness.glTexture : null);
  }
  updateTexture(e26) {
    null != this._texture && e26 === this._texture.id || (this._texture = t(this._texture), this._textureId = e26, this._acquire(this._textureId, (t16) => this._texture = t16));
  }
  _acquire(s14, i16) {
    if (null == s14)
      return void i16(null);
    const u5 = this._textureRepository.acquire(s14);
    if (E(u5))
      return ++this._numLoading, void u5.then((e26) => {
        if (this._disposed)
          return t(e26), void i16(null);
        i16(e26);
      }).finally(() => --this._numLoading);
    i16(u5);
  }
};
var l2 = class extends n7 {
  constructor(t16 = null, e26 = null, s14 = null, i16 = null, u5 = null) {
    super(), this.texture = t16, this.textureNormal = e26, this.textureEmissive = s14, this.textureOcclusion = i16, this.textureMetallicRoughness = u5;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js
var c3;
!function(e26) {
  e26[e26.Disabled = 0] = "Disabled", e26[e26.Normal = 1] = "Normal", e26[e26.Schematic = 2] = "Schematic", e26[e26.Water = 3] = "Water", e26[e26.WaterOnIntegratedMesh = 4] = "WaterOnIntegratedMesh", e26[e26.Terrain = 5] = "Terrain", e26[e26.TerrainWithWater = 6] = "TerrainWithWater", e26[e26.COUNT = 7] = "COUNT";
}(c3 || (c3 = {}));
function l3(n15, u5) {
  const l13 = n15.fragment, m7 = u5.hasMetallicRoughnessTexture || u5.hasEmissionTexture || u5.hasOcclusionTexture;
  if (u5.pbrMode === c3.Normal && m7 && n15.include(s6, u5), u5.pbrMode !== c3.Schematic)
    if (u5.pbrMode !== c3.Disabled) {
      if (u5.pbrMode === c3.Normal) {
        l13.code.add(o4`vec3 mrr;
vec3 emission;
float occlusion;`);
        const e26 = u5.pbrTextureBindType;
        u5.hasMetallicRoughnessTexture && (l13.uniforms.add(e26 === a4.Pass ? new s5("texMetallicRoughness", (e27) => e27.textureMetallicRoughness) : new s4("texMetallicRoughness", (e27) => e27.textureMetallicRoughness)), l13.code.add(o4`void applyMetallnessAndRoughness(vec2 uv) {
vec3 metallicRoughness = textureLookup(texMetallicRoughness, uv).rgb;
mrr[0] *= metallicRoughness.b;
mrr[1] *= metallicRoughness.g;
}`)), u5.hasEmissionTexture && (l13.uniforms.add(e26 === a4.Pass ? new s5("texEmission", (e27) => e27.textureEmissive) : new s4("texEmission", (e27) => e27.textureEmissive)), l13.code.add(o4`void applyEmission(vec2 uv) {
emission *= textureLookup(texEmission, uv).rgb;
}`)), u5.hasOcclusionTexture ? (l13.uniforms.add(e26 === a4.Pass ? new s5("texOcclusion", (e27) => e27.textureOcclusion) : new s4("texOcclusion", (e27) => e27.textureOcclusion)), l13.code.add(o4`void applyOcclusion(vec2 uv) {
occlusion *= textureLookup(texOcclusion, uv).r;
}
float getBakedOcclusion() {
return occlusion;
}`)) : l13.code.add(o4`float getBakedOcclusion() { return 1.0; }`), e26 === a4.Pass ? l13.uniforms.add(new e10("emissionFactor", (e27) => e27.emissiveFactor), new e10("mrrFactors", (e27) => e27.mrrFactors)) : l13.uniforms.add(new o8("emissionFactor", (e27) => e27.emissiveFactor), new o8("mrrFactors", (e27) => e27.mrrFactors)), l13.code.add(o4`
    void applyPBRFactors() {
      mrr = mrrFactors;
      emission = emissionFactor;
      occlusion = 1.0;

      ${u5.hasMetallicRoughnessTexture ? o4`applyMetallnessAndRoughness(${u5.hasMetallicRoughnessTextureTransform ? o4`metallicRoughnessUV` : "vuv0"});` : ""}

      ${u5.hasEmissionTexture ? o4`applyEmission(${u5.hasEmissiveTextureTransform ? o4`emissiveUV` : "vuv0"});` : ""}

      ${u5.hasOcclusionTexture ? o4`applyOcclusion(${u5.hasOcclusionTextureTransform ? o4`occlusionUV` : "vuv0"});` : ""}
    }
  `);
      }
    } else
      l13.code.add(o4`float getBakedOcclusion() { return 1.0; }`);
  else
    l13.code.add(o4`vec3 mrr = vec3(0.0, 0.6, 0.2);
vec3 emission = vec3(0.0);
float occlusion = 1.0;
void applyPBRFactors() {}
float getBakedOcclusion() { return 1.0; }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/PositionAttribute.glsl.js
function o9(o22) {
  o22.attributes.add(e3.POSITION, "vec3"), o22.vertex.code.add(o4`vec3 positionModel() { return position; }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/DoublePrecision.glsl.js
function c4({ code: c12 }, i16) {
  i16.doublePrecisionRequiresObfuscation ? c12.add(o4`vec3 dpPlusFrc(vec3 a, vec3 b) {
return mix(a, a + b, vec3(notEqual(b, vec3(0))));
}
vec3 dpMinusFrc(vec3 a, vec3 b) {
return mix(vec3(0), a - b, vec3(notEqual(a, b)));
}
vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {
vec3 t1 = dpPlusFrc(hiA, hiB);
vec3 e = dpMinusFrc(t1, hiA);
vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;
return t1 + t2;
}`) : c12.add(o4`vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {
vec3 t1 = hiA + hiB;
vec3 e = t1 - hiA;
vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;
return t1 + t2;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix3DrawUniform.js
var o10 = class extends a5 {
  constructor(r18, o22) {
    super(r18, "mat3", a4.Draw, (e26, s14, t16) => e26.setUniformMatrix3fv(r18, o22(s14, t16)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix3PassUniform.js
var e12 = class extends a5 {
  constructor(r18, e26) {
    super(r18, "mat3", a4.Pass, (s14, o22, t16) => s14.setUniformMatrix3fv(r18, e26(o22, t16)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js
var e13 = class extends a5 {
  constructor(r18, e26) {
    super(r18, "mat4", a4.Pass, (s14, o22, t16) => s14.setUniformMatrix4fv(r18, e26(o22, t16)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexPosition.glsl.js
function v(r18, o22) {
  r18.include(o9);
  const e26 = r18.vertex;
  e26.include(c4, o22), r18.varyings.add("vPositionWorldCameraRelative", "vec3"), r18.varyings.add("vPosition_view", "vec3"), e26.uniforms.add(new e10("transformWorldFromViewTH", (r19) => r19.transformWorldFromViewTH), new e10("transformWorldFromViewTL", (r19) => r19.transformWorldFromViewTL), new e12("transformViewFromCameraRelativeRS", (r19) => r19.transformViewFromCameraRelativeRS), new e13("transformProjFromView", (r19) => r19.transformProjFromView), new o10("transformWorldFromModelRS", (r19) => r19.transformWorldFromModelRS), new o8("transformWorldFromModelTH", (r19) => r19.transformWorldFromModelTH), new o8("transformWorldFromModelTL", (r19) => r19.transformWorldFromModelTL)), e26.code.add(o4`vec3 positionWorldCameraRelative() {
vec3 rotatedModelPosition = transformWorldFromModelRS * positionModel();
vec3 transform_CameraRelativeFromModel = dpAdd(
transformWorldFromModelTL,
transformWorldFromModelTH,
-transformWorldFromViewTL,
-transformWorldFromViewTH
);
return transform_CameraRelativeFromModel + rotatedModelPosition;
}`), e26.code.add(o4`
    void forwardPosition(float fOffset) {
      vPositionWorldCameraRelative = positionWorldCameraRelative();
      if (fOffset != 0.0) {
        vPositionWorldCameraRelative += fOffset * ${o22.spherical ? o4`normalize(transformWorldFromViewTL + vPositionWorldCameraRelative)` : o4`vec3(0.0, 0.0, 1.0)`};
      }

      vPosition_view = transformViewFromCameraRelativeRS * vPositionWorldCameraRelative;
      gl_Position = transformProjFromView * vec4(vPosition_view, 1.0);
    }
  `), r18.fragment.uniforms.add(new e10("transformWorldFromViewTL", (r19) => r19.transformWorldFromViewTL)), e26.code.add(o4`vec3 positionWorld() {
return transformWorldFromViewTL + vPositionWorldCameraRelative;
}`), r18.fragment.code.add(o4`vec3 positionWorld() {
return transformWorldFromViewTL + vPositionWorldCameraRelative;
}`);
}
var F = class extends n7 {
  constructor() {
    super(...arguments), this.transformWorldFromViewTH = n2(), this.transformWorldFromViewTL = n2(), this.transformViewFromCameraRelativeRS = e4(), this.transformProjFromView = e5();
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl.js
function c5(o22, a16) {
  switch (a16.normalType) {
    case a8.Attribute:
    case a8.Compressed:
      o22.include(t2, a16), o22.varyings.add("vNormalWorld", "vec3"), o22.varyings.add("vNormalView", "vec3"), o22.vertex.uniforms.add(new o10("transformNormalGlobalFromModel", (r18) => r18.transformNormalGlobalFromModel), new e12("transformNormalViewFromGlobal", (r18) => r18.transformNormalViewFromGlobal)), o22.vertex.code.add(o4`void forwardNormal() {
vNormalWorld = transformNormalGlobalFromModel * normalModel();
vNormalView = transformNormalViewFromGlobal * vNormalWorld;
}`);
      break;
    case a8.Ground:
      o22.include(v, a16), o22.varyings.add("vNormalWorld", "vec3"), o22.vertex.code.add(o4`
        void forwardNormal() {
          vNormalWorld = ${a16.spherical ? o4`normalize(vPositionWorldCameraRelative);` : o4`vec3(0.0, 0.0, 1.0);`}
        }
        `);
      break;
    case a8.ScreenDerivative:
      o22.vertex.code.add(o4`void forwardNormal() {}`);
      break;
    default:
      n5(a16.normalType);
    case a8.COUNT:
  }
}
var f2 = class extends F {
  constructor() {
    super(...arguments), this.transformNormalViewFromGlobal = e4();
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js
var o11 = 0.1;
var t4 = 1e-3;

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js
function t5(e26) {
  e26.varyings.add("linearDepth", "float");
}
function i6(e26) {
  e26.vertex.uniforms.add(new e8("nearFar", (e27, r18) => r18.camera.nearFar));
}
function n8(e26) {
  e26.vertex.code.add(o4`float calculateLinearDepth(vec2 nearFar,float z) {
return (-z - nearFar[0]) / (nearFar[1] - nearFar[0]);
}`);
}
function d4(a16, d12) {
  const { vertex: s14 } = a16;
  switch (d12.output) {
    case o6.Color:
      if (d12.receiveShadows)
        return t5(a16), void s14.code.add(o4`void forwardLinearDepth() { linearDepth = gl_Position.w; }`);
      break;
    case o6.Depth:
    case o6.Shadow:
    case o6.ShadowHighlight:
    case o6.ShadowExcludeHighlight:
      return a16.include(v, d12), t5(a16), i6(a16), n8(a16), void s14.code.add(o4`void forwardLinearDepth() {
linearDepth = calculateLinearDepth(nearFar, vPosition_view.z);
}`);
  }
  s14.code.add(o4`void forwardLinearDepth() {}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/Offset.glsl.js
function e14(e26) {
  e26.vertex.code.add(o4`vec4 offsetBackfacingClipPosition(vec4 posClip, vec3 posWorld, vec3 normalWorld, vec3 camPosWorld) {
vec3 camToVert = posWorld - camPosWorld;
bool isBackface = dot(camToVert, normalWorld) > 0.0;
if (isBackface) {
posClip.z += 0.0000003 * posClip.w;
}
return posClip;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js
function P2(e26, s14) {
  h(e26, s14, new o8("slicePlaneOrigin", (e27, i16) => g3(s14, e27, i16)), new o8("slicePlaneBasis1", (e27, i16) => {
    var _a;
    return I(s14, e27, i16, (_a = i16.slicePlane) == null ? void 0 : _a.basis1);
  }), new o8("slicePlaneBasis2", (e27, i16) => {
    var _a;
    return I(s14, e27, i16, (_a = i16.slicePlane) == null ? void 0 : _a.basis2);
  }));
}
function h(e26, s14, ...i16) {
  if (!s14.hasSlicePlane) {
    const i17 = o4`#define rejectBySlice(_pos_) false
#define discardBySlice(_pos_) {}
#define highlightSlice(_color_, _pos_) (_color_)`;
    return s14.hasSliceInVertexProgram && e26.vertex.code.add(i17), void e26.fragment.code.add(i17);
  }
  s14.hasSliceInVertexProgram && e26.vertex.uniforms.add(...i16), e26.fragment.uniforms.add(...i16);
  const a16 = o4`struct SliceFactors {
float front;
float side0;
float side1;
float side2;
float side3;
};
SliceFactors calculateSliceFactors(vec3 pos) {
vec3 rel = pos - slicePlaneOrigin;
vec3 slicePlaneNormal = -cross(slicePlaneBasis1, slicePlaneBasis2);
float slicePlaneW = -dot(slicePlaneNormal, slicePlaneOrigin);
float basis1Len2 = dot(slicePlaneBasis1, slicePlaneBasis1);
float basis2Len2 = dot(slicePlaneBasis2, slicePlaneBasis2);
float basis1Dot = dot(slicePlaneBasis1, rel);
float basis2Dot = dot(slicePlaneBasis2, rel);
return SliceFactors(
dot(slicePlaneNormal, pos) + slicePlaneW,
-basis1Dot - basis1Len2,
basis1Dot - basis1Len2,
-basis2Dot - basis2Len2,
basis2Dot - basis2Len2
);
}
bool sliceByFactors(SliceFactors factors) {
return factors.front < 0.0
&& factors.side0 < 0.0
&& factors.side1 < 0.0
&& factors.side2 < 0.0
&& factors.side3 < 0.0;
}
bool sliceEnabled() {
return dot(slicePlaneBasis1, slicePlaneBasis1) != 0.0;
}
bool sliceByPlane(vec3 pos) {
return sliceEnabled() && sliceByFactors(calculateSliceFactors(pos));
}
#define rejectBySlice(_pos_) sliceByPlane(_pos_)
#define discardBySlice(_pos_) { if (sliceByPlane(_pos_)) discard; }`, l13 = o4`vec4 applySliceHighlight(vec4 color, vec3 pos) {
SliceFactors factors = calculateSliceFactors(pos);
const float HIGHLIGHT_WIDTH = 1.0;
const vec4 HIGHLIGHT_COLOR = vec4(0.0, 0.0, 0.0, 0.3);
factors.front /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.front);
factors.side0 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side0);
factors.side1 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side1);
factors.side2 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side2);
factors.side3 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side3);
if (sliceByFactors(factors)) {
return color;
}
float highlightFactor = (1.0 - step(0.5, factors.front))
* (1.0 - step(0.5, factors.side0))
* (1.0 - step(0.5, factors.side1))
* (1.0 - step(0.5, factors.side2))
* (1.0 - step(0.5, factors.side3));
return mix(color, vec4(HIGHLIGHT_COLOR.rgb, color.a), highlightFactor * HIGHLIGHT_COLOR.a);
}`, c12 = s14.hasSliceHighlight ? o4`
        ${l13}
        #define highlightSlice(_color_, _pos_) (sliceEnabled() ? applySliceHighlight(_color_, _pos_) : (_color_))
      ` : o4`#define highlightSlice(_color_, _pos_) (_color_)`;
  s14.hasSliceInVertexProgram && e26.vertex.code.add(a16), e26.fragment.code.add(a16), e26.fragment.code.add(c12);
}
function p2(e26, s14, i16) {
  return e26.instancedDoublePrecision ? o(b, i16.camera.viewInverseTransposeMatrix[3], i16.camera.viewInverseTransposeMatrix[7], i16.camera.viewInverseTransposeMatrix[11]) : s14.slicePlaneLocalOrigin;
}
function m(e26, s14) {
  return null != e26 ? e2(v2, s14.origin, e26) : s14.origin;
}
function H(s14, i16, a16) {
  return s14.hasSliceTranslatedView ? null != i16 ? i2(S2, a16.camera.viewMatrix, i16) : a16.camera.viewMatrix : null;
}
function g3(e26, s14, a16) {
  if (null == a16.slicePlane)
    return f;
  const l13 = p2(e26, s14, a16), c12 = m(l13, a16.slicePlane), r18 = H(e26, l13, a16);
  return null != r18 ? O(v2, c12, r18) : c12;
}
function I(e26, s14, c12, r18) {
  if (null == r18 || null == c12.slicePlane)
    return f;
  const t16 = p2(e26, s14, c12), n15 = m(t16, c12.slicePlane), f7 = H(e26, t16, c12);
  return null != f7 ? (u(B2, r18, n15), O(v2, n15, f7), O(B2, B2, f7), e2(B2, B2, v2)) : r18;
}
var b = n2();
var v2 = n2();
var B2 = n2();
var S2 = e5();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js
function o12(o22) {
  n8(o22), o22.vertex.code.add(o4`vec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {
vec4 eye = view * vec4(pos, 1.0);
depth = calculateLinearDepth(nearFar,eye.z);
return proj * eye;
}`), o22.vertex.code.add(o4`vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {
return proj * (view * vec4(pos, 1.0));
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix4DrawUniform.js
var o13 = class extends a5 {
  constructor(r18, o22) {
    super(r18, "mat4", a4.Draw, (e26, s14, t16) => e26.setUniformMatrix4fv(r18, o22(s14, t16)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js
function f3(r18, a16) {
  a16.instancedDoublePrecision ? r18.constants.add("cameraPosition", "vec3", f) : r18.uniforms.add(new o8("cameraPosition", (r19, a17) => o(w, a17.camera.viewInverseTransposeMatrix[3] - r19.origin[0], a17.camera.viewInverseTransposeMatrix[7] - r19.origin[1], a17.camera.viewInverseTransposeMatrix[11] - r19.origin[2])));
}
function d5(a16, i16) {
  if (!i16.instancedDoublePrecision)
    return void a16.uniforms.add(new e13("proj", (r18, a17) => a17.camera.projectionMatrix), new o13("view", (a17, e26) => i2(v3, e26.camera.viewMatrix, a17.origin)), new o8("localOrigin", (r18) => r18.origin));
  const o22 = (r18) => o(w, r18.camera.viewInverseTransposeMatrix[3], r18.camera.viewInverseTransposeMatrix[7], r18.camera.viewInverseTransposeMatrix[11]);
  a16.uniforms.add(new e13("proj", (r18, a17) => a17.camera.projectionMatrix), new e13("view", (a17, e26) => i2(v3, e26.camera.viewMatrix, o22(e26))), new e10("localOrigin", (r18, a17) => o22(a17)));
}
var v3 = e5();
var w = n2();
function p3(r18) {
  r18.uniforms.add(new e13("viewNormal", (r19, a16) => a16.camera.viewInverseTransposeMatrix));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/ShaderTechniqueConfiguration.js
var t6 = class extends n7 {
  constructor() {
    super(), this._key = "", this._keyDirty = false, this._parameterBits = this._parameterBits ? this._parameterBits.map(() => 0) : [], this._parameterNames || (this._parameterNames = []);
  }
  get key() {
    return this._keyDirty && (this._keyDirty = false, this._key = String.fromCharCode.apply(String, this._parameterBits)), this._key;
  }
  snapshot() {
    const e26 = this._parameterNames, t16 = { key: this.key };
    for (const r18 of e26)
      t16[r18] = this[r18];
    return t16;
  }
};
function r9(e26 = {}) {
  return (t16, r18) => {
    if (t16._parameterNames = t16._parameterNames ?? [], t16._parameterNames.push(r18), null != e26.constValue)
      Object.defineProperty(t16, r18, { get: () => e26.constValue });
    else {
      const s14 = t16._parameterNames.length - 1, a16 = e26.count || 2, i16 = Math.ceil(Math.log2(a16)), o22 = t16._parameterBits ?? [0];
      let h6 = 0;
      for (; o22[h6] + i16 > 16; )
        h6++, h6 >= o22.length && o22.push(0);
      t16._parameterBits = o22;
      const n15 = o22[h6], m7 = (1 << i16) - 1 << n15;
      o22[h6] += i16, Object.defineProperty(t16, r18, { get() {
        return this[s14];
      }, set(e27) {
        if (this[s14] !== e27 && (this[s14] = e27, this._keyDirty = true, this._parameterBits[h6] = this._parameterBits[h6] & ~m7 | +e27 << n15 & m7, "number" != typeof e27 && "boolean" != typeof e27))
          throw new Error("Configuration value for " + r18 + " must be boolean or number, got " + typeof e27);
      } });
    }
  };
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/InstancedDoublePrecision.glsl.js
var h2 = class extends t6 {
  constructor() {
    super(...arguments), this.instancedDoublePrecision = false, this.hasModelTransformation = false;
  }
};
e([r9()], h2.prototype, "instancedDoublePrecision", void 0), e([r9()], h2.prototype, "hasModelTransformation", void 0);
var w2 = e4();
function N(e26, r18) {
  const i16 = r18.hasModelTransformation, c12 = r18.instancedDoublePrecision;
  i16 && (e26.vertex.uniforms.add(new e13("model", (e27) => e27.modelTransformation ?? o2)), e26.vertex.uniforms.add(new e12("normalLocalOriginFromModel", (e27) => (g2(w2, e27.modelTransformation ?? o2), w2)))), r18.instanced && c12 && (e26.attributes.add(e3.INSTANCEMODELORIGINHI, "vec3"), e26.attributes.add(e3.INSTANCEMODELORIGINLO, "vec3"), e26.attributes.add(e3.INSTANCEMODEL, "mat3"), e26.attributes.add(e3.INSTANCEMODELNORMAL, "mat3"));
  const v6 = e26.vertex;
  c12 && (v6.include(c4, r18), v6.uniforms.add(new o8("viewOriginHi", (e27, o22) => o3(o(T2, o22.camera.viewInverseTransposeMatrix[3], o22.camera.viewInverseTransposeMatrix[7], o22.camera.viewInverseTransposeMatrix[11]), T2)), new o8("viewOriginLo", (e27, o22) => r7(o(T2, o22.camera.viewInverseTransposeMatrix[3], o22.camera.viewInverseTransposeMatrix[7], o22.camera.viewInverseTransposeMatrix[11]), T2)))), v6.code.add(o4`
    vec3 getVertexInLocalOriginSpace() {
      return ${i16 ? c12 ? "(model * vec4(instanceModel * localPosition().xyz, 1.0)).xyz" : "(model * localPosition()).xyz" : c12 ? "instanceModel * localPosition().xyz" : "localPosition().xyz"};
    }

    vec3 subtractOrigin(vec3 _pos) {
      ${c12 ? o4`
          // Negated inputs are intentionally the first two arguments. The other way around the obfuscation in dpAdd() stopped
          // working for macOS 14+ and iOS 17+.
          // Issue: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/56280
          vec3 originDelta = dpAdd(-instanceModelOriginHi, -instanceModelOriginLo, viewOriginHi, viewOriginLo);
          return _pos - originDelta;` : "return vpos;"}
    }
    `), v6.code.add(o4`
    vec3 dpNormal(vec4 _normal) {
      return normalize(${i16 ? c12 ? "normalLocalOriginFromModel * (instanceModelNormal * _normal.xyz)" : "normalLocalOriginFromModel * _normal.xyz" : c12 ? "instanceModelNormal * _normal.xyz" : "_normal.xyz"});
    }
    `), r18.output === o6.Normal && (p3(v6), v6.code.add(o4`
    vec3 dpNormalView(vec4 _normal) {
      return normalize((viewNormal * ${i16 ? c12 ? "vec4(normalLocalOriginFromModel * (instanceModelNormal * _normal.xyz), 1.0)" : "vec4(normalLocalOriginFromModel * _normal.xyz, 1.0)" : c12 ? "vec4(instanceModelNormal * _normal.xyz, 1.0)" : "_normal"}).xyz);
    }
    `)), r18.hasVertexTangents && v6.code.add(o4`
    vec4 dpTransformVertexTangent(vec4 _tangent) {
      ${i16 ? c12 ? "return vec4(normalLocalOriginFromModel * (instanceModelNormal * _tangent.xyz), _tangent.w);" : "return vec4(normalLocalOriginFromModel * _tangent.xyz, _tangent.w);" : c12 ? "return vec4(instanceModelNormal * _tangent.xyz, _tangent.w);" : "return _tangent;"}
    }`);
}
var T2 = n2();

// node_modules/@arcgis/core/views/3d/webgl-engine/collections/Component/Material/shader/DecodeSymbolColor.glsl.js
function e15(e26) {
  e26.vertex.code.add(o4`
    vec4 decodeSymbolColor(vec4 symbolColor, out int colorMixMode) {
      float symbolAlpha = 0.0;

      const float maxTint = 85.0;
      const float maxReplace = 170.0;
      const float scaleAlpha = 3.0;

      if (symbolColor.a > maxReplace) {
        colorMixMode = ${o4.int(n6.Multiply)};
        symbolAlpha = scaleAlpha * (symbolColor.a - maxReplace);
      } else if (symbolColor.a > maxTint) {
        colorMixMode = ${o4.int(n6.Replace)};
        symbolAlpha = scaleAlpha * (symbolColor.a - maxTint);
      } else if (symbolColor.a > 0.0) {
        colorMixMode = ${o4.int(n6.Tint)};
        symbolAlpha = scaleAlpha * symbolColor.a;
      } else {
        colorMixMode = ${o4.int(n6.Multiply)};
        symbolAlpha = 0.0;
      }

      return vec4(symbolColor.r, symbolColor.g, symbolColor.b, symbolAlpha);
    }
  `);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/IntegerPassUniform.js
var e16 = class extends a5 {
  constructor(r18, e26) {
    super(r18, "int", a4.Pass, (s14, o22, i16) => s14.setUniform1i(r18, e26(o22, i16)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/screenSizePerspectiveUtils.js
function c6(e26) {
  return Math.abs(e26 * e26 * e26);
}
function l5(e26, t16, a16) {
  const r18 = a16.parameters;
  return F2.scale = Math.min(r18.divisor / (t16 - r18.offset), 1), F2.factor = c6(e26), F2;
}
function s7(t16, a16) {
  return s(t16 * Math.max(a16.scale, a16.minScaleFactor), t16, a16.factor);
}
function m2(e26, t16, a16, r18) {
  return s7(e26, l5(t16, a16, r18));
}
var v4 = { curvatureDependent: { min: { curvature: M(10), tiltAngle: M(12), scaleFallOffFactor: 0.5 }, max: { curvature: M(70), tiltAngle: M(40), scaleFallOffFactor: 0.8 } }, scaleStart: 0.3, scaleFallOffRange: 0.65, minPixelSize: 0 };
var F2 = { scale: 0, factor: 0, minScaleFactor: 0 };

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/internal/MaterialUtil.js
var p4 = i3();
function h3(t16, n15, e26, o22, i16, r18) {
  if (t16.visible)
    if (t16.boundingInfo) {
      s2(t16.type === e6.Mesh);
      const s14 = n15.tolerance;
      d6(t16.boundingInfo, e26, o22, s14, i16, r18);
    } else {
      const n16 = t16.attributes.get(e3.POSITION), s14 = n16.indices;
      M2(e26, o22, 0, s14.length / 3, s14, n16, void 0, i16, r18);
    }
}
var b2 = n2();
function d6(t16, n15, e26, o22, i16, r18) {
  if (null == t16)
    return;
  const s14 = T3(n15, e26, b2);
  if (A2(p4, t16.bbMin), G(p4, t16.bbMax), null != i16 && i16.applyToAabb(p4), I2(p4, n15, s14, o22)) {
    const { primitiveIndices: s15, position: c12 } = t16, l13 = s15 ? s15.length : c12.indices.length / 3;
    if (l13 > P3) {
      const s16 = t16.getChildren();
      if (void 0 !== s16) {
        for (const t17 of s16)
          d6(t17, n15, e26, o22, i16, r18);
        return;
      }
    }
    M2(n15, e26, 0, l13, c12.indices, c12, s15, i16, r18);
  }
}
var x = n2();
function M2(t16, n15, e26, o22, i16, r18, s14, c12, l13) {
  if (s14)
    return g4(t16, n15, e26, o22, i16, r18, s14, c12, l13);
  const { data: f7, stride: u5 } = r18, a16 = t16[0], m7 = t16[1], p7 = t16[2], h6 = n15[0] - a16, b4 = n15[1] - m7, d12 = n15[2] - p7;
  for (let M5 = e26, g7 = 3 * e26; M5 < o22; ++M5) {
    let t17 = u5 * i16[g7++], n16 = f7[t17++], e27 = f7[t17++], o23 = f7[t17];
    t17 = u5 * i16[g7++];
    let r19 = f7[t17++], s15 = f7[t17++], y5 = f7[t17];
    t17 = u5 * i16[g7++];
    let j3 = f7[t17++], T5 = f7[t17++], I4 = f7[t17];
    null != c12 && ([n16, e27, o23] = c12.applyToVertex(n16, e27, o23, M5), [r19, s15, y5] = c12.applyToVertex(r19, s15, y5, M5), [j3, T5, I4] = c12.applyToVertex(j3, T5, I4, M5));
    const V2 = r19 - n16, L3 = s15 - e27, N3 = y5 - o23, O4 = j3 - n16, A7 = T5 - e27, E6 = I4 - o23, P6 = b4 * E6 - A7 * d12, S4 = d12 * O4 - E6 * h6, U2 = h6 * A7 - O4 * b4, W2 = V2 * P6 + L3 * S4 + N3 * U2;
    if (Math.abs(W2) <= Number.EPSILON)
      continue;
    const k = a16 - n16, B4 = m7 - e27, C = p7 - o23, z2 = k * P6 + B4 * S4 + C * U2;
    if (W2 > 0) {
      if (z2 < 0 || z2 > W2)
        continue;
    } else if (z2 > 0 || z2 < W2)
      continue;
    const H2 = B4 * N3 - L3 * C, R3 = C * V2 - N3 * k, Y2 = k * L3 - V2 * B4, q = h6 * H2 + b4 * R3 + d12 * Y2;
    if (W2 > 0) {
      if (q < 0 || z2 + q > W2)
        continue;
    } else if (q > 0 || z2 + q < W2)
      continue;
    const w4 = (O4 * H2 + A7 * R3 + E6 * Y2) / W2;
    if (w4 >= 0) {
      l13(w4, v5(V2, L3, N3, O4, A7, E6, x), M5, false);
    }
  }
}
function g4(t16, n15, e26, o22, i16, r18, s14, c12, l13) {
  const { data: f7, stride: u5 } = r18, a16 = t16[0], m7 = t16[1], p7 = t16[2], h6 = n15[0] - a16, b4 = n15[1] - m7, d12 = n15[2] - p7;
  for (let M5 = e26; M5 < o22; ++M5) {
    const t17 = s14[M5];
    let n16 = 3 * t17, e27 = u5 * i16[n16++], o23 = f7[e27++], r19 = f7[e27++], g7 = f7[e27];
    e27 = u5 * i16[n16++];
    let y5 = f7[e27++], j3 = f7[e27++], T5 = f7[e27];
    e27 = u5 * i16[n16];
    let I4 = f7[e27++], V2 = f7[e27++], L3 = f7[e27];
    null != c12 && ([o23, r19, g7] = c12.applyToVertex(o23, r19, g7, M5), [y5, j3, T5] = c12.applyToVertex(y5, j3, T5, M5), [I4, V2, L3] = c12.applyToVertex(I4, V2, L3, M5));
    const N3 = y5 - o23, O4 = j3 - r19, A7 = T5 - g7, E6 = I4 - o23, P6 = V2 - r19, S4 = L3 - g7, U2 = b4 * S4 - P6 * d12, W2 = d12 * E6 - S4 * h6, k = h6 * P6 - E6 * b4, B4 = N3 * U2 + O4 * W2 + A7 * k;
    if (Math.abs(B4) <= Number.EPSILON)
      continue;
    const C = a16 - o23, z2 = m7 - r19, H2 = p7 - g7, R3 = C * U2 + z2 * W2 + H2 * k;
    if (B4 > 0) {
      if (R3 < 0 || R3 > B4)
        continue;
    } else if (R3 > 0 || R3 < B4)
      continue;
    const Y2 = z2 * A7 - O4 * H2, q = H2 * N3 - A7 * C, w4 = C * O4 - N3 * z2, D2 = h6 * Y2 + b4 * q + d12 * w4;
    if (B4 > 0) {
      if (D2 < 0 || R3 + D2 > B4)
        continue;
    } else if (D2 > 0 || R3 + D2 < B4)
      continue;
    const F4 = (E6 * Y2 + P6 * q + S4 * w4) / B4;
    if (F4 >= 0) {
      l13(F4, v5(N3, O4, A7, E6, P6, S4, x), t17, false);
    }
  }
}
var y2 = n2();
var j = n2();
function v5(t16, n15, r18, s14, c12, l13, f7) {
  return o(y2, t16, n15, r18), o(j, s14, c12, l13), _(f7, y2, j), z(f7, f7), f7;
}
function T3(t16, n15, o22) {
  return o(o22, 1 / (n15[0] - t16[0]), 1 / (n15[1] - t16[1]), 1 / (n15[2] - t16[2]));
}
function I2(t16, n15, e26, o22) {
  return V(t16, n15, e26, o22, 1 / 0);
}
function V(t16, n15, e26, o22, i16) {
  const r18 = (t16[0] - o22 - n15[0]) * e26[0], s14 = (t16[3] + o22 - n15[0]) * e26[0];
  let c12 = Math.min(r18, s14), l13 = Math.max(r18, s14);
  const f7 = (t16[1] - o22 - n15[1]) * e26[1], u5 = (t16[4] + o22 - n15[1]) * e26[1];
  if (l13 = Math.min(l13, Math.max(f7, u5)), l13 < 0)
    return false;
  if (c12 = Math.max(c12, Math.min(f7, u5)), c12 > l13)
    return false;
  const a16 = (t16[2] - o22 - n15[2]) * e26[2], m7 = (t16[5] + o22 - n15[2]) * e26[2];
  return l13 = Math.min(l13, Math.max(a16, m7)), !(l13 < 0) && (c12 = Math.max(c12, Math.min(a16, m7)), !(c12 > l13) && c12 < i16);
}
function L2(t16, e26, o22, i16, r18) {
  let s14 = (o22.screenLength || 0) * t16.pixelRatio;
  null != r18 && (s14 = m2(s14, i16, e26, r18));
  const c12 = s14 * Math.tan(0.5 * t16.fovY) / (0.5 * t16.fullHeight);
  return i(c12 * e26, o22.minWorldLength || 0, null != o22.maxWorldLength ? o22.maxWorldLength : 1 / 0);
}
function N2(t16, n15) {
  const e26 = n15 ? N2(n15) : {};
  for (const o22 in t16) {
    let n16 = t16[o22];
    (n16 == null ? void 0 : n16.forEach) && (n16 = A3(n16)), null == n16 && o22 in e26 || (e26[o22] = n16);
  }
  return e26;
}
function O2(n15, e26) {
  let o22 = false;
  for (const i16 in e26) {
    const r18 = e26[i16];
    void 0 !== r18 && (Array.isArray(r18) ? null === n15[i16] ? (n15[i16] = r18.slice(), o22 = true) : a(n15[i16], r18) && (o22 = true) : n15[i16] !== r18 && (o22 = true, n15[i16] = r18));
  }
  return o22;
}
function A3(t16) {
  const n15 = [];
  return t16.forEach((t17) => n15.push(t17)), n15;
}
var E3 = { multiply: 1, ignore: 2, replace: 3, tint: 4 };
var P3 = 1e3;

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/SymbolColor.glsl.js
function i7(i16, t16) {
  t16.hasSymbolColors ? (i16.include(e15), i16.attributes.add(e3.SYMBOLCOLOR, "vec4"), i16.varyings.add("colorMixMode", "mediump float"), i16.vertex.code.add(o4`int symbolColorMixMode;
vec4 getSymbolColor() {
return decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451;
}
void forwardColorMixMode() {
colorMixMode = float(symbolColorMixMode) + 0.5;
}`)) : (i16.fragment.uniforms.add(new e16("colorMixMode", (o22) => E3[o22.colorMixMode])), i16.vertex.code.add(o4`vec4 getSymbolColor() { return vec4(1.0); }
void forwardColorMixMode() {}`));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js
function e17(e26, d12) {
  d12.hasVertexColors ? (e26.attributes.add(e3.COLOR, "vec4"), e26.varyings.add("vColor", "vec4"), e26.vertex.code.add(o4`void forwardVertexColor() { vColor = color; }`), e26.vertex.code.add(o4`void forwardNormalizedVertexColor() { vColor = color * 0.003921568627451; }`)) : e26.vertex.code.add(o4`void forwardVertexColor() {}
void forwardNormalizedVertexColor() {}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/ScreenSizePerspective.glsl.js
function s8(e26) {
  e26.vertex.code.add(o4`float screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {
return absCosAngle * absCosAngle * absCosAngle;
}`), e26.vertex.code.add(o4`vec3 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec3 params) {
return vec3(
min(params.x / (distanceToCamera - params.y), 1.0),
screenSizePerspectiveViewAngleDependentFactor(absCosAngle),
params.z
);
}`), e26.vertex.code.add(o4`float applyScreenSizePerspectiveScaleFactorFloat(float size, vec3 factor) {
return mix(size * clamp(factor.x, factor.z, 1.0), size, factor.y);
}`), e26.vertex.code.add(o4`float screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec3 params) {
return applyScreenSizePerspectiveScaleFactorFloat(
size,
screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params)
);
}`), e26.vertex.code.add(o4`vec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec3 factor) {
return mix(size * clamp(factor.x, factor.z, 1.0), size, factor.y);
}`), e26.vertex.code.add(o4`vec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec3 params) {
return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));
}`);
}
function o14(e26) {
  e26.uniforms.add(new e10("screenSizePerspectiveAlignment", (e27) => i8(e27.screenSizePerspectiveAlignment || e27.screenSizePerspective)));
}
function i8(a16) {
  return o(n9, a16.parameters.divisor, a16.parameters.offset, a16.minScaleFactor);
}
var n9 = n2();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VerticalOffset.glsl.js
function a9(e26, r18) {
  const c12 = e26.vertex;
  r18.hasVerticalOffset ? (f4(c12), r18.hasScreenSizePerspective && (e26.include(s8), o14(c12), f3(e26.vertex, r18)), c12.code.add(o4`
      vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);
        ${r18.spherical ? o4`vec3 worldNormal = normalize(worldPos + localOrigin);` : o4`vec3 worldNormal = vec3(0.0, 0.0, 1.0);`}
        ${r18.hasScreenSizePerspective ? o4`
            float cosAngle = dot(worldNormal, normalize(worldPos - cameraPosition));
            float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);` : o4`
            float verticalOffsetScreenHeight = verticalOffset.x;`}
        // Screen sized offset in world space, used for example for line callouts
        float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);
        return worldNormal * worldOffset;
      }

      vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        return worldPos + calculateVerticalOffset(worldPos, localOrigin);
      }
    `)) : c12.code.add(o4`vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) { return worldPos; }`);
}
var i9 = n3();
function f4(r18) {
  r18.uniforms.add(new e9("verticalOffset", (r19, t16) => {
    const { minWorldLength: l13, maxWorldLength: o22, screenLength: c12 } = r19.verticalOffset, s14 = Math.tan(0.5 * t16.camera.fovY) / (0.5 * t16.camera.fullViewport[3]), a16 = t16.camera.pixelRatio || 1;
    return r3(i9, c12 * a16, s14, l13, o22);
  }));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Float4sPassUniform.js
var e18 = class extends a5 {
  constructor(r18, e26, o22) {
    super(r18, "vec4", a4.Pass, (s14, o23, t16) => s14.setUniform4fv(r18, e26(o23, t16)), o22);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/FloatsPassUniform.js
var o15 = class extends a5 {
  constructor(r18, o22, e26) {
    super(r18, "float", a4.Pass, (s14, e27, t16) => s14.setUniform1fv(r18, o22(e27, t16)), e26);
  }
};

// node_modules/@arcgis/core/views/3d/support/debugFlags.js
var T4 = class extends g {
  constructor() {
    super(...arguments), this.SCENEVIEW_HITTEST_RETURN_INTERSECTOR = false, this.DECONFLICTOR_SHOW_VISIBLE = false, this.DECONFLICTOR_SHOW_INVISIBLE = false, this.DECONFLICTOR_SHOW_GRID = false, this.LABELS_SHOW_BORDER = false, this.TEXT_SHOW_BASELINE = false, this.TEXT_SHOW_BORDER = false, this.OVERLAY_DRAW_DEBUG_TEXTURE = false, this.OVERLAY_SHOW_CENTER = false, this.SHOW_POI = false, this.TESTS_DISABLE_OPTIMIZATIONS = false, this.TESTS_DISABLE_FAST_UPDATES = false, this.DRAW_MESH_GEOMETRY_NORMALS = false, this.FEATURE_TILE_FETCH_SHOW_TILES = false, this.FEATURE_TILE_TREE_SHOW_TILES = false, this.TERRAIN_TILE_TREE_SHOW_TILES = false, this.I3S_TREE_SHOW_TILES = false, this.I3S_SHOW_MODIFICATIONS = false, this.LOD_INSTANCE_RENDERER_DISABLE_UPDATES = false, this.LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL = false, this.EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES = false, this.LINE_WIREFRAMES = false;
  }
};
e([y()], T4.prototype, "SCENEVIEW_HITTEST_RETURN_INTERSECTOR", void 0), e([y()], T4.prototype, "DECONFLICTOR_SHOW_VISIBLE", void 0), e([y()], T4.prototype, "DECONFLICTOR_SHOW_INVISIBLE", void 0), e([y()], T4.prototype, "DECONFLICTOR_SHOW_GRID", void 0), e([y()], T4.prototype, "LABELS_SHOW_BORDER", void 0), e([y()], T4.prototype, "TEXT_SHOW_BASELINE", void 0), e([y()], T4.prototype, "TEXT_SHOW_BORDER", void 0), e([y()], T4.prototype, "OVERLAY_DRAW_DEBUG_TEXTURE", void 0), e([y()], T4.prototype, "OVERLAY_SHOW_CENTER", void 0), e([y()], T4.prototype, "SHOW_POI", void 0), e([y()], T4.prototype, "TESTS_DISABLE_OPTIMIZATIONS", void 0), e([y()], T4.prototype, "TESTS_DISABLE_FAST_UPDATES", void 0), e([y()], T4.prototype, "DRAW_MESH_GEOMETRY_NORMALS", void 0), e([y()], T4.prototype, "FEATURE_TILE_FETCH_SHOW_TILES", void 0), e([y()], T4.prototype, "FEATURE_TILE_TREE_SHOW_TILES", void 0), e([y()], T4.prototype, "TERRAIN_TILE_TREE_SHOW_TILES", void 0), e([y()], T4.prototype, "I3S_TREE_SHOW_TILES", void 0), e([y()], T4.prototype, "I3S_SHOW_MODIFICATIONS", void 0), e([y()], T4.prototype, "LOD_INSTANCE_RENDERER_DISABLE_UPDATES", void 0), e([y()], T4.prototype, "LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL", void 0), e([y()], T4.prototype, "EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES", void 0), e([y()], T4.prototype, "LINE_WIREFRAMES", void 0), T4 = e([c("esri.views.3d.support.DebugFlags")], T4);
var t7 = new T4();

// node_modules/@arcgis/core/views/3d/layers/support/FastSymbolUpdates.js
var S3;
var y3;
!function(e26) {
  e26[e26.Undefined = 0] = "Undefined", e26[e26.DefinedSize = 1] = "DefinedSize", e26[e26.DefinedScale = 2] = "DefinedScale";
}(S3 || (S3 = {})), function(e26) {
  e26[e26.Undefined = 0] = "Undefined", e26[e26.DefinedAngle = 1] = "DefinedAngle";
}(y3 || (y3 = {}));
var Y = e5();
var Z = n2();
var ee = e5();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/DefaultVertexAttributeLocations.js
var E4 = /* @__PURE__ */ new Map([[e3.POSITION, 0], [e3.NORMAL, 1], [e3.NORMALCOMPRESSED, 1], [e3.UV0, 2], [e3.COLOR, 3], [e3.COLORFEATUREATTRIBUTE, 3], [e3.SIZE, 4], [e3.TANGENT, 4], [e3.AUXPOS1, 5], [e3.SYMBOLCOLOR, 5], [e3.AUXPOS2, 6], [e3.FEATUREATTRIBUTE, 6], [e3.INSTANCEFEATUREATTRIBUTE, 6], [e3.INSTANCECOLOR, 7], [e3.OBJECTANDLAYERIDCOLOR, 7], [e3.INSTANCEOBJECTANDLAYERIDCOLOR, 7], [e3.INSTANCEMODEL, 8], [e3.INSTANCEMODELNORMAL, 12], [e3.INSTANCEMODELORIGINHI, 11], [e3.INSTANCEMODELORIGINLO, 15]]);

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Material.js
var c8 = class extends r6 {
  constructor(t16, r18) {
    super(), this.type = e6.Material, this.supportsEdges = false, this._visible = true, this._renderPriority = 0, this._vertexAttributeLocations = E4, this._pp0 = r2(0, 0, 1), this._pp1 = r2(0, 0, 0), this._parameters = N2(t16, r18), this.validateParameters(this._parameters);
  }
  get parameters() {
    return this._parameters;
  }
  update(e26) {
    return false;
  }
  setParameters(e26, t16 = true) {
    O2(this._parameters, e26) && (this.validateParameters(this._parameters), t16 && this.parametersChanged());
  }
  validateParameters(e26) {
  }
  get visible() {
    return this._visible;
  }
  set visible(e26) {
    e26 !== this._visible && (this._visible = e26, this.parametersChanged());
  }
  shouldRender(e26) {
    return this.isVisible() && this.isVisibleForOutput(e26.output) && (!this.parameters.isDecoration || e26.bindParameters.decorations === i4.ON) && 0 != (this.parameters.renderOccluded & e26.renderOccludedMask);
  }
  isVisibleForOutput(e26) {
    return true;
  }
  get renderPriority() {
    return this._renderPriority;
  }
  set renderPriority(e26) {
    e26 !== this._renderPriority && (this._renderPriority = e26, this.parametersChanged());
  }
  get vertexAttributeLocations() {
    return this._vertexAttributeLocations;
  }
  isVisible() {
    return this._visible;
  }
  parametersChanged() {
    var _a;
    (_a = this.repository) == null ? void 0 : _a.materialChanged(this);
  }
  intersectDraped(e26, t16, r18, s14, i16, a16) {
    return this._pp0[0] = this._pp1[0] = s14[0], this._pp0[1] = this._pp1[1] = s14[1], this.intersect(e26, t16, r18, this._pp0, this._pp1, i16);
  }
};
var d7;
!function(e26) {
  e26[e26.None = 0] = "None", e26[e26.Occlude = 1] = "Occlude", e26[e26.Transparent = 2] = "Transparent", e26[e26.OccludeAndTransparent = 4] = "OccludeAndTransparent", e26[e26.OccludeAndTransparentStencil = 8] = "OccludeAndTransparentStencil", e26[e26.Opaque = 16] = "Opaque";
}(d7 || (d7 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/VisualVariablePassParameters.js
var e19 = 8;

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/VisualVariables.glsl.js
function l7(l13, n15) {
  const { vertex: s14, attributes: u5 } = l13;
  n15.hasVvInstancing && (n15.vvSize || n15.vvColor) && u5.add(e3.INSTANCEFEATUREATTRIBUTE, "vec4"), n15.vvSize ? (s14.uniforms.add(new e10("vvSizeMinSize", (e26) => e26.vvSize.minSize)), s14.uniforms.add(new e10("vvSizeMaxSize", (e26) => e26.vvSize.maxSize)), s14.uniforms.add(new e10("vvSizeOffset", (e26) => e26.vvSize.offset)), s14.uniforms.add(new e10("vvSizeFactor", (e26) => e26.vvSize.factor)), s14.uniforms.add(new e12("vvSymbolRotationMatrix", (e26) => e26.vvSymbolRotationMatrix)), s14.uniforms.add(new e10("vvSymbolAnchor", (e26) => e26.vvSymbolAnchor)), s14.code.add(o4`vec3 vvScale(vec4 _featureAttribute) {
return clamp(vvSizeOffset + _featureAttribute.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize);
}
vec4 vvTransformPosition(vec3 position, vec4 _featureAttribute) {
return vec4(vvSymbolRotationMatrix * ( vvScale(_featureAttribute) * (position + vvSymbolAnchor)), 1.0);
}`), s14.code.add(o4`
      const float eps = 1.192092896e-07;
      vec4 vvTransformNormal(vec3 _normal, vec4 _featureAttribute) {
        vec3 vvScale = clamp(vvSizeOffset + _featureAttribute.x * vvSizeFactor, vvSizeMinSize + eps, vvSizeMaxSize);
        return vec4(vvSymbolRotationMatrix * _normal / vvScale, 1.0);
      }

      ${n15.hasVvInstancing ? o4`
      vec4 vvLocalNormal(vec3 _normal) {
        return vvTransformNormal(_normal, instanceFeatureAttribute);
      }

      vec4 localPosition() {
        return vvTransformPosition(position, instanceFeatureAttribute);
      }` : ""}
    `)) : s14.code.add(o4`vec4 localPosition() { return vec4(position, 1.0); }
vec4 vvLocalNormal(vec3 _normal) { return vec4(_normal, 1.0); }`), n15.vvColor ? (s14.constants.add("vvColorNumber", "int", e19), s14.uniforms.add(new o15("vvColorValues", (e26) => e26.vvColor.values, e19), new e18("vvColorColors", (e26) => e26.vvColor.colors, e19)), s14.code.add(o4`
      vec4 interpolateVVColor(float value) {
        if (value <= vvColorValues[0]) {
          return vvColorColors[0];
        }

        for (int i = 1; i < vvColorNumber; ++i) {
          if (vvColorValues[i] >= value) {
            float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);
            return mix(vvColorColors[i-1], vvColorColors[i], f);
          }
        }
        return vvColorColors[vvColorNumber - 1];
      }

      vec4 vvGetColor(vec4 featureAttribute) {
        return interpolateVVColor(featureAttribute.y);
      }

      ${n15.hasVvInstancing ? o4`
            vec4 vvColor() {
              return vvGetColor(instanceFeatureAttribute);
            }` : "vec4 vvColor() { return vec4(1.0); }"}
    `)) : s14.code.add(o4`vec4 vvColor() { return vec4(1.0); }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/DiscardOrAdjustAlphaBlend.glsl.js
function d8(d12) {
  d12.fragment.code.add(o4`
    #define discardOrAdjustAlpha(color) { if (color.a < ${o4.float(t4)}) { discard; } }
  `);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl.js
function s10(a16, e26) {
  l8(a16, e26, new o5("textureAlphaCutoff", (a17) => a17.textureAlphaCutoff));
}
function l8(e26, r18, s14) {
  const t16 = e26.fragment;
  switch (r18.alphaDiscardMode !== s3.Mask && r18.alphaDiscardMode !== s3.MaskBlend || t16.uniforms.add(s14), r18.alphaDiscardMode) {
    case s3.Blend:
      return e26.include(d8);
    case s3.Opaque:
      t16.code.add(o4`void discardOrAdjustAlpha(inout vec4 color) {
color.a = 1.0;
}`);
      break;
    case s3.Mask:
      t16.code.add(o4`#define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } else { color.a = 1.0; } }`);
      break;
    case s3.MaskBlend:
      e26.fragment.code.add(o4`#define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } }`);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/ObjectAndLayerIdColor.glsl.js
function d9(d12, t16) {
  const a16 = t16.output === o6.ObjectAndLayerIdColor, n15 = t16.objectAndLayerIdColorInstanced;
  a16 && (d12.varyings.add("objectAndLayerIdColorVarying", "vec4"), n15 ? d12.attributes.add(e3.INSTANCEOBJECTANDLAYERIDCOLOR, "vec4") : d12.attributes.add(e3.OBJECTANDLAYERIDCOLOR, "vec4")), d12.vertex.code.add(o4`
     void forwardObjectAndLayerIdColor() {
      ${a16 ? n15 ? o4`objectAndLayerIdColorVarying = instanceObjectAndLayerIdColor * 0.003921568627451;` : o4`objectAndLayerIdColorVarying = objectAndLayerIdColor * 0.003921568627451;` : o4``} }`), d12.fragment.code.add(o4`
      void outputObjectAndLayerIdColor() {
        ${a16 ? o4`fragColor = objectAndLayerIdColorVarying;` : o4``} }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloat16Encoding.glsl.js
function a11(a16) {
  a16.code.add(o4`const float MAX_RGBA4_FLOAT =
15.0 / 16.0 +
15.0 / 16.0 / 16.0 +
15.0 / 16.0 / 16.0 / 16.0 +
15.0 / 16.0 / 16.0 / 16.0 / 16.0;
const vec4 FIXED_POINT_FACTORS_RGBA4 = vec4(1.0, 16.0, 16.0 * 16.0, 16.0 * 16.0 * 16.0);
vec4 floatToRgba4(const float value) {
float valueInValidDomain = clamp(value, 0.0, MAX_RGBA4_FLOAT);
vec4 fixedPointU4 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS_RGBA4) * 16.0);
const float toU4AsFloat = 1.0 / 15.0;
return fixedPointU4 * toU4AsFloat;
}
const vec4 RGBA4_2_FLOAT_FACTORS = vec4(
15.0 / (16.0),
15.0 / (16.0 * 16.0),
15.0 / (16.0 * 16.0 * 16.0),
15.0 / (16.0 * 16.0 * 16.0 * 16.0)
);
float rgba4ToFloat(vec4 rgba) {
return dot(rgba, RGBA4_2_FLOAT_FACTORS);
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js
function l9(l13, r18) {
  switch (r18.output) {
    case o6.Shadow:
    case o6.ShadowHighlight:
    case o6.ShadowExcludeHighlight:
      l13.fragment.include(a11), l13.fragment.code.add(o4`float _calculateFragDepth(const in float depth) {
const float SLOPE_SCALE = 2.0;
const float BIAS = 20.0 * .000015259;
float m = max(abs(dFdx(depth)), abs(dFdy(depth)));
return depth + SLOPE_SCALE * m + BIAS;
}
void outputDepth(float _linearDepth) {
fragColor = floatToRgba4(_calculateFragDepth(_linearDepth));
}`);
      break;
    case o6.Depth:
      l13.fragment.include(a6), l13.fragment.code.add(o4`void outputDepth(float _linearDepth) {
fragColor = float2rgba(_linearDepth);
}`);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js
var d10 = r4(1, 1, 0, 1);
var r11 = r4(1, 0, 1, 1);
function a12(e26) {
  e26.fragment.uniforms.add(new s5("depthTexture", (e27, o22) => o22.mainDepth)), e26.fragment.constants.add("occludedHighlightFlag", "vec4", d10).add("unoccludedHighlightFlag", "vec4", r11), e26.fragment.code.add(o4`void outputHighlight() {
float sceneDepth = float(texelFetch(depthTexture, ivec2(gl_FragCoord.xy), 0).x);
if (gl_FragCoord.z > sceneDepth + 5e-7) {
fragColor = occludedHighlightFlag;
} else {
fragColor = unoccludedHighlightFlag;
}
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/default/DefaultMaterialAuxiliaryPasses.glsl.js
function h4(h6, x5) {
  const { vertex: j3, fragment: O4 } = h6, w4 = x5.hasColorTexture && x5.alphaDiscardMode !== s3.Opaque;
  switch (x5.output) {
    case o6.Depth:
    case o6.Shadow:
    case o6.ShadowHighlight:
    case o6.ShadowExcludeHighlight:
    case o6.ObjectAndLayerIdColor:
      d5(j3, x5), h6.include(o12, x5), h6.include(o7, x5), h6.include(l7, x5), h6.include(l9, x5), h6.include(P2, x5), h6.include(d9, x5), i6(h6), h6.varyings.add("depth", "float"), w4 && O4.uniforms.add(new s5("tex", (o22) => o22.texture)), j3.code.add(o4`void main(void) {
vpos = getVertexInLocalOriginSpace();
vpos = subtractOrigin(vpos);
vpos = addVerticalOffset(vpos, localOrigin);
gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);
forwardTextureCoordinates();
forwardObjectAndLayerIdColor();
}`), h6.include(s10, x5), O4.code.add(o4`
          void main(void) {
            discardBySlice(vpos);
            ${w4 ? o4`
                    vec4 texColor = texture(tex, ${x5.hasColorTextureTransform ? o4`colorUV` : o4`vuv0`});
                    discardOrAdjustAlpha(texColor);` : ""}
            ${x5.output === o6.ObjectAndLayerIdColor ? o4`outputObjectAndLayerIdColor();` : o4`outputDepth(depth);`}
          }
        `);
      break;
    case o6.Normal: {
      d5(j3, x5), h6.include(o12, x5), h6.include(t2, x5), h6.include(c5, x5), h6.include(o7, x5), h6.include(l7, x5), w4 && O4.uniforms.add(new s5("tex", (o23) => o23.texture)), x5.normalType === a8.ScreenDerivative && h6.varyings.add("vPositionView", "vec3");
      const o22 = x5.normalType === a8.Attribute || x5.normalType === a8.Compressed;
      j3.code.add(o4`
          void main(void) {
            vpos = getVertexInLocalOriginSpace();

            ${o22 ? o4`vNormalWorld = dpNormalView(vvLocalNormal(normalModel()));` : o4`
                  // Get vertex position in camera space for screen-space derivative normals
                  vPositionView = (view * vec4(vpos, 1.0)).xyz;
                `}
            vpos = subtractOrigin(vpos);
            vpos = addVerticalOffset(vpos, localOrigin);
            gl_Position = transformPosition(proj, view, vpos);
            forwardTextureCoordinates();
          }
        `), h6.include(P2, x5), h6.include(s10, x5), O4.code.add(o4`
          void main() {
            discardBySlice(vpos);
            ${w4 ? o4`
                    vec4 texColor = texture(tex, ${x5.hasColorTextureTransform ? o4`colorUV` : o4`vuv0`});
                    discardOrAdjustAlpha(texColor);` : ""}

            ${x5.normalType === a8.ScreenDerivative ? o4`vec3 normal = screenDerivativeNormal(vPositionView);` : o4`
                  vec3 normal = normalize(vNormalWorld);
                  if (gl_FrontFacing == false){
                    normal = -normal;
                  }`}
            fragColor = vec4(0.5 + 0.5 * normal, 1.0);
          }
        `);
      break;
    }
    case o6.Highlight:
      d5(j3, x5), h6.include(o12, x5), h6.include(o7, x5), h6.include(l7, x5), w4 && O4.uniforms.add(new s5("tex", (o22) => o22.texture)), j3.code.add(o4`void main(void) {
vpos = getVertexInLocalOriginSpace();
vpos = subtractOrigin(vpos);
vpos = addVerticalOffset(vpos, localOrigin);
gl_Position = transformPosition(proj, view, vpos);
forwardTextureCoordinates();
}`), h6.include(P2, x5), h6.include(s10, x5), h6.include(a12, x5), O4.code.add(o4`
          void main() {
            discardBySlice(vpos);
            ${w4 ? o4`
                    vec4 texColor = texture(tex, ${x5.hasColorTextureTransform ? o4`colorUV` : o4`vuv0`});
                    discardOrAdjustAlpha(texColor);` : ""}
            outputHighlight();
          }
        `);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/FBOCache.js
var R;
!function(e26) {
  e26[e26.RED = 0] = "RED", e26[e26.RG = 1] = "RG", e26[e26.RGBA4 = 2] = "RGBA4", e26[e26.RGBA = 3] = "RGBA", e26[e26.RGBA_MIPMAP = 4] = "RGBA_MIPMAP", e26[e26.R16F = 5] = "R16F", e26[e26.RGBA16F = 6] = "RGBA16F";
}(R || (R = {}));
var w3 = new e7();
w3.pixelFormat = G2.RED, w3.internalFormat = P.R8, w3.wrapMode = D.CLAMP_TO_EDGE;
var f6 = new e7();
f6.pixelFormat = G2.RG, f6.internalFormat = P.RG8, f6.wrapMode = D.CLAMP_TO_EDGE;
var F3 = new e7();
F3.internalFormat = P.RGBA4, F3.dataType = U.UNSIGNED_SHORT_4_4_4_4, F3.wrapMode = D.CLAMP_TO_EDGE;
var A4 = new e7();
A4.wrapMode = D.CLAMP_TO_EDGE;
var M3 = new e7();
M3.wrapMode = D.CLAMP_TO_EDGE, M3.samplingMode = L.LINEAR_MIPMAP_LINEAR, M3.hasMipmap = true, M3.maxAnisotropy = 8;
var P4 = new e7();
P4.pixelFormat = G2.RED, P4.dataType = U.HALF_FLOAT, P4.internalFormat = P.R16F, P4.samplingMode = L.NEAREST;
var x3 = new e7();
x3.dataType = U.HALF_FLOAT, x3.internalFormat = P.RGBA16F, x3.samplingMode = L.NEAREST;
var b3 = { [R.RED]: w3, [R.RG]: f6, [R.RGBA4]: F3, [R.RGBA]: A4, [R.RGBA_MIPMAP]: M3, [R.R16F]: P4, [R.RGBA16F]: x3 };
var g5;
!function(e26) {
  e26[e26.DEPTH_STENCIL_TEXTURE = 0] = "DEPTH_STENCIL_TEXTURE", e26[e26.DEPTH_STENCIL_BUFFER = 1] = "DEPTH_STENCIL_BUFFER", e26[e26.DEPTH24_BUFFER = 2] = "DEPTH24_BUFFER", e26[e26.DEPTH16_BUFFER = 3] = "DEPTH16_BUFFER";
}(g5 || (g5 = {}));
var B3 = new e7();
B3.pixelFormat = G2.DEPTH_STENCIL, B3.dataType = U.UNSIGNED_INT_24_8, B3.samplingMode = L.NEAREST, B3.wrapMode = D.CLAMP_TO_EDGE;
var G3 = { [g5.DEPTH_STENCIL_TEXTURE]: B3, [g5.DEPTH_STENCIL_BUFFER]: new i5(B.DEPTH24_STENCIL8, 4), [g5.DEPTH24_BUFFER]: new i5(B.DEPTH_COMPONENT24, 4), [g5.DEPTH16_BUFFER]: new i5(B.DEPTH_COMPONENT16, 4) };

// node_modules/@arcgis/core/views/3d/webgl-engine/effects/RenderPlugin.js
var s12 = { required: [] };
var t8 = { required: [o6.Depth] };
var o16 = { required: [o6.CompositeColor] };
var n11 = { required: [o6.Highlight] };
var d11 = { required: [o6.Depth, o6.Normal] };
var i13 = class extends g {
  consumes() {
    return s12;
  }
  get usedMemory() {
    return 0;
  }
  get isDecoration() {
    return false;
  }
  get running() {
    return false;
  }
};
var u2 = class extends i13 {
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/ReloadableShaderModule.js
var t9 = class {
  constructor(t16, o22) {
    this._module = t16, this._loadModule = o22;
  }
  get() {
    return this._module;
  }
  async reload() {
    return this._module = await this._loadModule(), this._module;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/ShaderTechnique.js
var r12 = class {
  constructor(i16, t16, r18) {
    this.release = r18, this.initializeConfiguration(i16, t16), this._configuration = t16.snapshot(), this._program = this.initializeProgram(i16), this._pipeline = this.initializePipeline(i16.rctx.capabilities);
  }
  destroy() {
    this._program = r(this._program), this._pipeline = this._configuration = null;
  }
  reload(t16) {
    r(this._program), this._program = this.initializeProgram(t16), this._pipeline = this.initializePipeline(t16.rctx.capabilities);
  }
  get program() {
    return this._program;
  }
  get compiled() {
    return this.program.compiled;
  }
  get key() {
    return this._configuration.key;
  }
  get configuration() {
    return this._configuration;
  }
  ensureAttributeLocations(i16) {
    this.program.assertCompatibleVertexAttributeLocations(i16);
  }
  get primitiveType() {
    return E2.TRIANGLES;
  }
  getPipeline(i16, t16, r18) {
    return this._pipeline;
  }
  initializeConfiguration(i16, t16) {
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Program.js
var r13 = class {
  constructor(r18, i16, s14) {
    this._context = r18, this._locations = s14, this._textures = /* @__PURE__ */ new Map(), this._freeTextureUnits = new l({ deallocator: null }), this._glProgram = r18.programCache.acquire(i16.generate("vertex"), i16.generate("fragment"), s14), this._glProgram.stop = () => {
      throw new Error("Wrapped _glProgram used directly");
    }, this.bindPass = i16.generateBindPass(this), this.bindDraw = i16.generateBindDraw(this), this._fragmentUniforms = a3() ? i16.fragmentUniforms : null;
  }
  dispose() {
    this._glProgram.dispose();
  }
  get glName() {
    return this._glProgram.glName;
  }
  get compiled() {
    return this._glProgram.compiled;
  }
  setUniform1b(t16, e26) {
    this._glProgram.setUniform1i(t16, e26 ? 1 : 0);
  }
  setUniform1i(t16, e26) {
    this._glProgram.setUniform1i(t16, e26);
  }
  setUniform1f(t16, e26) {
    this._glProgram.setUniform1f(t16, e26);
  }
  setUniform2fv(t16, e26) {
    this._glProgram.setUniform2fv(t16, e26);
  }
  setUniform3fv(t16, e26) {
    this._glProgram.setUniform3fv(t16, e26);
  }
  setUniform4fv(t16, e26) {
    this._glProgram.setUniform4fv(t16, e26);
  }
  setUniformMatrix3fv(t16, e26) {
    this._glProgram.setUniformMatrix3fv(t16, e26);
  }
  setUniformMatrix4fv(t16, e26) {
    this._glProgram.setUniformMatrix4fv(t16, e26);
  }
  setUniform1fv(t16, e26) {
    this._glProgram.setUniform1fv(t16, e26);
  }
  setUniform1iv(t16, e26) {
    this._glProgram.setUniform1iv(t16, e26);
  }
  setUniform2iv(t16, e26) {
    this._glProgram.setUniform3iv(t16, e26);
  }
  setUniform3iv(t16, e26) {
    this._glProgram.setUniform3iv(t16, e26);
  }
  setUniform4iv(t16, e26) {
    this._glProgram.setUniform4iv(t16, e26);
  }
  assertCompatibleVertexAttributeLocations(t16) {
    t16.locations !== this._locations && console.error("VertexAttributeLocations are incompatible");
  }
  stop() {
    this._textures.clear(), this._freeTextureUnits.clear();
  }
  bindTexture(t16, e26) {
    if (null == (e26 == null ? void 0 : e26.glName)) {
      const e27 = this._textures.get(t16);
      return e27 && (this._context.bindTexture(null, e27.unit), this._freeTextureUnit(e27), this._textures.delete(t16)), null;
    }
    let r18 = this._textures.get(t16);
    return null == r18 ? (r18 = this._allocTextureUnit(e26), this._textures.set(t16, r18)) : r18.texture = e26, this._context.useProgram(this), this.setUniform1i(t16, r18.unit), this._context.bindTexture(e26, r18.unit), r18.unit;
  }
  rebindTextures() {
    this._context.useProgram(this), this._textures.forEach((t16, e26) => {
      this._context.bindTexture(t16.texture, t16.unit), this.setUniform1i(e26, t16.unit);
    }), null != this._fragmentUniforms && this._fragmentUniforms.forEach((t16) => {
      "sampler2D" !== t16.type && "samplerCube" !== t16.type || this._textures.has(t16.name) || console.error(`Texture sampler ${t16.name} has no bound texture`);
    });
  }
  _allocTextureUnit(t16) {
    return { texture: t16, unit: 0 === this._freeTextureUnits.length ? this._textures.size : this._freeTextureUnits.pop() };
  }
  _freeTextureUnit(t16) {
    this._freeTextureUnits.push(t16.unit);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/effects/ssao/SSAOBlurTechnique.js
var a13 = class _a extends r12 {
  initializeProgram(r18) {
    return new r13(r18.rctx, _a.shader.get().build(), E4);
  }
  initializePipeline() {
    return S({ colorWrite: _3 });
  }
};
a13.shader = new t9(c2, () => import("./SSAOBlur.glsl-7NOCE3VN.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/effects/ssao/SSAONoiseData.js
var e22 = "eXKEvZaUc66cjIKElE1jlJ6MjJ6Ufkl+jn2fcXp5jBx7c6KEflSGiXuXeW6OWs+tfqZ2Yot2Y7Zzfo2BhniEj3xoiXuXj4eGZpqEaHKDWjSMe7palFlzc3BziYOGlFVzg6Zzg7CUY5JrjFF7eYJ4jIKEcyyEonSXe7qUfqZ7j3xofqZ2c4R5lFZ5Y0WUbppoe1l2cIh2ezyUho+BcHN2cG6DbpqJhqp2e1GcezhrdldzjFGUcyxjc3aRjDyEc1h7Sl17c6aMjH92pb6Mjpd4dnqBjMOEhqZleIOBYzB7gYx+fnqGjJuEkWlwnCx7fGl+c4hjfGyRe5qMlNOMfnqGhIWHc6OMi4GDc6aMfqZuc6aMzqJzlKZ+lJ6Me3qRfoFue0WUhoR5UraEa6qMkXiPjMOMlJOGe7JrUqKMjK6MeYRzdod+Sl17boiPc6qEeYBlcIh2c1WEe7GDiWCDa0WMjEmMdod+Y0WcdntzhmN8WjyMjKJjiXtzgYxYaGd+a89zlEV7e2GJfnd+lF1rcK5zc4p5cHuBhL6EcXp5eYB7fnh8iX6HjIKEeaxuiYOGc66RfG2Ja5hzjlGMjEmMe9OEgXuPfHyGhPeEdl6JY02McGuMfnqGhFiMa3WJfnx2l4hwcG1uhmN8c0WMc39og1GBbrCEjE2EZY+JcIh2cIuGhIWHe0mEhIVrc09+gY5+eYBlnCyMhGCDl3drfmmMgX15aGd+gYx+fnuRfnhzY1SMsluJfnd+hm98WtNrcIuGh4SEj0qPdkqOjFF7jNNjdnqBgaqUjMt7boeBhnZ4jDR7c5pze4GGjEFrhLqMjHyMc0mUhKZze4WEa117kWlwbpqJjHZ2eX2Bc09zeId+e0V7WlF7jHJ2l72BfId8l3eBgXyBe897jGl7c66cgW+Xc76EjKNbgaSEjGx4fId8jFFjgZB8cG6DhlFziZhrcIh2fH6HgUqBgXiPY8dahGFzjEmMhEFre2dxhoBzc5SGfleGe6alc7aUeYBlhKqUdlp+cH5za4OEczxza0Gcc4J2jHZ5iXuXjH2Jh5yRjH2JcFx+hImBjH+MpddCl3dreZeJjIt8ZW18bm1zjoSEeIOBlF9oh3N7hlqBY4+UeYFwhLJjeYFwaGd+gUqBYxiEYot2fqZ2ondzhL6EYyiEY02Ea0VjgZB8doaGjHxoc66cjEGEiXuXiXWMiZhreHx8frGMe75rY02Ec5pzfnhzlEp4a3VzjM+EhFFza3mUY7Zza1V5e2iMfGyRcziEhDyEkXZ2Y4OBnCx7g5t2eyBjgV6EhEFrcIh2dod+c4Z+nJ5zjm15jEmUeYxijJp7nL6clIpjhoR5WrZraGd+fnuRa6pzlIiMg6ZzfHx5foh+eX1ufnB5eX1ufnB5aJt7UqKMjIh+e3aBfm5lbYSBhGFze6J4c39oc0mUc4Z+e0V7fKFVe0WEdoaGY02Ec4Z+Y02EZYWBfH6HgU1+gY5+hIWUgW+XjJ57ebWRhFVScHuBfJ6PhBx7WqJzlM+Ujpd4gHZziX6HjHmEgZN+lJt5boiPe2GJgX+GjIGJgHZzeaxufnB5hF2JtdN7jJ57hp57hK6ElFVzg6ZzbmiEbndzhIWHe3uJfoFue3qRhJd2j3xoc65zlE1jc3p8lE1jhniEgXJ7e657vZaUc3qBh52BhIF4aHKDa9drgY5+c52GWqZzbpqJe8tjnM+UhIeMfo2BfGl+hG1zSmmMjKJjZVaGgX15c1lze0mEp4OHa3mUhIWHhDyclJ6MeYOJkXiPc0VzhFiMlKaEboSJa5Jze41re3qRhn+HZYWBe0mEc4p5fnORbox5lEp4hGFjhGGEjJuEc1WEhLZjeHeGa7KlfHx2hLaMeX1ugY5+hIWHhKGPjMN7c1WEho1zhoBzZYx7fnhzlJt5exyUhFFziXtzfmmMa6qMYyiEiXxweV12kZSMeWqXSl17fnhzxmmMrVGEe1mcc4p5eHeGjK6MgY5+doaGa6pzlGV7g1qBh4KHkXiPeW6OaKqafqZ2eXZ5e1V7jGd7boSJc3BzhJd2e0mcYot2h1RoY8dahK6EQmWEWjx7e1l2lL6UgXyBdnR4eU9zc0VreX1umqaBhld7fo2Bc6KEc5Z+hDyEcIeBWtNrfHyGe5qMhMuMe5qMhEGEbVVupcNzg3aHhIF4boeBe0mEdlptc39ofFl5Y8uUlJOGiYt2UmGEcyxjjGx4jFF7a657ZYWBnElzhp57iXtrgZN+tfOEhIOBjE2HgU1+e8tjjKNbiWCDhE15gUqBgYN7fnqGc66ce9d7iYSBj0qPcG6DnGGcT3eGa6qMZY+JlIiMl4hwc3aRdnqBlGV7eHJ2hLZjfnuRhDyEeX6MSk17g6Z+c6aUjHmEhIF4gXyBc76EZW18fGl+fkl+jCxrhoVwhDyUhIqGlL2DlI6EhJd2tdN7eYORhEGMa2Faa6pzc3Bzc4R5lIRznM+UY9eMhDycc5Z+c4p5c4iGY117pb6MgXuPrbJafnx2eYOJeXZ5e657hDyEcziElKZjfoB5eHeGj4WRhGGEe6KGeX1utTStc76EhFGJnCyMa5hzfH6HnNeceYB7hmN8gYuMhIVrczSMgYF8h3N7c5pza5hzjJqEYIRdgYuMlL2DeYRzhGGEeX1uhLaEc4iGeZ1zdl6JhrVteX6Me2iMfm5lWqJzSpqEa6pzdnmchHx2c6OMhNdrhoR5g3aHczxzeW52gV6Ejm15frGMc0Vzc4Z+l3drfniJe+9rWq5rlF1rhGGEhoVwe9OEfoh+e7pac09+c3qBY0lrhDycdnp2lJ6MiYOGhGCDc3aRlL2DlJt5doaGdnp2gYF8gWeOjF2Uc4R5c5Z+jEmMe7KEc4mEeYJ4dmyBe0mcgXiPbqJ7eYB7fmGGiYSJjICGlF1reZ2PnElzbpqJfH6Hc39oe4WEc5eJhK6EhqyJc3qBgZB8c09+hEmEaHKDhFGJc5SGiXWMUpaEa89zc6OMnCyMiXtrho+Be5qMc7KEjJ57dmN+hKGPjICGbmiEe7prdod+hGCDdnmchBx7eX6MkXZ2hGGEa657hm98jFFjY5JreYOJgY2EjHZ2a295Y3FajJ6Mc1J+YzB7e4WBjF2Uc4R5eV12gYxzg1qBeId+c9OUc5pzjFFjgY5+hFiMlIaPhoR5lIpjjIKBlNdSe7KEeX2BfrGMhIqGc65zjE2UhK6EklZ+QmWEeziMWqZza3VzdnR4foh+gYF8n3iJiZhrnKp7gYF8eId+lJ6Me1lrcIuGjKJjhmN8c66MjFF7a6prjJ6UnJ5zezyUfruRWlF7nI5zfHyGe657h4SEe8tjhBx7jFFjc09+c39ojICMeZeJeXt+YzRzjHZ2c0WEcIeBeXZ5onSXkVR+gYJ+eYFwdldzgYF7eX2BjJ6UiXuXlE1jh4SEe1mchLJjc4Z+hqZ7eXZ5bm1zlL6Ue5p7iWeGhKqUY5pzjKJjcIeBe8t7gXyBYIRdlEp4a3mGnK6EfmmMZpqEfFl5gYxzjKZuhGFjhoKGhHx2fnx2eXuMe3aBiWeGvbKMe6KGa5hzYzB7gZOBlGV7hmN8hqZlYot2Y117a6pzc6KEfId8foB5rctrfneJfJ6PcHN2hFiMc5pzjH92c0VzgY2EcElzdmCBlFVzg1GBc65zY4OBboeBcHiBeYJ4ewxzfHx5lIRzlEmEnLKEbk1zfJ6PhmN8eYBljBiEnMOEiXxwezyUcIeBe76EdsKEeX2BdnR4jGWUrXWMjGd7fkl+j4WRlEGMa5Jzho+BhDyEfnqMeXt+g3aHlE1jczClhNN7ZW18eHx8hGFjZW18iXWMjKJjhH57gYuMcIuGWjyMe4ZtjJuExmmMj4WRdntzi4GDhFFzYIRdnGGcjJp7Y0F7e4WEkbCGiX57fnSHa657a6prhBCMe3Z+SmmMjH92eHJ2hK6EY1FzexhrvbKMnI5za4OEfnd+eXuMhImBe897hLaMjN+EfG+BeIOBhF1+eZeJi4GDkXZ2eXKEgZ6Ejpd4c2GHa1V5e5KUfqZuhCx7jKp7lLZrg11+hHx2hFWUoot2nI5zgbh5mo9zvZaUe3qRbqKMfqZ2kbCGhFiM";

// node_modules/@arcgis/core/views/3d/webgl-engine/effects/ssao/SSAOParameters.js
var r14 = class extends n7 {
  constructor() {
    super(...arguments), this.projScale = 1;
  }
};
var t10 = class extends r14 {
  constructor() {
    super(...arguments), this.intensity = 1;
  }
};
var c10 = class extends n7 {
};
var o17 = class extends c10 {
  constructor() {
    super(...arguments), this.blurSize = n4();
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/effects/ssao/SSAOTechnique.js
var l10 = class _l extends r12 {
  initializeProgram(e26) {
    return new r13(e26.rctx, _l.shader.get().build(), E4);
  }
  initializePipeline() {
    return S({ colorWrite: _3 });
  }
};
l10.shader = new t9(p, () => import("./SSAO.glsl-UUBNLFUF.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/RenderFeature.js
var o18;
!function(e26) {
  e26[e26.Antialiasing = 0] = "Antialiasing", e26[e26.HighQualityTransparency = 1] = "HighQualityTransparency", e26[e26.HighResolutionVoxel = 2] = "HighResolutionVoxel", e26[e26.HighResolutionAtmosphere = 3] = "HighResolutionAtmosphere", e26[e26.SSAO = 4] = "SSAO", e26[e26.WaterReflection = 5] = "WaterReflection", e26[e26.HighResolutionShadows = 6] = "HighResolutionShadows", e26[e26.PhysicalPixelRendering = 7] = "PhysicalPixelRendering";
}(o18 || (o18 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/RenderSlot.js
var A5;
!function(A7) {
  A7[A7.INTEGRATED_MESH = 0] = "INTEGRATED_MESH", A7[A7.OPAQUE_TERRAIN = 1] = "OPAQUE_TERRAIN", A7[A7.OPAQUE_MATERIAL = 2] = "OPAQUE_MATERIAL", A7[A7.TRANSPARENT_MATERIAL = 3] = "TRANSPARENT_MATERIAL", A7[A7.TRANSPARENT_TERRAIN = 4] = "TRANSPARENT_TERRAIN", A7[A7.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL = 5] = "TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL", A7[A7.OCCLUDED_TERRAIN = 6] = "OCCLUDED_TERRAIN", A7[A7.OCCLUDER_MATERIAL = 7] = "OCCLUDER_MATERIAL", A7[A7.TRANSPARENT_OCCLUDER_MATERIAL = 8] = "TRANSPARENT_OCCLUDER_MATERIAL", A7[A7.OCCLUSION_PIXELS = 9] = "OCCLUSION_PIXELS", A7[A7.ANTIALIASING = 10] = "ANTIALIASING", A7[A7.COMPOSITE = 11] = "COMPOSITE", A7[A7.BLIT = 12] = "BLIT", A7[A7.SSAO = 13] = "SSAO", A7[A7.HIGHLIGHT = 14] = "HIGHLIGHT", A7[A7.SHADOW_HIGHLIGHT = 15] = "SHADOW_HIGHLIGHT", A7[A7.ENVIRONMENT_OPAQUE = 16] = "ENVIRONMENT_OPAQUE", A7[A7.ENVIRONMENT_TRANSPARENT = 17] = "ENVIRONMENT_TRANSPARENT", A7[A7.LASERLINES = 18] = "LASERLINES", A7[A7.LASERLINES_CONTRAST_CONTROL = 19] = "LASERLINES_CONTRAST_CONTROL", A7[A7.HUD_MATERIAL = 20] = "HUD_MATERIAL", A7[A7.LABEL_MATERIAL = 21] = "LABEL_MATERIAL", A7[A7.LINE_CALLOUTS = 22] = "LINE_CALLOUTS", A7[A7.LINE_CALLOUTS_HUD_DEPTH = 23] = "LINE_CALLOUTS_HUD_DEPTH", A7[A7.DRAPED_MATERIAL = 24] = "DRAPED_MATERIAL", A7[A7.DRAPED_WATER = 25] = "DRAPED_WATER", A7[A7.VOXEL = 26] = "VOXEL", A7[A7.MAX_SLOTS = 27] = "MAX_SLOTS";
}(A5 || (A5 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/effects/ssao/SSAO.js
var R2 = 2;
var y4 = class extends u2 {
  constructor(e26) {
    super(e26), this._context = null, this._passParameters = new t10(), this._drawParameters = new o17(), this.produces = /* @__PURE__ */ new Map([[A5.SSAO, () => this._produces()]]);
  }
  _produces() {
    return null != this._enableTime && null != this._context;
  }
  consumes() {
    return this._produces() ? d11 : s12;
  }
  initializeRenderContext(e26) {
    this._context = e26, this.addHandles([d(() => {
      var _a;
      return this.view.qualitySettings.ambientOcclusion || ((_a = this._context) == null ? void 0 : _a.isFeatureEnabled(o18.SSAO));
    }, (e27) => e27 ? this._enable() : this._disable(), A)]);
  }
  uninitializeRenderContext() {
    this._disable(), this._context = null;
  }
  _disable() {
    this._passParameters.noiseTexture = r(this._passParameters.noiseTexture), this._enableTime = null;
  }
  destroy() {
    this._disable();
  }
  _enable() {
    var _a;
    if (null != this._enableTime || !this._context)
      return;
    const e26 = Uint8Array.from(atob(e22), (e27) => e27.charCodeAt(0)), t16 = new e7();
    t16.wrapMode = D.CLAMP_TO_EDGE, t16.pixelFormat = G2.RGB, t16.wrapMode = D.REPEAT, t16.hasMipmap = true, t16.width = 32, t16.height = 32, this._passParameters.noiseTexture = new T(this._context.renderContext.rctx, t16, e26), null == this._ssaoTechnique && (this._ssaoTechnique = this._context.techniqueRepository.acquire(l10)), null == this._blurTechnique && (this._blurTechnique = this._context.techniqueRepository.acquire(a13)), this._enableTime = n(0), (_a = this._context) == null ? void 0 : _a.requestRender();
  }
  renderNode(e26, t16, r18) {
    var _a, _b;
    const s14 = e26.bindParameters, i16 = (_a = s14.linearDepth) == null ? void 0 : _a.colorTexture, o22 = (_b = r18 == null ? void 0 : r18.normal) == null ? void 0 : _b.colorTexture;
    if (null == this._enableTime || null == this._context || null == i16 || !o22)
      return;
    if (!this._ssaoTechnique.compiled || !this._blurTechnique.compiled)
      return this._enableTime = e26.time, void this._context.requestRender();
    0 === this._enableTime && (this._enableTime = e26.time);
    const a16 = e26.rctx, m7 = s14.camera, u5 = this.view.qualitySettings.fadeDuration, l13 = u5 > 0 ? Math.min(u5, e26.time - this._enableTime) / u5 : 1;
    this._passParameters.normalTexture = o22, this._passParameters.depthTexture = i16, this._passParameters.projScale = 1 / m7.computeScreenPixelSizeAtDist(1), this._passParameters.intensity = 4 * O3 / d2(m7) ** 6 * l13;
    const h6 = m7.fullViewport[2], p7 = m7.fullViewport[3], _4 = Math.round(h6 / R2), d12 = Math.round(p7 / R2), b4 = this._context.fbos, f7 = b4.acquire(R.RED, h6, p7);
    a16.bindFramebuffer(f7.fbo), a16.setViewport(0, 0, h6, p7);
    a16.bindTechnique(this._ssaoTechnique, this._passParameters, s14).bindDraw(this._drawParameters, s14, this._passParameters), a16.screen.draw();
    const w4 = a16.bindTechnique(this._blurTechnique, this._passParameters, s14);
    a16.setViewport(0, 0, _4, d12);
    const x5 = b4.acquire(R.RED, _4, d12);
    a16.bindFramebuffer(x5.fbo), this._drawParameters.colorTexture = f7.colorTexture, r5(this._drawParameters.blurSize, 0, R2 / p7), w4.bindDraw(this._drawParameters, s14, this._passParameters), a16.setViewport(0, 0, _4, d12), a16.screen.draw(), f7.release();
    const P6 = b4.acquire(R.RED, _4, d12);
    return a16.bindFramebuffer(P6.fbo), a16.setViewport(0, 0, h6, p7), a16.setClearColor(1, 1, 1, 0), a16.clear(_2.COLOR_BUFFER_BIT), a16.setViewport(0, 0, _4, d12), this._drawParameters.colorTexture = x5.colorTexture, r5(this._drawParameters.blurSize, R2 / h6, 0), w4.bindDraw(this._drawParameters, s14, this._passParameters), a16.screen.draw(), a16.setViewport4fv(m7.fullViewport), x5.release(), l13 < 1 && this._context.requestRender(), P6;
  }
};
e([y({ constructOnly: true })], y4.prototype, "view", void 0), e([y()], y4.prototype, "_context", void 0), y4 = e([c("esri.views.3d.webgl-engine.effects.ssao.SSAO")], y4);
var O3 = 0.5;

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl.js
function t12(t16, o22) {
  const a16 = t16.fragment;
  o22.receiveAmbientOcclusion ? (a16.uniforms.add(new s5("ssaoTex", (e26, s14) => {
    var _a;
    return (_a = s14.ssao) == null ? void 0 : _a.colorTexture;
  })), a16.constants.add("blurSizePixelsInverse", "float", 1 / R2), a16.code.add(o4`float evaluateAmbientOcclusionInverse() {
vec2 ssaoTextureSizeInverse = 1.0 / vec2(textureSize(ssaoTex, 0));
return texture(ssaoTex, gl_FragCoord.xy * blurSizePixelsInverse * ssaoTextureSizeInverse).r;
}
float evaluateAmbientOcclusion() {
return 1.0 - evaluateAmbientOcclusionInverse();
}`)) : a16.code.add(o4`float evaluateAmbientOcclusionInverse() { return 1.0; }
float evaluateAmbientOcclusion() { return 0.0; }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js
function t13(n15) {
  n15.uniforms.add(new e10("mainLightDirection", (i16, n16) => n16.lighting.mainLight.direction));
}
function a14(n15) {
  n15.uniforms.add(new e10("mainLightIntensity", (i16, n16) => n16.lighting.mainLight.intensity));
}
function o19(i16) {
  t13(i16.fragment), a14(i16.fragment), i16.fragment.code.add(o4`vec3 evaluateMainLighting(vec3 normal_global, float shadowing) {
float dotVal = clamp(dot(normal_global, mainLightDirection), 0.0, 1.0);
return mainLightIntensity * ((1.0 - shadowing) * dotVal);
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/AnalyticalSkyModel.glsl.js
function t14(t16) {
  const a16 = t16.fragment.code;
  a16.add(o4`vec3 evaluateDiffuseIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float NdotNG)
{
return ((1.0 - NdotNG) * ambientGround + (1.0 + NdotNG) * ambientSky) * 0.5;
}`), a16.add(o4`float integratedRadiance(float cosTheta2, float roughness)
{
return (cosTheta2 - 1.0) / (cosTheta2 * (1.0 - roughness * roughness) - 1.0);
}`), a16.add(o4`vec3 evaluateSpecularIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float RdotNG, float roughness)
{
float cosTheta2 = 1.0 - RdotNG * RdotNG;
float intRadTheta = integratedRadiance(cosTheta2, roughness);
float ground = RdotNG < 0.0 ? 1.0 - intRadTheta : 1.0 + intRadTheta;
float sky = 2.0 - ground;
return (ground * ambientGround + sky * ambientSky) * 0.5;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PiUtils.glsl.js
function t15(t16) {
  t16.vertex.code.add(o4`const float PI = 3.141592653589793;`), t16.fragment.code.add(o4`const float PI = 3.141592653589793;
const float LIGHT_NORMALIZATION = 1.0 / PI;
const float INV_PI = 0.3183098861837907;
const float HALF_PI = 1.570796326794897;`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRendering.glsl.js
function n12(n15, r18) {
  const l13 = n15.fragment.code;
  n15.include(t15), r18.pbrMode !== c3.Normal && r18.pbrMode !== c3.Schematic && r18.pbrMode !== c3.Terrain && r18.pbrMode !== c3.TerrainWithWater || (l13.add(o4`float normalDistribution(float NdotH, float roughness)
{
float a = NdotH * roughness;
float b = roughness / (1.0 - NdotH * NdotH + a * a);
return b * b * INV_PI;
}`), l13.add(o4`const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);
const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);
const vec2 c2 = vec2(-1.04, 1.04);
vec2 prefilteredDFGAnalytical(float roughness, float NdotV) {
vec4 r = roughness * c0 + c1;
float a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;
return c2 * a004 + r.zw;
}`)), r18.pbrMode !== c3.Normal && r18.pbrMode !== c3.Schematic || (n15.include(t14), l13.add(o4`struct PBRShadingInfo
{
float NdotL;
float NdotV;
float NdotH;
float VdotH;
float LdotH;
float NdotNG;
float RdotNG;
float NdotAmbDir;
float NdotH_Horizon;
vec3 skyRadianceToSurface;
vec3 groundRadianceToSurface;
vec3 skyIrradianceToSurface;
vec3 groundIrradianceToSurface;
float averageAmbientRadiance;
float ssao;
vec3 albedoLinear;
vec3 f0;
vec3 f90;
vec3 diffuseColor;
float metalness;
float roughness;
};`), l13.add(o4`vec3 evaluateEnvironmentIllumination(PBRShadingInfo inputs) {
vec3 indirectDiffuse = evaluateDiffuseIlluminationHemisphere(inputs.groundIrradianceToSurface, inputs.skyIrradianceToSurface, inputs.NdotNG);
vec3 indirectSpecular = evaluateSpecularIlluminationHemisphere(inputs.groundRadianceToSurface, inputs.skyRadianceToSurface, inputs.RdotNG, inputs.roughness);
vec3 diffuseComponent = inputs.diffuseColor * indirectDiffuse * INV_PI;
vec2 dfg = prefilteredDFGAnalytical(inputs.roughness, inputs.NdotV);
vec3 specularColor = inputs.f0 * dfg.x + inputs.f90 * dfg.y;
vec3 specularComponent = specularColor * indirectSpecular;
return (diffuseComponent + specularComponent);
}`), l13.add(o4`float gamutMapChanel(float x, vec2 p){
return (x < p.x) ? mix(0.0, p.y, x/p.x) : mix(p.y, 1.0, (x - p.x) / (1.0 - p.x) );
}`), l13.add(o4`vec3 blackLevelSoftCompression(vec3 inColor, PBRShadingInfo inputs){
vec3 outColor;
vec2 p = vec2(0.02 * (inputs.averageAmbientRadiance), 0.0075 * (inputs.averageAmbientRadiance));
outColor.x = gamutMapChanel(inColor.x, p) ;
outColor.y = gamutMapChanel(inColor.y, p) ;
outColor.z = gamutMapChanel(inColor.z, p) ;
return outColor;
}`));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientLighting.glsl.js
function m5(n15, g7) {
  const m7 = n15.fragment, o22 = void 0 !== g7.lightingSphericalHarmonicsOrder ? g7.lightingSphericalHarmonicsOrder : 2;
  0 === o22 ? (m7.uniforms.add(new e10("lightingAmbientSH0", (n16, t16) => o(a15, t16.lighting.sh.r[0], t16.lighting.sh.g[0], t16.lighting.sh.b[0]))), m7.code.add(o4`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec3 ambientLight = 0.282095 * lightingAmbientSH0;
return ambientLight * (1.0 - ambientOcclusion);
}`)) : 1 === o22 ? (m7.uniforms.add(new e9("lightingAmbientSH_R", (i16, n16) => r3(r15, n16.lighting.sh.r[0], n16.lighting.sh.r[1], n16.lighting.sh.r[2], n16.lighting.sh.r[3])), new e9("lightingAmbientSH_G", (i16, n16) => r3(r15, n16.lighting.sh.g[0], n16.lighting.sh.g[1], n16.lighting.sh.g[2], n16.lighting.sh.g[3])), new e9("lightingAmbientSH_B", (i16, n16) => r3(r15, n16.lighting.sh.b[0], n16.lighting.sh.b[1], n16.lighting.sh.b[2], n16.lighting.sh.b[3]))), m7.code.add(o4`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec4 sh0 = vec4(
0.282095,
0.488603 * normal.x,
0.488603 * normal.z,
0.488603 * normal.y
);
vec3 ambientLight = vec3(
dot(lightingAmbientSH_R, sh0),
dot(lightingAmbientSH_G, sh0),
dot(lightingAmbientSH_B, sh0)
);
return ambientLight * (1.0 - ambientOcclusion);
}`)) : 2 === o22 && (m7.uniforms.add(new e10("lightingAmbientSH0", (n16, t16) => o(a15, t16.lighting.sh.r[0], t16.lighting.sh.g[0], t16.lighting.sh.b[0])), new e9("lightingAmbientSH_R1", (i16, n16) => r3(r15, n16.lighting.sh.r[1], n16.lighting.sh.r[2], n16.lighting.sh.r[3], n16.lighting.sh.r[4])), new e9("lightingAmbientSH_G1", (i16, n16) => r3(r15, n16.lighting.sh.g[1], n16.lighting.sh.g[2], n16.lighting.sh.g[3], n16.lighting.sh.g[4])), new e9("lightingAmbientSH_B1", (i16, n16) => r3(r15, n16.lighting.sh.b[1], n16.lighting.sh.b[2], n16.lighting.sh.b[3], n16.lighting.sh.b[4])), new e9("lightingAmbientSH_R2", (i16, n16) => r3(r15, n16.lighting.sh.r[5], n16.lighting.sh.r[6], n16.lighting.sh.r[7], n16.lighting.sh.r[8])), new e9("lightingAmbientSH_G2", (i16, n16) => r3(r15, n16.lighting.sh.g[5], n16.lighting.sh.g[6], n16.lighting.sh.g[7], n16.lighting.sh.g[8])), new e9("lightingAmbientSH_B2", (i16, n16) => r3(r15, n16.lighting.sh.b[5], n16.lighting.sh.b[6], n16.lighting.sh.b[7], n16.lighting.sh.b[8]))), m7.code.add(o4`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec3 ambientLight = 0.282095 * lightingAmbientSH0;
vec4 sh1 = vec4(
0.488603 * normal.x,
0.488603 * normal.z,
0.488603 * normal.y,
1.092548 * normal.x * normal.y
);
vec4 sh2 = vec4(
1.092548 * normal.y * normal.z,
0.315392 * (3.0 * normal.z * normal.z - 1.0),
1.092548 * normal.x * normal.z,
0.546274 * (normal.x * normal.x - normal.y * normal.y)
);
ambientLight += vec3(
dot(lightingAmbientSH_R1, sh1),
dot(lightingAmbientSH_G1, sh1),
dot(lightingAmbientSH_B1, sh1)
);
ambientLight += vec3(
dot(lightingAmbientSH_R2, sh2),
dot(lightingAmbientSH_G2, sh2),
dot(lightingAmbientSH_B2, sh2)
);
return ambientLight * (1.0 - ambientOcclusion);
}`), g7.pbrMode !== c3.Normal && g7.pbrMode !== c3.Schematic || m7.code.add(o4`const vec3 skyTransmittance = vec3(0.9, 0.9, 1.0);
vec3 calculateAmbientRadiance(float ambientOcclusion)
{
vec3 ambientLight = 1.2 * (0.282095 * lightingAmbientSH0) - 0.2;
return ambientLight *= (1.0 - ambientOcclusion) * skyTransmittance;
}`));
}
var a15 = n2();
var r15 = n3();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/BooleanPassUniform.js
var s13 = class extends a5 {
  constructor(o22, s14) {
    super(o22, "bool", a4.Pass, (r18, e26, t16) => r18.setUniform1b(o22, s14(e26, t16)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lighting/SphericalHarmonics.js
var P5 = n2();

// node_modules/@arcgis/core/views/3d/webgl-engine/lighting/SceneLighting.js
var l12 = 0.4;
var p5 = n2();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js
function u3(i16) {
  i16.constants.add("ambientBoostFactor", "float", l12);
}
function h5(i16) {
  i16.uniforms.add(new o5("lightingGlobalFactor", (i17, n15) => n15.lighting.globalFactor));
}
function p6(g7, p7) {
  const v6 = g7.fragment;
  switch (g7.include(t12, p7), p7.pbrMode !== c3.Disabled && g7.include(n12, p7), g7.include(m5, p7), g7.include(t15), v6.code.add(o4`
    const float GAMMA_SRGB = 2.1;
    const float INV_GAMMA_SRGB = 0.4761904;
    ${p7.pbrMode === c3.Disabled ? "" : "const vec3 GROUND_REFLECTANCE = vec3(0.2);"}
  `), u3(v6), h5(v6), t13(v6), v6.code.add(o4`
    float additionalDirectedAmbientLight(vec3 vPosWorld) {
      float vndl = dot(${p7.spherical ? o4`normalize(vPosWorld)` : o4`vec3(0.0, 0.0, 1.0)`}, mainLightDirection);
      return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));
    }
  `), a14(v6), v6.code.add(o4`vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {
float additionalAmbientScale = additionalDirectedAmbientLight(vPosWorld);
return (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * mainLightIntensity;
}`), p7.pbrMode) {
    case c3.Disabled:
    case c3.WaterOnIntegratedMesh:
    case c3.Water:
      g7.include(o19), v6.code.add(o4`vec3 evaluateSceneLighting(vec3 normalWorld, vec3 albedo, float shadow, float ssao, vec3 additionalLight)
{
vec3 mainLighting = evaluateMainLighting(normalWorld, shadow);
vec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ssao);
vec3 albedoLinear = pow(albedo, vec3(GAMMA_SRGB));
vec3 totalLight = mainLighting + ambientLighting + additionalLight;
totalLight = min(totalLight, vec3(PI));
vec3 outColor = vec3((albedoLinear / PI) * totalLight);
return pow(outColor, vec3(INV_GAMMA_SRGB));
}`);
      break;
    case c3.Normal:
    case c3.Schematic:
      v6.code.add(o4`const float fillLightIntensity = 0.25;
const float horizonLightDiffusion = 0.4;
const float additionalAmbientIrradianceFactor = 0.02;
vec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, vec3 mrr, vec3 _emission, float additionalAmbientIrradiance)
{
vec3 viewDirection = -viewDir;
vec3 h = normalize(viewDirection + mainLightDirection);
PBRShadingInfo inputs;
inputs.NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);
inputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);
inputs.NdotH = clamp(dot(normal, h), 0.0, 1.0);
inputs.VdotH = clamp(dot(viewDirection, h), 0.0, 1.0);
inputs.NdotNG = clamp(dot(normal, normalGround), -1.0, 1.0);
vec3 reflectedView = normalize(reflect(viewDirection, normal));
inputs.RdotNG = clamp(dot(reflectedView, normalGround), -1.0, 1.0);
inputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));
inputs.ssao = ssao;
inputs.metalness = mrr[0];
inputs.roughness = clamp(mrr[1] * mrr[1], 0.001, 0.99);`), v6.code.add(o4`inputs.f0 = (0.16 * mrr[2] * mrr[2]) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;
inputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0));
inputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);`), p7.useFillLights ? v6.uniforms.add(new s13("hasFillLights", (i16, n15) => n15.enableFillLights)) : v6.constants.add("hasFillLights", "bool", false), v6.code.add(o4`vec3 ambientDir = vec3(5.0 * normalGround[1] - normalGround[0] * normalGround[2], - 5.0 * normalGround[0] - normalGround[2] * normalGround[1], normalGround[1] * normalGround[1] + normalGround[0] * normalGround[0]);
ambientDir = ambientDir != vec3(0.0) ? normalize(ambientDir) : normalize(vec3(5.0, -1.0, 0.0));
inputs.NdotAmbDir = hasFillLights ? abs(dot(normal, ambientDir)) : 1.0;
vec3 mainLightIrradianceComponent = inputs.NdotL * (1.0 - shadow) * mainLightIntensity;
vec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * mainLightIntensity * fillLightIntensity;
vec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;
inputs.skyIrradianceToSurface = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;
inputs.groundIrradianceToSurface = GROUND_REFLECTANCE * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;`), v6.uniforms.add(new o5("lightingSpecularStrength", (i16, n15) => n15.lighting.mainLight.specularStrength), new o5("lightingEnvironmentStrength", (i16, n15) => n15.lighting.mainLight.environmentStrength)), v6.code.add(o4`vec3 horizonRingDir = inputs.RdotNG * normalGround - reflectedView;
vec3 horizonRingH = normalize(viewDirection + horizonRingDir);
inputs.NdotH_Horizon = dot(normal, horizonRingH);
vec3 mainLightRadianceComponent = lightingSpecularStrength * normalDistribution(inputs.NdotH, inputs.roughness) * mainLightIntensity * (1.0 - shadow);
vec3 horizonLightRadianceComponent = lightingEnvironmentStrength * normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * mainLightIntensity * fillLightIntensity;
vec3 ambientLightRadianceComponent = lightingEnvironmentStrength * calculateAmbientRadiance(ssao) + additionalLight;
float normalDirectionModifier = mix(1., min(mix(0.1, 2.0, (inputs.NdotNG + 1.) * 0.5), 1.0), clamp(inputs.roughness * 5.0, 0.0 , 1.0));
inputs.skyRadianceToSurface = (ambientLightRadianceComponent + horizonLightRadianceComponent) * normalDirectionModifier + mainLightRadianceComponent;
inputs.groundRadianceToSurface = 0.5 * GROUND_REFLECTANCE * (ambientLightRadianceComponent + horizonLightRadianceComponent) * normalDirectionModifier + mainLightRadianceComponent;
inputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + GROUND_REFLECTANCE[1]);`), v6.code.add(o4`
        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);
        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;
        vec3 emissionComponent = _emission == vec3(0.0) ? _emission : pow(_emission, vec3(GAMMA_SRGB));
        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent + emissionComponent;
        ${p7.pbrMode !== c3.Schematic || p7.hasColorTexture ? o4`vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs), vec3(INV_GAMMA_SRGB));` : o4`vec3 outColor = pow(max(vec3(0.0), outColorLinear - 0.005 * inputs.averageAmbientRadiance), vec3(INV_GAMMA_SRGB));`}
        return outColor;
      }
    `);
      break;
    case c3.Terrain:
    case c3.TerrainWithWater:
      g7.include(o19), v6.code.add(o4`const float roughnessTerrain = 0.5;
const float specularityTerrain = 0.5;
const vec3 fresnelReflectionTerrain = vec3(0.04);
vec3 evaluateTerrainLighting(vec3 n, vec3 c, float shadow, float ssao, vec3 al, vec3 vd, vec3 nup) {
vec3 viewDirection = -vd;
vec3 h = normalize(viewDirection + mainLightDirection);
float NdotL = clamp(dot(n, mainLightDirection), 0.001, 1.0);
float NdotV = clamp(abs(dot(n, viewDirection)), 0.001, 1.0);
float NdotH = clamp(dot(n, h), 0.0, 1.0);
float NdotNG = clamp(dot(n, nup), -1.0, 1.0);
vec3 albedoLinear = pow(c, vec3(GAMMA_SRGB));
float lightness = 0.3 * albedoLinear[0] + 0.5 * albedoLinear[1] + 0.2 * albedoLinear[2];
vec3 f0 = (0.85 * lightness + 0.15) * fresnelReflectionTerrain;
vec3 f90 =  vec3(clamp(dot(f0, vec3(50.0 * 0.33)), 0.0, 1.0));
vec3 mainLightIrradianceComponent = (1. - shadow) * NdotL * mainLightIntensity;
vec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(n, ssao) + al;
vec3 ambientSky = ambientLightIrradianceComponent + mainLightIrradianceComponent;
vec3 indirectDiffuse = ((1.0 - NdotNG) * mainLightIrradianceComponent + (1.0 + NdotNG ) * ambientSky) * 0.5;
vec3 outDiffColor = albedoLinear * (1.0 - f0) * indirectDiffuse / PI;
vec3 mainLightRadianceComponent = normalDistribution(NdotH, roughnessTerrain) * mainLightIntensity;
vec2 dfg = prefilteredDFGAnalytical(roughnessTerrain, NdotV);
vec3 specularColor = f0 * dfg.x + f90 * dfg.y;
vec3 specularComponent = specularityTerrain * specularColor * mainLightRadianceComponent;
vec3 outColorLinear = outDiffColor + specularComponent;
vec3 outColor = pow(outColorLinear, vec3(INV_GAMMA_SRGB));
return outColor;
}`);
      break;
    default:
      n5(p7.pbrMode);
    case c3.COUNT:
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js
function o20(o22, n15) {
  if (!n15.multipassEnabled)
    return;
  o22.fragment.include(a7), o22.fragment.uniforms.add(new s5("terrainDepthTexture", (e26, r18) => {
    var _a;
    return (_a = r18.multipassTerrain.linearDepth) == null ? void 0 : _a.colorTexture;
  })), o22.fragment.uniforms.add(new e8("nearFar", (e26, r18) => r18.camera.nearFar));
  const s14 = n15.occlusionPass;
  o22.fragment.code.add(o4`
   ${s14 ? "bool" : "void"} terrainDepthTest(float fragmentDepth) {
      vec4 data = texelFetch(terrainDepthTexture, ivec2(gl_FragCoord.xy), 0);
      float linearDepth = linearDepthFromRGBA(data, nearFar);
      ${s14 ? o4`return fragmentDepth < linearDepth && data != vec4(0.0, 0.0, 0.0, 1.0);` : o4`
          if(fragmentDepth ${n15.cullAboveGround ? ">" : "<="} linearDepth){
            discard;
          }`}
    }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix4sDrawUniform.js
var o21 = class extends a5 {
  constructor(r18, o22, s14) {
    super(r18, "mat4", a4.Draw, (e26, s15, t16, i16) => e26.setUniformMatrix4fv(r18, o22(s15, t16, i16)), s14);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix4sPassUniform.js
var e24 = class extends a5 {
  constructor(r18, e26, o22) {
    super(r18, "mat4", a4.Pass, (s14, o23, t16) => s14.setUniformMatrix4fv(r18, e26(o23, t16)), o22);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js
function x4(e26, s14) {
  s14.receiveShadows && (e26.fragment.uniforms.add(new e24("shadowMapMatrix", (e27, s15) => s15.shadowMap.getShadowMapMatrices(e27.origin), 4)), u4(e26));
}
function m6(e26, s14) {
  s14.receiveShadows && (e26.fragment.uniforms.add(new o21("shadowMapMatrix", (e27, s15) => s15.shadowMap.getShadowMapMatrices(e27.origin), 4)), u4(e26));
}
function u4(e26) {
  const s14 = e26.fragment;
  s14.include(a11), s14.uniforms.add(new s5("shadowMapTex", (e27, s15) => s15.shadowMap.depthTexture), new e16("numCascades", (e27, s15) => s15.shadowMap.numCascades), new e9("cascadeDistances", (e27, s15) => s15.shadowMap.cascadeDistances)), s14.code.add(o4`int chooseCascade(float depth, out mat4 mat) {
vec4 distance = cascadeDistances;
int i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;
mat = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];
return i;
}
vec3 lightSpacePosition(vec3 _vpos, mat4 mat) {
vec4 lv = mat * vec4(_vpos, 1.0);
lv.xy /= lv.w;
return 0.5 * lv.xyz + vec3(0.5);
}
vec2 cascadeCoordinates(int i, ivec2 textureSize, vec3 lvpos) {
float xScale = float(textureSize.y) / float(textureSize.x);
return vec2((float(i) + lvpos.x) * xScale, lvpos.y);
}
float readShadowMapDepth(ivec2 uv, sampler2D _depthTex) {
return rgba4ToFloat(texelFetch(_depthTex, uv, 0));
}
float posIsInShadow(ivec2 uv, vec3 lvpos, sampler2D _depthTex) {
return readShadowMapDepth(uv, _depthTex) < lvpos.z ? 1.0 : 0.0;
}
float filterShadow(vec2 uv, vec3 lvpos, ivec2 texSize, sampler2D _depthTex) {
vec2 st = fract(uv * vec2(texSize) + vec2(0.5));
ivec2 base = ivec2(uv * vec2(texSize) - vec2(0.5));
float s00 = posIsInShadow(ivec2(base.x, base.y), lvpos, _depthTex);
float s10 = posIsInShadow(ivec2(base.x + 1, base.y), lvpos, _depthTex);
float s11 = posIsInShadow(ivec2(base.x + 1, base.y + 1), lvpos, _depthTex);
float s01 = posIsInShadow(ivec2(base.x, base.y + 1), lvpos, _depthTex);
return mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);
}
float readShadowMap(const in vec3 _vpos, float _linearDepth) {
mat4 mat;
int i = chooseCascade(_linearDepth, mat);
if (i >= numCascades) { return 0.0; }
vec3 lvpos = lightSpacePosition(_vpos, mat);
if (lvpos.z >= 1.0) { return 0.0; }
if (lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }
ivec2 size = textureSize(shadowMapTex, 0);
vec2 uv = cascadeCoordinates(i, size, lvpos);
return filterShadow(uv, lvpos, size, shadowMapTex);
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js
function e25(e26) {
  e26.code.add(o4`vec4 premultiplyAlpha(vec4 v) {
return vec4(v.rgb * v.a, v.a);
}
vec3 rgb2hsv(vec3 c) {
vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);
vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);
float d = q.x - min(q.w, q.y);
float e = 1.0e-10;
return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), min(d / (q.x + e), 1.0), q.x);
}
vec3 hsv2rgb(vec3 c) {
vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
float rgb2v(vec3 c) {
return max(c.x, max(c.y, c.z));
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/MixExternalColor.glsl.js
function i15(i16) {
  i16.include(e25), i16.code.add(o4`
    vec3 mixExternalColor(vec3 internalColor, vec3 textureColor, vec3 externalColor, int mode) {
      // workaround for artifacts in OSX using Intel Iris Pro
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475
      vec3 internalMixed = internalColor * textureColor;
      vec3 allMixed = internalMixed * externalColor;

      if (mode == ${o4.int(n6.Multiply)}) {
        return allMixed;
      }
      if (mode == ${o4.int(n6.Ignore)}) {
        return internalMixed;
      }
      if (mode == ${o4.int(n6.Replace)}) {
        return externalColor;
      }

      // tint (or something invalid)
      float vIn = rgb2v(internalMixed);
      vec3 hsvTint = rgb2hsv(externalColor);
      vec3 hsvOut = vec3(hsvTint.x, hsvTint.y, vIn * hsvTint.z);
      return hsv2rgb(hsvOut);
    }

    float mixExternalOpacity(float internalOpacity, float textureOpacity, float externalOpacity, int mode) {
      // workaround for artifacts in OSX using Intel Iris Pro
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475
      float internalMixed = internalOpacity * textureOpacity;
      float allMixed = internalMixed * externalOpacity;

      if (mode == ${o4.int(n6.Ignore)}) {
        return internalMixed;
      }
      if (mode == ${o4.int(n6.Replace)}) {
        return externalOpacity;
      }

      // multiply or tint (or something invalid)
      return allMixed;
    }
  `);
}

export {
  o6 as o,
  t2 as t,
  a8 as a,
  d3 as d,
  o7 as o2,
  s6 as s,
  e10 as e,
  r8 as r,
  c3 as c,
  l3 as l,
  E4 as E,
  h3 as h,
  L2 as L,
  c8 as c2,
  d7 as d2,
  A5 as A,
  o9 as o3,
  e12 as e2,
  c5 as c3,
  f2 as f,
  o11 as o4,
  t4 as t2,
  t9 as t3,
  r12 as r2,
  r13 as r3,
  d4 as d3,
  e14 as e3,
  P2 as P,
  o12 as o5,
  f3 as f2,
  d5 as d4,
  r9 as r4,
  h2,
  N,
  i7 as i,
  e17 as e4,
  a9 as a2,
  l7 as l2,
  s10 as s2,
  h4 as h3,
  t12 as t4,
  t13 as t5,
  a14 as a3,
  n12 as n,
  u3 as u,
  h5 as h4,
  p6 as p,
  o20 as o6,
  x4 as x,
  m6 as m,
  i15 as i2
};
//# sourceMappingURL=chunk-BGMKQPOO.js.map
