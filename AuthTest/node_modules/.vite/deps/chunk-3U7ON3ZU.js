import {
  T as T3
} from "./chunk-CQ6GN5T7.js";
import {
  n as n5,
  n2 as n6
} from "./chunk-VLDVHSJX.js";
import {
  e as e7
} from "./chunk-DRBYLQY3.js";
import {
  e as e8,
  e2 as e9
} from "./chunk-BV5PCIP6.js";
import {
  c as c4
} from "./chunk-UDTTHPQA.js";
import {
  T as T2,
  e2 as e6
} from "./chunk-T56C4ORZ.js";
import {
  t as t2
} from "./chunk-ODGAHKYT.js";
import {
  t as t3
} from "./chunk-NI23WAWZ.js";
import {
  o as o5
} from "./chunk-MXOY2B3L.js";
import {
  e2 as e5
} from "./chunk-JNWIDZDW.js";
import {
  e as e3
} from "./chunk-DSGGSKRZ.js";
import {
  e as e4,
  o as o4
} from "./chunk-MUSQVDUI.js";
import {
  o as o3
} from "./chunk-OG2GBCUQ.js";
import {
  de,
  fe,
  ie,
  le,
  me,
  ne,
  oe,
  re,
  se,
  ue,
  ye
} from "./chunk-UMP4LYVN.js";
import {
  i as i3
} from "./chunk-HR42LBYN.js";
import {
  f as f2
} from "./chunk-3S7E6CPQ.js";
import {
  t
} from "./chunk-L2VCMOKZ.js";
import {
  T,
  _
} from "./chunk-TREPTI6V.js";
import {
  d
} from "./chunk-BUMLJETN.js";
import {
  Ae,
  B,
  C,
  X,
  Y,
  ae,
  ce
} from "./chunk-XFC7DZXI.js";
import {
  D,
  G,
  L,
  R
} from "./chunk-RCLKRKWR.js";
import {
  r as r4
} from "./chunk-OYPRFNII.js";
import {
  _ as _3
} from "./chunk-2S2NELNV.js";
import {
  At,
  Gt,
  Z,
  et,
  ht,
  jt,
  yt
} from "./chunk-3II2L7GF.js";
import {
  _ as _2
} from "./chunk-2FFBPEOX.js";
import {
  n as n4
} from "./chunk-6M5DUIJQ.js";
import {
  n as n3
} from "./chunk-CMGHBCKF.js";
import {
  a,
  r as r3,
  s as s6
} from "./chunk-NDKHIQMD.js";
import {
  l
} from "./chunk-J2R5B4T4.js";
import {
  c as c3,
  i as i2,
  u as u3
} from "./chunk-EIY2DYTV.js";
import {
  c as c2,
  i
} from "./chunk-MKW4ORPJ.js";
import {
  g as g2,
  n as n2,
  o as o2,
  r as r2,
  s as s5
} from "./chunk-YTH6VA7N.js";
import {
  p
} from "./chunk-TBSVVR6M.js";
import {
  o
} from "./chunk-423VNHLR.js";
import {
  x2 as x
} from "./chunk-QNOCEWCR.js";
import {
  Pt,
  j
} from "./chunk-R5DM4YAB.js";
import {
  g,
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  b,
  e as e2,
  f,
  m,
  s as s4,
  u as u2
} from "./chunk-RFPH3ZTZ.js";
import {
  r,
  u
} from "./chunk-WGO3VFQP.js";
import {
  n
} from "./chunk-CQS47VN5.js";
import {
  s,
  s2,
  s3
} from "./chunk-WJ3HJKNC.js";
import {
  has
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/shaderRepository.js
var e10 = { background: { "background.frag": "#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main() {\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = u_opacity * color;\n#else\ngl_FragColor = u_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "background.vert": "precision mediump float;\nattribute vec2 a_pos;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\nuniform mediump vec4 u_tlbr;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\n#endif\nvoid main() {\ngl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\nv_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\nv_tlbr             = u_tlbr / u_mosaicSize.xyxy;\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}" }, circle: { "circle.frag": "precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float dist = length(v_offset);\nmediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\nlowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\ngl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "circle.vert": "precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_stroke_color = stroke_color * stroke_opacity;\nv_stroke_width = stroke_width;\nv_radius = radius;\nv_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\nmediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\nv_offset = offset;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, fill: { "fill.frag": "precision lowp float;\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_color[3] * color;\n#else\ngl_FragColor = v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "fill.vert": "precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\n#include <util/util.glsl>\nuniform mediump vec2 u_mosaicSize;\nuniform mediump float u_patternFactor;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n#ifdef PATTERN\nfloat patternWidth = nextPOT(tlbr.z - tlbr.x);\nfloat patternHeight = nextPOT(tlbr.w - tlbr.y);\nfloat scaleX = 1.0 / (patternWidth * u_patternFactor);\nfloat scaleY = 1.0 / (patternHeight * u_patternFactor);\nmat3 patterMat = mat3(scaleX, 0.0,    0.0,\n0.0,    -scaleY, 0.0,\n0.0,    0.0,    1.0);\nv_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;\nv_tlbr             = tlbr / u_mosaicSize.xyxy;\n#endif\nvec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, icon: { "icon.frag": "precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\nconst float softEdgeRatio = 0.248062016;\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * softEdgeRatio * size;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nif (v_halo_width > 0.25) {\nlowp vec4 outlinePixelColor = u_outlineColor;\nconst float outlineLimitRatio = (16.0 / 86.0);\nfloat clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\noutlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\ngl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\ngl_FragColor = v_opacity * texColor;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "icon.vert": "attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nv_color = color;\nv_opacity = opacity;\n#ifdef SDF\nv_halo_width = halo_width;\n#endif\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_opacity *= interpolatedOpacity;\nmediump float a_angle         = a_levelInfo[1];\nmediump float a_minLevel      = a_levelInfo[2];\nmediump float a_maxLevel      = a_levelInfo[3];\nmediump vec2 a_tex            = a_texAngleRange.xy;\nmediump float delta_z = 0.0;\nmediump float rotated = mod(a_angle + u_mapRotation, 256.0);\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_opacity, 0.0);\nvec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\nv_size = abs(offset);\n#ifdef SDF\noffset = (120.0 / 86.0) * offset;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_tex = a_tex.xy / u_mosaicSize;\n}" }, line: { "line.frag": "precision lowp float;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#if defined (PATTERN) || defined(SDF)\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\nuniform sampler2D u_texture;\nuniform mediump float u_antialiasing;\n#endif\n#ifdef SDF\n#include <util/encoding.glsl>\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\nmediump float relativeTexX = fract(v_accumulatedDistance / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = alpha * v_color[3] * color;\n#elif defined(SDF)\nmediump float relativeTexX = fract((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY =  0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * (v_lineHalfWidth + u_antialiasing / 2.0);\ngl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n#else\ngl_FragColor = alpha * v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "line.vert": "precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_extrude_offset;\nattribute vec4 a_dir_normal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\nconst mediump float tileCoordRatio = 8.0;\n#if defined (SDF)\nconst mediump float sdfPatternHalfWidth = 15.5;\n#endif\n#if defined (PATTERN) || defined(SDF)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_blur = blur + u_antialiasing;\nv_normal = a_dir_normal.zw * scale;\n#if defined (PATTERN) || defined(SDF)\nv_tlbr          = tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);\n#if defined (PATTERN)\nv_widthRatio = width / v_patternSize.y;\n#else\nv_widthRatio = width / sdfPatternHalfWidth / 2.0;\n#endif\n#endif\nv_lineHalfWidth = (width + u_antialiasing) * 0.5;\nmediump vec2 dir = a_dir_normal.xy * scale;\nmediump vec2 offset_ = a_extrude_offset.zw * scale * offset;\nmediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n#if defined (PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}" }, outline: { "outline.frag": "varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = abs(v_normal.y);\nlowp float alpha = smoothstep(1.0, 0.0, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "outline.vert": "attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_normal = a_xnormal;\nmediump vec2 dist = u_outline_width * scale * a_offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, text: { "text.frag": "uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "text.vert": "attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nif (u_halo > 0.5)\n{\nv_color = halo_color * opacity;\nhalo_width *= sdfPixel;\nhalo_blur *= sdfPixel;\n}\nelse\n{\nv_color = color * opacity;\nhalo_width = 0.0;\nhalo_blur = 0.0;\n}\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_color *= interpolatedOpacity;\nmediump float a_angle       = a_levelInfo[1];\nmediump float a_minLevel    = a_levelInfo[2];\nmediump float a_maxLevel    = a_levelInfo[3];\nmediump vec2 a_tex          = a_texAngleRange.xy;\nmediump float a_visMinAngle    = a_texAngleRange.z;\nmediump float a_visMaxAngle    = a_texAngleRange.w;\nmediump float delta_z = 0.0;\nmediump float angle = mod(a_angle + u_mapRotation, 256.0);\nif (a_visMinAngle < a_visMaxAngle)\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n}\nelse\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n}\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_color[3], 0.0);\nv_tex = a_tex.xy / u_mosaicSize;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_edgeDistance = edgePos - halo_width / size;\nv_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}" }, util: { "encoding.glsl": "const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}", "util.glsl": "float nextPOT(in float x) {\nreturn pow(2.0, ceil(log2(abs(x))));\n}" } };

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/resolver.js
function o6(e14) {
  let o10 = e10;
  return e14.split("/").forEach((r14) => {
    o10 && (o10 = o10[r14]);
  }), o10;
}
var t4 = new e8(o6);
function n7(r14) {
  return t4.resolveIncludes(r14);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/BitBlitPrograms.js
var e11 = { shaders: { vertexShader: n6("bitBlit/bitBlit.vert"), fragmentShader: n6("bitBlit/bitBlit.frag") }, attributes: /* @__PURE__ */ new Map([["a_pos", 0], ["a_tex", 1]]) };

// node_modules/@arcgis/core/views/2d/engine/webgl/RectangleBinPack.js
var t5 = class {
  constructor(t11, e14) {
    this._width = 0, this._height = 0, this._free = [], this._width = t11, this._height = e14, this._free.push(new t(0, 0, t11, e14));
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  allocate(t11, e14) {
    if (t11 > this._width || e14 > this._height)
      return new t();
    let i6 = null, s11 = -1;
    for (let h5 = 0; h5 < this._free.length; ++h5) {
      const r14 = this._free[h5];
      t11 <= r14.width && e14 <= r14.height && (null === i6 || r14.y <= i6.y && r14.x <= i6.x) && (i6 = r14, s11 = h5);
    }
    return null === i6 ? new t() : (this._free.splice(s11, 1), i6.width < i6.height ? (i6.width > t11 && this._free.push(new t(i6.x + t11, i6.y, i6.width - t11, e14)), i6.height > e14 && this._free.push(new t(i6.x, i6.y + e14, i6.width, i6.height - e14))) : (i6.width > t11 && this._free.push(new t(i6.x + t11, i6.y, i6.width - t11, i6.height)), i6.height > e14 && this._free.push(new t(i6.x, i6.y + e14, t11, i6.height - e14))), new t(i6.x, i6.y, t11, e14));
  }
  release(h5) {
    for (let t11 = 0; t11 < this._free.length; ++t11) {
      const e14 = this._free[t11];
      if (e14.y === h5.y && e14.height === h5.height && e14.x + e14.width === h5.x)
        e14.width += h5.width;
      else if (e14.x === h5.x && e14.width === h5.width && e14.y + e14.height === h5.y)
        e14.height += h5.height;
      else if (h5.y === e14.y && h5.height === e14.height && h5.x + h5.width === e14.x)
        e14.x = h5.x, e14.width += h5.width;
      else {
        if (h5.x !== e14.x || h5.width !== e14.width || h5.y + h5.height !== e14.y)
          continue;
        e14.y = h5.y, e14.height += h5.height;
      }
      this._free.splice(t11, 1), this.release(h5);
    }
    this._free.push(h5);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GlyphMosaic.js
var n8 = 256;
var o7 = (t11) => Math.floor(t11 / 256);
function c5(t11) {
  const e14 = /* @__PURE__ */ new Set();
  for (const i6 of t11)
    e14.add(o7(i6));
  return e14;
}
function l2(e14, i6, h5) {
  return e14.has(i6) || e14.set(i6, h5().then(() => {
    e14.delete(i6);
  }).catch((h6) => {
    e14.delete(i6), f(h6);
  })), e14.get(i6);
}
var g3 = (t11) => ({ rect: new t(0, 0, 0, 0), page: 0, metrics: { left: 0, width: 0, height: 0, advance: 0, top: 0 }, code: t11, sdf: true });
var p2 = class {
  constructor(t11, e14, h5) {
    this.width = 0, this.height = 0, this._dirties = [], this._glyphData = [], this._currentPage = 0, this._glyphCache = {}, this._textures = [], this._rangePromises = /* @__PURE__ */ new Map(), this._preloadCache = {}, this.width = t11, this.height = e14, this._glyphSource = h5, this._binPack = new t5(t11 - 4, e14 - 4), this._glyphData.push(new Uint8Array(t11 * e14)), this._dirties.push(true), this._textures.push(null), this._initDecorationGlyphs();
  }
  dispose() {
    this._binPack = null;
    for (const t11 of this._textures)
      t11 && t11.dispose();
    this._textures.length = 0, this._glyphData.length = 0;
  }
  _initDecorationGlyphs() {
    const t11 = [117, 149, 181, 207, 207, 181, 149, 117], e14 = [], i6 = [];
    for (let r14 = 0; r14 < t11.length; r14++) {
      const h6 = t11[r14];
      for (let t12 = 0; t12 < 11; t12++) {
        const s12 = r14 >= 3 && r14 < 5 && t12 >= 3 && t12 < 8 ? 255 : 0;
        e14.push(h6), i6.push(s12);
      }
    }
    const h5 = { metrics: { width: 5, height: 2, left: 0, top: 0, advance: 0 }, bitmap: new Uint8Array(e14) }, s11 = { metrics: { width: 5, height: 2, left: 0, top: 0, advance: 0 }, bitmap: new Uint8Array(i6) };
    this._recordGlyph(h5), this._recordGlyph(s11);
  }
  async getGlyphItems(t11, e14, i6) {
    const h5 = this._getGlyphCache(t11);
    return await this._fetchRanges(t11, e14, i6), e14.map((e15) => this._getMosaicItem(h5, t11, e15));
  }
  bind(t11, e14, i6, h5) {
    const s11 = this._getTexture(t11, i6);
    s11.setSamplingMode(e14), this._dirties[i6] && (s11.setData(this._glyphData[i6]), this._dirties[i6] = false), t11.bindTexture(s11, h5);
  }
  preloadASCIIGlyphCache(t11) {
    const e14 = this._preloadCache[t11];
    if (null != e14)
      return e14;
    const i6 = this._glyphSource.preloadASCIIRange(t11).then(() => {
      const e15 = this._getGlyphCache(t11);
      for (let i7 = 0; i7 < 256; i7++)
        this._getMosaicItem(e15, t11, i7);
    });
    return this._preloadCache[t11] = i6, i6;
  }
  _getGlyphCache(t11) {
    return this._glyphCache[t11] || (this._glyphCache[t11] = {}), this._glyphCache[t11];
  }
  _getTexture(t11, e14) {
    if (!this._textures[e14]) {
      const i6 = new e6();
      i6.pixelFormat = G.ALPHA, i6.wrapMode = D.CLAMP_TO_EDGE, i6.width = this.width, i6.height = this.height, this._textures[e14] = new T2(t11, i6, new Uint8Array(this.width * this.height));
    }
    return this._textures[e14];
  }
  _invalidate() {
    this._dirties[this._currentPage] = true;
  }
  async _fetchRanges(t11, e14, i6) {
    const h5 = c5(e14), s11 = [];
    h5.forEach((e15) => {
      s11.push(this._fetchRange(t11, e15, i6));
    }), await Promise.all(s11);
  }
  async _fetchRange(t11, e14, i6) {
    if (e14 > n8)
      return;
    const h5 = t11 + e14;
    return l2(this._rangePromises, h5, () => this._glyphSource.getRange(t11, e14, i6));
  }
  _getMosaicItem(t11, e14, i6) {
    if (!t11[i6]) {
      const h5 = this._glyphSource.getGlyph(e14, i6);
      if (!(h5 == null ? void 0 : h5.metrics))
        return g3(i6);
      const s11 = this._recordGlyph(h5), r14 = this._currentPage, a9 = h5.metrics;
      t11[i6] = { rect: s11, page: r14, metrics: a9, code: i6, sdf: true }, this._invalidate();
    }
    return t11[i6];
  }
  _recordGlyph(t11) {
    const h5 = t11.metrics;
    let s11;
    if (0 === h5.width)
      s11 = new t(0, 0, 0, 0);
    else {
      const e14 = 3, r14 = h5.width + 2 * e14, a9 = h5.height + 2 * e14;
      s11 = this._binPack.allocate(r14, a9), s11.isEmpty && (this._dirties[this._currentPage] || (this._glyphData[this._currentPage] = null), this._currentPage = this._glyphData.length, this._glyphData.push(new Uint8Array(this.width * this.height)), this._dirties.push(true), this._textures.push(null), this._initDecorationGlyphs(), this._binPack = new t5(this.width - 4, this.height - 4), s11 = this._binPack.allocate(r14, a9));
      const n13 = this._glyphData[this._currentPage], o10 = t11.bitmap;
      let c12, l8;
      if (o10)
        for (let t12 = 0; t12 < a9; t12++) {
          c12 = r14 * t12, l8 = this.width * (s11.y + t12) + s11.x;
          for (let t13 = 0; t13 < r14; t13++)
            n13[l8 + t13] = o10[c12 + t13];
        }
      has("esri-glyph-debug") && this._showDebugPage(n13);
    }
    return s11;
  }
  _showDebugPage(t11) {
    const e14 = document.createElement("canvas"), i6 = e14.getContext("2d"), h5 = new ImageData(this.width, this.height), s11 = h5.data;
    e14.width = this.width, e14.height = this.height, e14.style.border = "1px solid black";
    for (let r14 = 0; r14 < t11.length; ++r14)
      s11[4 * r14] = t11[r14], s11[4 * r14 + 1] = 0, s11[4 * r14 + 2] = 0, s11[4 * r14 + 3] = 255;
    i6.putImageData(h5, 0, 0), document.body.appendChild(e14);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GlyphSource.js
var a2 = class {
  constructor(e14) {
    for (this._metrics = [], this._bitmaps = []; e14.next(); )
      switch (e14.tag()) {
        case 1: {
          const t11 = e14.getMessage();
          for (; t11.next(); )
            switch (t11.tag()) {
              case 3: {
                const e15 = t11.getMessage();
                let a9, s11, r14, n13, i6, c12, g7;
                for (; e15.next(); )
                  switch (e15.tag()) {
                    case 1:
                      a9 = e15.getUInt32();
                      break;
                    case 2:
                      s11 = e15.getBytes();
                      break;
                    case 3:
                      r14 = e15.getUInt32();
                      break;
                    case 4:
                      n13 = e15.getUInt32();
                      break;
                    case 5:
                      i6 = e15.getSInt32();
                      break;
                    case 6:
                      c12 = e15.getSInt32();
                      break;
                    case 7:
                      g7 = e15.getUInt32();
                      break;
                    default:
                      e15.skip();
                  }
                e15.release(), a9 && (this._metrics[a9] = { width: r14, height: n13, left: i6, top: c12, advance: g7 }, this._bitmaps[a9] = s11);
                break;
              }
              default:
                t11.skip();
            }
          t11.release();
          break;
        }
        default:
          e14.skip();
      }
  }
  getMetrics(e14) {
    return this._metrics[e14];
  }
  getBitmap(e14) {
    return this._bitmaps[e14];
  }
};
var s7 = class {
  constructor() {
    this._ranges = [];
  }
  getRange(e14) {
    return this._ranges[e14];
  }
  addRange(e14, t11) {
    this._ranges[e14] = t11;
  }
};
var r5 = class {
  constructor(e14) {
    this._glyphInfo = {}, this._baseURL = e14;
  }
  getRange(s11, r14, n13) {
    const i6 = this._getFontStack(s11);
    if (i6.getRange(r14))
      return Promise.resolve();
    const c12 = 256 * r14, g7 = c12 + 255, o10 = this._baseURL.replace("{fontstack}", s11).replace("{range}", c12 + "-" + g7);
    return j(o10, { responseType: "array-buffer", ...n13 }).then((e14) => {
      i6.addRange(r14, new a2(new r4(new Uint8Array(e14.data), new DataView(e14.data))));
    });
  }
  async preloadASCIIRange(s11) {
    const r14 = this._getFontStack(s11), n13 = 0, i6 = 255, c12 = this._baseURL.replace("{fontstack}", s11).replace("{range}", n13 + "-" + i6), g7 = await j(c12, { responseType: "array-buffer" }), o10 = new a2(new r4(new Uint8Array(g7.data), new DataView(g7.data)));
    for (let e14 = n13; e14 <= i6; e14++)
      r14.getRange(e14) || r14.addRange(e14, o10);
  }
  getGlyph(e14, t11) {
    const a9 = this._getFontStack(e14);
    if (!a9)
      return;
    const s11 = Math.floor(t11 / 256), r14 = a9.getRange(s11);
    return r14 ? { metrics: r14.getMetrics(t11), bitmap: r14.getBitmap(t11) } : void 0;
  }
  _getFontStack(e14) {
    let t11 = this._glyphInfo[e14];
    return t11 || (t11 = this._glyphInfo[e14] = new s7()), t11;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/SDFConverter.js
var i4 = 1e20;
var r6 = class {
  constructor(t11) {
    this._svg = null, this.size = t11;
    const e14 = document.createElement("canvas");
    e14.width = e14.height = t11, this._context = e14.getContext("2d", { willReadFrequently: false }), this._gridOuter = new Float64Array(t11 * t11), this._gridInner = new Float64Array(t11 * t11), this._f = new Float64Array(t11), this._d = new Float64Array(t11), this._z = new Float64Array(t11 + 1), this._v = new Int16Array(t11);
  }
  dispose() {
    this._context = this._gridOuter = this._gridInner = this._f = this._d = this._z = this._v = null, this._svg && (document.body.removeChild(this._svg), this._svg = null);
  }
  draw(r14, h5, n13, o10 = 31) {
    this._initSVG();
    const d8 = this.createSVGString(r14, h5);
    return new Promise((r15, h6) => {
      const a9 = new Image();
      a9.src = "data:image/svg+xml; charset=utf8, " + encodeURIComponent(d8), a9.onload = () => {
        a9.onload = null, this._context.clearRect(0, 0, this.size, this.size), this._context.drawImage(a9, 0, 0, this.size, this.size);
        const e14 = this._context.getImageData(0, 0, this.size, this.size), s11 = new Uint8Array(this.size * this.size * 4);
        for (let t11 = 0; t11 < this.size * this.size; t11++) {
          const s12 = e14.data[4 * t11 + 3] / 255;
          this._gridOuter[t11] = 1 === s12 ? 0 : 0 === s12 ? i4 : Math.max(0, 0.5 - s12) ** 2, this._gridInner[t11] = 1 === s12 ? i4 : 0 === s12 ? 0 : Math.max(0, s12 - 0.5) ** 2;
        }
        this._edt(this._gridOuter, this.size, this.size), this._edt(this._gridInner, this.size, this.size);
        for (let i6 = 0; i6 < this.size * this.size; i6++) {
          const e15 = this._gridOuter[i6] - this._gridInner[i6];
          o3(0.5 - e15 / (2 * o10), s11, 4 * i6);
        }
        r15(s11);
      };
      const l8 = n13 == null ? void 0 : n13.signal;
      l8 && m(l8, () => h6(u2()));
    });
  }
  _initSVG() {
    if (!this._svg) {
      const t11 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      t11.setAttribute("style", "position: absolute;"), t11.setAttribute("width", "0"), t11.setAttribute("height", "0"), t11.setAttribute("aria-hidden", "true"), t11.setAttribute("role", "presentation"), document.body.appendChild(t11), this._svg = t11;
    }
    return this._svg;
  }
  createSVGString(t11, e14) {
    const s11 = this._initSVG(), i6 = document.createElementNS("http://www.w3.org/2000/svg", "path");
    i6.setAttribute("d", t11), s11.appendChild(i6);
    const r14 = i6.getBBox(), h5 = r14.width / r14.height, n13 = this.size / 2;
    let o10, d8, a9;
    if (h5 > 1) {
      o10 = n13 / r14.width;
      const t12 = n13 * (1 / h5);
      d8 = this.size / 4, a9 = n13 - t12 / 2;
    } else {
      o10 = n13 / r14.height;
      d8 = n13 - n13 * h5 / 2, a9 = this.size / 4;
    }
    const l8 = -r14.x * o10 + d8, _7 = -r14.y * o10 + a9;
    i6.setAttribute("style", `transform: matrix(${o10}, 0, 0, ${o10}, ${l8}, ${_7})`), i6.setAttribute("stroke-width", "" + 0.5 / o10);
    const g7 = `<svg style="fill:${e14 ? "red" : "none"}; stroke:${e14 ? "none" : "red"}" height="${this.size}" width="${this.size}" xmlns="http://www.w3.org/2000/svg">${s11.innerHTML}</svg>`;
    return s11.removeChild(i6), g7;
  }
  _edt(t11, e14, s11) {
    const i6 = this._f, r14 = this._d, h5 = this._v, n13 = this._z;
    for (let o10 = 0; o10 < e14; o10++) {
      for (let r15 = 0; r15 < s11; r15++)
        i6[r15] = t11[r15 * e14 + o10];
      this._edt1d(i6, r14, h5, n13, s11);
      for (let i7 = 0; i7 < s11; i7++)
        t11[i7 * e14 + o10] = r14[i7];
    }
    for (let o10 = 0; o10 < s11; o10++) {
      for (let s12 = 0; s12 < e14; s12++)
        i6[s12] = t11[o10 * e14 + s12];
      this._edt1d(i6, r14, h5, n13, e14);
      for (let s12 = 0; s12 < e14; s12++)
        t11[o10 * e14 + s12] = Math.sqrt(r14[s12]);
    }
  }
  _edt1d(t11, e14, s11, r14, h5) {
    s11[0] = 0, r14[0] = -i4, r14[1] = +i4;
    for (let n13 = 1, o10 = 0; n13 < h5; n13++) {
      let e15 = (t11[n13] + n13 * n13 - (t11[s11[o10]] + s11[o10] * s11[o10])) / (2 * n13 - 2 * s11[o10]);
      for (; e15 <= r14[o10]; )
        o10--, e15 = (t11[n13] + n13 * n13 - (t11[s11[o10]] + s11[o10] * s11[o10])) / (2 * n13 - 2 * s11[o10]);
      o10++, s11[o10] = n13, r14[o10] = e15, r14[o10 + 1] = +i4;
    }
    for (let i6 = 0, n13 = 0; i6 < h5; i6++) {
      for (; r14[n13 + 1] < i6; )
        n13++;
      e14[i6] = (i6 - s11[n13]) * (i6 - s11[n13]) + t11[s11[n13]];
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/SpriteMosaic.js
function c6(t11) {
  return t11 && "static" === t11.type;
}
var n9 = class _n {
  constructor(t11, e14, i6 = 0) {
    this._mosaicPages = [], this._maxItemSize = 0, this._currentPage = 0, this._pageWidth = 0, this._pageHeight = 0, this._mosaicRects = /* @__PURE__ */ new Map(), this._spriteCopyQueue = [], this.pixelRatio = 1, (t11 <= 0 || e14 <= 0) && console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"), this._pageWidth = t11, this._pageHeight = e14, i6 > 0 && (this._maxItemSize = i6), this.pixelRatio = window.devicePixelRatio || 1, this._binPack = new t5(this._pageWidth, this._pageHeight);
    const s11 = Math.floor(this._pageWidth), o10 = Math.floor(this._pageHeight);
    this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(s11 * o10) }, size: [this._pageWidth, this._pageHeight], dirty: true, texture: void 0 });
  }
  getWidth(t11) {
    return t11 >= this._mosaicPages.length ? -1 : this._mosaicPages[t11].size[0];
  }
  getHeight(t11) {
    return t11 >= this._mosaicPages.length ? -1 : this._mosaicPages[t11].size[1];
  }
  getPageTexture(t11) {
    return t11 < this._mosaicPages.length ? this._mosaicPages[t11].texture : null;
  }
  has(t11) {
    return this._mosaicRects.has(t11);
  }
  get itemCount() {
    return this._mosaicRects.size;
  }
  getSpriteItem(t11) {
    return this._mosaicRects.get(t11);
  }
  addSpriteItem(t11, i6, a9, o10, r14, h5, n13 = 1) {
    if (this._mosaicRects.has(t11))
      return this._mosaicRects.get(t11);
    let g7, p5, m4;
    if (c6(a9))
      [g7, p5, m4] = this._allocateImage(i6[0], i6[1]);
    else {
      g7 = new t(0, 0, i6[0], i6[1]), p5 = this._mosaicPages.length;
      const t12 = void 0;
      this._mosaicPages.push({ mosaicsData: a9, size: [i6[0] + 2 * ae, i6[1] + 2 * ae], dirty: true, texture: t12 });
    }
    if (g7.width <= 0 || g7.height <= 0)
      return null;
    const d8 = { rect: g7, width: i6[0], height: i6[1], sdf: r14, simplePattern: h5, pixelRatio: n13, page: p5 };
    return this._mosaicRects.set(t11, d8), c6(a9) && (has("esri-mosaic-debug") && this._showDebugSprite(i6, a9.data), this._copy({ rect: g7, spriteSize: i6, spriteData: a9.data, page: p5, pageSize: m4, repeat: o10, sdf: r14 })), d8;
  }
  hasItemsToProcess() {
    return 0 !== this._spriteCopyQueue.length;
  }
  processNextItem() {
    const t11 = this._spriteCopyQueue.pop();
    t11 && this._copy(t11);
  }
  getSpriteItems(t11) {
    const e14 = {};
    for (const i6 of t11)
      e14[i6] = this.getSpriteItem(i6);
    return e14;
  }
  getMosaicItemPosition(t11) {
    const i6 = this.getSpriteItem(t11), s11 = i6 == null ? void 0 : i6.rect;
    if (!s11)
      return null;
    s11.width = i6.width, s11.height = i6.height;
    const a9 = i6.width, o10 = i6.height, r14 = ae, h5 = this._mosaicPages[i6.page].size;
    return { size: [i6.width, i6.height], tl: [(s11.x + r14) / h5[0], (s11.y + r14) / h5[1]], br: [(s11.x + r14 + a9) / h5[0], (s11.y + r14 + o10) / h5[1]], page: i6.page };
  }
  bind(t11, e14, i6 = 0, s11 = 0) {
    const a9 = this._mosaicPages[i6], o10 = a9.mosaicsData;
    let r14 = a9.texture;
    if (r14 || (r14 = p3(t11, a9.size), a9.texture = r14), r14.setSamplingMode(e14), c6(o10))
      t11.bindTexture(r14, s11), a9.dirty && (r14.setData(new Uint8Array(o10.data.buffer)), r14.generateMipmap(), has("esri-mosaic-debug") && this._showDebugPage(i6));
    else {
      o10.data.bindFrame(t11, r14, s11), r14.generateMipmap();
    }
    a9.dirty = false;
  }
  dispose() {
    this._binPack = null;
    for (const t11 of this._mosaicPages) {
      const e14 = t11.texture;
      e14 && e14.dispose();
      const i6 = t11.mosaicsData;
      if (!c6(i6)) {
        i6.data.destroy();
      }
    }
    this._mosaicPages = null, this._mosaicRects.clear();
  }
  static _copyBits(t11, e14, i6, s11, a9, o10, r14, h5, c12, n13, g7) {
    let p5 = s11 * e14 + i6, m4 = h5 * o10 + r14;
    if (g7) {
      m4 -= o10;
      for (let r15 = -1; r15 <= n13; r15++, p5 = ((r15 + n13) % n13 + s11) * e14 + i6, m4 += o10)
        for (let e15 = -1; e15 <= c12; e15++)
          a9[m4 + e15] = t11[p5 + (e15 + c12) % c12];
    } else
      for (let d8 = 0; d8 < n13; d8++) {
        for (let e15 = 0; e15 < c12; e15++)
          a9[m4 + e15] = t11[p5 + e15];
        p5 += e14, m4 += o10;
      }
  }
  _copy(i6) {
    if (i6.page >= this._mosaicPages.length)
      return;
    const s11 = this._mosaicPages[i6.page], a9 = s11.mosaicsData;
    if (!c6(s11.mosaicsData))
      throw new s3("mapview-invalid-resource", "unsuitable data type!");
    const o10 = i6.spriteData, r14 = a9.data;
    r14 && o10 || console.error("Source or target images are uninitialized!"), _n._copyBits(o10, i6.spriteSize[0], 0, 0, r14, i6.pageSize[0], i6.rect.x + ae, i6.rect.y + ae, i6.spriteSize[0], i6.spriteSize[1], i6.repeat), s11.dirty = true;
  }
  _allocateImage(t11, o10) {
    t11 += 2 * ae, o10 += 2 * ae;
    const r14 = Math.max(t11, o10);
    if (this._maxItemSize && this._maxItemSize < r14) {
      const e14 = 2 ** Math.ceil(e3(t11)), a9 = 2 ** Math.ceil(e3(o10)), r15 = new t(0, 0, t11, o10);
      return this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(e14 * a9) }, size: [e14, a9], dirty: true, texture: void 0 }), [r15, this._mosaicPages.length - 1, [e14, a9]];
    }
    const h5 = this._binPack.allocate(t11, o10);
    if (h5.width <= 0) {
      const e14 = this._mosaicPages[this._currentPage];
      return !e14.dirty && c6(e14.mosaicsData) && (e14.mosaicsData.data = null), this._currentPage = this._mosaicPages.length, this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(this._pageWidth * this._pageHeight) }, size: [this._pageWidth, this._pageHeight], dirty: true, texture: void 0 }), this._binPack = new t5(this._pageWidth, this._pageHeight), this._allocateImage(t11, o10);
    }
    return [h5, this._currentPage, [this._pageWidth, this._pageHeight]];
  }
  _showDebugSprite([t11, e14], i6) {
    const s11 = document.createElement("canvas");
    s11.width = t11, s11.height = e14, s11.setAttribute("style", `position: absolute; top: ${4 + 204 * g4++}px; right: 208px; width: 200px; height: 200px; border: 1px solid black;`);
    const a9 = s11.getContext("2d"), o10 = new ImageData(t11, e14);
    o10.data.set(new Uint8Array(i6.buffer)), a9.putImageData(o10, 0, 0), document.body.appendChild(s11);
  }
  _showDebugPage(t11) {
    const e14 = this._mosaicPages[t11], { size: [i6, s11], mosaicsData: a9 } = e14;
    if (!c6(a9))
      return void console.error("Could not show sprite mosaic debug for non-static resource");
    const o10 = `mosaicDebugPage${t11}`, r14 = document.getElementById(o10) ?? document.createElement("canvas");
    r14.id = o10, r14.width = i6, r14.height = s11, r14.setAttribute("style", `position: absolute; top: ${4 + 204 * t11}px; right: 4px; width: 200px; height: 200px; border: 1px solid black;`);
    const h5 = r14.getContext("2d"), n13 = new ImageData(i6, s11);
    n13.data.set(new Uint8Array(a9.data.buffer)), h5.putImageData(n13, 0, 0), document.body.appendChild(r14);
  }
};
var g4 = 0;
function p3(t11, e14) {
  const i6 = new e6();
  return i6.width = e14[0], i6.height = e14[1], i6.wrapMode = D.CLAMP_TO_EDGE, new T2(t11, i6, null);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/animatedFormats/utils.js
function o8(t11) {
  return n(t11.frameDurations.reduce((t12, e14) => t12 + e14, 0));
}
function s8(t11) {
  const { width: e14, height: r14 } = t11, i6 = t11.frameDurations.reverse(), a9 = (e15) => {
    const r15 = t11.frameDurations.length - 1 - e15;
    return t11.getFrame(r15);
  };
  return { frameCount: t11.frameCount, duration: t11.duration, frameDurations: i6, getFrame: a9, width: e14, height: r14 };
}
function m2(t11, r14) {
  const { width: i6, height: a9, getFrame: n13 } = t11, o10 = r14 / t11.duration, s11 = t11.frameDurations.map((t12) => n(t12 * o10));
  return { frameCount: t11.frameCount, duration: t11.duration, frameDurations: s11, getFrame: n13, width: i6, height: a9 };
}
function u4(t11, r14) {
  const { width: i6, height: a9, getFrame: n13 } = t11, o10 = t11.frameDurations.slice(), s11 = o10.shift();
  return o10.unshift(n(s11 + r14)), { frameCount: t11.frameCount, duration: t11.duration + r14, frameDurations: o10, getFrame: n13, width: i6, height: a9 };
}
function h(t11, r14) {
  const { width: i6, height: a9, getFrame: n13 } = t11, o10 = t11.frameDurations.slice(), s11 = o10.pop();
  return o10.push(n(s11 + r14)), { frameCount: t11.frameCount, duration: t11.duration + r14, frameDurations: o10, getFrame: n13, width: i6, height: a9 };
}
var c7 = class {
  constructor(t11, e14, r14, i6) {
    this._animation = t11, this._repeatType = r14, this._onFrameData = i6, this._direction = 1, this._currentFrame = 0, this.timeToFrame = this._animation.frameDurations[this._currentFrame];
    let a9 = 0;
    for (; e14 > a9; )
      a9 += this.timeToFrame, this.nextFrame();
    const n13 = this._animation.getFrame(this._currentFrame);
    this._onFrameData(n13);
  }
  nextFrame() {
    if (this._currentFrame += this._direction, this._direction > 0) {
      if (this._currentFrame === this._animation.frameDurations.length)
        switch (this._repeatType) {
          case d.None:
            this._currentFrame -= this._direction;
            break;
          case d.Loop:
            this._currentFrame = 0;
            break;
          case d.Oscillate:
            this._currentFrame -= this._direction, this._direction = -1;
        }
    } else if (-1 === this._currentFrame)
      switch (this._repeatType) {
        case d.None:
          this._currentFrame -= this._direction;
          break;
        case d.Loop:
          this._currentFrame = this._animation.frameDurations.length - 1;
          break;
        case d.Oscillate:
          this._currentFrame -= this._direction, this._direction = 1;
      }
    this.timeToFrame = this._animation.frameDurations[this._currentFrame];
    const t11 = this._animation.getFrame(this._currentFrame);
    this._onFrameData(t11);
  }
};
function f3(t11, r14, f4, l8) {
  let d8, { repeatType: g7 } = r14;
  if (null == g7 && (g7 = d.Loop), true === r14.reverseAnimation && (t11 = s8(t11)), null != r14.duration && (t11 = m2(t11, n(1e3 * r14.duration))), null != r14.repeatDelay) {
    const a9 = 1e3 * r14.repeatDelay;
    g7 === d.Loop ? t11 = h(t11, n(a9)) : g7 === d.Oscillate && (t11 = u4(h(t11, n(a9 / 2)), n(a9 / 2)));
  }
  if (null != r14.startTimeOffset)
    d8 = n(1e3 * r14.startTimeOffset);
  else if (null != r14.randomizeStartTime) {
    const i6 = o4(f4), s11 = 82749913, m4 = null != r14.randomizeStartSeed ? r14.randomizeStartSeed : s11, u6 = e4(i6, m4);
    d8 = n(u6 * o8(t11));
  } else
    d8 = n(0);
  return new c7(t11, d8, g7, l8);
}
function l3(e14, r14, i6, a9) {
  const n13 = null == r14.playAnimation || r14.playAnimation, o10 = f3(e14, r14, i6, a9);
  let s11, m4 = o10.timeToFrame;
  function u6() {
    s11 = n13 ? setTimeout(() => {
      o10.nextFrame(), m4 = o10.timeToFrame, u6();
    }, m4) : void 0;
  }
  return u6(), e2(() => n13 && clearTimeout(s11));
}
var d2;
var g5;
function F() {
  return d2 ?? (d2 = document.createElement("canvas")), g5 ?? (g5 = d2.getContext("2d")), { canvas: d2, ctx: g5 };
}
function _4(t11, e14, i6) {
  const { canvas: a9, ctx: n13 } = F();
  a9.width = e14, a9.height = i6;
  const o10 = [], s11 = t11.frameDurations.length;
  for (let m4 = 0; m4 < s11; m4++) {
    const a10 = t11.getFrame(m4);
    n13.clearRect(0, 0, e14, i6), a10 instanceof ImageData ? n13.drawImage(o5(a10), 0, 0, e14, i6) : n13.drawImage(a10, 0, 0, e14, i6), o10.push(n13.getImageData(0, 0, e14, i6));
  }
  return { width: e14, height: i6, frameDurations: t11.frameDurations, getFrame: (t12) => o10[t12], frameCount: t11.frameCount, duration: t11.duration };
}

// node_modules/@arcgis/core/views/2d/engine/webgl/animatedFormats/AnimatableTextureResource.js
var a3 = class {
  constructor(t11, a9, e14, n13) {
    this._animation = t11, this._frameData = null;
    const h5 = (t12) => {
      this._frameData = t12, a9.requestRender();
    };
    this.frameCount = this._animation.frameDurations.length, this.width = this._animation.width, this.height = this._animation.height, this._playHandle = l3(this._animation, e14, n13, h5);
  }
  destroy() {
    this._playHandle.remove();
  }
  bindFrame(i6, a9, e14) {
    i6.bindTexture(a9, e14);
    const n13 = this._frameData;
    if (null == n13)
      return;
    const h5 = "width" in n13 ? n13.width : n13.codedWidth, s11 = "height" in n13 ? n13.height : n13.codedHeight;
    a9.updateData(0, ae, ae, h5, s11, n13), this._frameData = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/symbolUtils.js
function e12(e14) {
  switch (e14.type) {
    case "esriSMS":
      return `${e14.style}.${e14.path}`;
    case "esriSLS":
      return `${e14.style}.${e14.cap}`;
    case "esriSFS":
      return `${e14.style}`;
    case "esriPFS":
    case "esriPMS":
      return e14.imageData ? `${e14.imageData}${e14.width}${e14.height}` : `${e14.url}${e14.width}${e14.height}`;
    default:
      return "mosaicHash" in e14 ? e14.mosaicHash : JSON.stringify(e14);
  }
}

// node_modules/@arcgis/core/views/2d/engine/webgl/TextureManager.js
var $ = n4();
var k = "arial-unicode-ms-regular";
var H = s2.getLogger("esri.views.2d.engine.webgl.TextureManager");
function O(t11) {
  const e14 = Math.round(u3(t11) * window.devicePixelRatio);
  return e14 * (e14 >= 128 ? 2 : 4);
}
function Q(t11, e14) {
  return Math.min(t11, O(e14));
}
function V(t11, e14) {
  if (!t11 || !e14)
    return { width: 0, height: 0 };
  const i6 = t11 / e14;
  if (i6 > 1) {
    const e15 = O(t11);
    return { width: e15, height: e15 / i6 };
  }
  const s11 = O(e14);
  return { width: s11 * i6, height: s11 };
}
var Y2 = (t11, e14, i6) => H.error(new s3(t11, e14, i6));
var D2 = class _D {
  static fromMosaic(t11, e14) {
    return new _D(t11, e14.page, e14.sdf);
  }
  constructor(t11, e14, i6) {
    this.mosaicType = t11, this.page = e14, this.sdf = i6;
  }
};
var J = class {
  constructor(i6, r14, o10) {
    this._requestRender = i6, this.resourceManager = r14, this._allowNonPowerOfTwo = o10, this._invalidFontsMap = /* @__PURE__ */ new Map(), this._sdfConverter = new r6(ce), this._bindingInfos = new Array(), this._hashToBindingIndex = /* @__PURE__ */ new Map(), this._ongoingRasterizations = /* @__PURE__ */ new Map(), this._imageRequestQueue = new _2({ concurrency: 10, process: async (t11, i7) => {
      s4(i7);
      try {
        return await j(t11, { responseType: "image", signal: i7 });
      } catch (r15) {
        if (!b(r15))
          throw new s3("mapview-invalid-resource", `Could not fetch requested resource at ${t11}`, r15);
        throw r15;
      }
    } }), this._spriteMosaic = new n9(2048, 2048, 500), this._glyphSource = new r5(`${s.fontsUrl}/{fontstack}/{range}.pbf`), this._glyphMosaic = new p2(1024, 1024, this._glyphSource), this._rasterizer = new c4(r14);
  }
  dispose() {
    this._spriteMosaic.dispose(), this._glyphMosaic.dispose(), this._rasterizer.dispose(), this._sdfConverter.dispose(), this._spriteMosaic = null, this._glyphMosaic = null, this._sdfConverter = null, this._hashToBindingIndex.clear(), this._hashToBindingIndex = null, this._bindingInfos = null, this._ongoingRasterizations.clear(), this._ongoingRasterizations = null, this._imageRequestQueue.clear(), this._imageRequestQueue = null;
  }
  get sprites() {
    return this._spriteMosaic;
  }
  get glyphs() {
    return this._glyphMosaic;
  }
  async rasterizeItem(t11, e14, i6, s11) {
    if (null == t11)
      return Y2("mapview-null-resource", "Unable to rasterize null resource"), null;
    switch (t11.type) {
      case "text":
      case "esriTS": {
        const e15 = await this._rasterizeText(t11, i6, s11);
        return e15.forEach((t12) => this._setTextureBinding(_.GLYPH, t12)), { glyphMosaicItems: e15 };
      }
      default: {
        if (ue(t11))
          return Y2("mapview-invalid-type", `MapView does not support symbol type: ${t11.type}`, t11), null;
        const i7 = await this._rasterizeSpriteSymbol(t11, e14, s11);
        return e5(i7) && i7 && this._setTextureBinding(_.SPRITE, i7), { spriteMosaicItem: i7 };
      }
    }
  }
  bindTextures(t11, e14, i6, s11 = false) {
    if (0 === i6.textureBinding)
      return;
    const r14 = this._bindingInfos[i6.textureBinding - 1], o10 = r14.page, n13 = s11 ? L.LINEAR_MIPMAP_LINEAR : L.LINEAR;
    switch (r14.mosaicType) {
      case _.SPRITE: {
        const i7 = this.sprites.getWidth(o10), s12 = this.sprites.getHeight(o10), r15 = r3($, i7, s12);
        return this._spriteMosaic.bind(t11, n13, o10, B), e14.setUniform1i("u_texture", B), void e14.setUniform2fv("u_mosaicSize", r15);
      }
      case _.GLYPH: {
        const i7 = this.glyphs.width, s12 = this.glyphs.height, r15 = r3($, i7, s12);
        return this._glyphMosaic.bind(t11, n13, o10, C), e14.setUniform1i("u_texture", C), void e14.setUniform2fv("u_mosaicSize", r15);
      }
      default:
        H.error("mapview-texture-manager", `Cannot handle unknown type ${r14.mosaicType}`);
    }
  }
  _hashMosaic(t11, e14) {
    return 1 | t11 << 1 | (e14.sdf ? 1 : 0) << 2 | e14.page << 3;
  }
  _setTextureBinding(t11, e14) {
    const i6 = this._hashMosaic(t11, e14);
    if (!this._hashToBindingIndex.has(i6)) {
      const s11 = D2.fromMosaic(t11, e14), r14 = this._bindingInfos.length + 1;
      this._hashToBindingIndex.set(i6, r14), this._bindingInfos.push(s11);
    }
    e14.textureBinding = this._hashToBindingIndex.get(i6);
  }
  async _rasterizeText(t11, e14, s11) {
    let o10, n13;
    if ("cim" in t11) {
      const e15 = t11;
      o10 = e15.fontName, n13 = e15.text;
    } else {
      const e15 = t11;
      o10 = f2(e15.font), n13 = e15.text;
    }
    const a9 = this._invalidFontsMap.has(o10), h5 = e14 || de(i3(n13)[0]);
    try {
      const t12 = a9 ? k : o10;
      return has("esri-2d-stabilize-glyphs") && await this._glyphMosaic.preloadASCIIGlyphCache(t12), await this._glyphMosaic.getGlyphItems(t12, h5, s11);
    } catch (c12) {
      return Y2("mapview-invalid-resource", `Couldn't find font ${o10}. Falling back to Arial Unicode MS Regular`), this._invalidFontsMap.set(o10, true), this._glyphMosaic.getGlyphItems(k, h5, s11);
    }
  }
  async _rasterizeSpriteSymbol(t11, e14, i6) {
    if (le(t11))
      return;
    const r14 = e12(t11);
    if (this._spriteMosaic.has(r14))
      return this._spriteMosaic.getSpriteItem(r14);
    if (ne(t11) || re(t11) && !ye(t11))
      return this._handleAsyncResource(r14, t11, i6);
    const o10 = Ae, n13 = this._rasterizer.rasterizeJSONResource(t11, o10);
    if (n13) {
      const { size: e15, image: i7, sdf: s11, simplePattern: o11, rasterizationScale: a9 } = n13;
      return this._addItemToMosaic(r14, e15, { type: "static", data: i7 }, fe(t11), s11, o11, a9);
    }
    return new s3("TextureManager", "unrecognized or null rasterized image");
  }
  async _handleAsyncResource(t11, e14, i6) {
    if (this._ongoingRasterizations.has(t11))
      return this._ongoingRasterizations.get(t11);
    let s11;
    s11 = ne(e14) ? this._handleSVG(e14, t11, i6) : this._handleImage(e14, t11, i6), this._ongoingRasterizations.set(t11, s11);
    try {
      await s11, this._ongoingRasterizations.delete(t11);
    } catch {
      this._ongoingRasterizations.delete(t11);
    }
    return s11;
  }
  async _handleSVG(t11, e14, i6) {
    const s11 = [ce, ce], r14 = !("cim" in t11) || t11.cim.asFill, o10 = await this._sdfConverter.draw(t11.path, r14, i6);
    return this._addItemToMosaic(e14, s11, { type: "static", data: new Uint32Array(o10.buffer) }, false, true, true);
  }
  async _handleGIFOrPNG(t11, e14, i6) {
    const r14 = se(t11);
    await this.resourceManager.fetchResource(r14, i6);
    let o10 = this.resourceManager.getResource(r14);
    if (null == o10)
      return new s3("mapview-invalid-resource", `Could not fetch requested resource at ${r14}.`);
    let a9 = o10.width, h5 = o10.height;
    if (o10 instanceof HTMLImageElement) {
      "esriPMS" === t11.type && (a9 = Math.round(Q(o10.width, me(t11))), h5 = Math.round(o10.height * (a9 / o10.width)));
      const i7 = "cim" in t11 ? t11.cim.colorSubstitutions : void 0, { size: s11, sdf: r15, image: n13 } = this._rasterizer.rasterizeImageResource(a9, h5, o10, i7);
      return this._addItemToMosaic(e14, s11, { type: "static", data: n13 }, fe(t11), r15, false);
    }
    this._allowNonPowerOfTwo || (a9 = c2(o10.width + 2 * ae) - 2 * ae, h5 = c2(o10.height + 2 * ae) - 2 * ae), a9 === o10.width && h5 === o10.height || (o10 = _4(o10, a9, h5));
    const c12 = t11.animatedSymbolProperties || {}, u6 = t11.objectId, d8 = new a3(o10, this._requestRender, c12, u6);
    return this._addItemToMosaic(e14, [d8.width, d8.height], { type: "animated", data: d8 }, fe(t11), false, false);
  }
  async _handleImage(t11, e14, i6) {
    if (ie(t11) || oe(t11))
      return this._handleGIFOrPNG(t11, e14, i6);
    const r14 = se(t11);
    try {
      let s11;
      const o10 = this.resourceManager.getResource(r14);
      if (null != o10 && o10 instanceof HTMLImageElement)
        s11 = o10;
      else {
        const { data: t12 } = await this._imageRequestQueue.push(r14, { ...i6 });
        s11 = t12;
      }
      if (Pt(r14)) {
        if ("width" in t11 && "height" in t11) {
          const { width: e15, height: i7 } = V(t11.width, t11.height);
          s11.width = e15, s11.height = i7;
        } else if ("cim" in t11) {
          const e15 = t11.cim, { width: i7, height: r15 } = V(e15.width ?? e15.scaleX * e15.size, e15.size);
          s11.width = i7, s11.height = r15;
        }
      }
      if (!s11.width || !s11.height)
        return null;
      let n13 = s11.width, a9 = s11.height;
      "esriPMS" === t11.type && (n13 = Math.round(Q(s11.width, me(t11))), a9 = Math.round(s11.height * (n13 / s11.width)));
      const h5 = "cim" in t11 ? t11.cim.colorSubstitutions : void 0, { size: c12, sdf: d8, image: l8 } = this._rasterizer.rasterizeImageResource(n13, a9, s11, h5);
      return this._addItemToMosaic(e14, c12, { type: "static", data: l8 }, fe(t11), d8, false);
    } catch (Y3) {
      if (!b(Y3))
        return new s3("mapview-invalid-resource", `Could not fetch requested resource at ${r14}. ${Y3.message}`);
    }
  }
  _addItemToMosaic(t11, e14, i6, s11, r14, o10, n13) {
    return this._spriteMosaic.addSpriteItem(t11, e14, i6, s11, r14, o10, n13);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/StencilPrograms.js
var r7 = { shaders: { vertexShader: n6("stencil/stencil.vert"), fragmentShader: n6("stencil/stencil.frag") }, attributes: /* @__PURE__ */ new Map([["a_pos", 0]]) };

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/BlendPrograms.js
var r8 = (e14) => e14.replace("-", "_").toUpperCase();
var t6 = (e14) => `#define ${r8(e14)}
`;
function n10(r14) {
  return { attributes: /* @__PURE__ */ new Map([["a_pos", 0], ["a_tex", 1]]), shaders: { vertexShader: t6(r14) + n6("blend/blend.vert"), fragmentShader: t6(r14) + n6("blend/blend.frag") } };
}

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/BlendEffect.js
var c8 = s2.getLogger("esri.views.2d.engine.webgl.effects.blendEffects.BlendEffect");
var m3 = class {
  constructor() {
    this._size = [0, 0];
  }
  dispose(e14) {
    this._backBufferTexture = r(this._backBufferTexture), this._quad = r(this._quad);
  }
  draw(r14, t11, i6, a9, d8) {
    const { context: u6, drawPhase: f4 } = r14;
    if (this._setupShader(u6), a9 && "normal" !== a9 && f4 !== T.LABEL)
      return void this._drawBlended(r14, t11, i6, a9, d8);
    const m4 = n10("normal"), h5 = u6.programCache.acquire(m4.shaders.vertexShader, m4.shaders.fragmentShader, m4.attributes);
    if (!h5)
      return void c8.error(new s3("mapview-BlendEffect", 'Error creating shader program for blend mode "normal"'));
    u6.useProgram(h5), t11.setSamplingMode(i6), u6.bindTexture(t11, 0), h5.setUniform1i("u_layerTexture", 0), h5.setUniform1f("u_opacity", d8), u6.setBlendingEnabled(true), u6.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA);
    const l8 = this._quad;
    l8.draw(), l8.unbind(), h5.dispose();
  }
  _drawBlended(r14, t11, s11, i6, a9) {
    const { context: d8, state: u6, pixelRatio: f4, inFadeTransition: m4 } = r14, { size: h5 } = u6, l8 = d8.getBoundFramebufferObject();
    let _7, p5;
    null != l8 ? (_7 = l8.width, p5 = l8.height) : (_7 = Math.round(f4 * h5[0]), p5 = Math.round(f4 * h5[1])), this._createOrResizeTexture(r14, _7, p5);
    const b2 = this._backBufferTexture;
    l8.copyToTexture(0, 0, _7, p5, 0, 0, b2), d8.setStencilTestEnabled(false), d8.setStencilWriteMask(0), d8.setBlendingEnabled(true), d8.setDepthTestEnabled(false), d8.setDepthWriteEnabled(false);
    const g7 = n10(i6), x2 = d8.programCache.acquire(g7.shaders.vertexShader, g7.shaders.fragmentShader, g7.attributes);
    if (!x2)
      return void c8.error(new s3("mapview-BlendEffect", `Error creating shader program for blend mode ${i6}`));
    d8.useProgram(x2), b2.setSamplingMode(s11), d8.bindTexture(b2, 0), x2.setUniform1i("u_backbufferTexture", 0), t11.setSamplingMode(s11), d8.bindTexture(t11, 1), x2.setUniform1i("u_layerTexture", 1), x2.setUniform1f("u_opacity", a9), x2.setUniform1f("u_inFadeOpacity", m4 ? 1 : 0), d8.setBlendFunction(R.ONE, R.ZERO);
    const T5 = this._quad;
    T5.draw(), T5.unbind(), x2.dispose(), d8.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA);
  }
  _setupShader(e14) {
    this._quad || (this._quad = new n5(e14, [-1, -1, 1, -1, -1, 1, 1, 1]));
  }
  _createOrResizeTexture(e14, r14, t11) {
    const { context: s11 } = e14;
    if (null === this._backBufferTexture || r14 !== this._size[0] || t11 !== this._size[1]) {
      if (this._backBufferTexture)
        this._backBufferTexture.resize(r14, t11);
      else {
        const e15 = new e6();
        e15.internalFormat = G.RGBA, e15.wrapMode = D.CLAMP_TO_EDGE, e15.width = r14, e15.height = t11, this._backBufferTexture = new T2(s11, e15);
      }
      this._size[0] = r14, this._size[1] = t11;
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/HighlightPrograms.js
var t7 = { shaders: { vertexShader: n6("highlight/textured.vert"), fragmentShader: n6("highlight/highlight.frag") }, attributes: /* @__PURE__ */ new Map([["a_position", 0], ["a_texcoord", 1]]) };
var r9 = { shaders: { vertexShader: n6("highlight/textured.vert"), fragmentShader: n6("highlight/blur.frag") }, attributes: /* @__PURE__ */ new Map([["a_position", 0], ["a_texcoord", 1]]) };

// node_modules/@arcgis/core/views/2d/engine/webgl/Profiler.js
var r10 = has("esri-2d-profiler");
var n11 = class {
  constructor(n13, i6) {
    if (this._events = new o(), this._entries = /* @__PURE__ */ new Map(), this._timings = new t2(10), this._currentContainer = null, this._currentPass = null, this._currentBrush = null, this._currentSummary = null, !r10)
      return;
    this._ext = T3(n13.gl, {}), this._debugOutput = i6;
    const o10 = n13.gl;
    if (!this.enableCommandLogging)
      return;
    let a9;
    for (a9 in o10)
      if ("function" == typeof o10[a9]) {
        const e14 = o10[a9], t11 = a9.includes("draw");
        o10[a9] = (...s11) => (this._events.emit("command", { container: this._currentContainer, pass: this._currentPass, brush: this._currentBrush, method: a9, args: s11, isDrawCommand: t11 }), this._currentSummary && (this._currentSummary.commands++, t11 && this._currentSummary.drawCommands++), e14.apply(o10, s11));
      }
  }
  get enableCommandLogging() {
    return !("object" == typeof r10 && r10.disableCommands);
  }
  recordContainerStart(e14) {
    r10 && (this._currentContainer = e14);
  }
  recordContainerEnd() {
    r10 && (this._currentContainer = null);
  }
  recordPassStart(e14) {
    r10 && (this._currentPass = e14, this._initSummary());
  }
  recordPassEnd() {
    r10 && (this._currentPass = null, this._emitSummary());
  }
  recordBrushStart(e14) {
    r10 && (this._currentBrush = e14);
  }
  recordBrushEnd() {
    r10 && (this._currentBrush = null);
  }
  recordStart(e14) {
    if (r10 && null != this._ext) {
      if (this._entries.has(e14)) {
        const t12 = this._entries.get(e14), s11 = this._ext.resultAvailable(t12.query), r14 = this._ext.disjoint();
        if (s11 && !r14) {
          const s12 = this._ext.getResult(t12.query) / 1e6;
          let r15 = 0;
          if (null != this._timings.enqueue(s12)) {
            const e15 = this._timings.entries, t13 = e15.length;
            let s13 = 0;
            for (const r16 of e15)
              s13 += r16;
            r15 = s13 / t13;
          }
          const n13 = s12.toFixed(2), i6 = r15 ? r15.toFixed(2) : "--";
          this.enableCommandLogging ? (console.groupCollapsed(`Frame report for ${e14}, ${n13} ms (${i6} last 10 avg)
${t12.commandsLen} Commands (${t12.drawCommands} draw)`), console.log("RenderPass breakdown: "), console.table(t12.summaries), console.log("Commands: ", t12.commands), console.groupEnd()) : console.log(`Frame report for ${e14}, ${n13} ms (${i6} last 10 avg)`), this._debugOutput.innerHTML = `${n13} (${i6})`;
        }
        for (const e15 of t12.handles)
          e15.remove();
        this._ext.deleteQuery(t12.query), this._entries.delete(e14);
      }
      const t11 = { name: e14, query: this._ext.createQuery(), commands: [], commandsLen: 0, drawCommands: 0, summaries: [], handles: [] };
      this.enableCommandLogging && (t11.handles.push(this._events.on("command", (e15) => {
        t11.commandsLen++, t11.commands.push(e15), e15.isDrawCommand && t11.drawCommands++;
      })), t11.handles.push(this._events.on("summary", (e15) => {
        t11.summaries.push(e15);
      }))), this._ext.beginTimeElapsed(t11.query), this._entries.set(e14, t11);
    }
  }
  recordEnd(e14) {
    r10 && null != this._ext && this._entries.has(e14) && this._ext.endTimeElapsed();
  }
  _initSummary() {
    this.enableCommandLogging && (this._currentSummary = { container: this._currentContainer, pass: this._currentPass, drawCommands: 0, commands: 0 });
  }
  _emitSummary() {
    this.enableCommandLogging && this._currentSummary && this._events.emit("summary", this._currentSummary);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/collisions/CollisionGrid.js
var e13 = 2;
var i5 = 1;
var o9 = 0;
var h2 = 1;
var r11 = 2;
var l4 = class {
  constructor(t11, e14, o10) {
    this._debugMap = /* @__PURE__ */ new Map(), this._width = t11 * o10, this._height = e14 * o10, this._pixelRatio = o10;
    const h5 = Math.ceil(this._width / i5), r14 = Math.ceil(this._height / i5);
    this._cols = h5, this._rows = r14, this._cells = t3.create(h5 * r14);
  }
  insertMetrics(t11) {
    const s11 = this._hasCollision(t11);
    return s11 === o9 && this._markMetrics(t11), s11;
  }
  getCellId(t11, s11) {
    return t11 + s11 * this._cols;
  }
  has(t11) {
    return this._cells.has(t11);
  }
  hasRange(t11, s11) {
    return this._cells.hasRange(t11, s11);
  }
  set(t11) {
    this._cells.set(t11);
  }
  setRange(t11, s11) {
    this._cells.setRange(t11, s11);
  }
  _collide(s11, e14, l8, n13) {
    const c12 = s11 - l8 / 2, a9 = e14 - n13 / 2, _7 = c12 + l8, d8 = a9 + n13;
    if (_7 < 0 || d8 < 0 || c12 > this._width || a9 > this._height)
      return h2;
    const u6 = i(Math.floor(c12 / i5), 0, this._cols), p5 = i(Math.floor(a9 / i5), 0, this._rows), M = i(Math.ceil(_7 / i5), 0, this._cols), f4 = i(Math.ceil(d8 / i5), 0, this._rows);
    for (let t11 = p5; t11 <= f4; t11++)
      for (let s12 = u6; s12 <= M; s12++) {
        const e15 = this.getCellId(s12, t11);
        if (this.has(e15))
          return r11;
      }
    return o9;
  }
  _mark(s11, e14, o10, h5, r14) {
    const l8 = s11 - o10 / 2, n13 = e14 - h5 / 2, c12 = l8 + o10, a9 = n13 + h5, _7 = i(Math.floor(l8 / i5), 0, this._cols), d8 = i(Math.floor(n13 / i5), 0, this._rows), u6 = i(Math.ceil(c12 / i5), 0, this._cols), p5 = i(Math.ceil(a9 / i5), 0, this._rows);
    for (let t11 = d8; t11 <= p5; t11++)
      for (let s12 = _7; s12 <= u6; s12++) {
        const e15 = this.getCellId(s12, t11);
        this._debugMap.set(e15, r14), this.set(e15);
      }
    return false;
  }
  _hasCollision(t11) {
    const s11 = t11.id;
    let i6 = 0, l8 = 0;
    t11.save();
    do {
      const s12 = t11.boundsCount;
      i6 += s12;
      for (let i7 = 0; i7 < s12; i7++) {
        const s13 = t11.boundsComputedAnchorX(i7), o10 = t11.boundsComputedAnchorY(i7), n13 = (t11.boundsWidth(i7) + e13) * this._pixelRatio, c12 = (t11.boundsHeight(i7) + e13) * this._pixelRatio;
        switch (this._collide(s13, o10, n13, c12)) {
          case r11:
            return r11;
          case h2:
            l8++;
        }
      }
    } while (t11.peekId() === s11 && t11.next());
    return t11.restore(), i6 === l8 ? h2 : o9;
  }
  _markMetrics(t11) {
    const s11 = t11.id;
    t11.save();
    do {
      const s12 = t11.boundsCount;
      for (let i6 = 0; i6 < s12; i6++) {
        const s13 = t11.boundsComputedAnchorX(i6), o10 = t11.boundsComputedAnchorY(i6), h5 = (t11.boundsWidth(i6) + e13) * this._pixelRatio, r14 = (t11.boundsHeight(i6) + e13) * this._pixelRatio;
        this._mark(s13, o10, h5, r14, t11.id);
      }
    } while (t11.peekId() === s11 && t11.next());
    t11.restore();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/collisions/CollisionEngine.js
var r12 = 254;
var l5 = 255;
var a4 = 0;
function d3(e14, i6) {
  const t11 = [];
  e14.forEachTile((e15) => t11.push(e15)), t11.sort((e15, i7) => e15.instanceId - i7.instanceId), t11.forEach((e15) => {
    null != e15.labelMetrics && e15.isReady && i6(e15, e15.labelMetrics.getCursor());
  });
}
var c9 = class {
  run(e14, i6, t11) {
    const o10 = [];
    for (let s11 = e14.length - 1; s11 >= 0; s11--) {
      const i7 = e14[s11];
      i7.labelingCollisionInfos && o10.push(...i7.labelingCollisionInfos);
    }
    this._transformMetrics(o10), this._runCollision(o10, i6, t11);
  }
  _runCollision(e14, i6, o10) {
    const [s11, n13] = i6.state.size, r14 = new l4(s11, n13, i6.pixelRatio);
    for (const { tileRenderer: t11, deconflictionEnabled: c12, visible: f4 } of e14) {
      const e15 = t11.featuresView.attributeView;
      c12 ? f4 ? (this._prepare(t11), this._collideVisible(r14, t11, o10), this._collideInvisible(r14, t11)) : d3(t11, (i7, t12) => {
        for (; t12.nextId(); )
          e15.setLabelMinZoom(t12.id, l5);
      }) : d3(t11, (i7, t12) => {
        for (; t12.nextId(); )
          e15.setLabelMinZoom(t12.id, a4), f4 && r14.insertMetrics(t12);
      });
    }
  }
  _isFiltered(t11, o10, s11) {
    const n13 = o10.getFilterFlags(t11), r14 = !s11.hasFilter || !!(n13 & X), l8 = null == s11.featureEffect || s11.featureEffect.excludedLabelsVisible || !!(n13 & Y);
    return !(r14 && l8);
  }
  _prepare(e14) {
    const i6 = e14.featuresView.attributeView, t11 = /* @__PURE__ */ new Set();
    d3(e14, (o10, s11) => {
      for (; s11.nextId(); ) {
        if (t11.has(s11.id))
          continue;
        if (t11.add(s11.id), this._isFiltered(s11.id, i6, e14.layerView)) {
          i6.setLabelMinZoom(s11.id, r12);
          continue;
        }
        i6.getLabelMinZoom(s11.id) !== a4 ? i6.setLabelMinZoom(s11.id, l5) : i6.setLabelMinZoom(s11.id, a4);
      }
    });
  }
  _collideVisible(e14, i6, t11) {
    const l8 = i6.featuresView.attributeView, c12 = /* @__PURE__ */ new Set();
    d3(i6, (i7, d8) => {
      for (; d8.nextId(); )
        if (!c12.has(d8.id))
          if (i7.key.level === t11) {
            if (0 === l8.getLabelMinZoom(d8.id)) {
              switch (e14.insertMetrics(d8)) {
                case h2:
                  break;
                case r11:
                  l8.setLabelMinZoom(d8.id, r12), c12.add(d8.id);
                  break;
                case o9:
                  l8.setLabelMinZoom(d8.id, a4), c12.add(d8.id);
              }
            }
          } else
            l8.setLabelMinZoom(d8.id, r12);
    });
  }
  _collideInvisible(e14, i6) {
    const t11 = i6.featuresView.attributeView, r14 = /* @__PURE__ */ new Set();
    d3(i6, (i7, d8) => {
      for (; d8.nextId(); )
        if (!r14.has(d8.id) && t11.getLabelMinZoom(d8.id) === l5) {
          switch (e14.insertMetrics(d8)) {
            case h2:
              break;
            case r11:
              t11.setLabelMinZoom(d8.id, l5), r14.add(d8.id);
              break;
            case o9:
              t11.setLabelMinZoom(d8.id, a4), r14.add(d8.id);
          }
        }
    });
  }
  _transformMetrics(e14) {
    for (const { tileRenderer: i6, geometryType: t11, vvEvaluators: o10 } of e14)
      d3(i6, (e15, s11) => {
        const n13 = i6.featuresView.attributeView, r14 = e15.transforms.labelMat2d;
        r14[4] = Math.round(r14[4]), r14[5] = Math.round(r14[5]);
        const l8 = "polyline" === t11;
        for (; s11.next(); ) {
          const e16 = s11.boundsCount, i7 = s11.anchorX, t12 = s11.anchorY;
          let a9 = s11.size;
          const d8 = o10[0];
          if (null != d8) {
            const e17 = d8(n13.getVVSize(s11.id));
            a9 = isNaN(e17) || null == e17 || e17 === 1 / 0 ? a9 : e17;
          }
          const c12 = s11.directionX * (a9 / 2), f4 = s11.directionY * (a9 / 2);
          for (let o11 = 0; o11 < e16; o11++) {
            let e17 = i7, n14 = s11.anchorY;
            if (l8) {
              let i8 = e17 + s11.boundsX(o11) + c12, t13 = n14 + s11.boundsY(o11) + f4;
              i8 = r14[0] * i8 + r14[2] * t13 + r14[4], t13 = r14[1] * i8 + r14[3] * t13 + r14[5], s11.setBoundsComputedAnchorX(o11, Math.floor(i8)), s11.setBoundsComputedAnchorY(o11, Math.floor(t13));
            } else {
              e17 = r14[0] * i7 + r14[2] * t12 + r14[4], n14 = r14[1] * i7 + r14[3] * t12 + r14[5];
              const l9 = e17 + s11.boundsX(o11) + c12, a10 = n14 + s11.boundsY(o11) + f4;
              s11.setBoundsComputedAnchorX(o11, l9), s11.setBoundsComputedAnchorY(o11, a10);
            }
          }
        }
      });
  }
};

// node_modules/@arcgis/core/views/2d/LabelManager.js
var p4 = 32;
var a5 = class extends g {
  constructor(e14) {
    super(e14), this.collisionEngine = new c9(), this.lastUpdateId = -1, this.updateRequested = false, this.view = null, this._applyVisibilityPass = e7((e15) => {
      const t11 = this.view;
      if (t11)
        try {
          const s11 = t11.featuresTilingScheme.getClosestInfoForScale(e15.state.scale).level;
          this.collisionEngine.run(t11.allLayerViews.items, e15, s11);
        } catch (s11) {
        }
    }, p4, this), this.addHandles(this._applyVisibilityPass);
  }
  get updating() {
    return has("esri-2d-log-updating") && console.log(`Updating LabelManager ${this.updateRequested}:
-> updateRequested: ${this.updateRequested}`), this.updateRequested;
  }
  update(e14) {
    this._applyVisibilityPass(e14);
  }
  viewChange() {
    this.requestUpdate();
  }
  requestUpdate() {
    var _a;
    this.updateRequested || (this.updateRequested = true, (_a = this.view) == null ? void 0 : _a.requestUpdate());
  }
  processUpdate(e14) {
    this.updateRequested && (this.updateRequested = false, this.update(e14));
  }
};
e([y()], a5.prototype, "updateRequested", void 0), e([y()], a5.prototype, "updating", null), e([y()], a5.prototype, "view", void 0), a5 = e([c("esri.views.2d.LabelManager")], a5);

// node_modules/@arcgis/core/views/2d/navigation/ZoomBox.js
var a6 = "esri-zoom-box";
var n12 = { container: `${a6}__container`, overlay: `${a6}__overlay`, background: `${a6}__overlay-background`, box: `${a6}__outline` };
var h3 = { zoom: "Shift", counter: "Ctrl" };
var l6 = class extends g {
  constructor(t11) {
    super(t11), this._container = null, this._overlay = null, this._backgroundShape = null, this._boxShape = null, this._box = { x: 0, y: 0, width: 0, height: 0 }, this._rafId = null, this._redraw = this._redraw.bind(this);
  }
  destroy() {
    this.view = null;
  }
  set view(t11) {
    this.removeAllHandles(), this._destroyOverlay(), this._set("view", t11), t11 && this.addHandles([t11.on("drag", [h3.zoom], (t12) => this._handleDrag(t12, 1), _3.INTERNAL), t11.on("drag", [h3.zoom, h3.counter], (t12) => this._handleDrag(t12, -1), _3.INTERNAL)]);
  }
  _start() {
    this._createContainer(), this._createOverlay(), this.navigation.begin();
  }
  _update(t11, e14, r14, i6) {
    this._box.x = t11, this._box.y = e14, this._box.width = r14, this._box.height = i6, this._rafId || (this._rafId = requestAnimationFrame(this._redraw));
  }
  _end(t11, e14, i6, s11, o10) {
    const a9 = this.view, n13 = a9.toMap(c3(t11 + 0.5 * i6, e14 + 0.5 * s11));
    let h5 = Math.max(i6 / a9.width, s11 / a9.height);
    -1 === o10 && (h5 = 1 / h5), this._destroyOverlay(), this.navigation.end(), a9.goTo({ center: n13, scale: a9.scale * h5 });
  }
  _updateBox(t11, e14, r14, i6) {
    const s11 = this._boxShape;
    s11.setAttributeNS(null, "x", "" + t11), s11.setAttributeNS(null, "y", "" + e14), s11.setAttributeNS(null, "width", "" + r14), s11.setAttributeNS(null, "height", "" + i6), s11.setAttributeNS(null, "class", n12.box);
  }
  _updateBackground(t11, e14, r14, i6) {
    this._backgroundShape.setAttributeNS(null, "d", this._toSVGPath(t11, e14, r14, i6, this.view.width, this.view.height));
  }
  _createContainer() {
    const t11 = document.createElement("div");
    t11.className = n12.container, this.view.root.appendChild(t11), this._container = t11;
  }
  _createOverlay() {
    const t11 = this.view.width, e14 = this.view.height, r14 = document.createElementNS("http://www.w3.org/2000/svg", "path");
    r14.setAttributeNS(null, "d", "M 0 0 L " + t11 + " 0 L " + t11 + " " + e14 + " L 0 " + e14 + " Z"), r14.setAttributeNS(null, "class", n12.background);
    const i6 = document.createElementNS("http://www.w3.org/2000/svg", "rect"), s11 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    s11.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink"), s11.setAttributeNS(null, "class", n12.overlay), s11.appendChild(r14), s11.appendChild(i6), this._container.appendChild(s11), this._backgroundShape = r14, this._boxShape = i6, this._overlay = s11;
  }
  _destroyOverlay() {
    this._container && this._container.parentNode && this._container.parentNode.removeChild(this._container), this._container = this._backgroundShape = this._boxShape = this._overlay = null;
  }
  _toSVGPath(t11, e14, r14, i6, s11, o10) {
    const a9 = t11 + r14, n13 = e14 + i6;
    return "M 0 0 L " + s11 + " 0 L " + s11 + " " + o10 + " L 0 " + o10 + " ZM " + t11 + " " + e14 + " L " + t11 + " " + n13 + " L " + a9 + " " + n13 + " L " + a9 + " " + e14 + " Z";
  }
  _handleDrag(t11, e14) {
    const r14 = t11.x, i6 = t11.y, s11 = t11.origin.x, o10 = t11.origin.y;
    let a9, n13, h5, l8;
    switch (r14 > s11 ? (a9 = s11, h5 = r14 - s11) : (a9 = r14, h5 = s11 - r14), i6 > o10 ? (n13 = o10, l8 = i6 - o10) : (n13 = i6, l8 = o10 - i6), t11.action) {
      case "start":
        this._start();
        break;
      case "update":
        this._update(a9, n13, h5, l8);
        break;
      case "end":
        this._end(a9, n13, h5, l8, e14);
    }
    t11.stopPropagation();
  }
  _redraw() {
    if (!this._rafId)
      return;
    if (this._rafId = null, !this._overlay)
      return;
    const { x: t11, y: e14, width: r14, height: i6 } = this._box;
    this._updateBox(t11, e14, r14, i6), this._updateBackground(t11, e14, r14, i6), this._rafId = requestAnimationFrame(this._redraw);
  }
};
e([y()], l6.prototype, "navigation", void 0), e([y()], l6.prototype, "view", null), l6 = e([c("esri.views.2d.navigation.ZoomBox")], l6);
var c10 = l6;

// node_modules/@arcgis/core/views/navigation/FilteredFiniteDifference.js
var t8 = class {
  constructor(t11) {
    this._gain = t11, this.lastValue = void 0, this.filteredDelta = void 0;
  }
  update(t11) {
    if (this.hasLastValue()) {
      const e14 = this.computeDelta(t11);
      this._updateDelta(e14);
    }
    this.lastValue = t11;
  }
  reset() {
    this.lastValue = void 0, this.filteredDelta = void 0;
  }
  hasLastValue() {
    return void 0 !== this.lastValue;
  }
  hasFilteredDelta() {
    return void 0 !== this.filteredDelta;
  }
  computeDelta(t11) {
    return void 0 === this.lastValue ? NaN : t11 - this.lastValue;
  }
  _updateDelta(t11) {
    void 0 !== this.filteredDelta ? this.filteredDelta = (1 - this._gain) * this.filteredDelta + this._gain * t11 : this.filteredDelta = t11;
  }
};

// node_modules/@arcgis/core/views/navigation/Momentum.js
var t9 = class {
  constructor(t11, i6, o10) {
    this._initialVelocity = t11, this._stopVelocity = i6, this._friction = o10, this._duration = Math.abs(Math.log(Math.abs(this._initialVelocity) / this._stopVelocity) / Math.log(1 - this._friction));
  }
  get duration() {
    return this._duration;
  }
  isFinished(t11) {
    return t11 > this.duration;
  }
  get friction() {
    return this._friction;
  }
  value(t11) {
    return this.valueFromInitialVelocity(this._initialVelocity, t11);
  }
  valueDelta(t11, i6) {
    const o10 = this.value(t11);
    return this.value(t11 + i6) - o10;
  }
  valueFromInitialVelocity(t11, i6) {
    i6 = Math.min(i6, this.duration);
    const o10 = 1 - this.friction;
    return t11 * (o10 ** i6 - 1) / Math.log(o10);
  }
};

// node_modules/@arcgis/core/views/navigation/PanPlanarMomentumEstimator.js
var c11 = class extends t9 {
  constructor(e14, t11, i6, s11, n13) {
    super(e14, t11, i6), this._sceneVelocity = s11, this.direction = n13;
  }
  value(e14) {
    return super.valueFromInitialVelocity(this._sceneVelocity, e14);
  }
};
var l7 = class {
  constructor(e14 = 300, t11 = 12, i6 = 0.84) {
    this._minimumInitialVelocity = e14, this._stopVelocity = t11, this._friction = i6, this.enabled = true, this._time = new t8(0.6), this._screen = [new t8(0.4), new t8(0.4)], this._scene = [new t8(0.6), new t8(0.6), new t8(0.6)], this._tmpDirection = n2();
  }
  add(e14, t11, i6) {
    if (this.enabled) {
      if (this._time.hasLastValue()) {
        if (this._time.computeDelta(i6) < 0.015)
          return;
      }
      this._screen[0].update(e14[0]), this._screen[1].update(e14[1]), this._scene[0].update(t11[0]), this._scene[1].update(t11[1]), this._scene[2].update(t11[2]), this._time.update(i6);
    }
  }
  reset() {
    this._screen[0].reset(), this._screen[1].reset(), this._scene[0].reset(), this._scene[1].reset(), this._scene[2].reset(), this._time.reset();
  }
  evaluateMomentum() {
    if (!this.enabled || !this._screen[0].hasFilteredDelta() || !this._time.hasFilteredDelta())
      return null;
    const e14 = this._screen[0].filteredDelta, t11 = this._screen[1].filteredDelta, i6 = null == e14 || null == t11 ? 0 : Math.sqrt(e14 * e14 + t11 * t11), s11 = this._time.filteredDelta, n13 = null == s11 || null == i6 ? 0 : i6 / s11;
    return Math.abs(n13) < this._minimumInitialVelocity ? null : this.createMomentum(n13, this._stopVelocity, this._friction);
  }
  createMomentum(s11, n13, r14) {
    o2(this._tmpDirection, this._scene[0].filteredDelta ?? 0, this._scene[1].filteredDelta ?? 0, this._scene[2].filteredDelta ?? 0);
    const l8 = s5(this._tmpDirection);
    l8 > 0 && g2(this._tmpDirection, this._tmpDirection, 1 / l8);
    const h5 = this._time.filteredDelta;
    return new c11(s11, n13, r14, null == h5 ? 0 : l8 / h5, this._tmpDirection);
  }
};

// node_modules/@arcgis/core/views/2d/navigation/actions/Pan.js
var v = class extends g {
  constructor(t11) {
    super(t11), this.animationTime = 0, this.momentumEstimator = new l7(500, 6, 0.92), this.momentum = null, this.tmpMomentum = n2(), this.momentumFinished = false, this.viewpoint = new l({ targetGeometry: new x(), scale: 0, rotation: 0 }), this._previousDrag = null, p(() => this.momentumFinished, () => this.navigation.stop());
  }
  begin(t11, i6) {
    this.navigation.begin(), this.momentumEstimator.reset(), this.addToEstimator(i6), this._previousDrag = i6;
  }
  update(t11, i6) {
    this.addToEstimator(i6);
    let o10 = i6.center.x, s11 = i6.center.y;
    const e14 = this._previousDrag;
    o10 = e14 ? e14.center.x - o10 : -o10, s11 = e14 ? s11 - e14.center.y : s11, t11.viewpoint = At(this.viewpoint, t11.viewpoint, [o10 || 0, s11 || 0]), this._previousDrag = i6;
  }
  end(t11, i6) {
    this.addToEstimator(i6);
    const o10 = t11.navigation.momentumEnabled;
    this.momentum = o10 ? this.momentumEstimator.evaluateMomentum() : null, this.animationTime = 0, this.momentum && this.onAnimationUpdate(t11), this._previousDrag = null, this.navigation.end();
  }
  addToEstimator(t11) {
    const i6 = t11.center.x, o10 = t11.center.y, s11 = i2(-i6, o10), m4 = r2(-i6, o10, 0);
    this.momentumEstimator.add(s11, m4, 1e-3 * t11.timestamp);
  }
  onAnimationUpdate(t11) {
    var _a;
    (_a = this.navigation.animationManager) == null ? void 0 : _a.animateContinous(t11.viewpoint, (i6, o10) => {
      const { momentum: s11, animationTime: e14, tmpMomentum: m4 } = this, n13 = 1e-3 * o10;
      if (!(this.momentumFinished = !s11 || s11.isFinished(e14))) {
        const o11 = s11.valueDelta(e14, n13);
        g2(m4, s11.direction, o11), At(i6, i6, m4), t11.constraints.constrainByGeometry(i6);
      }
      this.animationTime += n13;
    });
  }
  stopMomentumNavigation() {
    this.momentum && (this.momentumEstimator.reset(), this.momentum = null, this.navigation.stop());
  }
};
e([y()], v.prototype, "momentumFinished", void 0), e([y()], v.prototype, "viewpoint", void 0), e([y()], v.prototype, "navigation", void 0), v = e([c("esri.views.2d.navigation.actions.Pan")], v);
var d4 = v;

// node_modules/@arcgis/core/views/navigation/MomentumEstimator.js
var s9 = class {
  constructor(t11 = 2.5, i6 = 0.01, s11 = 0.95, l8 = 12) {
    this._minimumInitialVelocity = t11, this._stopVelocity = i6, this._friction = s11, this._maxVelocity = l8, this.enabled = true, this.value = new t8(0.8), this.time = new t8(0.3);
  }
  add(t11, e14) {
    if (this.enabled && null != e14) {
      if (this.time.hasLastValue()) {
        if (this.time.computeDelta(e14) < 0.01)
          return;
        if (this.value.hasFilteredDelta()) {
          const e15 = this.value.computeDelta(t11);
          this.value.filteredDelta * e15 < 0 && this.value.reset();
        }
      }
      this.time.update(e14), this.value.update(t11);
    }
  }
  reset() {
    this.value.reset(), this.time.reset();
  }
  evaluateMomentum() {
    if (!this.enabled || !this.value.hasFilteredDelta() || !this.time.hasFilteredDelta())
      return null;
    let e14 = this.value.filteredDelta / this.time.filteredDelta;
    return e14 = i(e14, -this._maxVelocity, this._maxVelocity), Math.abs(e14) < this._minimumInitialVelocity ? null : this.createMomentum(e14, this._stopVelocity, this._friction);
  }
  createMomentum(t11, e14, s11) {
    return new t9(t11, e14, s11);
  }
};

// node_modules/@arcgis/core/views/navigation/RotationMomentumEstimator.js
var a7 = class extends s9 {
  constructor(t11 = 3, a9 = 0.01, s11 = 0.95, o10 = 12) {
    super(t11, a9, s11, o10);
  }
  add(t11, a9) {
    const s11 = this.value.lastValue;
    if (null != s11) {
      let a10 = t11 - s11;
      for (; a10 > Math.PI; )
        a10 -= 2 * Math.PI;
      for (; a10 < -Math.PI; )
        a10 += 2 * Math.PI;
      t11 = s11 + a10;
    }
    super.add(t11, a9);
  }
};

// node_modules/@arcgis/core/views/navigation/ZoomMomentumEstimator.js
var r13 = class extends t9 {
  constructor(e14, t11, r14) {
    super(e14, t11, r14);
  }
  value(e14) {
    const t11 = super.value(e14);
    return Math.exp(t11);
  }
  valueDelta(e14, t11) {
    const r14 = super.value(e14), s11 = super.value(e14 + t11) - r14;
    return Math.exp(s11);
  }
};
var s10 = class extends s9 {
  constructor(e14 = 2.5, t11 = 0.01, r14 = 0.95, s11 = 12) {
    super(e14, t11, r14, s11);
  }
  add(e14, t11) {
    super.add(Math.log(e14), t11);
  }
  createMomentum(e14, t11, s11) {
    return new r13(e14, t11, s11);
  }
};

// node_modules/@arcgis/core/views/2d/navigation/actions/Pinch.js
var _5 = class extends g {
  constructor(t11) {
    super(t11), this._animationTime = 0, this._momentumFinished = false, this._previousAngle = 0, this._previousRadius = 0, this._previousCenter = null, this._rotationMomentumEstimator = new a7(0.6, 0.15, 0.95), this._rotationDirection = 1, this._startAngle = 0, this._startRadius = 0, this._updateTimestamp = null, this._zoomDirection = 1, this._zoomMomentumEstimator = new s10(), this._zoomOnly = null, this.zoomMomentum = null, this.rotateMomentum = null, this.viewpoint = new l({ targetGeometry: new x(), scale: 0, rotation: 0 }), this.addHandles(p(() => this._momentumFinished, () => this.navigation.stop()));
  }
  begin(t11, o10) {
    this.navigation.begin(), this._rotationMomentumEstimator.reset(), this._zoomMomentumEstimator.reset(), this._zoomOnly = null, this._previousAngle = this._startAngle = o10.angle, this._previousRadius = this._startRadius = o10.radius, this._previousCenter = o10.center, this._updateTimestamp = null, t11.constraints.rotationEnabled && this.addToRotateEstimator(0, o10.timestamp), this.addToZoomEstimator(o10, 1);
  }
  update(t11, o10) {
    null === this._updateTimestamp && (this._updateTimestamp = o10.timestamp);
    const i6 = o10.angle, s11 = o10.radius, e14 = o10.center, n13 = Math.abs(180 * (i6 - this._startAngle) / Math.PI), m4 = Math.abs(s11 - this._startRadius), a9 = this._startRadius / s11;
    if (this._previousRadius && this._previousCenter) {
      const r14 = s11 / this._previousRadius;
      let h5 = 180 * (i6 - this._previousAngle) / Math.PI;
      this._rotationDirection = h5 >= 0 ? 1 : -1, this._zoomDirection = r14 >= 1 ? 1 : -1, t11.constraints.rotationEnabled ? (null === this._zoomOnly && o10.timestamp - this._updateTimestamp > 200 && (this._zoomOnly = m4 - n13 > 0), null === this._zoomOnly || this._zoomOnly ? h5 = 0 : this.addToRotateEstimator(i6 - this._startAngle, o10.timestamp)) : h5 = 0, this.addToZoomEstimator(o10, a9), this.navigation.setViewpoint([e14.x, e14.y], 1 / r14, h5, [this._previousCenter.x - e14.x, e14.y - this._previousCenter.y]);
    }
    this._previousAngle = i6, this._previousRadius = s11, this._previousCenter = e14;
  }
  end(t11) {
    this.rotateMomentum = this._rotationMomentumEstimator.evaluateMomentum(), this.zoomMomentum = this._zoomMomentumEstimator.evaluateMomentum(), this._animationTime = 0, (this.rotateMomentum || this.zoomMomentum) && this.onAnimationUpdate(t11), this.navigation.end();
  }
  addToRotateEstimator(t11, o10) {
    this._rotationMomentumEstimator.add(t11, 1e-3 * o10);
  }
  addToZoomEstimator(t11, o10) {
    this._zoomMomentumEstimator.add(o10, 1e-3 * t11.timestamp);
  }
  canZoomIn(t11) {
    const o10 = t11.scale, i6 = t11.constraints.effectiveMaxScale;
    return 0 === i6 || o10 > i6;
  }
  canZoomOut(t11) {
    const o10 = t11.scale, i6 = t11.constraints.effectiveMinScale;
    return 0 === i6 || o10 < i6;
  }
  onAnimationUpdate(t11) {
    var _a;
    (_a = this.navigation.animationManager) == null ? void 0 : _a.animateContinous(t11.viewpoint, (o10, i6) => {
      const s11 = !this.canZoomIn(t11) && this._zoomDirection > 1 || !this.canZoomOut(t11) && this._zoomDirection < 1, e14 = !this.rotateMomentum || this.rotateMomentum.isFinished(this._animationTime), n13 = s11 || !this.zoomMomentum || this.zoomMomentum.isFinished(this._animationTime), p5 = 1e-3 * i6;
      if (this._momentumFinished = e14 && n13, !this._momentumFinished) {
        const i7 = this.rotateMomentum ? Math.abs(this.rotateMomentum.valueDelta(this._animationTime, p5)) * this._rotationDirection * 180 / Math.PI : 0;
        let s12 = this.zoomMomentum ? Math.abs(this.zoomMomentum.valueDelta(this._animationTime, p5)) : 1;
        const e15 = n3(), n14 = n3();
        if (this._previousCenter) {
          r3(e15, this._previousCenter.x, this._previousCenter.y), et(n14, t11.size, t11.padding), s6(e15, e15, n14);
          const { constraints: r14, scale: p6 } = t11, l8 = p6 * s12;
          s12 < 1 && !r14.canZoomInTo(l8) ? (s12 = p6 / r14.effectiveMaxScale, this.zoomMomentum = null, this.rotateMomentum = null) : s12 > 1 && !r14.canZoomOutTo(l8) && (s12 = p6 / r14.effectiveMinScale, this.zoomMomentum = null, this.rotateMomentum = null), jt(o10, t11.viewpoint, s12, i7, e15, t11.size), t11.constraints.constrainByGeometry(o10);
        }
      }
      this._animationTime += p5;
    });
  }
  stopMomentumNavigation() {
    (this.rotateMomentum || this.zoomMomentum) && (this.rotateMomentum && (this._rotationMomentumEstimator.reset(), this.rotateMomentum = null), this.zoomMomentum && (this._zoomMomentumEstimator.reset(), this.zoomMomentum = null), this.navigation.stop());
  }
};
e([y()], _5.prototype, "_momentumFinished", void 0), e([y()], _5.prototype, "viewpoint", void 0), e([y()], _5.prototype, "navigation", void 0), _5 = e([c("esri.views.2d.navigation.actions.Pinch")], _5);
var d5 = _5;

// node_modules/@arcgis/core/views/2d/navigation/actions/Rotate.js
var u5 = n3();
var d6 = n3();
var j2 = class extends g {
  constructor(t11) {
    super(t11), this._previousCenter = n3(), this.viewpoint = new l({ targetGeometry: new x(), scale: 0, rotation: 0 });
  }
  begin(t11, e14) {
    this.navigation.begin(), r3(this._previousCenter, e14.center.x, e14.center.y);
  }
  update(t11, e14) {
    const { state: { size: o10, padding: r14 } } = t11;
    r3(u5, e14.center.x, e14.center.y), Z(d6, o10, r14), t11.viewpoint = ht(this.viewpoint, t11.state.paddedViewState.viewpoint, yt(d6, this._previousCenter, u5)), a(this._previousCenter, u5);
  }
  end() {
    this.navigation.end();
  }
};
e([y()], j2.prototype, "viewpoint", void 0), e([y()], j2.prototype, "navigation", void 0), j2 = e([c("esri.views.2d.actions.Rotate")], j2);
var h4 = j2;

// node_modules/@arcgis/core/views/2d/navigation/MapViewNavigation.js
var v2 = 10;
var w = 1;
var g6 = new l({ targetGeometry: new x() });
var _6 = [0, 0];
var d7 = 250;
var T4 = class extends g {
  constructor(t11) {
    super(t11), this._endTimer = null, this._lastEventTimestamp = null, this.animationManager = null, this.interacting = false;
  }
  initialize() {
    this.pan = new d4({ navigation: this }), this.rotate = new h4({ navigation: this }), this.pinch = new d5({ navigation: this }), this.zoomBox = new c10({ view: this.view, navigation: this });
  }
  destroy() {
    this.pan = u(this.pan), this.rotate = u(this.rotate), this.pinch = u(this.pinch), this.zoomBox = u(this.zoomBox), this.animationManager = null;
  }
  begin() {
    this._set("interacting", true);
  }
  end() {
    this._lastEventTimestamp = performance.now(), this._startTimer(d7);
  }
  async zoom(t11, i6 = this._getDefaultAnchor()) {
    if (this.stop(), this.begin(), this.view.constraints.snapToZoom && this.view.constraints.effectiveLODs)
      return t11 < 1 ? this.zoomIn(i6) : this.zoomOut(i6);
    this.setViewpoint(i6, t11, 0, [0, 0]);
  }
  async zoomIn(t11) {
    const i6 = this.view, o10 = i6.constraints.snapToNextScale(i6.scale);
    return this._zoomToScale(o10, t11);
  }
  async zoomOut(t11) {
    const i6 = this.view, o10 = i6.constraints.snapToPreviousScale(i6.scale);
    return this._zoomToScale(o10, t11);
  }
  setViewpoint(t11, i6, o10, n13) {
    this.begin(), this.view.stateManager.state.viewpoint = this._scaleRotateTranslateViewpoint(this.view.viewpoint, t11, i6, o10, n13), this.end();
  }
  setViewpointImmediate(t11, i6 = 0, o10 = [0, 0], n13 = this._getDefaultAnchor()) {
    this.view.stateManager.state.viewpoint = this._scaleRotateTranslateViewpoint(this.view.viewpoint, n13, t11, i6, o10);
  }
  continousRotateClockwise() {
    var _a;
    const t11 = this.view.viewpoint;
    (_a = this.animationManager) == null ? void 0 : _a.animateContinous(t11, (t12) => {
      ht(t12, t12, -w);
    });
  }
  continousRotateCounterclockwise() {
    var _a;
    const t11 = this.view.viewpoint;
    (_a = this.animationManager) == null ? void 0 : _a.animateContinous(t11, (t12) => {
      ht(t12, t12, w);
    });
  }
  resetRotation() {
    this.view.constraints.rotationEnabled && (this.view.rotation = 0);
  }
  continousPanLeft() {
    this._continuousPan([-v2, 0]);
  }
  continousPanRight() {
    this._continuousPan([v2, 0]);
  }
  continousPanUp() {
    this._continuousPan([0, v2]);
  }
  continousPanDown() {
    this._continuousPan([0, -v2]);
  }
  continuousPanVector({ x: t11, y: i6 }) {
    this._continuousPan([t11 * v2, i6 * v2]);
  }
  stop() {
    var _a;
    this.pan.stopMomentumNavigation(), (_a = this.animationManager) == null ? void 0 : _a.stop(), this.end(), null !== this._endTimer && (clearTimeout(this._endTimer), this._endTimer = null, this._set("interacting", false));
  }
  _continuousPan(t11) {
    var _a;
    const i6 = this.view.viewpoint;
    (_a = this.animationManager) == null ? void 0 : _a.animateContinous(i6, (i7) => {
      At(i7, i7, t11), this.view.constraints.constrainByGeometry(i7);
    });
  }
  _startTimer(t11) {
    return null !== this._endTimer || (this._endTimer = setTimeout(() => {
      this._endTimer = null;
      const t12 = performance.now() - (this._lastEventTimestamp ?? 0);
      t12 < d7 ? this._endTimer = this._startTimer(t12) : this._set("interacting", false);
    }, t11)), this._endTimer;
  }
  _getDefaultAnchor() {
    const { size: t11, padding: { left: i6, right: o10, top: n13, bottom: e14 } } = this.view;
    return _6[0] = 0.5 * (t11[0] - o10 + i6), _6[1] = 0.5 * (t11[1] - e14 + n13), _6;
  }
  async _zoomToScale(t11, i6 = this._getDefaultAnchor()) {
    const { view: o10 } = this, { constraints: n13, scale: e14, viewpoint: s11, size: a9, padding: r14 } = o10, c12 = n13.canZoomInTo(t11), m4 = n13.canZoomOutTo(t11);
    if (!(t11 < e14 && !c12 || t11 > e14 && !m4))
      return Gt(g6, s11, t11 / e14, 0, i6, a9, r14), n13.constrainByGeometry(g6), o10.goTo(g6, { animate: true, pickClosestTarget: false });
  }
  _scaleRotateTranslateViewpoint(t11, i6, o10, n13, e14) {
    const { view: s11 } = this, { size: a9, padding: r14, constraints: m4, scale: p5, viewpoint: u6 } = s11, l8 = p5 * o10, v3 = m4.canZoomInTo(l8), w2 = m4.canZoomOutTo(l8);
    return (o10 < 1 && !v3 || o10 > 1 && !w2) && (o10 = 1), At(u6, u6, e14), Gt(t11, u6, o10, n13, i6, a9, r14), m4.constrainByGeometry(t11);
  }
};
e([y()], T4.prototype, "animationManager", void 0), e([y({ type: Boolean, readOnly: true })], T4.prototype, "interacting", void 0), e([y()], T4.prototype, "pan", void 0), e([y()], T4.prototype, "pinch", void 0), e([y()], T4.prototype, "rotate", void 0), e([y()], T4.prototype, "view", void 0), e([y()], T4.prototype, "zoomBox", void 0), T4 = e([c("esri.views.2d.navigation.MapViewNavigation")], T4);
var y2 = T4;

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/MagnifierPrograms.js
var a8 = { shaders: { vertexShader: n6("magnifier/magnifier.vert"), fragmentShader: n6("magnifier/magnifier.frag") }, attributes: /* @__PURE__ */ new Map([["a_pos", 0]]) };
function t10(r14) {
  return e9(r14, a8);
}

export {
  n7 as n,
  e11 as e,
  l3 as l,
  J,
  r7 as r,
  m3 as m,
  t7 as t,
  r9 as r2,
  n11 as n2,
  a5 as a,
  y2 as y,
  a8 as a2,
  t10 as t2
};
//# sourceMappingURL=chunk-3U7ON3ZU.js.map
