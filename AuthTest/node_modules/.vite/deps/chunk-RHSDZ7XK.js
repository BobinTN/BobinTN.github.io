import {
  a as a3
} from "./chunk-T66WPMUO.js";
import {
  c as c4
} from "./chunk-UFIIIHSC.js";
import {
  i
} from "./chunk-FRJE22BH.js";
import {
  t
} from "./chunk-RFDTTDIQ.js";
import {
  Ze
} from "./chunk-GKVKVLT4.js";
import {
  m as m2
} from "./chunk-P5GW5DPX.js";
import {
  r as r2
} from "./chunk-PHX4PE2G.js";
import {
  a,
  a2,
  c as c3,
  g as g2,
  l,
  r
} from "./chunk-HBL2432S.js";
import {
  b as b2
} from "./chunk-45OAWGCA.js";
import {
  c as c2
} from "./chunk-B3RXTW72.js";
import {
  p
} from "./chunk-IPCIO3PX.js";
import {
  o as o2
} from "./chunk-V2RPSCV3.js";
import {
  p as p2
} from "./chunk-AOJ6OCPK.js";
import {
  S
} from "./chunk-2D3PORS4.js";
import {
  m
} from "./chunk-CCXEAKIM.js";
import {
  M
} from "./chunk-Y5D433JZ.js";
import {
  f as f2
} from "./chunk-QWPLZ3QH.js";
import {
  o,
  s as s3
} from "./chunk-EUTNDAIV.js";
import {
  I,
  j
} from "./chunk-R5DM4YAB.js";
import {
  f,
  u2
} from "./chunk-NSRXJNTS.js";
import {
  g,
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  b,
  u
} from "./chunk-RFPH3ZTZ.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";

// node_modules/@arcgis/core/networks/support/TopologyValidationJobInfo.js
var n = o()({ Pending: "job-waiting", InProgress: "job-executing", Completed: "job-succeeded" });
var l2 = class extends i {
  constructor(t2) {
    super(t2), this.statusUrl = null, this.status = null, this.submissionTime = null, this.lastUpdatedTime = null, this._timer = void 0;
  }
  destroy() {
    clearInterval(this._timer);
  }
  async checkJobStatus(t2) {
    const s5 = { ...t2, query: { f: "json" } }, { data: r3 } = await j(this.statusUrl, s5);
    return this.read(r3), this.editsResolver && this.editsResolver.resolve({ edits: null, addedFeatures: [], updatedFeatures: [], deletedFeatures: [], addedAttachments: [], updatedAttachments: [], deletedAttachments: [], exceededTransferLimit: true, historicMoment: null }), this;
  }
  async waitForJobCompletion(t2 = {}) {
    const { interval: e3 = 1e3, statusCallback: s5 } = t2;
    return new Promise((t3, o3) => {
      this._clearTimer();
      const i3 = setInterval(() => {
        this._timer || o3(u()), this.checkJobStatus().then((e4) => {
          const { status: r3 } = e4;
          switch (this.status = r3, r3) {
            case "job-succeeded":
              this._clearTimer(), t3(this);
              break;
            case "job-waiting":
            case "job-executing":
              s5 && s5(this);
          }
        }, (t4) => {
          this._clearTimer(), o3(t4);
        });
      }, e3);
      this._timer = i3;
    });
  }
  _clearTimer() {
    clearInterval(this._timer), this._timer = void 0;
  }
};
e([y()], l2.prototype, "editsResolver", void 0), e([y({ type: String, json: { write: true } })], l2.prototype, "statusUrl", void 0), e([o2(n)], l2.prototype, "status", void 0), e([y({ type: Date, json: { type: Number, write: { writer: (t2, e3) => {
  e3.submissionTime = t2 ? t2.getTime() : null;
} } } })], l2.prototype, "submissionTime", void 0), e([y({ type: Date, json: { type: Number, write: { writer: (t2, e3) => {
  e3.lastUpdatedTime = t2 ? t2.getTime() : null;
} } } })], l2.prototype, "lastUpdatedTime", void 0), l2 = e([c("esri.networks.support.TopologyValidationJobInfo")], l2);
var p3 = l2;

// node_modules/@arcgis/core/networks/support/utils.js
async function l3(e3, t2) {
  if ("Utility Network Layer" === e3) {
    const { default: e4 } = await import("./UtilityNetwork-H4MLAN3E.js");
    return new e4({ layerUrl: t2 });
  }
  return null;
}
async function i2(r3) {
  var _a;
  let a6 = "portalItem" in r3 ? r3 : { portalItem: r3 };
  !a6.portalItem || a6.portalItem instanceof S || (a6 = { ...a6, portalItem: new S(a6.portalItem) });
  const n4 = a6.portalItem;
  if (await n4.load(), "Feature Service" !== n4.type)
    throw new s2("portal:unknown-item-type", "Unknown item type '${type}'", { type: n4.type });
  const s5 = n4.url, i3 = await j(s5, { responseType: "json", query: { f: "json" } }), u4 = "Network Layer";
  if ((_a = i3.data.type) == null ? void 0 : _a.includes(u4))
    return l3(i3.data.type, s5);
  if (i3.data.layers) {
    const e3 = i3.data.layers.find((e4) => e4.type.includes(u4));
    if (e3) {
      const t2 = `${s5}/${e3.id}`;
      return l3(e3.type, t2);
    }
  }
  return null;
}

// node_modules/@arcgis/core/networks/Network.js
var U = class extends m2(m) {
  static fromPortalItem(e3) {
    return i2(e3);
  }
  constructor(e3) {
    super(e3), this.id = null, this.title = null, this.layerUrl = null, this.dataElement = null, this.fullExtent = null, this.spatialReference = null, this.type = null, this.sourceJSON = null, this.gdbVersion = null, this.historicMoment = null, this._applyEditsHandler = (e4) => {
      const { serviceUrl: t2, gdbVersion: r3, result: o3 } = e4, s5 = t2 === this.featureServiceUrl, i3 = g2(t2, r3, this.gdbVersion);
      s5 && i3 && o3.then((e5) => {
        a(t2, r3) && (this.historicMoment = e5.historicMoment);
      });
    }, this._updateMomentHandler = (e4) => {
      const { serviceUrl: t2, gdbVersion: r3, moment: o3 } = e4, s5 = t2 === this.featureServiceUrl, i3 = g2(t2, r3, this.gdbVersion);
      s5 && i3 && (this.historicMoment = o3);
    }, this.when().then(() => {
      this.addHandles([l(this._applyEditsHandler), a2(this._updateMomentHandler)]);
    }, () => {
    });
  }
  initialize() {
    this.when().catch((e3) => {
      b(e3) || s.getLogger(this).error("#load()", `Failed to load layer (title: '${this.title ?? "no title"}', id: '${this.id ?? "no id"}')`, { error: e3 });
    });
  }
  get datasetName() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.name) ?? null;
  }
  get owner() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.userIdentity) ?? null;
  }
  get schemaGeneration() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.schemaGeneration) ?? null;
  }
  get parsedUrl() {
    return I(this.layerUrl);
  }
  get featureServiceUrl() {
    return p2(this.parsedUrl.path).url.path;
  }
  get networkServiceUrl() {
    return this.featureServiceUrl.replace(/\/FeatureServer/i, "/UtilityNetworkServer");
  }
  get layerId() {
    return p2(this.parsedUrl.path).sublayer;
  }
  get networkSystemLayers() {
    return null;
  }
  async load(e3) {
    return this.addResolvingPromise(this._fetchDataElement(this.featureServiceUrl, this.layerId.toString(), e3)), this.addResolvingPromise(this._fetchLayerMetaData(this.layerUrl, e3)), this;
  }
  getLayerIdBySourceId(e3) {
    if (this.dataElement) {
      const t2 = this.dataElement.domainNetworks;
      for (const r3 of t2) {
        for (const t3 of r3.edgeSources ?? [])
          if (t3.sourceId === e3)
            return t3.layerId;
        for (const t3 of r3.junctionSources ?? [])
          if (t3.sourceId === e3)
            return t3.layerId;
      }
      return null;
    }
    return null;
  }
  async queryNamedTraceConfigurations(e3, t2) {
    var _a;
    const [{ queryNamedTraceConfigurations: r3 }, { default: o3 }] = await Promise.all([import("./queryNamedTraceConfigurations-IZBMH4OM.js"), import("./QueryNamedTraceConfigurationsParameters-EMECICHH.js")]), s5 = this.networkServiceUrl, i3 = o3.from(e3);
    return (_a = await r3(s5, i3, { ...t2 })) == null ? void 0 : _a.namedTraceConfigurations;
  }
  async validateTopology(e3, t2) {
    var _a, _b, _c;
    if (!e3.validateArea)
      throw new s2("network:undefined-validateArea", "the network must have validateArea defined in the validate network topology parameters.");
    const [{ validateNetworkTopology: r3 }, { default: s5 }] = await Promise.all([import("./validateNetworkTopology-C7FPAGDI.js"), import("./ValidateNetworkTopologyParameters-BSN7IT4Y.js")]), i3 = s5.from(e3);
    a(this.featureServiceUrl, this.gdbVersion || null) && (i3.sessionID = r), i3.gdbVersion = this.gdbVersion;
    const a6 = this.networkServiceUrl, n4 = this.featureServiceUrl, l5 = c3(n4, null, this.gdbVersion, true), d2 = await r3(a6, i3, { ...t2 });
    if (d2 == null ? void 0 : d2.serviceEdits) {
      const e4 = [];
      for (const t3 of d2.serviceEdits) {
        const { editedFeatures: r4 } = t3, o3 = (r4 == null ? void 0 : r4.spatialReference) ? new f2(r4.spatialReference) : null;
        e4.push({ layerId: t3.layerId, editedFeatures: { adds: ((_a = r4 == null ? void 0 : r4.adds) == null ? void 0 : _a.map((e5) => this._createEditedFeature(e5, o3))) || [], updates: ((_b = r4 == null ? void 0 : r4.updates) == null ? void 0 : _b.map((e5) => ({ original: this._createEditedFeature(e5[0], o3), current: this._createEditedFeature(e5[1], o3) }))) || [], deletes: ((_c = r4 == null ? void 0 : r4.deletes) == null ? void 0 : _c.map((e5) => this._createEditedFeature(e5, o3))) || [], spatialReference: o3 } });
      }
      l5.resolve({ edits: null, addedFeatures: [], updatedFeatures: [], deletedFeatures: [], addedAttachments: [], updatedAttachments: [], deletedAttachments: [], editedFeatures: e4, exceededTransferLimit: false, historicMoment: d2.moment });
    }
    return d2;
  }
  async submitTopologyValidationJob(e3, t2) {
    if (!e3.validateArea)
      throw new s2("network:undefined-validateArea", "the network must have validateArea defined in the validate network topology parameters.");
    if (!this.gdbVersion)
      throw new s2("network:undefined-gdb-version", "version must be defined");
    const [{ submitValidateNetworkTopologyJob: r3 }, { default: s5 }] = await Promise.all([import("./validateNetworkTopology-C7FPAGDI.js"), import("./ValidateNetworkTopologyParameters-BSN7IT4Y.js")]), i3 = s5.from(e3);
    a(this.featureServiceUrl, this.gdbVersion || null) && (i3.sessionID = r), i3.gdbVersion = this.gdbVersion;
    const a6 = this.networkServiceUrl, n4 = this.featureServiceUrl ? c3(this.featureServiceUrl, null, this.gdbVersion, true) : void 0, l5 = await r3(a6, i3, { ...t2 });
    return new p3({ statusUrl: l5, editsResolver: n4 });
  }
  _createEditedFeature(e3, r3) {
    return new c2({ attributes: e3.attributes, geometry: p({ ...e3.geometry, spatialReference: r3 }) });
  }
  async _fetchLayerMetaData(e3, t2) {
    const o3 = await j(e3, { responseType: "json", query: { f: "json" }, ...t2 });
    this.sourceJSON = o3.data, this.read(o3.data, { origin: "service" });
  }
  async _fetchDataElement(e3, t2, o3) {
    if (this.dataElement)
      return;
    const s5 = await j(`${e3}/queryDataElements`, { responseType: "json", query: { layers: JSON.stringify([t2]), f: "json" }, ...o3 }).then((e4) => {
      var _a;
      return (_a = e4.data.layerDataElements) == null ? void 0 : _a[0];
    });
    s5 && this.read(s5, { origin: "service" });
  }
};
e([y({ type: String, nonNullable: true, json: { origins: { "web-map": { read: true, write: { isRequired: true } }, service: { read: true } }, read: false } })], U.prototype, "id", void 0), e([y({ type: String, nonNullable: true, json: { origins: { "web-map": { read: true, write: { isRequired: true } }, service: { read: { source: "name" } } }, read: false } })], U.prototype, "title", void 0), e([y({ type: String, nonNullable: true, json: { origins: { "web-map": { read: { source: "url" }, write: { target: "url", isRequired: true } } }, read: false } })], U.prototype, "layerUrl", void 0), e([y({ type: Object, json: { origins: { service: { read: true } }, read: false } })], U.prototype, "dataElement", void 0), e([y({ type: M, json: { origins: { service: { read: { source: "extent" } } }, read: false } })], U.prototype, "fullExtent", void 0), e([y({ type: f2, json: { origins: { service: { read: { source: "extent.spatialReference" } } }, read: false } })], U.prototype, "spatialReference", void 0), e([y({ type: ["utility", "trace"], readOnly: true, json: { read: false, write: false } })], U.prototype, "type", void 0), e([y({ readOnly: true })], U.prototype, "datasetName", null), e([y({ readOnly: true })], U.prototype, "owner", null), e([y({ readOnly: true })], U.prototype, "schemaGeneration", null), e([y({ readOnly: true })], U.prototype, "parsedUrl", null), e([y({ readOnly: true })], U.prototype, "featureServiceUrl", null), e([y({ readOnly: true })], U.prototype, "networkServiceUrl", null), e([y({ readOnly: true })], U.prototype, "layerId", null), e([y()], U.prototype, "sourceJSON", void 0), e([y({ readOnly: true })], U.prototype, "networkSystemLayers", null), e([y()], U.prototype, "gdbVersion", void 0), e([y({ type: Date })], U.prototype, "historicMoment", void 0), U = e([c("esri.networks.Network")], U);
var k = U;

// node_modules/@arcgis/core/networks/RulesTable.js
var a4 = class extends u2(m) {
  constructor(e3) {
    super(e3), this.request = j;
  }
  initialize() {
  }
  async load(e3) {
    const t2 = this.layer.load(e3).then(() => this._initializeRulesTable());
    return this.addResolvingPromise(t2), this;
  }
  getFeatureSQL(e3, t2) {
    var _a, _b;
    const s5 = e3.layerId.toString(), o3 = (_a = e3.fieldsIndex) == null ? void 0 : _a.normalizeFieldName("assetGroup"), r3 = (_b = e3.fieldsIndex) == null ? void 0 : _b.normalizeFieldName("assetType"), n4 = o3 ? t2.attributes[o3] : null, i3 = r3 ? t2.attributes[r3] : null, a6 = this.rulesHash[s5];
    if (a6) {
      const e4 = a6.assetGroupHash[n4];
      if (e4) {
        return e4.assetTypeHash[i3] || null;
      }
    }
    return null;
  }
  async _initializeRulesTable() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    const e3 = {};
    let t2;
    !function(e4) {
      e4[e4.from = 0] = "from", e4[e4.to = 1] = "to", e4[e4.via = 2] = "via";
    }(t2 || (t2 = {}));
    const s5 = [{ networkSourceId: "fromNetworkSource", assetGroupId: "fromAssetGroup", assetTypeId: "fromAssetType" }, { networkSourceId: "toNetworkSource", assetGroupId: "toAssetGroup", assetTypeId: "toAssetType" }, { networkSourceId: "viaNetworkSource", assetGroupId: "viaAssetGroup", assetTypeId: "viaAssetType" }];
    for (const o3 of this.rules) {
      if (o3.ruleType !== t.RTJunctionJunctionConnectivity && o3.ruleType !== t.RTJunctionEdgeConnectivity && o3.ruleType !== t.RTEdgeJunctionEdgeConnectivity)
        continue;
      let r3 = [[t2.from, t2.to], [t2.to, t2.from]];
      o3.ruleType === t.RTEdgeJunctionEdgeConnectivity && (r3 = [[t2.from, t2.via], [t2.via, t2.from], [t2.to, t2.via], [t2.via, t2.to]]);
      for (const n4 of r3) {
        const r4 = n4.shift(), a6 = n4.shift();
        let u4 = false;
        switch (o3.ruleType) {
          case t.RTEdgeJunctionEdgeConnectivity:
            u4 = r4 === t2.from || r4 === t2.to;
            break;
          case t.RTJunctionEdgeConnectivity:
            u4 = r4 === t2.to;
        }
        const c5 = s5[r4], p8 = ((_a = o3[c5.networkSourceId]) == null ? void 0 : _a.layerId.toString()) ?? "", d2 = (_c = (_b = o3[c5.assetGroupId]) == null ? void 0 : _b.assetGroupCode) == null ? void 0 : _c.toString(), l5 = o3[c5.assetTypeId], y3 = (_d = l5 == null ? void 0 : l5.assetTypeCode) == null ? void 0 : _d.toString(), f3 = s5[a6], m4 = ((_e = o3[f3.networkSourceId]) == null ? void 0 : _e.layerId.toString()) ?? "", T = (_g = (_f = o3[f3.assetGroupId]) == null ? void 0 : _f.assetGroupCode) == null ? void 0 : _g.toString(), h = o3[f3.assetTypeId], v = (_h = h == null ? void 0 : h.assetTypeCode) == null ? void 0 : _h.toString(), S2 = e3[p8] ?? { assetGroupHash: {} };
        if (!(d2 && y3 && T && v))
          continue;
        const I2 = S2.assetGroupHash[d2] ?? { assetTypeHash: {} }, g3 = I2.assetTypeHash[y3] ?? {};
        if (g3[m4] = g3[m4] ?? {}, u4) {
          g3[p8] = g3[p8] ?? {};
          const e4 = `(assetgroup = ${d2} AND assettype = ${y3})`;
          g3[p8].anyVertex = g3[p8].anyVertex ? `${g3[p8].anyVertex}` : `${e4}`, "esriNECPEndVertex" === (h == null ? void 0 : h.connectivityPolicy) && (g3[p8].endVertex = ((_i = g3[p8]) == null ? void 0 : _i.endVertex) ? `${g3[p8].endVertex}` : `${e4}`);
        }
        const x = `(assetgroup = ${T} AND assettype = ${v})`;
        g3[m4].anyVertex = ((_j = g3[m4]) == null ? void 0 : _j.anyVertex) ? `${g3[m4].anyVertex} OR ${x}` : `${x}`, "esriNECPEndVertex" === (h == null ? void 0 : h.connectivityPolicy) && (g3[m4].endVertex = ((_k = g3[m4]) == null ? void 0 : _k.endVertex) ? `${g3[m4].endVertex} OR ${x}` : `${x}`), I2.assetTypeHash[y3] = g3, S2.assetGroupHash[d2] = I2, e3[p8] = S2;
      }
    }
    this.rulesHash = e3;
  }
};
e([y({ constructOnly: true })], a4.prototype, "layer", void 0), e([y({ constructOnly: true })], a4.prototype, "rules", void 0), e([y()], a4.prototype, "rulesHash", void 0), e([y({ constructOnly: true })], a4.prototype, "request", void 0), a4 = e([c("esri.networks.RulesTable")], a4);
var u3 = a4;

// node_modules/@arcgis/core/networks/support/NetworkSystemLayers.js
var e2 = class extends g {
  constructor(r3) {
    super(r3), this.rulesTableId = null, this.rulesTableUrl = null, this.subnetworksTableId = null, this.subnetworksTableUrl = null, this.dirtyAreasLayerId = null, this.dirtyAreasLayerUrl = null;
  }
};
e([y({ constructOnly: true })], e2.prototype, "rulesTableId", void 0), e([y({ constructOnly: true })], e2.prototype, "rulesTableUrl", void 0), e([y({ constructOnly: true })], e2.prototype, "subnetworksTableId", void 0), e([y({ constructOnly: true })], e2.prototype, "subnetworksTableUrl", void 0), e([y({ constructOnly: true })], e2.prototype, "dirtyAreasLayerId", void 0), e([y({ constructOnly: true })], e2.prototype, "dirtyAreasLayerUrl", void 0), e2 = e([c("esri.networks.support.NetworkSystemLayers")], e2);
var l4 = e2;

// node_modules/@arcgis/core/networks/support/Terminal.js
var s4 = class extends f {
  constructor(r3) {
    super(r3), this.id = null, this.name = null;
  }
};
e([y({ type: Number, json: { read: { source: "terminalId" }, write: { target: "terminalId" } } })], s4.prototype, "id", void 0), e([y({ type: String, json: { read: { source: "terminalName" }, write: { target: "terminalName" } } })], s4.prototype, "name", void 0), e([y({ type: Boolean, json: { write: true } })], s4.prototype, "isUpstreamTerminal", void 0), s4 = e([c("esri.networks.support.Terminal")], s4);
var p4 = s4;

// node_modules/@arcgis/core/networks/support/TerminalConfiguration.js
var a5 = new s3({ esriUNTMBidirectional: "bidirectional", esriUNTMDirectional: "directional" });
var n2 = class extends f {
  constructor(r3) {
    super(r3), this.defaultConfiguration = null, this.id = null, this.name = null, this.terminals = [], this.traversabilityModel = null;
  }
};
e([y({ type: String, json: { write: true } })], n2.prototype, "defaultConfiguration", void 0), e([y({ type: Number, json: { read: { source: "terminalConfigurationId" }, write: { target: "terminalConfigurationId" } } })], n2.prototype, "id", void 0), e([y({ type: String, json: { read: { source: "terminalConfigurationName" }, write: { target: "terminalConfigurationName" } } })], n2.prototype, "name", void 0), e([y({ type: [p4], json: { write: true } })], n2.prototype, "terminals", void 0), e([y({ type: a5.apiValues, json: { type: a5.jsonValues, read: a5.read, write: a5.write } })], n2.prototype, "traversabilityModel", void 0), n2 = e([c("esri.networks.support.TerminalConfiguration")], n2);
var p5 = n2;

// node_modules/@arcgis/core/networks/support/TraceJobInfo.js
var n3 = o()({ Pending: "job-waiting", InProgress: "job-executing", Completed: "job-succeeded" });
var p6 = class extends a3 {
  constructor(t2) {
    super(t2), this.statusUrl = null, this.status = null, this.submissionTime = null, this.lastUpdatedTime = null, this._timer = void 0;
  }
  destroy() {
    clearInterval(this._timer);
  }
  async checkJobStatus(t2) {
    const e3 = { ...t2, query: { f: "json" } }, { data: r3 } = await j(this.statusUrl, e3), o3 = r3.traceResults ? { ...r3.traceResults, ...r3 } : r3;
    return this.read(o3), this;
  }
  async waitForJobCompletion(t2 = {}) {
    const { interval: s5 = 1e3, statusCallback: e3 } = t2;
    return new Promise((t3, o3) => {
      this._clearTimer();
      const i3 = setInterval(() => {
        this._timer || o3(u()), this.checkJobStatus().then((s6) => {
          const { status: r3 } = s6;
          switch (this.status = r3, r3) {
            case "job-succeeded":
              this._clearTimer(), t3(this);
              break;
            case "job-waiting":
            case "job-executing":
              e3 && e3(this);
          }
        }, (t4) => {
          this._clearTimer(), o3(t4);
        });
      }, s5);
      this._timer = i3;
    });
  }
  _clearTimer() {
    clearInterval(this._timer), this._timer = void 0;
  }
};
e([y({ type: String, json: { write: true } })], p6.prototype, "statusUrl", void 0), e([o2(n3)], p6.prototype, "status", void 0), e([y({ type: Date, json: { type: Number, write: { writer: (t2, s5) => {
  s5.submissionTime = t2 ? t2.getTime() : null;
} } } })], p6.prototype, "submissionTime", void 0), e([y({ type: Date, json: { type: Number, write: { writer: (t2, s5) => {
  s5.lastUpdatedTime = t2 ? t2.getTime() : null;
} } } })], p6.prototype, "lastUpdatedTime", void 0), p6 = e([c("esri.networks.support.TraceJobInfo")], p6);
var m3 = p6;

// node_modules/@arcgis/core/networks/UtilityNetwork.js
var y2 = class extends k {
  constructor(e3) {
    super(e3), this.sharedNamedTraceConfigurations = [], this.type = "utility";
  }
  get serviceTerritoryFeatureLayerId() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.serviceTerritoryFeatureLayerId) ?? null;
  }
  get networkSystemLayers() {
    var _a, _b, _c, _d, _e, _f;
    return new l4({ rulesTableId: (_a = this.sourceJSON) == null ? void 0 : _a.systemLayers.rulesTableId, rulesTableUrl: this.sourceJSON ? `${this.featureServiceUrl}/${(_b = this.sourceJSON) == null ? void 0 : _b.systemLayers.rulesTableId}` : null, subnetworksTableId: (_c = this.sourceJSON) == null ? void 0 : _c.systemLayers.subnetworksTableId, subnetworksTableUrl: this.sourceJSON ? `${this.featureServiceUrl}/${(_d = this.sourceJSON) == null ? void 0 : _d.systemLayers.subnetworksTableId}` : null, dirtyAreasLayerId: (_e = this.sourceJSON) == null ? void 0 : _e.systemLayers.dirtyAreasLayerId, dirtyAreasLayerUrl: this.sourceJSON ? `${this.featureServiceUrl}/${(_f = this.sourceJSON) == null ? void 0 : _f.systemLayers.dirtyAreasLayerId}` : null });
  }
  get terminalConfigurations() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.terminalConfigurations.map((e3) => p5.fromJSON(e3))) || [];
  }
  get domainNetworkNames() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.domainNetworks.map((e3) => e3.domainNetworkName)) || [];
  }
  get _utilityLayerList() {
    var _a, _b;
    const e3 = /* @__PURE__ */ new Set();
    return (_b = (_a = this.dataElement) == null ? void 0 : _a.domainNetworks) == null ? void 0 : _b.map((t2) => {
      t2.edgeSources.map((t3) => {
        e3.add(t3.layerId);
      }), t2.junctionSources.map((t3) => {
        e3.add(t3.layerId);
      });
    }), e3;
  }
  async load(e3) {
    return this.addResolvingPromise(super.load(e3)), this.addResolvingPromise(this._loadNamedTraceConfigurationsFromNetwork(e3)), this;
  }
  getTerminalConfiguration(e3) {
    var _a, _b, _c, _d;
    let t2 = null, r3 = null;
    const s5 = e3.layer;
    let a6 = null;
    if ("feature" === (s5 == null ? void 0 : s5.type)) {
      if (a6 = s5.layerId, null === a6)
        return null;
    } else {
      if ("subtype-sublayer" !== (s5 == null ? void 0 : s5.type))
        return null;
      if (a6 = ((_a = s5 == null ? void 0 : s5.parent) == null ? void 0 : _a.layerId) ?? null, null === a6)
        return null;
    }
    const o3 = e3.attributes;
    if (null == o3)
      return null;
    for (const u4 of Object.keys(o3))
      "ASSETGROUP" === u4.toUpperCase() && (t2 = e3.getAttribute(u4)), "ASSETTYPE" === u4.toUpperCase() && (r3 = e3.getAttribute(u4));
    if (!this.dataElement)
      return null;
    let i3 = null;
    const n4 = this.dataElement.domainNetworks;
    for (const u4 of n4) {
      const e4 = (_b = u4.junctionSources) == null ? void 0 : _b.find((e5) => e5.layerId === a6);
      if (e4) {
        const s6 = (_c = e4.assetGroups) == null ? void 0 : _c.find((e5) => e5.assetGroupCode === t2);
        if (s6) {
          const e5 = (_d = s6.assetTypes) == null ? void 0 : _d.find((e6) => e6.assetTypeCode === r3);
          if (e5) {
            i3 = e5.terminalConfigurationId;
            break;
          }
        }
      }
    }
    if (null != i3) {
      const e4 = this.dataElement.terminalConfigurations, t3 = e4 == null ? void 0 : e4.find((e5) => e5.terminalConfigurationId === i3);
      return t3 ? p5.fromJSON(t3) : null;
    }
    return null;
  }
  getTierNames(e3) {
    var _a;
    const t2 = (_a = this.dataElement) == null ? void 0 : _a.domainNetworks.find((t3) => t3.domainNetworkName === e3);
    return (t2 == null ? void 0 : t2.tiers.map((e4) => e4.name)) || [];
  }
  async getRulesTable() {
    return this._sharedRulesTable || (this._sharedRulesTable = this._createRulesTable()), await this._sharedRulesTable;
  }
  isUtilityLayer(e3) {
    return this._utilityLayerList.has(e3.layerId);
  }
  async queryAssociations(e3) {
    const [{ queryAssociations: t2 }, { default: r3 }] = await Promise.all([import("./queryAssociations-GN2EYOV2.js"), import("./QueryAssociationsParameters-K2BYX2PU.js")]), s5 = r3.from(e3);
    s5.gdbVersion = this.gdbVersion, s5.moment = this.historicMoment;
    return (await t2(this.networkServiceUrl, s5)).associations;
  }
  async synthesizeAssociationGeometries(e3) {
    const [{ synthesizeAssociationGeometries: t2 }, { default: r3 }] = await Promise.all([import("./synthesizeAssociationGeometries-ABATQIO4.js"), import("./SynthesizeAssociationGeometriesParameters-E67VKKZ7.js")]), s5 = r3.from(e3);
    return s5.gdbVersion = this.gdbVersion, s5.moment = this.historicMoment, t2(this.networkServiceUrl, s5);
  }
  async trace(e3) {
    const [{ trace: t2 }, { default: r3 }] = await Promise.all([import("./trace-WRMG46JX.js"), import("./TraceParameters-I7RMTP27.js")]), s5 = r3.from(e3);
    return s5.gdbVersion = this.gdbVersion, s5.moment = this.historicMoment, t2(this.networkServiceUrl, s5);
  }
  async submitTraceJob(e3) {
    const [{ submitTraceJob: t2 }, { default: r3 }] = await Promise.all([import("./trace-WRMG46JX.js"), import("./TraceParameters-I7RMTP27.js")]), s5 = r3.from(e3);
    s5.gdbVersion = this.gdbVersion, s5.moment = this.historicMoment;
    const a6 = await t2(this.networkServiceUrl, s5);
    return new m3({ statusUrl: a6 });
  }
  async _loadNamedTraceConfigurationsFromNetwork(e3) {
    var _a;
    if (0 === ((_a = this.sharedNamedTraceConfigurations) == null ? void 0 : _a.length))
      return;
    const t2 = this.sharedNamedTraceConfigurations.map((e4) => e4.globalId), r3 = await this.queryNamedTraceConfigurations({ globalIds: t2 }, e3);
    for (const s5 of this.sharedNamedTraceConfigurations) {
      const e4 = r3 == null ? void 0 : r3.find((e5) => e5.globalId === s5.globalId);
      if (e4) {
        const t3 = e4.write({}, { origin: "service" });
        s5.read(t3, { origin: "service" });
      }
    }
  }
  async _createRulesTable() {
    var _a;
    const e3 = this.networkSystemLayers.rulesTableUrl, t2 = new Ze({ url: e3 });
    await t2.load();
    const r3 = (_a = this.dataElement) == null ? void 0 : _a.domainNetworks;
    if (!r3)
      return null;
    const a6 = r3.flatMap((e4) => [...e4.edgeSources, ...e4.junctionSources]), o3 = (await this._queryRulesTable(t2)).map((e4) => this._hydrateRuleInfo(t2, a6, e4));
    return new u3({ layer: t2, rules: o3 });
  }
  async _queryRulesTable(e3) {
    const t2 = new b2({ where: "1=1", outFields: ["*"] });
    return (await r2(e3, t2)).features;
  }
  _hydrateRuleInfo(e3, t2, r3) {
    const s5 = e3.fieldsIndex, a6 = s5.get("RULETYPE"), o3 = s5.get("CREATIONDATE"), i3 = s5.get("FROMNETWORKSOURCEID"), n4 = s5.get("FROMASSETGROUP"), u4 = s5.get("FROMASSETTYPE"), l5 = s5.get("FROMTERMINALID"), m4 = s5.get("TONETWORKSOURCEID"), c5 = s5.get("TOASSETGROUP"), y3 = s5.get("TOASSETTYPE"), p8 = s5.get("TOTERMINALID"), f3 = s5.get("VIANETWORKSOURCEID"), T = s5.get("VIAASSETGROUP"), h = s5.get("VIAASSETTYPE"), g3 = s5.get("VIATERMINALID"), b3 = r3.attributes[a6.name], w = new Date(r3.attributes[o3.name]), I2 = [{ networkSourceId: r3.attributes[i3.name], assetGroupId: r3.attributes[n4.name], assetTypeId: r3.attributes[u4.name], terminalId: r3.attributes[l5.name] }, { networkSourceId: r3.attributes[m4.name], assetGroupId: r3.attributes[c5.name], assetTypeId: r3.attributes[y3.name], terminalId: r3.attributes[p8.name] }, { networkSourceId: r3.attributes[f3.name], assetGroupId: r3.attributes[T.name], assetTypeId: r3.attributes[h.name], terminalId: r3.attributes[g3.name] }];
    let S2;
    !function(e4) {
      e4[e4.from = 0] = "from", e4[e4.to = 1] = "to", e4[e4.via = 2] = "via";
    }(S2 || (S2 = {}));
    const N = { ruleType: b3, creationDate: w };
    for (const k2 of [S2.from, S2.to, S2.via]) {
      if (b3 !== t.RTEdgeJunctionEdgeConnectivity && k2 === S2.via)
        continue;
      const e4 = I2[k2], r4 = t2.find((t3) => t3.sourceId === e4.networkSourceId), s6 = r4 == null ? void 0 : r4.assetGroups.find((t3) => t3.assetGroupCode === e4.assetGroupId), a7 = s6 == null ? void 0 : s6.assetTypes.find((t3) => t3.assetTypeCode === e4.assetTypeId);
      let o4 = this._getTerminal(b3, a7, e4);
      b3 !== t.RTContainment && b3 !== t.RTAttachment || (o4 = null);
      let i4 = "";
      switch (k2) {
        case S2.from:
          i4 = "from";
          break;
        case S2.to:
          i4 = "to";
          break;
        case S2.via:
          i4 = "via";
      }
      N[`${i4}NetworkSource`] = r4, N[`${i4}AssetGroup`] = s6, N[`${i4}AssetType`] = a7, N[`${i4}Terminal`] = o4 == null ? void 0 : o4.toJSON();
    }
    return N;
  }
  _getTerminal(e3, t2, r3) {
    var _a, _b;
    if (e3 === t.RTAttachment || e3 === t.RTContainment)
      return null;
    const s5 = t2 == null ? void 0 : t2.terminalConfigurationId, a6 = (_a = this.terminalConfigurations) == null ? void 0 : _a.find((e4) => e4.id === s5);
    return ((_b = a6 == null ? void 0 : a6.terminals) == null ? void 0 : _b.find((e4) => e4.id === r3.terminalId)) ?? null;
  }
};
e([y({ type: [c4], json: { origins: { "web-map": { read: { source: "traceConfigurations" }, write: { target: "traceConfigurations" } }, service: { read: { source: "traceConfigurations" } } }, read: false } })], y2.prototype, "sharedNamedTraceConfigurations", void 0), e([y({ type: ["utility"], readOnly: true, json: { read: false, write: false } })], y2.prototype, "type", void 0), e([y({ readOnly: true })], y2.prototype, "serviceTerritoryFeatureLayerId", null), e([y({ readOnly: true })], y2.prototype, "networkSystemLayers", null), e([y({ readOnly: true })], y2.prototype, "terminalConfigurations", null), e([y({ readOnly: true })], y2.prototype, "domainNetworkNames", null), y2 = e([c("esri.networks.UtilityNetwork")], y2);
var p7 = y2;

export {
  p7 as p
};
//# sourceMappingURL=chunk-RHSDZ7XK.js.map
