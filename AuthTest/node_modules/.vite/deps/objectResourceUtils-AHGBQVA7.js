import {
  t as t7
} from "./chunk-V4OCWQ27.js";
import {
  A as A2,
  S as S3,
  a as a6,
  c as c6,
  l as l6
} from "./chunk-PTWYQEPE.js";
import {
  J,
  i as i6
} from "./chunk-NQ2JVNAH.js";
import {
  R
} from "./chunk-SVJI4QHE.js";
import {
  A as A3,
  E as E4,
  L as L3,
  a as a4,
  c as c4,
  c2 as c5,
  d as d2,
  d2 as d3,
  f as f4,
  h as h3,
  h2 as h5,
  o as o5,
  o4 as o8,
  r as r9,
  r2 as r10,
  r3 as r11,
  r4 as r12,
  t3 as t8
} from "./chunk-BGMKQPOO.js";
import {
  S as S2,
  _ as _2,
  h as h4,
  o as o6,
  o2 as o7
} from "./chunk-BNTQULGG.js";
import {
  t as t6
} from "./chunk-DJ3H5D5X.js";
import "./chunk-A6KO3R3G.js";
import {
  E as E3,
  T,
  e2 as e11
} from "./chunk-T56C4ORZ.js";
import "./chunk-2CJ4SBZD.js";
import "./chunk-AALPUTPM.js";
import {
  a as a5
} from "./chunk-55WTSNPL.js";
import "./chunk-RN5RTM2J.js";
import {
  H as H3,
  ee
} from "./chunk-R4QMNBYM.js";
import "./chunk-T73MCNAU.js";
import {
  I as I2
} from "./chunk-G5UJ3AKS.js";
import {
  e as e8,
  r as r7
} from "./chunk-V76ETMKA.js";
import "./chunk-5JIGIHKI.js";
import {
  t as t2
} from "./chunk-NQ7SK7XM.js";
import "./chunk-AC7J7MCW.js";
import "./chunk-IGVJ7QLR.js";
import {
  E as E2
} from "./chunk-WM2YJJQZ.js";
import {
  f as f3,
  l2 as l4,
  n2 as n4,
  n3 as n5,
  o3,
  o4,
  t as t3,
  t2 as t4,
  u as u7
} from "./chunk-TUEI54TI.js";
import {
  r as r8
} from "./chunk-PRZWMTUS.js";
import {
  N,
  e as e9,
  n as n3,
  s as s6,
  u as u6
} from "./chunk-NB4VIBDC.js";
import {
  a as a3
} from "./chunk-RCB4CZ33.js";
import {
  H as H2
} from "./chunk-L7QWOCUD.js";
import {
  s as s5
} from "./chunk-YNB3DCUM.js";
import {
  e as e5
} from "./chunk-GLBAW5CR.js";
import "./chunk-53TKZQ46.js";
import {
  l as l3
} from "./chunk-VHDTZ7JB.js";
import {
  D,
  G as G2,
  I,
  L as L2,
  O as O3,
  c as c2
} from "./chunk-RCLKRKWR.js";
import {
  n as n2,
  r as r5,
  u as u5
} from "./chunk-GLOKOXWD.js";
import {
  e as e7
} from "./chunk-4OLZTDWK.js";
import "./chunk-JYYKU27J.js";
import "./chunk-SKLWU2B3.js";
import {
  e as e6
} from "./chunk-2RN2AAP7.js";
import {
  E,
  L,
  O as O2,
  c,
  i as i3,
  q as q2,
  u as u4,
  x,
  y
} from "./chunk-YHB3DQSV.js";
import "./chunk-ED5W63C6.js";
import "./chunk-3ON6HO7Q.js";
import {
  r as r6
} from "./chunk-VKTTTBW2.js";
import "./chunk-T3Y5GTKO.js";
import "./chunk-KWSMYM7P.js";
import {
  r as r4
} from "./chunk-AMSVADDY.js";
import {
  e as e10,
  t as t5
} from "./chunk-76KPSQLT.js";
import "./chunk-MVXU4PVF.js";
import {
  l as l5
} from "./chunk-DXAIPMHS.js";
import {
  c as c3,
  i as i5
} from "./chunk-6M5DUIJQ.js";
import "./chunk-CMGHBCKF.js";
import {
  g as g2,
  i as i4
} from "./chunk-YVNEJWNQ.js";
import "./chunk-NDKHIQMD.js";
import "./chunk-TWNBDJHC.js";
import {
  P as P2,
  h as h2
} from "./chunk-IRNKV32L.js";
import {
  G,
  H,
  h
} from "./chunk-F6MD5VOH.js";
import "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import {
  A,
  F,
  O2 as O,
  P,
  S,
  d,
  e as e3,
  e2 as e4,
  f,
  f2,
  g,
  i as i2,
  l2,
  m as m2,
  n,
  o as o2,
  q,
  r as r2,
  r2 as r3,
  s as s4,
  u2 as u3,
  z
} from "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import "./chunk-TBSVVR6M.js";
import {
  _
} from "./chunk-6TJWLWLO.js";
import "./chunk-JUZJCTW2.js";
import {
  o
} from "./chunk-423VNHLR.js";
import "./chunk-FN47E7YK.js";
import "./chunk-Y5D433JZ.js";
import "./chunk-QNOCEWCR.js";
import "./chunk-WURET5CW.js";
import "./chunk-QWPLZ3QH.js";
import "./chunk-HLGIRLYQ.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import {
  a as a2
} from "./chunk-SJZIFARA.js";
import {
  Z,
  i2 as i,
  j,
  tt
} from "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import "./chunk-LXXF7K7W.js";
import "./chunk-SBW6NNVI.js";
import {
  e as e2
} from "./chunk-62CXLI6S.js";
import {
  a,
  m,
  s as s3,
  u as u2
} from "./chunk-RFPH3ZTZ.js";
import {
  l,
  r
} from "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import {
  U,
  e,
  has,
  t4 as t,
  u
} from "./chunk-4V6374PV.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/geometry/support/FloatArray.js
function t9(n8, t14 = false) {
  return n8 <= U ? t14 ? new Array(n8).fill(0) : new Array(n8) : new Float32Array(n8);
}

// node_modules/@arcgis/core/views/3d/glTF/internal/TextureTransformUtils.js
function r13(r17) {
  if (null == r17)
    return null;
  const f7 = null != r17.offset ? r17.offset : c3, l9 = null != r17.rotation ? r17.rotation : 0, c11 = null != r17.scale ? r17.scale : i5, u12 = t5(1, 0, 0, 0, 1, 0, f7[0], f7[1], 1), i10 = t5(Math.cos(l9), -Math.sin(l9), 0, Math.sin(l9), Math.cos(l9), 0, 0, 0, 1), m6 = t5(c11[0], 0, 0, 0, c11[1], 0, 0, 0, 1), e13 = e10();
  return i4(e13, i10, m6), i4(e13, u12, e13), e13;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/ProcessedObjectResource.js
var s7 = class {
  constructor() {
    this.geometries = new Array(), this.materials = new Array(), this.textures = new Array();
  }
};
var t10 = class {
  constructor(t14, e13, r17) {
    this.name = t14, this.lodThreshold = e13, this.pivotOffset = r17, this.stageResources = new s7(), this.numberOfVertices = 0;
  }
};

// node_modules/@arcgis/core/libs/basisu/BasisU.js
function t11() {
  if (null == s8) {
    const t14 = (t15) => a2(`esri/libs/basisu/${t15}`);
    s8 = import("./basis_transcoder-HJFKOVTO.js").then((e13) => e13.b).then(({ default: e13 }) => e13({ locateFile: t14 }).then((e14) => (e14.initializeBasis(), delete e14.then, e14)));
  }
  return s8;
}
var s8;

// node_modules/@arcgis/core/libs/basisu/TextureFormat.js
var _3;
!function(_6) {
  _6[_6.ETC1_RGB = 0] = "ETC1_RGB", _6[_6.ETC2_RGBA = 1] = "ETC2_RGBA", _6[_6.BC1_RGB = 2] = "BC1_RGB", _6[_6.BC3_RGBA = 3] = "BC3_RGBA", _6[_6.BC4_R = 4] = "BC4_R", _6[_6.BC5_RG = 5] = "BC5_RG", _6[_6.BC7_M6_RGB = 6] = "BC7_M6_RGB", _6[_6.BC7_M5_RGBA = 7] = "BC7_M5_RGBA", _6[_6.PVRTC1_4_RGB = 8] = "PVRTC1_4_RGB", _6[_6.PVRTC1_4_RGBA = 9] = "PVRTC1_4_RGBA", _6[_6.ASTC_4x4_RGBA = 10] = "ASTC_4x4_RGBA", _6[_6.ATC_RGB = 11] = "ATC_RGB", _6[_6.ATC_RGBA = 12] = "ATC_RGBA", _6[_6.FXT1_RGB = 17] = "FXT1_RGB", _6[_6.PVRTC2_4_RGB = 18] = "PVRTC2_4_RGB", _6[_6.PVRTC2_4_RGBA = 19] = "PVRTC2_4_RGBA", _6[_6.ETC2_EAC_R11 = 20] = "ETC2_EAC_R11", _6[_6.ETC2_EAC_RG11 = 21] = "ETC2_EAC_RG11", _6[_6.RGBA32 = 13] = "RGBA32", _6[_6.RGB565 = 14] = "RGB565", _6[_6.BGR565 = 15] = "BGR565", _6[_6.RGBA4444 = 16] = "RGBA4444";
}(_3 || (_3 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/BasisUtil.js
var l7 = null;
var o9 = null;
async function g3() {
  return null == o9 && (o9 = t11(), l7 = await o9), o9;
}
function u8(e13, t14) {
  if (null == l7)
    return e13.byteLength;
  const n8 = new l7.BasisFile(new Uint8Array(e13)), s12 = E5(n8) ? m3(n8.getNumLevels(0), n8.getHasAlpha(), n8.getImageWidth(0, 0), n8.getImageHeight(0, 0), t14) : 0;
  return n8.close(), n8.delete(), s12;
}
function c7(e13, t14) {
  if (null == l7)
    return e13.byteLength;
  const n8 = new l7.KTX2File(new Uint8Array(e13)), s12 = T2(n8) ? m3(n8.getLevels(), n8.getHasAlpha(), n8.getWidth(), n8.getHeight(), t14) : 0;
  return n8.close(), n8.delete(), s12;
}
function m3(e13, t14, s12, r17, i10) {
  const l9 = E3(t14 ? c2.COMPRESSED_RGBA8_ETC2_EAC : c2.COMPRESSED_RGB8_ETC2), o13 = i10 && e13 > 1 ? (4 ** e13 - 1) / (3 * 4 ** (e13 - 1)) : 1;
  return Math.ceil(s12 * r17 * l9 * o13);
}
function E5(e13) {
  return e13.getNumImages() >= 1 && !e13.isUASTC();
}
function T2(e13) {
  return e13.getFaces() >= 1 && e13.isETC1S();
}
async function h6(e13, t14, n8) {
  null == l7 && (l7 = await g3());
  const s12 = new l7.BasisFile(new Uint8Array(n8));
  if (!E5(s12))
    return null;
  s12.startTranscoding();
  const r17 = p(e13, t14, s12.getNumLevels(0), s12.getHasAlpha(), s12.getImageWidth(0, 0), s12.getImageHeight(0, 0), (e14, t15) => s12.getImageTranscodedSizeInBytes(0, e14, t15), (e14, t15, n9) => s12.transcodeImage(n9, 0, e14, t15, 0, 0));
  return s12.close(), s12.delete(), r17;
}
async function _4(e13, t14, n8) {
  null == l7 && (l7 = await g3());
  const s12 = new l7.KTX2File(new Uint8Array(n8));
  if (!T2(s12))
    return null;
  s12.startTranscoding();
  const r17 = p(e13, t14, s12.getLevels(), s12.getHasAlpha(), s12.getWidth(), s12.getHeight(), (e14, t15) => s12.getImageTranscodedSizeInBytes(e14, 0, 0, t15), (e14, t15, n9) => s12.transcodeImage(n9, e14, 0, 0, t15, 0, -1, -1));
  return s12.close(), s12.delete(), r17;
}
function p(e13, a10, l9, o13, g5, u12, c11, m6) {
  const { compressedTextureETC: E10, compressedTextureS3TC: T5 } = e13.capabilities, [h10, _6] = E10 ? o13 ? [_3.ETC2_RGBA, c2.COMPRESSED_RGBA8_ETC2_EAC] : [_3.ETC1_RGB, c2.COMPRESSED_RGB8_ETC2] : T5 ? o13 ? [_3.BC3_RGBA, c2.COMPRESSED_RGBA_S3TC_DXT5_EXT] : [_3.BC1_RGB, c2.COMPRESSED_RGB_S3TC_DXT1_EXT] : [_3.RGBA32, G2.RGBA], p4 = a10.hasMipmap ? l9 : Math.min(1, l9), A6 = [];
  for (let t14 = 0; t14 < p4; t14++)
    A6.push(new Uint8Array(c11(t14, h10))), m6(t14, h10, A6[t14]);
  return a10.internalFormat = _6, a10.hasMipmap = A6.length > 1, a10.samplingMode = a10.hasMipmap ? L2.LINEAR_MIPMAP_LINEAR : L2.LINEAR, a10.width = g5, a10.height = u12, new T(e13, a10, { type: "compressed", levels: A6 });
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/DDSUtil.js
var o10 = s.getLogger("esri.views.3d.webgl-engine.lib.DDSUtil");
var a7 = 542327876;
var i7 = 131072;
var l8 = 4;
function s9(e13) {
  return e13.charCodeAt(0) + (e13.charCodeAt(1) << 8) + (e13.charCodeAt(2) << 16) + (e13.charCodeAt(3) << 24);
}
function u9(e13) {
  return String.fromCharCode(255 & e13, e13 >> 8 & 255, e13 >> 16 & 255, e13 >> 24 & 255);
}
var c8 = s9("DXT1");
var h7 = s9("DXT3");
var m4 = s9("DXT5");
var d4 = 31;
var p2 = 0;
var g4 = 1;
var D2 = 2;
var C = 3;
var f5 = 4;
var w = 7;
var T3 = 20;
var _5 = 21;
function E6(e13, r17, o13) {
  const a10 = S4(o13, r17.hasMipmap ?? false);
  if (null == a10)
    throw new Error("DDS texture data is null");
  const { textureData: i10, internalFormat: l9, width: s12, height: u12 } = a10;
  return r17.samplingMode = i10.levels.length > 1 ? L2.LINEAR_MIPMAP_LINEAR : L2.LINEAR, r17.hasMipmap = i10.levels.length > 1, r17.internalFormat = l9, r17.width = s12, r17.height = u12, new T(e13, r17, i10);
}
function S4(e13, t14) {
  const n8 = new Int32Array(e13, 0, d4);
  if (n8[p2] !== a7)
    return o10.error("Invalid magic number in DDS header"), null;
  if (!(n8[T3] & l8))
    return o10.error("Unsupported format, must contain a FourCC code"), null;
  const s12 = n8[_5];
  let E10, S7;
  switch (s12) {
    case c8:
      E10 = 8, S7 = c2.COMPRESSED_RGB_S3TC_DXT1_EXT;
      break;
    case h7:
      E10 = 16, S7 = c2.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      break;
    case m4:
      E10 = 16, S7 = c2.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      break;
    default:
      return o10.error("Unsupported FourCC code:", u9(s12)), null;
  }
  let A6 = 1, M4 = n8[f5], x2 = n8[C];
  0 == (3 & M4) && 0 == (3 & x2) || (o10.warn("Rounding up compressed texture size to nearest multiple of 4."), M4 = M4 + 3 & -4, x2 = x2 + 3 & -4);
  const R5 = M4, X2 = x2;
  let b2, I6;
  n8[D2] & i7 && false !== t14 && (A6 = Math.max(1, n8[w]));
  let v3 = n8[g4] + 4;
  const F2 = [];
  for (let r17 = 0; r17 < A6; ++r17)
    I6 = (M4 + 3 >> 2) * (x2 + 3 >> 2) * E10, b2 = new Uint8Array(e13, v3, I6), F2.push(b2), v3 += I6, M4 = Math.max(1, M4 >> 1), x2 = Math.max(1, x2 >> 1);
  return { textureData: { type: "compressed", levels: F2 }, internalFormat: S7, width: R5, height: X2 };
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/textureUtils.js
function i8(t14, e13) {
  const n8 = 1048576, i10 = 4096, h10 = 2;
  let o13 = t14.width * t14.height;
  if (o13 < i10)
    return t14 instanceof ImageData ? a8(t14) : t14;
  let c11 = t14.width, u12 = t14.height;
  do {
    c11 = Math.ceil(c11 / h10), u12 = Math.ceil(u12 / h10), o13 = c11 * u12;
  } while (o13 > n8 || null != e13 && (c11 > e13 || u12 > e13));
  return r14(t14, c11, u12);
}
function h8(t14, e13) {
  const n8 = Math.max(t14.width, t14.height);
  if (n8 <= e13)
    return t14;
  const i10 = e13 / n8;
  return r14(t14, Math.round(t14.width * i10), Math.round(t14.height * i10));
}
function r14(t14, e13, n8) {
  if (t14 instanceof ImageData)
    return r14(a8(t14), e13, n8);
  const i10 = document.createElement("canvas");
  i10.width = e13, i10.height = n8;
  return i10.getContext("2d").drawImage(t14, 0, 0, i10.width, i10.height), i10;
}
function a8(e13) {
  const n8 = document.createElement("canvas");
  n8.width = e13.width, n8.height = e13.height;
  const i10 = n8.getContext("2d");
  if (null == i10)
    throw new s2("Failed to create 2d context from HTMLCanvasElement");
  return i10.putImageData(e13, 0, 0), n8;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Texture.js
var N2 = class extends r7 {
  get parameters() {
    return this._parameters;
  }
  constructor(e13, r17) {
    super(), this._data = e13, this.type = e8.Texture, this._glTexture = null, this._loadingPromise = null, this._loadingController = null, this.events = new o(), this._parameters = { ...M, ...r17 }, this._startPreload(e13);
  }
  dispose() {
    this.unload(), this._data = this.frameUpdate = void 0;
  }
  _startPreload(e13) {
    null != e13 && (e13 instanceof HTMLVideoElement ? (this.frameUpdate = (t14) => this._frameUpdate(e13, t14), this._startPreloadVideoElement(e13)) : e13 instanceof HTMLImageElement && this._startPreloadImageElement(e13));
  }
  _startPreloadVideoElement(e13) {
    if (!(Z(e13.src) || "auto" === e13.preload && e13.crossOrigin)) {
      e13.preload = "auto", e13.crossOrigin = "anonymous";
      const t14 = !e13.paused;
      if (e13.src = e13.src, t14 && e13.autoplay) {
        const t15 = () => {
          e13.removeEventListener("canplay", t15), e13.play();
        };
        e13.addEventListener("canplay", t15);
      }
    }
  }
  _startPreloadImageElement(e13) {
    tt(e13.src) || Z(e13.src) || e13.crossOrigin || (e13.crossOrigin = "anonymous", e13.src = e13.src);
  }
  _createDescriptor(e13) {
    const t14 = new e11();
    return t14.wrapMode = this._parameters.wrap ?? D.REPEAT, t14.flipped = !this._parameters.noUnpackFlip, t14.samplingMode = this._parameters.mipmap ? L2.LINEAR_MIPMAP_LINEAR : L2.LINEAR, t14.hasMipmap = !!this._parameters.mipmap, t14.preMultiplyAlpha = !!this._parameters.preMultiplyAlpha, t14.maxAnisotropy = this._parameters.maxAnisotropy ?? (this._parameters.mipmap ? e13.parameters.maxMaxAnisotropy : 1), t14;
  }
  get glTexture() {
    return this._glTexture;
  }
  get memoryEstimate() {
    var _a;
    return ((_a = this._glTexture) == null ? void 0 : _a.gpuMemoryUsage) || C2(this._data, this._parameters);
  }
  load(e13) {
    if (this._glTexture)
      return this._glTexture;
    if (this._loadingPromise)
      return this._loadingPromise;
    const t14 = this._data;
    return null == t14 ? (this._glTexture = new T(e13, this._createDescriptor(e13), null), this._glTexture) : (this._parameters.reloadable || (this._data = void 0), "string" == typeof t14 ? this._loadFromURL(e13, t14) : t14 instanceof Image ? this._loadFromImageElement(e13, t14) : t14 instanceof HTMLVideoElement ? this._loadFromVideoElement(e13, t14) : t14 instanceof ImageData || t14 instanceof HTMLCanvasElement ? this._loadFromImage(e13, t14) : (t(t14) || u(t14)) && this._parameters.encoding === u6.DDS_ENCODING ? this._loadFromDDSData(e13, t14) : (t(t14) || u(t14)) && this._parameters.encoding === u6.KTX2_ENCODING ? this._loadFromKTX2(e13, t14) : (t(t14) || u(t14)) && this._parameters.encoding === u6.BASIS_ENCODING ? this._loadFromBasis(e13, t14) : u(t14) ? this._loadFromPixelData(e13, t14) : t(t14) ? this._loadFromPixelData(e13, new Uint8Array(t14)) : null);
  }
  _frameUpdate(e13, t14) {
    return null == this._glTexture || e13.readyState < V.HAVE_CURRENT_DATA || t14 === e13.currentTime ? t14 : (this._glTexture.setData(e13), this._glTexture.descriptor.hasMipmap && this._glTexture.generateMipmap(), this._parameters.updateCallback && this._parameters.updateCallback(), e13.currentTime);
  }
  _loadFromDDSData(e13, t14) {
    return this._glTexture = E6(e13, this._createDescriptor(e13), t14), this._glTexture;
  }
  _loadFromKTX2(e13, t14) {
    return this._loadAsync(() => _4(e13, this._createDescriptor(e13), t14).then((e14) => (this._glTexture = e14, e14)));
  }
  _loadFromBasis(e13, t14) {
    return this._loadAsync(() => h6(e13, this._createDescriptor(e13), t14).then((e14) => (this._glTexture = e14, e14)));
  }
  _loadFromPixelData(e13, t14) {
    s5(this._parameters.width > 0 && this._parameters.height > 0);
    const r17 = this._createDescriptor(e13);
    return r17.pixelFormat = 1 === this._parameters.components ? G2.LUMINANCE : 3 === this._parameters.components ? G2.RGB : G2.RGBA, r17.width = this._parameters.width ?? 0, r17.height = this._parameters.height ?? 0, this._glTexture = new T(e13, r17, t14), this._glTexture;
  }
  _loadFromURL(e13, t14) {
    return this._loadAsync(async (r17) => {
      const s12 = await t7(t14, { signal: r17 });
      return s3(r17), this._loadFromImage(e13, s12);
    });
  }
  _loadFromImageElement(e13, t14) {
    return t14.complete ? this._loadFromImage(e13, t14) : this._loadAsync(async (r17) => {
      const s12 = await i(t14, t14.src, false, r17);
      return s3(r17), this._loadFromImage(e13, s12);
    });
  }
  _loadFromVideoElement(e13, t14) {
    return t14.readyState >= V.HAVE_CURRENT_DATA ? this._loadFromImage(e13, t14) : this._loadFromVideoElementAsync(e13, t14);
  }
  _loadFromVideoElementAsync(t14, r17) {
    return this._loadAsync((a10) => new Promise((n8, l9) => {
      const m6 = () => {
        r17.removeEventListener("loadeddata", h10), r17.removeEventListener("error", _6), l(p4);
      }, h10 = () => {
        r17.readyState >= V.HAVE_CURRENT_DATA && (m6(), n8(this._loadFromImage(t14, r17)));
      }, _6 = (t15) => {
        m6(), l9(t15 || new s2("Failed to load video"));
      };
      r17.addEventListener("loadeddata", h10), r17.addEventListener("error", _6);
      const p4 = m(a10, () => _6(u2()));
    }));
  }
  _loadFromImage(e13, t14) {
    let r17 = t14;
    if (!(r17 instanceof HTMLVideoElement)) {
      const { maxTextureSize: t15 } = e13.parameters;
      r17 = this._parameters.downsampleUncompressed ? i8(r17, t15) : h8(r17, t15);
    }
    const s12 = R2(r17);
    this._parameters.width = s12.width, this._parameters.height = s12.height;
    const a10 = this._createDescriptor(e13);
    return a10.pixelFormat = 3 === this._parameters.components ? G2.RGB : G2.RGBA, a10.width = s12.width, a10.height = s12.height, this._glTexture = new T(e13, a10, r17), this._glTexture;
  }
  _loadAsync(e13) {
    const t14 = new AbortController();
    this._loadingController = t14;
    const r17 = e13(t14.signal);
    this._loadingPromise = r17;
    const s12 = () => {
      this._loadingController === t14 && (this._loadingController = null), this._loadingPromise === r17 && (this._loadingPromise = null);
    };
    return r17.then(s12, s12), r17;
  }
  unload() {
    if (this._glTexture = r(this._glTexture), null != this._loadingController) {
      const e13 = this._loadingController;
      this._loadingController = null, this._loadingPromise = null, e13.abort();
    }
    this.events.emit("unloaded");
  }
};
function C2(e13, t14) {
  if (null == e13)
    return 0;
  if (t(e13) || u(e13))
    return t14.encoding === u6.KTX2_ENCODING ? c7(e13, !!t14.mipmap) : t14.encoding === u6.BASIS_ENCODING ? u8(e13, !!t14.mipmap) : e13.byteLength;
  const { width: r17, height: s12 } = e13 instanceof Image || e13 instanceof ImageData || e13 instanceof HTMLCanvasElement || e13 instanceof HTMLVideoElement ? R2(e13) : t14;
  return (t14.mipmap ? 4 / 3 : 1) * r17 * s12 * (t14.components || 4) || 0;
}
function R2(e13) {
  return e13 instanceof HTMLVideoElement ? { width: e13.videoWidth, height: e13.videoHeight } : e13;
}
var V;
!function(e13) {
  e13[e13.HAVE_NOTHING = 0] = "HAVE_NOTHING", e13[e13.HAVE_METADATA = 1] = "HAVE_METADATA", e13[e13.HAVE_CURRENT_DATA = 2] = "HAVE_CURRENT_DATA", e13[e13.HAVE_FUTURE_DATA = 3] = "HAVE_FUTURE_DATA", e13[e13.HAVE_ENOUGH_DATA = 4] = "HAVE_ENOUGH_DATA";
}(V || (V = {}));
var M = { wrap: { s: D.REPEAT, t: D.REPEAT }, mipmap: true, noUnpackFlip: false, preMultiplyAlpha: false, downsampleUncompressed: false };

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/verticalOffsetUtils.js
var d5 = class {
  constructor(t14 = 0) {
    this.offset = t14, this.tmpVertex = n();
  }
  applyToVertex(t14, s12, r17) {
    const e13 = o2(R3, t14, s12, r17), o13 = u3(q3, e13, this.localOrigin), i10 = this.offset / s4(o13);
    return q(this.tmpVertex, e13, o13, i10), this.tmpVertex;
  }
  applyToAabb(t14) {
    const s12 = B, r17 = D3, e13 = G3;
    for (let a10 = 0; a10 < 3; ++a10)
      s12[a10] = t14[0 + a10] + this.localOrigin[a10], r17[a10] = t14[3 + a10] + this.localOrigin[a10], e13[a10] = s12[a10];
    const o13 = this.applyToVertex(s12[0], s12[1], s12[2]);
    for (let a10 = 0; a10 < 3; ++a10)
      t14[a10] = o13[a10], t14[a10 + 3] = o13[a10];
    const i10 = (s13) => {
      const r18 = this.applyToVertex(s13[0], s13[1], s13[2]);
      for (let e14 = 0; e14 < 3; ++e14)
        t14[e14] = Math.min(t14[e14], r18[e14]), t14[e14 + 3] = Math.max(t14[e14 + 3], r18[e14]);
    };
    for (let a10 = 1; a10 < 8; ++a10) {
      for (let t15 = 0; t15 < 3; ++t15)
        e13[t15] = 0 == (a10 & 1 << t15) ? s12[t15] : r17[t15];
      i10(e13);
    }
    let n8 = 0;
    for (let a10 = 0; a10 < 3; ++a10) {
      s12[a10] * r17[a10] < 0 && (n8 |= 1 << a10);
    }
    if (0 !== n8 && 7 !== n8) {
      for (let a10 = 0; a10 < 8; ++a10)
        if (0 == (n8 & a10)) {
          for (let t15 = 0; t15 < 3; ++t15)
            e13[t15] = 0 != (n8 & 1 << t15) ? 0 : 0 != (a10 & 1 << t15) ? s12[t15] : r17[t15];
          i10(e13);
        }
    }
    for (let a10 = 0; a10 < 3; ++a10)
      t14[a10] -= this.localOrigin[a10], t14[a10 + 3] -= this.localOrigin[a10];
    return t14;
  }
};
var V2 = class {
  constructor(t14 = 0) {
    this.componentLocalOriginLength = 0, this._tmpVertex = n(), this._mbs = E2(), this._obb = H3(), this._totalOffset = 0, this._offset = 0, this._resetOffset(t14);
  }
  _resetOffset(t14) {
    this._offset = t14, this._totalOffset = t14;
  }
  set offset(t14) {
    this._resetOffset(t14);
  }
  get offset() {
    return this._offset;
  }
  set componentOffset(t14) {
    this._totalOffset = this._offset + t14;
  }
  set localOrigin(t14) {
    this.componentLocalOriginLength = s4(t14);
  }
  applyToVertex(t14, s12, r17) {
    const e13 = o2(R3, t14, s12, r17), o13 = o2(q3, t14, s12, r17 + this.componentLocalOriginLength), i10 = this._totalOffset / s4(o13);
    return q(this._tmpVertex, e13, o13, i10), this._tmpVertex;
  }
  applyToAabb(t14) {
    const s12 = o2(R3, t14[0], t14[1], t14[2] + this.componentLocalOriginLength), r17 = o2(q3, t14[3], t14[4], t14[5] + this.componentLocalOriginLength), e13 = l2(B, s12), o13 = l2(D3, r17), i10 = f2(G3, s12), n8 = f2(S5, r17), f7 = m2(C3, i10, n8);
    f7[0] = e13[0] * o13[0] < 0 ? 0 : f7[0], f7[1] = e13[1] * o13[1] < 0 ? 0 : f7[1], f7[2] = e13[2] * o13[2] < 0 ? 0 : f7[2];
    const l9 = s4(f7);
    if (l9 < this._totalOffset)
      return t14[0] -= s12[0] < 0 ? this._totalOffset : 0, t14[1] -= s12[1] < 0 ? this._totalOffset : 0, t14[2] -= s12[2] < 0 ? this._totalOffset : 0, t14[3] += r17[0] > 0 ? this._totalOffset : 0, t14[4] += r17[1] > 0 ? this._totalOffset : 0, t14[5] += r17[2] > 0 ? this._totalOffset : 0, t14;
    const u12 = d(C3, i10, n8), v3 = s4(u12), O6 = this._totalOffset / v3, g5 = this._totalOffset / l9;
    return t14[0] += s12[0] * (s12[0] > 0 ? O6 : g5), t14[1] += s12[1] * (s12[1] > 0 ? O6 : g5), t14[2] += s12[2] * (s12[2] > 0 ? O6 : g5), t14[3] += r17[0] * (r17[0] < 0 ? O6 : g5), t14[4] += r17[1] * (r17[1] < 0 ? O6 : g5), t14[5] += r17[2] * (r17[2] < 0 ? O6 : g5), t14;
  }
  applyToMbs(t14) {
    const s12 = s4(t14), r17 = this._totalOffset / s12;
    return q(this._mbs, t14, t14, r17), this._mbs[3] = t14[3] + t14[3] * this._totalOffset / s12, this._mbs;
  }
  applyToObb(t14) {
    return ee(t14, this._totalOffset, this._totalOffset, l5.Global, this._obb), this._obb;
  }
};
var L4 = class {
  constructor(t14 = 0) {
    this.offset = t14, this.sphere = E2(), this.tmpVertex = n();
  }
  applyToVertex(t14, s12, r17) {
    const e13 = this.objectTransform.transform, o13 = o2(R3, t14, s12, r17), i10 = O(o13, o13, e13), n8 = this.offset / s4(i10);
    q(i10, i10, i10, n8);
    const f7 = this.objectTransform.inverse;
    return O(this.tmpVertex, i10, f7), this.tmpVertex;
  }
  applyToMinMax(t14, s12) {
    const r17 = this.offset / s4(t14);
    q(t14, t14, t14, r17);
    const e13 = this.offset / s4(s12);
    q(s12, s12, s12, e13);
  }
  applyToAabb(t14) {
    const s12 = this.offset / Math.sqrt(t14[0] * t14[0] + t14[1] * t14[1] + t14[2] * t14[2]);
    t14[0] += t14[0] * s12, t14[1] += t14[1] * s12, t14[2] += t14[2] * s12;
    const r17 = this.offset / Math.sqrt(t14[3] * t14[3] + t14[4] * t14[4] + t14[5] * t14[5]);
    return t14[3] += t14[3] * r17, t14[4] += t14[4] * r17, t14[5] += t14[5] * r17, t14;
  }
  applyToBoundingSphere(t14) {
    const s12 = s4(t14), r17 = this.offset / s12;
    return q(this.sphere, t14, t14, r17), this.sphere[3] = t14[3] + t14[3] * this.offset / s12, this.sphere;
  }
};
var j2 = new L4();
function I3(t14) {
  return null != t14 ? (j2.offset = t14, j2) : null;
}
var M2 = new V2();
var k = new d5();
var R3 = n();
var q3 = n();
var B = n();
var D3 = n();
var G3 = n();
var S5 = n();
var C3 = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/internal/bufferWriterUtils.js
function u10(e13, t14, f7) {
  const { data: o13, indices: r17 } = e13, i10 = t14.typedBuffer, s12 = t14.typedBufferStride, n8 = r17.length;
  f7 *= s12;
  for (let c11 = 0; c11 < n8; ++c11) {
    const e14 = 2 * r17[c11];
    i10[f7] = o13[e14], i10[f7 + 1] = o13[e14 + 1], f7 += s12;
  }
}
function a9(e13, t14, f7, o13) {
  const { data: r17, indices: i10 } = e13, s12 = t14.typedBuffer, n8 = t14.typedBufferStride, c11 = i10.length;
  if (f7 *= n8, null == o13 || 1 === o13)
    for (let l9 = 0; l9 < c11; ++l9) {
      const e14 = 3 * i10[l9];
      s12[f7] = r17[e14], s12[f7 + 1] = r17[e14 + 1], s12[f7 + 2] = r17[e14 + 2], f7 += n8;
    }
  else
    for (let l9 = 0; l9 < c11; ++l9) {
      const e14 = 3 * i10[l9];
      for (let t15 = 0; t15 < o13; ++t15)
        s12[f7] = r17[e14], s12[f7 + 1] = r17[e14 + 1], s12[f7 + 2] = r17[e14 + 2], f7 += n8;
    }
}
function p3(e13, t14, f7, o13 = 1) {
  const { data: r17, indices: i10 } = e13, s12 = t14.typedBuffer, n8 = t14.typedBufferStride, c11 = i10.length;
  if (f7 *= n8, 1 === o13)
    for (let l9 = 0; l9 < c11; ++l9) {
      const e14 = 4 * i10[l9];
      s12[f7] = r17[e14], s12[f7 + 1] = r17[e14 + 1], s12[f7 + 2] = r17[e14 + 2], s12[f7 + 3] = r17[e14 + 3], f7 += n8;
    }
  else
    for (let l9 = 0; l9 < c11; ++l9) {
      const e14 = 4 * i10[l9];
      for (let t15 = 0; t15 < o13; ++t15)
        s12[f7] = r17[e14], s12[f7 + 1] = r17[e14 + 1], s12[f7 + 2] = r17[e14 + 2], s12[f7 + 3] = r17[e14 + 3], f7 += n8;
    }
}
function b(t14, f7, o13, r17, i10 = 1) {
  if (!f7)
    return void a9(t14, o13, r17, i10);
  const { data: s12, indices: n8 } = t14, c11 = o13.typedBuffer, l9 = o13.typedBufferStride, d6 = n8.length, u12 = f7[0], p4 = f7[1], y4 = f7[2], B3 = f7[4], g5 = f7[5], b2 = f7[6], O6 = f7[8], h10 = f7[9], S7 = f7[10], N5 = f7[12], R5 = f7[13], E10 = f7[14];
  r17 *= l9;
  let A6 = 0, L6 = 0, z4 = 0;
  const F2 = H(f7) ? (e13) => {
    A6 = s12[e13] + N5, L6 = s12[e13 + 1] + R5, z4 = s12[e13 + 2] + E10;
  } : (e13) => {
    const t15 = s12[e13], f8 = s12[e13 + 1], o14 = s12[e13 + 2];
    A6 = u12 * t15 + B3 * f8 + O6 * o14 + N5, L6 = p4 * t15 + g5 * f8 + h10 * o14 + R5, z4 = y4 * t15 + b2 * f8 + S7 * o14 + E10;
  };
  if (1 === i10)
    for (let e13 = 0; e13 < d6; ++e13)
      F2(3 * n8[e13]), c11[r17] = A6, c11[r17 + 1] = L6, c11[r17 + 2] = z4, r17 += l9;
  else
    for (let e13 = 0; e13 < d6; ++e13) {
      F2(3 * n8[e13]);
      for (let e14 = 0; e14 < i10; ++e14)
        c11[r17] = A6, c11[r17 + 1] = L6, c11[r17 + 2] = z4, r17 += l9;
    }
}
function O4(f7, o13, r17, i10, s12 = 1) {
  if (!o13)
    return void a9(f7, r17, i10, s12);
  const { data: n8, indices: c11 } = f7, l9 = o13, d6 = r17.typedBuffer, u12 = r17.typedBufferStride, p4 = c11.length, y4 = l9[0], B3 = l9[1], g5 = l9[2], b2 = l9[4], O6 = l9[5], h10 = l9[6], S7 = l9[8], N5 = l9[9], R5 = l9[10], E10 = !G(l9), A6 = 1e-6, L6 = 1 - A6;
  i10 *= u12;
  let z4 = 0, F2 = 0, I6 = 0;
  const T5 = H(l9) ? (e13) => {
    z4 = n8[e13], F2 = n8[e13 + 1], I6 = n8[e13 + 2];
  } : (e13) => {
    const t14 = n8[e13], f8 = n8[e13 + 1], o14 = n8[e13 + 2];
    z4 = y4 * t14 + b2 * f8 + S7 * o14, F2 = B3 * t14 + O6 * f8 + N5 * o14, I6 = g5 * t14 + h10 * f8 + R5 * o14;
  };
  if (1 === s12)
    if (E10)
      for (let e13 = 0; e13 < p4; ++e13) {
        T5(3 * c11[e13]);
        const t14 = z4 * z4 + F2 * F2 + I6 * I6;
        if (t14 < L6 && t14 > A6) {
          const e14 = 1 / Math.sqrt(t14);
          d6[i10] = z4 * e14, d6[i10 + 1] = F2 * e14, d6[i10 + 2] = I6 * e14;
        } else
          d6[i10] = z4, d6[i10 + 1] = F2, d6[i10 + 2] = I6;
        i10 += u12;
      }
    else
      for (let e13 = 0; e13 < p4; ++e13)
        T5(3 * c11[e13]), d6[i10] = z4, d6[i10 + 1] = F2, d6[i10 + 2] = I6, i10 += u12;
  else
    for (let e13 = 0; e13 < p4; ++e13) {
      if (T5(3 * c11[e13]), E10) {
        const e14 = z4 * z4 + F2 * F2 + I6 * I6;
        if (e14 < L6 && e14 > A6) {
          const t14 = 1 / Math.sqrt(e14);
          z4 *= t14, F2 *= t14, I6 *= t14;
        }
      }
      for (let e14 = 0; e14 < s12; ++e14)
        d6[i10] = z4, d6[i10 + 1] = F2, d6[i10 + 2] = I6, i10 += u12;
    }
}
function h9(e13, f7, o13, r17, i10 = 1) {
  if (!f7)
    return void p3(e13, o13, r17, i10);
  const { data: s12, indices: n8 } = e13, c11 = f7, l9 = o13.typedBuffer, d6 = o13.typedBufferStride, u12 = n8.length, a10 = c11[0], y4 = c11[1], B3 = c11[2], g5 = c11[4], b2 = c11[5], O6 = c11[6], h10 = c11[8], S7 = c11[9], N5 = c11[10], R5 = !G(c11), E10 = 1e-6, A6 = 1 - E10;
  if (r17 *= d6, 1 === i10)
    for (let t14 = 0; t14 < u12; ++t14) {
      const e14 = 4 * n8[t14], f8 = s12[e14], o14 = s12[e14 + 1], i11 = s12[e14 + 2], c12 = s12[e14 + 3];
      let u13 = a10 * f8 + g5 * o14 + h10 * i11, p4 = y4 * f8 + b2 * o14 + S7 * i11, L6 = B3 * f8 + O6 * o14 + N5 * i11;
      if (R5) {
        const e15 = u13 * u13 + p4 * p4 + L6 * L6;
        if (e15 < A6 && e15 > E10) {
          const t15 = 1 / Math.sqrt(e15);
          u13 *= t15, p4 *= t15, L6 *= t15;
        }
      }
      l9[r17] = u13, l9[r17 + 1] = p4, l9[r17 + 2] = L6, l9[r17 + 3] = c12, r17 += d6;
    }
  else
    for (let t14 = 0; t14 < u12; ++t14) {
      const e14 = 4 * n8[t14], f8 = s12[e14], o14 = s12[e14 + 1], c12 = s12[e14 + 2], u13 = s12[e14 + 3];
      let p4 = a10 * f8 + g5 * o14 + h10 * c12, L6 = y4 * f8 + b2 * o14 + S7 * c12, z4 = B3 * f8 + O6 * o14 + N5 * c12;
      if (R5) {
        const e15 = p4 * p4 + L6 * L6 + z4 * z4;
        if (e15 < A6 && e15 > E10) {
          const t15 = 1 / Math.sqrt(e15);
          p4 *= t15, L6 *= t15, z4 *= t15;
        }
      }
      for (let t15 = 0; t15 < i10; ++t15)
        l9[r17] = p4, l9[r17 + 1] = L6, l9[r17 + 2] = z4, l9[r17 + 3] = u13, r17 += d6;
    }
}
function S6(e13, t14, f7, o13, r17 = 1) {
  const { data: i10, indices: s12 } = e13, n8 = f7.typedBuffer, c11 = f7.typedBufferStride, l9 = s12.length;
  if (o13 *= c11, t14 !== i10.length || 4 !== t14)
    if (1 !== r17)
      if (4 !== t14)
        for (let d6 = 0; d6 < l9; ++d6) {
          const e14 = 3 * s12[d6];
          for (let t15 = 0; t15 < r17; ++t15)
            n8[o13] = i10[e14], n8[o13 + 1] = i10[e14 + 1], n8[o13 + 2] = i10[e14 + 2], n8[o13 + 3] = 255, o13 += c11;
        }
      else
        for (let d6 = 0; d6 < l9; ++d6) {
          const e14 = 4 * s12[d6];
          for (let t15 = 0; t15 < r17; ++t15)
            n8[o13] = i10[e14], n8[o13 + 1] = i10[e14 + 1], n8[o13 + 2] = i10[e14 + 2], n8[o13 + 3] = i10[e14 + 3], o13 += c11;
        }
    else {
      if (4 === t14) {
        for (let e14 = 0; e14 < l9; ++e14) {
          const t15 = 4 * s12[e14];
          n8[o13] = i10[t15], n8[o13 + 1] = i10[t15 + 1], n8[o13 + 2] = i10[t15 + 2], n8[o13 + 3] = i10[t15 + 3], o13 += c11;
        }
        return;
      }
      for (let e14 = 0; e14 < l9; ++e14) {
        const t15 = 3 * s12[e14];
        n8[o13] = i10[t15], n8[o13 + 1] = i10[t15 + 1], n8[o13 + 2] = i10[t15 + 2], n8[o13 + 3] = 255, o13 += c11;
      }
    }
  else {
    n8[o13] = i10[0], n8[o13 + 1] = i10[1], n8[o13 + 2] = i10[2], n8[o13 + 3] = i10[3];
    const e14 = new Uint32Array(f7.typedBuffer.buffer, f7.start), t15 = c11 / 4, s13 = e14[o13 /= 4];
    o13 += t15;
    const d6 = l9 * r17;
    for (let f8 = 1; f8 < d6; ++f8)
      e14[o13] = s13, o13 += t15;
  }
}
function N3(e13, t14, f7) {
  const { data: o13, indices: r17 } = e13, i10 = t14.typedBuffer, s12 = t14.typedBufferStride, n8 = r17.length, c11 = o13[0];
  f7 *= s12;
  for (let l9 = 0; l9 < n8; ++l9)
    i10[f7] = c11, f7 += s12;
}
function R4(e13, t14, f7, o13, r17 = 1) {
  const i10 = t14.typedBuffer, s12 = t14.typedBufferStride;
  if (o13 *= s12, 1 === r17)
    for (let n8 = 0; n8 < f7; ++n8)
      i10[o13] = e13[0], i10[o13 + 1] = e13[1], i10[o13 + 2] = e13[2], i10[o13 + 3] = e13[3], o13 += s12;
  else
    for (let n8 = 0; n8 < f7; ++n8)
      for (let t15 = 0; t15 < r17; ++t15)
        i10[o13] = e13[0], i10[o13 + 1] = e13[1], i10[o13 + 2] = e13[2], i10[o13 + 3] = e13[3], o13 += s12;
}
function E7(e13, t14, o13, r17, i10, s12) {
  var _a;
  for (const n8 of t14.fields.keys()) {
    const t15 = e13.attributes.get(n8), c11 = t15 == null ? void 0 : t15.indices;
    if (t15 && c11)
      A4(n8, t15, o13, r17, i10, s12);
    else if (n8 === e5.OBJECTANDLAYERIDCOLOR && null != e13.objectAndLayerIdColor) {
      const t16 = (_a = e13.attributes.get(e5.POSITION)) == null ? void 0 : _a.indices;
      if (t16) {
        const o14 = t16.length, r18 = i10.getField(n8, x);
        R4(e13.objectAndLayerIdColor, r18, o14, s12);
      }
    }
  }
}
function A4(e13, t14, d6, a10, y4, B3) {
  switch (e13) {
    case e5.POSITION: {
      s5(3 === t14.size);
      const f7 = y4.getField(e13, i3);
      s5(!!f7, `No buffer view for ${e13}`), f7 && b(t14, d6, f7, B3);
      break;
    }
    case e5.NORMAL: {
      s5(3 === t14.size);
      const f7 = y4.getField(e13, i3);
      s5(!!f7, `No buffer view for ${e13}`), f7 && O4(t14, a10, f7, B3);
      break;
    }
    case e5.NORMALCOMPRESSED: {
      s5(2 === t14.size);
      const f7 = y4.getField(e13, q2);
      s5(!!f7, `No buffer view for ${e13}`), f7 && u10(t14, f7, B3);
      break;
    }
    case e5.UV0: {
      s5(2 === t14.size);
      const f7 = y4.getField(e13, u4);
      s5(!!f7, `No buffer view for ${e13}`), f7 && u10(t14, f7, B3);
      break;
    }
    case e5.COLOR:
    case e5.SYMBOLCOLOR: {
      const o13 = y4.getField(e13, x);
      s5(!!o13, `No buffer view for ${e13}`), s5(3 === t14.size || 4 === t14.size), !o13 || 3 !== t14.size && 4 !== t14.size || S6(t14, t14.size, o13, B3);
      break;
    }
    case e5.COLORFEATUREATTRIBUTE: {
      const f7 = y4.getField(e13, y);
      s5(!!f7, `No buffer view for ${e13}`), s5(1 === t14.size), f7 && 1 === t14.size && N3(t14, f7, B3);
      break;
    }
    case e5.TANGENT: {
      s5(4 === t14.size);
      const f7 = y4.getField(e13, c);
      s5(!!f7, `No buffer view for ${e13}`), f7 && h9(t14, a10, f7, B3);
      break;
    }
    case e5.PROFILERIGHT:
    case e5.PROFILEUP:
    case e5.PROFILEVERTEXANDNORMAL:
    case e5.FEATUREVALUE: {
      s5(4 === t14.size);
      const f7 = y4.getField(e13, c);
      s5(!!f7, `No buffer view for ${e13}`), f7 && p3(t14, f7, B3);
    }
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/DefaultBufferWriter.js
var r15 = class {
  constructor(t14) {
    this.vertexBufferLayout = t14;
  }
  elementCount(e13) {
    return e13.attributes.get(e5.POSITION).indices.length;
  }
  write(t14, r17, i10, o13, s12) {
    E7(i10, this.vertexBufferLayout, t14, r17, o13, s12);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/StencilUtils.js
var i9 = { func: O3.LESS };
var s10 = { func: O3.ALWAYS };
var e12 = { mask: 255 };
var f6 = { function: { func: O3.ALWAYS, ref: N.OutlineVisualElementMask, mask: N.OutlineVisualElementMask }, operation: { fail: I.KEEP, zFail: I.KEEP, zPass: I.ZERO } };
var o12 = { function: { func: O3.ALWAYS, ref: N.OutlineVisualElementMask, mask: N.OutlineVisualElementMask }, operation: { fail: I.KEEP, zFail: I.KEEP, zPass: I.REPLACE } };
var P3 = { function: { func: O3.EQUAL, ref: N.OutlineVisualElementMask, mask: N.OutlineVisualElementMask }, operation: { fail: I.KEEP, zFail: I.KEEP, zPass: I.KEEP } };
var m5 = { function: { func: O3.NOTEQUAL, ref: N.OutlineVisualElementMask, mask: N.OutlineVisualElementMask }, operation: { fail: I.KEEP, zFail: I.KEEP, zPass: I.KEEP } };

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/pbrUtils.js
function u11({ normalTexture: u12, metallicRoughnessTexture: n8, metallicFactor: r17, roughnessFactor: s12, emissiveTexture: o13, emissiveFactor: t14, occlusionTexture: c11 }) {
  return null == u12 && null == n8 && null == o13 && (null == t14 || F(t14, f)) && null == c11 && (null == s12 || 1 === s12) && (null == r17 || 1 === r17 || 0 === r17);
}
var n7 = [1, 1, 0.5];
var r16 = [0, 0.6, 0.2];
var s11 = [0, 1, 0.2];

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/DefaultMaterialTechnique.js
var k2 = class extends f4 {
  constructor() {
    super(...arguments), this.isSchematic = false, this.usePBR = false, this.mrrFactors = e3(n7), this.hasVertexColors = false, this.hasSymbolColors = false, this.doubleSided = false, this.doubleSidedType = "normal", this.cullFace = e9.Back, this.isInstanced = false, this.hasInstancedColor = false, this.emissiveFactor = r2(0, 0, 0), this.instancedDoublePrecision = false, this.normalType = a4.Attribute, this.receiveShadows = true, this.castShadows = true, this.shadowMappingEnabled = false, this.ambient = r2(0.2, 0.2, 0.2), this.diffuse = r2(0.8, 0.8, 0.8), this.externalColor = r4(1, 1, 1, 1), this.colorMixMode = "multiply", this.opacity = 1, this.layerOpacity = 1, this.origin = n(), this.hasSlicePlane = false, this.hasSliceHighlight = true, this.offsetTransparentBackfaces = false, this.vvSize = null, this.vvColor = null, this.vvOpacity = null, this.vvSymbolAnchor = null, this.vvSymbolRotationMatrix = null, this.modelTransformation = null, this.transparent = false, this.writeDepth = true, this.customDepthTest = n3.Less, this.textureAlphaMode = s6.Blend, this.textureAlphaCutoff = o8, this.textureAlphaPremultiplied = false, this.hasOccludees = false, this.renderOccluded = d3.Occlude, this.isDecoration = false;
  }
};
var q4 = class _q extends r10 {
  initializeConfiguration(e13, t14) {
    t14.spherical = e13.viewingMode === l5.Global, t14.doublePrecisionRequiresObfuscation = e13.rctx.driverTest.doublePrecisionRequiresObfuscation.result, t14.textureCoordinateType = t14.hasColorTexture || t14.hasMetallicRoughnessTexture || t14.hasEmissionTexture || t14.hasOcclusionTexture || t14.hasNormalTexture ? d2.Default : d2.None, t14.objectAndLayerIdColorInstanced = t14.instanced;
  }
  initializeProgram(e13) {
    return this._initializeProgram(e13, _q.shader);
  }
  _initializeProgram(e13, t14) {
    return new r11(e13.rctx, t14.get().build(this.configuration), E4);
  }
  _convertDepthTestFunction(e13) {
    return e13 === n3.Lequal ? O3.LEQUAL : O3.LESS;
  }
  _makePipeline(e13, t14) {
    const i10 = this.configuration, r17 = e13 === o6.NONE, s12 = e13 === o6.FrontFace;
    return S2({ blending: i10.output !== o5.Color && i10.output !== o5.Alpha || !i10.transparent ? null : r17 ? c6 : A2(e13), culling: z2(i10) ? h4(i10.cullFace) : null, depthTest: { func: l6(e13, this._convertDepthTestFunction(i10.customDepthTest)) }, depthWrite: (r17 || s12) && i10.writeDepth ? o7 : null, colorWrite: _2, stencilWrite: i10.hasOccludees ? e12 : null, stencilTest: i10.hasOccludees ? t14 ? o12 : f6 : null, polygonOffset: r17 || s12 ? null : a6(i10.enableOffset) });
  }
  initializePipeline() {
    return this._occludeePipelineState = this._makePipeline(this.configuration.transparencyPassType, true), this._makePipeline(this.configuration.transparencyPassType, false);
  }
  getPipeline(e13) {
    return e13 ? this._occludeePipelineState : super.getPipeline();
  }
};
function z2(e13) {
  return e13.cullFace !== e9.None || !e13.hasSlicePlane && (!e13.transparent && !e13.doubleSidedMode);
}
q4.shader = new t8(J, () => import("./DefaultMaterial.glsl-NBN7FTUS.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/DefaultTechniqueConfiguration.js
var t12 = class extends h5 {
};
e2([r12({ constValue: true })], t12.prototype, "hasSliceHighlight", void 0), e2([r12({ constValue: false })], t12.prototype, "hasSliceInVertexProgram", void 0), e2([r12({ constValue: a5.Pass })], t12.prototype, "pbrTextureBindType", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/DefaultMaterialTechniqueConfiguration.js
var c10 = class extends t12 {
  constructor() {
    super(...arguments), this.output = o5.Color, this.alphaDiscardMode = s6.Opaque, this.doubleSidedMode = i6.None, this.pbrMode = c4.Disabled, this.cullFace = e9.None, this.transparencyPassType = o6.NONE, this.normalType = a4.Attribute, this.textureCoordinateType = d2.None, this.customDepthTest = n3.Less, this.spherical = false, this.hasVertexColors = false, this.hasSymbolColors = false, this.hasVerticalOffset = false, this.hasSlicePlane = false, this.hasSliceHighlight = true, this.hasColorTexture = false, this.hasMetallicRoughnessTexture = false, this.hasEmissionTexture = false, this.hasOcclusionTexture = false, this.hasNormalTexture = false, this.hasScreenSizePerspective = false, this.hasVertexTangents = false, this.hasOccludees = false, this.multipassEnabled = false, this.hasModelTransformation = false, this.offsetBackfaces = false, this.vvSize = false, this.vvColor = false, this.receiveShadows = false, this.receiveAmbientOcclusion = false, this.textureAlphaPremultiplied = false, this.instanced = false, this.instancedColor = false, this.objectAndLayerIdColorInstanced = false, this.instancedDoublePrecision = false, this.doublePrecisionRequiresObfuscation = false, this.writeDepth = true, this.transparent = false, this.enableOffset = true, this.cullAboveGround = false, this.snowCover = false, this.hasColorTextureTransform = false, this.hasEmissionTextureTransform = false, this.hasNormalTextureTransform = false, this.hasOcclusionTextureTransform = false, this.hasMetallicRoughnessTextureTransform = false;
  }
};
e2([r12({ count: o5.COUNT })], c10.prototype, "output", void 0), e2([r12({ count: s6.COUNT })], c10.prototype, "alphaDiscardMode", void 0), e2([r12({ count: i6.COUNT })], c10.prototype, "doubleSidedMode", void 0), e2([r12({ count: c4.COUNT })], c10.prototype, "pbrMode", void 0), e2([r12({ count: e9.COUNT })], c10.prototype, "cullFace", void 0), e2([r12({ count: o6.COUNT })], c10.prototype, "transparencyPassType", void 0), e2([r12({ count: a4.COUNT })], c10.prototype, "normalType", void 0), e2([r12({ count: d2.COUNT })], c10.prototype, "textureCoordinateType", void 0), e2([r12({ count: n3.COUNT })], c10.prototype, "customDepthTest", void 0), e2([r12()], c10.prototype, "spherical", void 0), e2([r12()], c10.prototype, "hasVertexColors", void 0), e2([r12()], c10.prototype, "hasSymbolColors", void 0), e2([r12()], c10.prototype, "hasVerticalOffset", void 0), e2([r12()], c10.prototype, "hasSlicePlane", void 0), e2([r12()], c10.prototype, "hasSliceHighlight", void 0), e2([r12()], c10.prototype, "hasColorTexture", void 0), e2([r12()], c10.prototype, "hasMetallicRoughnessTexture", void 0), e2([r12()], c10.prototype, "hasEmissionTexture", void 0), e2([r12()], c10.prototype, "hasOcclusionTexture", void 0), e2([r12()], c10.prototype, "hasNormalTexture", void 0), e2([r12()], c10.prototype, "hasScreenSizePerspective", void 0), e2([r12()], c10.prototype, "hasVertexTangents", void 0), e2([r12()], c10.prototype, "hasOccludees", void 0), e2([r12()], c10.prototype, "multipassEnabled", void 0), e2([r12()], c10.prototype, "hasModelTransformation", void 0), e2([r12()], c10.prototype, "offsetBackfaces", void 0), e2([r12()], c10.prototype, "vvSize", void 0), e2([r12()], c10.prototype, "vvColor", void 0), e2([r12()], c10.prototype, "receiveShadows", void 0), e2([r12()], c10.prototype, "receiveAmbientOcclusion", void 0), e2([r12()], c10.prototype, "textureAlphaPremultiplied", void 0), e2([r12()], c10.prototype, "instanced", void 0), e2([r12()], c10.prototype, "instancedColor", void 0), e2([r12()], c10.prototype, "objectAndLayerIdColorInstanced", void 0), e2([r12()], c10.prototype, "instancedDoublePrecision", void 0), e2([r12()], c10.prototype, "doublePrecisionRequiresObfuscation", void 0), e2([r12()], c10.prototype, "writeDepth", void 0), e2([r12()], c10.prototype, "transparent", void 0), e2([r12()], c10.prototype, "enableOffset", void 0), e2([r12()], c10.prototype, "cullAboveGround", void 0), e2([r12()], c10.prototype, "snowCover", void 0), e2([r12()], c10.prototype, "hasColorTextureTransform", void 0), e2([r12()], c10.prototype, "hasEmissionTextureTransform", void 0), e2([r12()], c10.prototype, "hasNormalTextureTransform", void 0), e2([r12()], c10.prototype, "hasOcclusionTextureTransform", void 0), e2([r12()], c10.prototype, "hasMetallicRoughnessTextureTransform", void 0), e2([r12({ constValue: false })], c10.prototype, "occlusionPass", void 0), e2([r12({ constValue: true })], c10.prototype, "hasVvInstancing", void 0), e2([r12({ constValue: false })], c10.prototype, "useCustomDTRExponentForWater", void 0), e2([r12({ constValue: false })], c10.prototype, "supportsTextureAtlas", void 0), e2([r12({ constValue: true })], c10.prototype, "useFillLights", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/RealisticTreeTechnique.js
var t13 = class _t extends q4 {
  initializeConfiguration(i10, a10) {
    super.initializeConfiguration(i10, a10), a10.hasMetallicRoughnessTexture = false, a10.hasEmissionTexture = false, a10.hasOcclusionTexture = false, a10.hasNormalTexture = false, a10.hasModelTransformation = false, a10.normalType = a4.Attribute, a10.doubleSidedMode = i6.WindingOrder, a10.hasVertexTangents = false;
  }
  initializeProgram(e13) {
    return this._initializeProgram(e13, _t.shader);
  }
};
t13.shader = new t8(R, () => import("./RealisticTree.glsl-MGTTDUEN.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/DefaultMaterial.js
var I4 = class extends c5 {
  constructor(e13) {
    super(e13, j3), this.supportsEdges = true, this._configuration = new c10(), this._vertexBufferLayout = L5(this.parameters);
  }
  isVisibleForOutput(e13) {
    return e13 !== o5.Shadow && e13 !== o5.ShadowExcludeHighlight && e13 !== o5.ShadowHighlight || this.parameters.castShadows;
  }
  isVisible() {
    const e13 = this.parameters;
    if (!super.isVisible() || 0 === e13.layerOpacity)
      return false;
    const { hasInstancedColor: t14, hasVertexColors: r17, hasSymbolColors: s12, vvColor: a10 } = e13, i10 = "replace" === e13.colorMixMode, o13 = e13.opacity > 0, n8 = e13.externalColor && e13.externalColor[3] > 0, h10 = t14 || a10 || s12;
    return r17 && h10 ? i10 || o13 : r17 ? i10 ? n8 : o13 : h10 ? i10 || o13 : i10 ? n8 : o13;
  }
  getConfiguration(e13, t14) {
    return this._configuration.output = e13, this._configuration.hasNormalTexture = !!this.parameters.normalTextureId, this._configuration.hasColorTexture = !!this.parameters.textureId, this._configuration.hasVertexTangents = this.parameters.hasVertexTangents, this._configuration.instanced = this.parameters.isInstanced, this._configuration.instancedDoublePrecision = this.parameters.instancedDoublePrecision, this._configuration.vvSize = !!this.parameters.vvSize, this._configuration.hasVerticalOffset = null != this.parameters.verticalOffset, this._configuration.hasScreenSizePerspective = null != this.parameters.screenSizePerspective, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.hasSliceHighlight = this.parameters.hasSliceHighlight, this._configuration.alphaDiscardMode = this.parameters.textureAlphaMode, this._configuration.normalType = this.parameters.normalType, this._configuration.transparent = this.parameters.transparent, this._configuration.writeDepth = this.parameters.writeDepth, null != this.parameters.customDepthTest && (this._configuration.customDepthTest = this.parameters.customDepthTest), this._configuration.hasOccludees = this.parameters.hasOccludees, this._configuration.cullFace = this.parameters.hasSlicePlane ? e9.None : this.parameters.cullFace, this._configuration.multipassEnabled = t14.multipassEnabled, this._configuration.cullAboveGround = t14.multipassTerrain.cullAboveGround, this._configuration.hasModelTransformation = null != this.parameters.modelTransformation, e13 !== o5.Color && e13 !== o5.Alpha || (this._configuration.hasVertexColors = this.parameters.hasVertexColors, this._configuration.hasSymbolColors = this.parameters.hasSymbolColors, this.parameters.treeRendering ? this._configuration.doubleSidedMode = i6.WindingOrder : this._configuration.doubleSidedMode = this.parameters.doubleSided && "normal" === this.parameters.doubleSidedType ? i6.View : this.parameters.doubleSided && "winding-order" === this.parameters.doubleSidedType ? i6.WindingOrder : i6.None, this._configuration.instancedColor = this.parameters.hasInstancedColor, this._configuration.receiveShadows = this.parameters.receiveShadows && this.parameters.shadowMappingEnabled, this._configuration.receiveAmbientOcclusion = null != t14.ssao, this._configuration.vvColor = !!this.parameters.vvColor, this._configuration.textureAlphaPremultiplied = !!this.parameters.textureAlphaPremultiplied, this._configuration.pbrMode = this.parameters.usePBR ? this.parameters.isSchematic ? c4.Schematic : c4.Normal : c4.Disabled, this._configuration.hasMetallicRoughnessTexture = !!this.parameters.metallicRoughnessTextureId, this._configuration.hasEmissionTexture = !!this.parameters.emissiveTextureId, this._configuration.hasOcclusionTexture = !!this.parameters.occlusionTextureId, this._configuration.offsetBackfaces = !(!this.parameters.transparent || !this.parameters.offsetTransparentBackfaces), this._configuration.transparencyPassType = t14.transparencyPassType, this._configuration.enableOffset = t14.camera.relativeElevation < S3, this._configuration.snowCover = this.hasSnowCover(t14), this._configuration.hasColorTextureTransform = !!this.parameters.colorTextureTransformMatrix, this._configuration.hasNormalTextureTransform = !!this.parameters.normalTextureTransformMatrix, this._configuration.hasEmissionTextureTransform = !!this.parameters.emissiveTextureTransformMatrix, this._configuration.hasOcclusionTextureTransform = !!this.parameters.occlusionTextureTransformMatrix, this._configuration.hasMetallicRoughnessTextureTransform = !!this.parameters.metallicRoughnessTextureTransformMatrix), this._configuration;
  }
  hasSnowCover(e13) {
    return null != e13.weather && e13.weatherVisible && "snowy" === e13.weather.type && "enabled" === e13.weather.snowCover;
  }
  intersect(h10, l9, u12, m6, p4, d6) {
    if (null != this.parameters.verticalOffset) {
      const h11 = u12.camera;
      o2(z3, l9[12], l9[13], l9[14]);
      let d7 = null;
      switch (u12.viewingMode) {
        case l5.Global:
          d7 = z(B2, z3);
          break;
        case l5.Local:
          d7 = r3(B2, V3);
      }
      let f7 = 0;
      const g5 = e4(G4, z3, h11.eye), T5 = s4(g5), _6 = g(g5, g5, 1 / T5);
      let x2 = null;
      this.parameters.screenSizePerspective && (x2 = P(d7, _6)), f7 += L3(h11, T5, this.parameters.verticalOffset, x2 ?? 0, this.parameters.screenSizePerspective), g(d7, d7, f7), S(H4, d7, u12.transform.inverseRotation), m6 = e4(D4, m6, H4), p4 = e4(N4, p4, H4);
    }
    h3(h10, u12, m6, p4, I3(u12.verticalOffset), d6);
  }
  produces(e13, t14) {
    if (t14 === o5.Color || t14 === o5.Alpha || t14 === o5.Depth || t14 === o5.Normal || t14 === o5.Shadow || t14 === o5.ShadowHighlight || t14 === o5.ShadowExcludeHighlight || t14 === o5.Highlight || t14 === o5.ObjectAndLayerIdColor) {
      return e13 === (this.parameters.transparent ? this.parameters.writeDepth ? A3.TRANSPARENT_MATERIAL : A3.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL : A3.OPAQUE_MATERIAL) || e13 === A3.DRAPED_MATERIAL;
    }
    return false;
  }
  createGLMaterial(e13) {
    return new E8(e13);
  }
  createBufferWriter() {
    return new r15(this._vertexBufferLayout);
  }
};
var E8 = class extends r9 {
  constructor(e13) {
    super({ ...e13, ...e13.material.parameters });
  }
  _updateShadowState(e13) {
    e13.shadowMap.enabled !== this._material.parameters.shadowMappingEnabled && this._material.setParameters({ shadowMappingEnabled: e13.shadowMap.enabled });
  }
  _updateOccludeeState(e13) {
    e13.hasOccludees !== this._material.parameters.hasOccludees && this._material.setParameters({ hasOccludees: e13.hasOccludees });
  }
  beginSlot(t14) {
    this._output !== o5.Color && this._output !== o5.Alpha || (this._updateShadowState(t14), this._updateOccludeeState(t14));
    const r17 = this._material.parameters;
    this.updateTexture(r17.textureId);
    const s12 = t14.camera.viewInverseTransposeMatrix;
    return o2(r17.origin, s12[3], s12[7], s12[11]), this._material.setParameters(this.textureBindParameters), this.ensureTechnique(r17.treeRendering ? t13 : q4, t14);
  }
};
var P4 = class extends k2 {
  constructor() {
    super(...arguments), this.initTextureTransparent = false, this.treeRendering = false, this.hasVertexTangents = false;
  }
};
var j3 = new P4();
function L5(e13) {
  const t14 = H2().vec3f(e5.POSITION);
  e13.normalType === a4.Compressed ? t14.vec2i16(e5.NORMALCOMPRESSED, { glNormalized: true }) : t14.vec3f(e5.NORMAL), e13.hasVertexTangents && t14.vec4f(e5.TANGENT);
  return (e13.textureId || e13.normalTextureId || e13.metallicRoughnessTextureId || e13.emissiveTextureId || e13.occlusionTextureId) && t14.vec2f(e5.UV0), e13.hasVertexColors && t14.vec4u8(e5.COLOR), e13.hasSymbolColors && t14.vec4u8(e5.SYMBOLCOLOR), has("enable-feature:objectAndLayerId-rendering") && t14.vec4u8(e5.OBJECTANDLAYERIDCOLOR), t14;
}
var D4 = n();
var N4 = n();
var V3 = r2(0, 0, 1);
var B2 = n();
var H4 = n();
var z3 = n();
var G4 = n();

// node_modules/@arcgis/core/views/3d/layers/graphics/wosrLoader.js
var v2 = s.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");
async function A5(e13, t14) {
  const n8 = await j4(e13, t14), s12 = await E9(n8.textureDefinitions ?? {}, t14);
  let a10 = 0;
  for (const r17 in s12)
    if (s12.hasOwnProperty(r17)) {
      const e14 = s12[r17];
      a10 += (e14 == null ? void 0 : e14.image) ? e14.image.width * e14.image.height * 4 : 0;
    }
  return { resource: n8, textures: s12, size: a10 + e(n8) };
}
async function j4(r17, n8) {
  const s12 = n8 == null ? void 0 : n8.streamDataRequester;
  if (s12)
    return I5(r17, s12, n8);
  const a10 = await _(j(r17, n8));
  if (true === a10.ok)
    return a10.value.data;
  a(a10.error), P5(a10.error);
}
async function I5(e13, r17, n8) {
  const s12 = await _(r17.request(e13, "json", n8));
  if (true === s12.ok)
    return s12.value;
  a(s12.error), P5(s12.error.details.url);
}
function P5(e13) {
  throw new s2("", `Request for object resource failed: ${e13}`);
}
function M3(e13) {
  const t14 = e13.params, r17 = t14.topology;
  let n8 = true;
  switch (t14.vertexAttributes || (v2.warn("Geometry must specify vertex attributes"), n8 = false), t14.topology) {
    case "PerAttributeArray":
      break;
    case "Indexed":
    case null:
    case void 0: {
      const e14 = t14.faces;
      if (e14) {
        if (t14.vertexAttributes)
          for (const r18 in t14.vertexAttributes) {
            const t15 = e14[r18];
            (t15 == null ? void 0 : t15.values) ? (null != t15.valueType && "UInt32" !== t15.valueType && (v2.warn(`Unsupported indexed geometry indices type '${t15.valueType}', only UInt32 is currently supported`), n8 = false), null != t15.valuesPerElement && 1 !== t15.valuesPerElement && (v2.warn(`Unsupported indexed geometry values per element '${t15.valuesPerElement}', only 1 is currently supported`), n8 = false)) : (v2.warn(`Indexed geometry does not specify face indices for '${r18}' attribute`), n8 = false);
          }
      } else
        v2.warn("Indexed geometries must specify faces"), n8 = false;
      break;
    }
    default:
      v2.warn(`Unsupported topology '${r17}'`), n8 = false;
  }
  e13.params.material || (v2.warn("Geometry requires material"), n8 = false);
  const s12 = e13.params.vertexAttributes;
  for (const a10 in s12) {
    s12[a10].values || (v2.warn("Geometries with externally defined attributes are not yet supported"), n8 = false);
  }
  return n8;
}
function T4(e13, t14) {
  var _a, _b;
  const r17 = new Array(), n8 = new Array(), s12 = new Array(), o13 = new t6(), u12 = e13.resource, c11 = r6.parse(u12.version || "1.0", "wosr");
  q5.validate(c11);
  const m6 = u12.model.name, g5 = u12.model.geometries, h10 = u12.materialDefinitions ?? {}, v3 = e13.textures;
  let A6 = 0;
  const j5 = /* @__PURE__ */ new Map();
  for (let a10 = 0; a10 < g5.length; a10++) {
    const e14 = g5[a10];
    if (!M3(e14))
      continue;
    const i10 = k3(e14), u13 = e14.params.vertexAttributes, c12 = [], m7 = (t15) => {
      if ("PerAttributeArray" === e14.params.topology)
        return null;
      const r18 = e14.params.faces;
      for (const e15 in r18)
        if (e15 === t15)
          return r18[e15].values;
      return null;
    }, I6 = u13[e5.POSITION], P6 = I6.values.length / I6.valuesPerElement;
    for (const t15 in u13) {
      const e15 = u13[t15], r18 = e15.values, n9 = m7(t15) ?? l3(P6);
      c12.push([t15, new t2(r18, n9, e15.valuesPerElement, true)]);
    }
    const T5 = i10.texture, U3 = v3 && v3[T5];
    if (U3 && !j5.has(T5)) {
      const { image: e15, parameters: t15 } = U3, r18 = new N2(e15, t15);
      n8.push(r18), j5.set(T5, r18);
    }
    const E10 = j5.get(T5), q6 = E10 ? E10.id : void 0, R5 = i10.material;
    let B3 = o13.get(R5, T5);
    if (null == B3) {
      const e15 = h10[R5.substring(R5.lastIndexOf("/") + 1)].params;
      1 === e15.transparency && (e15.transparency = 0);
      const r18 = U3 && U3.alphaChannelUsage, n9 = e15.transparency > 0 || "transparency" === r18 || "maskAndTransparency" === r18, s13 = U3 ? O5(U3.alphaChannelUsage) : void 0, a11 = { ambient: e3(e15.diffuse), diffuse: e3(e15.diffuse), opacity: 1 - (e15.transparency || 0), transparent: n9, textureAlphaMode: s13, textureAlphaCutoff: 0.33, textureId: q6, initTextureTransparent: true, doubleSided: true, cullFace: e9.None, colorMixMode: e15.externalColorMixMode || "tint", textureAlphaPremultiplied: (U3 == null ? void 0 : U3.parameters.preMultiplyAlpha) ?? false };
      (t14 == null ? void 0 : t14.materialParameters) && Object.assign(a11, t14.materialParameters), B3 = new I4(a11), o13.set(R5, T5, B3);
    }
    s12.push(B3);
    const C4 = new I2(B3, c12);
    A6 += ((_b = (_a = c12.find((e15) => e15[0] === e5.POSITION)) == null ? void 0 : _a[1]) == null ? void 0 : _b.indices.length) ?? 0, r17.push(C4);
  }
  return { engineResources: [{ name: m6, stageResources: { textures: n8, materials: s12, geometries: r17 }, pivotOffset: u12.model.pivotOffset, numberOfVertices: A6, lodThreshold: null }], referenceBoundingBox: U2(r17) };
}
function U2(e13) {
  const t14 = P2();
  return e13.forEach((e14) => {
    const r17 = e14.boundingInfo;
    null != r17 && (h2(t14, r17.bbMin), h2(t14, r17.bbMax));
  }), t14;
}
async function E9(e13, t14) {
  const r17 = new Array();
  for (const a10 in e13) {
    const n9 = e13[a10], s13 = n9.images[0].data;
    if (!s13) {
      v2.warn("Externally referenced texture data is not yet supported");
      continue;
    }
    const o13 = n9.encoding + ";base64," + s13, i10 = "/textureDefinitions/" + a10, l9 = "rgba" === n9.channels ? n9.alphaChannelUsage || "transparency" : "none", u12 = { noUnpackFlip: true, wrap: { s: D.REPEAT, t: D.REPEAT }, preMultiplyAlpha: O5(l9) !== s6.Opaque }, c11 = null != t14 && t14.disableTextures ? Promise.resolve(null) : t7(o13, t14);
    r17.push(c11.then((e14) => ({ refId: i10, image: e14, parameters: u12, alphaChannelUsage: l9 })));
  }
  const n8 = await Promise.all(r17), s12 = {};
  for (const a10 of n8)
    s12[a10.refId] = a10;
  return s12;
}
function O5(e13) {
  switch (e13) {
    case "mask":
      return s6.Mask;
    case "maskAndTransparency":
      return s6.MaskBlend;
    case "none":
      return s6.Opaque;
    default:
      return s6.Blend;
  }
}
function k3(e13) {
  const t14 = e13.params;
  return { id: 1, material: t14.material, texture: t14.texture, region: t14.texture };
}
var q5 = new r6(1, 2, "wosr");

// node_modules/@arcgis/core/views/3d/layers/graphics/objectResourceUtils.js
async function X(t14, r17) {
  var _a;
  const o13 = Y(a3(t14));
  if ("wosr" === o13.fileType) {
    const e13 = await (r17.cache ? r17.cache.loadWOSR(o13.url, r17) : A5(o13.url, r17)), { engineResources: t15, referenceBoundingBox: s13 } = T4(e13, r17);
    return { lods: t15, referenceBoundingBox: s13, isEsriSymbolResource: false, isWosr: true };
  }
  const s12 = await (r17.cache ? r17.cache.loadGLTF(o13.url, r17, !!r17.usePBR) : l4(new n5(r17.streamDataRequester), o13.url, r17, r17.usePBR)), i10 = (_a = s12.model.meta) == null ? void 0 : _a.ESRI_proxyEllipsoid, n8 = s12.meta.isEsriSymbolResource && null != i10 && s12.meta.uri.includes("/RealisticTrees/");
  n8 && !s12.customMeta.esriTreeRendering && (s12.customMeta.esriTreeRendering = true, se(s12, i10));
  const l9 = !!r17.usePBR, a10 = s12.meta.isEsriSymbolResource ? { usePBR: l9, isSchematic: false, treeRendering: n8, mrrFactors: [...s11] } : { usePBR: l9, isSchematic: false, treeRendering: false, mrrFactors: [...n7] }, u12 = { ...r17.materialParameters, treeRendering: n8 }, { engineResources: c11, referenceBoundingBox: m6 } = Z2(s12, a10, u12, r17.skipHighLods && null == o13.specifiedLodIndex ? { skipHighLods: true } : { skipHighLods: false, singleLodIndex: o13.specifiedLodIndex });
  return { lods: c11, referenceBoundingBox: m6, isEsriSymbolResource: s12.meta.isEsriSymbolResource, isWosr: false };
}
function Y(e13) {
  const t14 = e13.match(/(.*\.(gltf|glb))(\?lod=([0-9]+))?$/);
  if (t14)
    return { fileType: "gltf", url: t14[1], specifiedLodIndex: null != t14[4] ? Number(t14[4]) : null };
  return e13.match(/(.*\.(json|json\.gz))$/) ? { fileType: "wosr", url: e13, specifiedLodIndex: null } : { fileType: "unknown", url: e13, specifiedLodIndex: null };
}
function Z2(e13, t14, r17, o13) {
  const s12 = e13.model, i10 = new Array(), n8 = /* @__PURE__ */ new Map(), l9 = /* @__PURE__ */ new Map(), a10 = s12.lods.length, u12 = P2();
  return s12.lods.forEach((e14, c11) => {
    const m6 = true === o13.skipHighLods && (a10 > 1 && 0 === c11 || a10 > 3 && 1 === c11) || false === o13.skipHighLods && null != o13.singleLodIndex && c11 !== o13.singleLodIndex;
    if (m6 && 0 !== c11)
      return;
    const f7 = new t10(e14.name, e14.lodThreshold, [0, 0, 0]);
    e14.parts.forEach((e15) => {
      const o14 = m6 ? new I4({}) : ee2(s12, e15, f7, t14, r17, n8, l9), { geometry: i11, vertexCount: a11 } = te(e15, null != o14 ? o14 : new I4({})), p4 = i11.boundingInfo;
      null != p4 && 0 === c11 && (h2(u12, p4.bbMin), h2(u12, p4.bbMax)), null != o14 && (f7.stageResources.geometries.push(i11), f7.numberOfVertices += a11);
    }), m6 || i10.push(f7);
  }), { engineResources: i10, referenceBoundingBox: u12 };
}
function ee2(e13, t14, r17, o13, s12, i10, n8) {
  const l9 = t14.material + (t14.attributes.normal ? "_normal" : "") + (t14.attributes.color ? "_color" : "") + (t14.attributes.texCoord0 ? "_texCoord0" : "") + (t14.attributes.tangent ? "_tangent" : ""), a10 = e13.materials.get(t14.material), u12 = null != t14.attributes.texCoord0, c11 = null != t14.attributes.normal;
  if (null == a10)
    return null;
  const m6 = oe(a10.alphaMode);
  if (!i10.has(l9)) {
    if (u12) {
      const t15 = (t16, r19 = false) => {
        if (null != t16 && !n8.has(t16)) {
          const o14 = e13.textures.get(t16);
          if (null != o14) {
            const e14 = o14.data;
            n8.set(t16, new N2(r8(e14) ? e14.data : e14, { ...o14.parameters, preMultiplyAlpha: !r8(e14) && r19, encoding: r8(e14) && null != e14.encoding ? e14.encoding : void 0 }));
          }
        }
      };
      t15(a10.textureColor, m6 !== s6.Opaque), t15(a10.textureNormal), t15(a10.textureOcclusion), t15(a10.textureEmissive), t15(a10.textureMetallicRoughness);
    }
    const r18 = a10.color[0] ** (1 / o4), f8 = a10.color[1] ** (1 / o4), d6 = a10.color[2] ** (1 / o4), p4 = a10.emissiveFactor[0] ** (1 / o4), g5 = a10.emissiveFactor[1] ** (1 / o4), x2 = a10.emissiveFactor[2] ** (1 / o4), b2 = null != a10.textureColor && u12 ? n8.get(a10.textureColor) : null, h10 = u11({ normalTexture: a10.textureNormal, metallicRoughnessTexture: a10.textureMetallicRoughness, metallicFactor: a10.metallicFactor, roughnessFactor: a10.roughnessFactor, emissiveTexture: a10.textureEmissive, emissiveFactor: a10.emissiveFactor, occlusionTexture: a10.textureOcclusion });
    i10.set(l9, new I4({ ...o13, transparent: m6 === s6.Blend, customDepthTest: n3.Lequal, textureAlphaMode: m6, textureAlphaCutoff: a10.alphaCutoff, diffuse: [r18, f8, d6], ambient: [r18, f8, d6], opacity: a10.opacity, doubleSided: a10.doubleSided, doubleSidedType: "winding-order", cullFace: a10.doubleSided ? e9.None : e9.Back, hasVertexColors: !!t14.attributes.color, hasVertexTangents: !!t14.attributes.tangent, normalType: c11 ? a4.Attribute : a4.ScreenDerivative, castShadows: true, textureId: null != b2 ? b2.id : void 0, colorMixMode: a10.colorMixMode, normalTextureId: null != a10.textureNormal && u12 ? n8.get(a10.textureNormal).id : void 0, textureAlphaPremultiplied: null != b2 && !!b2.parameters.preMultiplyAlpha, occlusionTextureId: null != a10.textureOcclusion && u12 ? n8.get(a10.textureOcclusion).id : void 0, emissiveTextureId: null != a10.textureEmissive && u12 ? n8.get(a10.textureEmissive).id : void 0, metallicRoughnessTextureId: null != a10.textureMetallicRoughness && u12 ? n8.get(a10.textureMetallicRoughness).id : void 0, emissiveFactor: [p4, g5, x2], mrrFactors: h10 ? [...r16] : [a10.metallicFactor, a10.roughnessFactor, o13.mrrFactors[2]], isSchematic: h10, colorTextureTransformMatrix: r13(a10.colorTextureTransform), normalTextureTransformMatrix: r13(a10.normalTextureTransform), occlusionTextureTransformMatrix: r13(a10.occlusionTextureTransform), emissiveTextureTransformMatrix: r13(a10.emissiveTextureTransform), metallicRoughnessTextureTransformMatrix: r13(a10.metallicRoughnessTextureTransform), ...s12 }));
  }
  const f7 = i10.get(l9);
  if (r17.stageResources.materials.push(f7), u12) {
    const e14 = (e15) => {
      null != e15 && r17.stageResources.textures.push(n8.get(e15));
    };
    e14(a10.textureColor), e14(a10.textureNormal), e14(a10.textureOcclusion), e14(a10.textureEmissive), e14(a10.textureMetallicRoughness);
  }
  return f7;
}
function te(e13, r17) {
  const o13 = e13.attributes.position.count, s12 = o3(e13.indices || o13, e13.primitiveType), i10 = t9(3 * o13), { typedBuffer: n8, typedBufferStride: l9 } = e13.attributes.position;
  r5(i10, n8, e13.transform, 3, l9);
  const a10 = [[e5.POSITION, new t2(i10, s12, 3, true)]];
  if (null != e13.attributes.normal) {
    const r18 = t9(3 * o13), { typedBuffer: i11, typedBufferStride: n9 } = e13.attributes.normal;
    g2(re, e13.transform), n2(r18, i11, re, 3, n9), a10.push([e5.NORMAL, new t2(r18, s12, 3, true)]);
  }
  if (null != e13.attributes.tangent) {
    const r18 = t9(4 * o13), { typedBuffer: i11, typedBufferStride: n9 } = e13.attributes.tangent;
    g2(re, e13.transform), f3(r18, i11, re, 4, n9), a10.push([e5.TANGENT, new t2(r18, s12, 4, true)]);
  }
  if (null != e13.attributes.texCoord0) {
    const t14 = t9(2 * o13), { typedBuffer: r18, typedBufferStride: i11 } = e13.attributes.texCoord0;
    n4(t14, r18, 2, i11), a10.push([e5.UV0, new t2(t14, s12, 2, true)]);
  }
  if (null != e13.attributes.color) {
    const t14 = new Uint8Array(4 * o13);
    4 === e13.attributes.color.elementCount ? e13.attributes.color instanceof c ? u7(t14, e13.attributes.color, 255) : e13.attributes.color instanceof x ? t4(t14, e13.attributes.color) : e13.attributes.color instanceof L && u7(t14, e13.attributes.color, 1 / 256) : (t14.fill(255), e13.attributes.color instanceof i3 ? u5(t14, e13.attributes.color, 255, 4) : e13.attributes.color instanceof O2 ? t3(t14, e13.attributes.color.typedBuffer, 4, e13.attributes.color.typedBufferStride) : e13.attributes.color instanceof E && u5(t14, e13.attributes.color, 1 / 256, 4)), a10.push([e5.COLOR, new t2(t14, s12, 4, true)]);
  }
  return { geometry: new I2(r17, a10), vertexCount: o13 };
}
var re = e6();
function oe(e13) {
  switch (e13) {
    case "BLEND":
      return s6.Blend;
    case "MASK":
      return s6.Mask;
    case "OPAQUE":
    case null:
    case void 0:
      return s6.Opaque;
  }
}
function se(e13, t14) {
  for (let r17 = 0; r17 < e13.model.lods.length; ++r17) {
    const f7 = e13.model.lods[r17];
    for (const d6 of f7.parts) {
      const f8 = d6.attributes.normal;
      if (null == f8)
        return;
      const p4 = d6.attributes.position, g5 = p4.count, b2 = n(), T5 = n(), y4 = n(), w2 = new Uint8Array(4 * g5), R5 = new Float64Array(3 * g5), v3 = h(e7(), d6.transform);
      let j5 = 0, B3 = 0;
      for (let o13 = 0; o13 < g5; o13++) {
        p4.getVec(o13, T5), f8.getVec(o13, b2), O(T5, T5, d6.transform), e4(y4, T5, t14.center), i2(y4, y4, t14.radius);
        const s12 = y4[2], m6 = s4(y4), g6 = Math.min(0.45 + 0.55 * m6 * m6, 1);
        i2(y4, y4, t14.radius), null !== v3 && O(y4, y4, v3), z(y4, y4), r17 + 1 !== e13.model.lods.length && e13.model.lods.length > 1 && A(y4, y4, b2, s12 > -1 ? 0.2 : Math.min(-4 * s12 - 3.8, 1)), R5[j5] = y4[0], R5[j5 + 1] = y4[1], R5[j5 + 2] = y4[2], j5 += 3, w2[B3] = 255 * g6, w2[B3 + 1] = 255 * g6, w2[B3 + 2] = 255 * g6, w2[B3 + 3] = 255, B3 += 4;
      }
      d6.attributes.normal = new i3(R5), d6.attributes.color = new x(w2);
    }
  }
}
export {
  X as fetch,
  Z2 as gltfToEngineResources,
  Y as parseUrl
};
//# sourceMappingURL=objectResourceUtils-AHGBQVA7.js.map
