import {
  i,
  o,
  r,
  s as s4
} from "./chunk-HYU6N3H3.js";
import {
  o as o2,
  r as r2
} from "./chunk-RHT6WWRD.js";
import {
  f
} from "./chunk-EUGXS5RE.js";
import {
  p,
  v
} from "./chunk-IPCIO3PX.js";
import {
  j as j2,
  m3 as m
} from "./chunk-OIIDE5GZ.js";
import {
  R,
  d
} from "./chunk-QNOCEWCR.js";
import {
  G,
  T
} from "./chunk-HLGIRLYQ.js";
import {
  I,
  j
} from "./chunk-R5DM4YAB.js";
import {
  s,
  s2,
  s3
} from "./chunk-WJ3HJKNC.js";

// node_modules/@arcgis/core/rest/geometryService/cut.js
async function i2(i3, n, p2, m4) {
  const a = f(i3), u = n[0].spatialReference, c = { ...m4, responseType: "json", query: { ...a.query, f: "json", sr: T(u), target: JSON.stringify({ geometryType: v(n[0]), geometries: n }), cutter: JSON.stringify(p2) } }, f2 = await j(a.path + "/cut", c), { cutIndexes: y2, geometries: g2 = [] } = f2.data;
  return { cutIndexes: y2, geometries: g2.map((e) => {
    const t = p(e);
    return t.spatialReference = u, t;
  }) };
}

// node_modules/@arcgis/core/rest/geometryService/simplify.js
async function m2(m4, p2, f2) {
  const n = "string" == typeof m4 ? I(m4) : m4, a = p2[0].spatialReference, u = v(p2[0]), l = { ...f2, query: { ...n.query, f: "json", sr: T(a), geometries: JSON.stringify(r2(p2)) } }, { data: y2 } = await j(n.path + "/simplify", l);
  return o2(y2.geometries, u, a);
}

// node_modules/@arcgis/core/geometry/support/normalizeUtils.js
var m3 = s2.getLogger("esri.geometry.support.normalizeUtils");
function g(t) {
  return "polygon" === t.type;
}
function y(t) {
  return "polygon" === t[0].type;
}
function x(t) {
  return "polyline" === t[0].type;
}
function d2(t) {
  const e = [];
  let n = 0, s5 = 0;
  for (let o3 = 0; o3 < t.length; o3++) {
    const r3 = t[o3];
    let i3 = null;
    for (let t2 = 0; t2 < r3.length; t2++)
      i3 = r3[t2], e.push(i3), 0 === t2 ? (n = i3[0], s5 = n) : (n = Math.min(n, i3[0]), s5 = Math.max(s5, i3[0]));
    i3 && e.push([(n + s5) / 2, 0]);
  }
  return e;
}
function M(t, n) {
  if (!(t instanceof m || t instanceof j2)) {
    const t2 = "straightLineDensify: the input geometry is neither polyline nor polygon";
    throw m3.error(t2), new s3(t2);
  }
  const i3 = o(t), l = [];
  for (const e of i3) {
    const t2 = [];
    l.push(t2), t2.push([e[0][0], e[0][1]]);
    for (let s5 = 0; s5 < e.length - 1; s5++) {
      const o3 = e[s5][0], r3 = e[s5][1], i4 = e[s5 + 1][0], l2 = e[s5 + 1][1], c = Math.sqrt((i4 - o3) * (i4 - o3) + (l2 - r3) * (l2 - r3)), f2 = (l2 - r3) / c, u = (i4 - o3) / c, a = c / n;
      if (a > 1) {
        for (let l3 = 1; l3 <= a - 1; l3++) {
          const e3 = l3 * n, s7 = u * e3 + o3, i6 = f2 * e3 + r3;
          t2.push([s7, i6]);
        }
        const e2 = (c + Math.floor(a - 1) * n) / 2, s6 = u * e2 + o3, i5 = f2 * e2 + r3;
        t2.push([s6, i5]);
      }
      t2.push([i4, l2]);
    }
  }
  return g(t) ? new j2({ rings: l, spatialReference: t.spatialReference }) : new m({ paths: l, spatialReference: t.spatialReference });
}
function w(t, e, n) {
  if (e) {
    const e2 = M(t, 1e6);
    t = R(e2, true);
  }
  return n && (t = s4(t, n)), t;
}
function j3(t, e, n) {
  if (Array.isArray(t)) {
    const s5 = t[0];
    if (s5 > e) {
      const n2 = i(s5, e);
      t[0] = s5 + n2 * (-2 * e);
    } else if (s5 < n) {
      const e2 = i(s5, n);
      t[0] = s5 + e2 * (-2 * n);
    }
  } else {
    const s5 = t.x;
    if (s5 > e) {
      const n2 = i(s5, e);
      t = t.clone().offset(n2 * (-2 * e), 0);
    } else if (s5 < n) {
      const e2 = i(s5, n);
      t = t.clone().offset(e2 * (-2 * n), 0);
    }
  }
  return t;
}
function b(t, e) {
  let n = -1;
  for (let s5 = 0; s5 < e.cutIndexes.length; s5++) {
    const o3 = e.cutIndexes[s5], i3 = e.geometries[s5], c = o(i3);
    for (let t2 = 0; t2 < c.length; t2++) {
      const e2 = c[t2];
      e2.some((n2) => {
        if (n2[0] < 180)
          return true;
        {
          let n3 = 0;
          for (let t3 = 0; t3 < e2.length; t3++) {
            const s7 = e2[t3][0];
            n3 = s7 > n3 ? s7 : n3;
          }
          n3 = Number(n3.toFixed(9));
          const s6 = -360 * i(n3, 180);
          for (let o4 = 0; o4 < e2.length; o4++) {
            const e3 = i3.getPoint(t2, o4);
            i3.setPoint(t2, o4, e3.clone().offset(s6, 0));
          }
          return true;
        }
      });
    }
    if (o3 === n) {
      if (y(t))
        for (const e2 of o(i3))
          t[o3] = t[o3].addRing(e2);
      else if (x(t))
        for (const e2 of o(i3))
          t[o3] = t[o3].addPath(e2);
    } else
      n = o3, t[o3] = i3;
  }
  return t;
}
async function R2(e, n, r3) {
  if (!Array.isArray(e))
    return R2([e], n);
  n && "string" != typeof n && m3.warn("normalizeCentralMeridian()", "The url object is deprecated, use the url string instead");
  const a = "string" == typeof n ? n : (n == null ? void 0 : n.url) ?? s.geometryServiceUrl;
  let g2, y2, x2, d3, M2, v3, P2, L2, U = 0;
  const z = [], A = [];
  for (const t of e)
    if (null != t)
      if (g2 || (g2 = t.spatialReference, y2 = G(g2), x2 = g2.isWebMercator, v3 = x2 ? 102100 : 4326, d3 = r[v3].maxX, M2 = r[v3].minX, P2 = r[v3].plus180Line, L2 = r[v3].minus180Line), y2)
        if ("mesh" === t.type)
          A.push(t);
        else if ("point" === t.type)
          A.push(j3(t.clone(), d3, M2));
        else if ("multipoint" === t.type) {
          const e2 = t.clone();
          e2.points = e2.points.map((t2) => j3(t2, d3, M2)), A.push(e2);
        } else if ("extent" === t.type) {
          const e2 = t.clone()._normalize(false, false, y2);
          A.push(e2.rings ? new j2(e2) : e2);
        } else if (t.extent) {
          const e2 = t.extent, n2 = i(e2.xmin, M2) * (2 * d3);
          let s5 = 0 === n2 ? t.clone() : s4(t.clone(), n2);
          e2.offset(n2, 0), e2.intersects(P2) && e2.xmax !== d3 ? (U = e2.xmax > U ? e2.xmax : U, s5 = w(s5, x2), z.push(s5), A.push("cut")) : e2.intersects(L2) && e2.xmin !== M2 ? (U = e2.xmax * (2 * d3) > U ? e2.xmax * (2 * d3) : U, s5 = w(s5, x2, 360), z.push(s5), A.push("cut")) : A.push(s5);
        } else
          A.push(t.clone());
      else
        A.push(t);
    else
      A.push(t);
  let S = i(U, d3), k = -90;
  const C = S, I2 = new m();
  for (; S > 0; ) {
    const t = 360 * S - 180;
    I2.addPath([[t, k], [t, -1 * k]]), k *= -1, S--;
  }
  if (z.length > 0 && C > 0) {
    const t = b(z, await i2(a, z, I2, r3)), n2 = [], s5 = [];
    for (let r4 = 0; r4 < A.length; r4++) {
      const o4 = A[r4];
      if ("cut" !== o4)
        s5.push(o4);
      else {
        const o5 = t.shift(), i4 = e[r4];
        null != i4 && "polygon" === i4.type && i4.rings && i4.rings.length > 1 && o5.rings.length >= i4.rings.length ? (n2.push(o5), s5.push("simplify")) : s5.push(x2 ? d(o5) : o5);
      }
    }
    if (!n2.length)
      return s5;
    const o3 = await m2(a, n2, r3), i3 = [];
    for (let e2 = 0; e2 < s5.length; e2++) {
      const t2 = s5[e2];
      "simplify" !== t2 ? i3.push(t2) : i3.push(x2 ? d(o3.shift()) : o3.shift());
    }
    return i3;
  }
  const X = [];
  for (let t = 0; t < A.length; t++) {
    const e2 = A[t];
    if ("cut" !== e2)
      X.push(e2);
    else {
      const t2 = z.shift();
      X.push(true === x2 ? d(t2) : t2);
    }
  }
  return X;
}
function v2(t) {
  if (!t)
    return null;
  const e = t.extent;
  if (!e)
    return null;
  const n = t.spatialReference && G(t.spatialReference);
  if (!n)
    return e;
  const [s5, o3] = n.valid, r3 = 2 * o3, { width: i3 } = e;
  let l, { xmin: c, xmax: u } = e;
  if ([c, u] = [u, c], "extent" === t.type || 0 === i3 || i3 <= o3 || i3 > r3 || c < s5 || u > o3)
    return e;
  switch (t.type) {
    case "polygon":
      if (!(t.rings.length > 1))
        return e;
      l = d2(t.rings);
      break;
    case "polyline":
      if (!(t.paths.length > 1))
        return e;
      l = d2(t.paths);
      break;
    case "multipoint":
      l = t.points;
  }
  const a = e.clone();
  for (let f2 = 0; f2 < l.length; f2++) {
    let t2 = l[f2][0];
    t2 < 0 ? (t2 += o3, u = Math.max(t2, u)) : (t2 -= o3, c = Math.min(t2, c));
  }
  return a.xmin = c, a.xmax = u, a.width < i3 ? (a.xmin -= o3, a.xmax -= o3, a) : e;
}
function P(t, e, n) {
  const s5 = G(n);
  if (null == s5)
    return t;
  const [o3, r3] = s5.valid, i3 = 2 * r3;
  let l = 0, c = 0;
  e > r3 ? l = Math.ceil(Math.abs(e - r3) / i3) : e < o3 && (l = -Math.ceil(Math.abs(e - o3) / i3)), t > r3 ? c = Math.ceil(Math.abs(t - r3) / i3) : t < o3 && (c = -Math.ceil(Math.abs(t - o3) / i3));
  let u = t + (l - c) * i3;
  const a = u - e;
  return a > r3 ? u -= i3 : a < o3 && (u += i3), u;
}
function L(t, e) {
  const n = G(e);
  if (n) {
    const [e2, s5] = n.valid, o3 = s5 - e2;
    if (t < e2)
      for (; t < e2; )
        t += o3;
    if (t > s5)
      for (; t > s5; )
        t -= o3;
  }
  return t;
}

export {
  R2 as R,
  v2 as v,
  P,
  L
};
//# sourceMappingURL=chunk-LOGPPZUD.js.map
