import {
  A as A2,
  N,
  h,
  i as i2,
  o
} from "./chunk-EWVUTXQQ.js";
import {
  i,
  s as s4,
  u
} from "./chunk-OJ65P3EQ.js";
import {
  w
} from "./chunk-AOJ6OCPK.js";
import "./chunk-LMT5JII2.js";
import {
  r as r3
} from "./chunk-APYNYYQC.js";
import {
  V,
  Wt,
  j
} from "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import "./chunk-LXXF7K7W.js";
import {
  r2
} from "./chunk-SBW6NNVI.js";
import "./chunk-62CXLI6S.js";
import {
  A,
  a,
  e,
  s as s3
} from "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import {
  n,
  r,
  t
} from "./chunk-CQS47VN5.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import {
  has
} from "./chunk-4V6374PV.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/graphics/sources/support/uploadAssetErrors.js
var e2 = "upload-assets";
var o2 = () => new Error();
var r4 = class extends s2 {
  constructor() {
    super(`${e2}:unsupported`, "Layer does not support asset uploads.", o2());
  }
};
var t2 = class extends s2 {
  constructor() {
    super(`${e2}:no-glb-support`, "Layer does not support glb.", o2());
  }
};
var a2 = class extends s2 {
  constructor() {
    super(`${e2}:no-supported-source`, "No supported external source found", o2());
  }
};
var n2 = class extends s2 {
  constructor() {
    super(`${e2}:not-base-64`, "Expected gltf data in base64 format after conversion.", o2());
  }
};
var p = class extends s2 {
  constructor() {
    super(`${e2}:unable-to-prepare-options`, "Unable to prepare uploadAsset request options.", o2());
  }
};
var u2 = class extends s2 {
  constructor(s5, r5) {
    super(`${e2}:bad-response`, `Bad response. Uploaded ${s5} items and received ${r5} results.`, o2());
  }
};
var c = class extends s2 {
  constructor(s5, r5) {
    super(`${e2}-layer:upload-failed`, `Failed to upload mesh file ${s5}. Error code: ${(r5 == null ? void 0 : r5.code) ?? "-1"}. Error message: ${(r5 == null ? void 0 : r5.messages) ?? "unknown"}`, o2());
  }
};
var d = class extends s2 {
  constructor(s5) {
    super(`${e2}-layer:unsupported-format`, `The service allowed us to upload an asset of FormatID ${s5}, but it does not list it in its supported formats.`, o2());
  }
};
var l = class extends s2 {
  constructor() {
    super(`${e2}:convert3D-failed`, "convert3D failed.");
  }
};

// node_modules/@arcgis/core/layers/graphics/sources/support/uploadProgressWeights.js
var e3 = { upload: { createFromFiles: 0.8, loadMesh: 0.2 }, uploadAssetBlobs: { prepareAssetItems: 0.9, uploadAssetItems: 0.1 }, uploadConvertibleSource: { uploadEditSource: 0.5, serviceAssetsToGlb: 0.5 }, uploadLocalMesh: { meshToAssetBlob: 0.5, uploadAssetBlobs: 0.5 } };

// node_modules/@arcgis/core/support/progressUtils.js
function i3(s5, t3 = (s6) => {
}, e4) {
  return new n3(s5, t3, e4);
}
var n3 = class {
  constructor(s5, t3 = (s6) => {
  }, e4) {
    if (this.onProgress = t3, this.taskName = e4, this._progressMap = /* @__PURE__ */ new Map(), this._startTime = void 0, this._timingsMap = /* @__PURE__ */ new Map(), "number" == typeof s5) {
      this._weights = {};
      for (let t4 = 0; t4 < s5; t4++) {
        const e5 = t4, r5 = 1 / s5;
        this._weights[e5] = r5, this._progressMap.set(e5, 0);
      }
    } else
      this._weights = s5;
    this.emitProgress();
  }
  emitProgress() {
    let s5 = 0;
    for (const [t3, e4] of this._progressMap.entries()) {
      s5 += e4 * this._weights[t3];
    }
    if (1 === s5 && has("enable-feature:esri-3dofl-upload-timings")) {
      const s6 = Math.round(performance.now() - (this._startTime ?? 0)) / 1e3;
      console.log(`${this.taskName} done in ${s6} sec`);
      for (const [t3, e4] of this._timingsMap) {
        const r5 = Math.round(e4.end - e4.start) / 1e3, o3 = Math.round(r5 / s6 * 100);
        console.log(this.taskName ?? "Task", { stepKey: t3, stepTime: r5, relativeTime: o3 });
      }
    }
    this.onProgress(s5);
  }
  setProgress(s5, e4) {
    if (this._progressMap.set(s5, e4), has("enable-feature:esri-3dofl-upload-timings")) {
      const r5 = performance.now();
      this._startTime ?? (this._startTime = r5);
      const o3 = r2(this._timingsMap, s5, () => ({ start: r5, end: 0 }));
      1 === e4 && (o3.end = r5);
    }
    this.emitProgress();
  }
  simulate(s5, t3) {
    return a3((t4) => this.setProgress(s5, t4), t3);
  }
  makeOnProgress(s5) {
    return (t3) => this.setProgress(s5, t3);
  }
};
function a3(t3 = (s5) => {
}, e4 = l2) {
  const r5 = performance.now();
  t3(0);
  const o3 = setInterval(() => {
    const s5 = performance.now() - r5, o4 = 1 - Math.exp(-s5 / e4);
    t3(o4);
  }, g);
  return e(() => {
    clearInterval(o3), t3(1);
  });
}
function h2(s5, t3 = c2) {
  return r(t(s5 * f / t3));
}
function m(s5, t3 = p2) {
  return r(t(s5 * f / t3));
}
var c2 = 10;
var p2 = 10;
var f = 8e-6;
var g = n(50);
var l2 = n(1e3);

// node_modules/@arcgis/core/layers/graphics/sources/support/uploads.js
var i4 = 1e6;
var p3 = 20 * i4;
var l3 = 2e9;
var m2 = 3;
async function c3({ data: r5, name: c4, description: u3 }, d2, h3) {
  let j2 = null;
  try {
    const w2 = V(d2, "uploads"), y = V(w2, "info"), { data: g2 } = await j(y, { query: { f: "json" }, responseType: "json" });
    s3(h3);
    const U = w(d2), q2 = g2.maxUploadFileSize * i4, z2 = U ? l3 : q2, T = U ? Math.min(p3, q2) : p3;
    if (r5.size > z2)
      throw new Error("Data too large");
    const A3 = V(w2, "register"), { data: E } = await j(A3, { query: { f: "json", itemName: f2(c4), description: u3 }, responseType: "json", method: "post" });
    if (s3(h3), !E.success)
      throw new Error("Registration failed");
    const { itemID: P } = E.item;
    j2 = V(w2, P);
    const D = V(j2, "uploadPart"), I2 = Math.ceil(r5.size / T), M2 = new Array();
    for (let e4 = 0; e4 < I2; ++e4)
      M2.push(r5.slice(e4 * T, Math.min((e4 + 1) * T, r5.size)));
    const b = M2.slice().reverse(), v2 = new Array(), x = i3(I2, h3 == null ? void 0 : h3.onProgress, "uploadItem"), F = async () => {
      for (; 0 !== b.length; ) {
        const t3 = M2.length - b.length, s5 = b.pop(), r6 = new FormData(), a4 = x.simulate(t3, h2(s5.size));
        try {
          const a5 = s5;
          r6.append("f", "json"), r6.append("file", a5), r6.append("partId", `${t3}`);
          const { data: n5 } = await j(D, { timeout: 0, body: r6, responseType: "json", method: "post" });
          if (s3(h3), !n5.success)
            throw new Error("Part upload failed");
        } finally {
          a4.remove();
        }
      }
    };
    for (let e4 = 0; e4 < m2 && 0 !== b.length; ++e4)
      v2.push(F());
    await Promise.all(v2);
    const _2 = V(j2, "commit"), { data: C2 } = await j(_2, { query: { f: "json", parts: M2.map((e4, o3) => o3).join(",") }, responseType: "json", method: "post" });
    if (s3(h3), !C2.success)
      throw new Error("Commit failed");
    return C2.item;
  } catch (w2) {
    if (null != j2) {
      const o3 = V(j2, "delete");
      await j(o3, { query: { f: "json" }, responseType: "json", method: "post" });
    }
    throw w2;
  }
}
function f2(e4) {
  return e4.replaceAll("/", "_").replaceAll("\\", "_");
}

// node_modules/@arcgis/core/layers/graphics/sources/support/uploadAssets.js
async function O(s5, e4, t3) {
  var _a;
  const r5 = s5.length;
  if (!r5)
    return (_a = t3 == null ? void 0 : t3.onProgress) == null ? void 0 : _a.call(t3, 1), [];
  const o3 = i3(r5, t3 == null ? void 0 : t3.onProgress, "uploadAssets");
  return Promise.all(s5.map((s6, r6) => v(s6, e4, { ...t3, onProgress: o3.makeOnProgress(r6) })));
}
async function v(s5, { layer: e4, ongoingUploads: t3 }, r5) {
  var _a;
  const o3 = t3.get(s5);
  if (o3)
    return o3;
  if (!Z(e4))
    throw new r4();
  if (I(s5, e4))
    return (_a = r5 == null ? void 0 : r5.onProgress) == null ? void 0 : _a.call(r5, 1), s5;
  const n5 = k(s5, e4, r5);
  t3.set(s5, n5);
  try {
    await n5;
  } finally {
    t3.delete(s5);
  }
  return s5;
}
function I(s5, e4) {
  const { parsedUrl: t3 } = e4;
  return null != t3 && s5.metadata.externalSources.some((s6) => h(s6, t3));
}
async function k(s5, e4, r5) {
  const { metadata: o3 } = s5, { displaySource: n5 } = o3, a4 = H(n5 == null ? void 0 : n5.source, e4), i5 = !!a4, c4 = o3.externalSources.length > 0, u3 = i5 ? B(a4, e4, r5) : c4 ? R(s5, e4, r5) : C(s5, e4, r5), l4 = await u3;
  return s3(r5), s5.addExternalSources([l4]), s5;
}
async function B(s5, e4, t3) {
  return { source: await G(s5, e4, t3), original: true };
}
async function R(s5, e4, t3) {
  const r5 = _(e4), { externalSources: o3 } = s5.metadata, n5 = q(o3, e4);
  if (!n5)
    throw new a2();
  const a4 = i3(e3.uploadConvertibleSource, t3 == null ? void 0 : t3.onProgress, "uploadConvertibleSource"), i5 = await G(n5, e4, { onProgress: a4.makeOnProgress("uploadEditSource") });
  s5.addExternalSources([{ source: i5, original: true }]);
  const c4 = n5.reduce((s6, { asset: e5 }) => e5 instanceof File ? s6 + e5.size : s6, 0), u3 = a4.simulate("serviceAssetsToGlb", m(c4));
  try {
    return { source: await V2(i5, e4, r5) };
  } finally {
    u3.remove();
  }
}
async function C(s5, e4, t3) {
  const r5 = i3(e3.uploadLocalMesh, t3 == null ? void 0 : t3.onProgress, "uploadLocalMesh"), o3 = L(s5, e4, { ...t3, onProgress: r5.makeOnProgress("meshToAssetBlob") });
  return { source: await J([o3], e4, { ...t3, onProgress: r5.makeOnProgress("uploadAssetBlobs") }), extent: s5.extent.clone(), original: true };
}
async function L(s5, e4, r5) {
  const o3 = _(e4), n5 = await s5.load(r5), a4 = await n5.toBinaryGLTF({ ignoreLocalTransform: true });
  s3(r5);
  const i5 = await a4.buffer();
  return s3(r5), { blob: new Blob([i5.data], { type: i5.type }), assetName: `${r3()}.glb`, assetType: o3 };
}
function q(s5, e4) {
  for (const t3 of s5) {
    const s6 = H(t3.source, e4);
    if (s6)
      return s6;
  }
  return null;
}
function H(s5, e4) {
  if (!s5)
    return null;
  const { infoFor3D: { supportedFormats: t3, editFormats: r5 } } = e4, o3 = A2(s5), n5 = new Array();
  let a4 = false;
  for (let i5 = 0; i5 < o3.length; ++i5) {
    const s6 = $(o3[i5], t3);
    if (!s6)
      return null;
    r5.includes(s6.assetType) && (a4 = true), n5.push(s6);
  }
  return a4 ? n5 : null;
}
function $(s5, e4) {
  const t3 = N(s5, e4);
  return t3 ? { asset: s5, assetType: t3 } : null;
}
async function G(s5, e4, t3) {
  return J(s5.map((s6) => M(s6, t3)), e4, t3);
}
async function J(s5, e4, r5) {
  const o3 = i3(e3.uploadAssetBlobs, r5 == null ? void 0 : r5.onProgress, "uploadAssetBlobs"), n5 = await z(s5, e4, { ...r5, onProgress: o3.makeOnProgress("prepareAssetItems") });
  s3(r5);
  const a4 = n5.map(({ item: s6 }) => s6), { uploadResults: i5 } = await K(a4, e4, { ...r5, onProgress: o3.makeOnProgress("uploadAssetItems") });
  return s3(r5), s5.map((s6, t3) => Q(n5[t3], i5[t3], e4));
}
async function M(s5, e4) {
  const { asset: r5, assetType: o3 } = s5;
  if (r5 instanceof File)
    return { blob: r5, assetName: r5.name, assetType: o3 };
  const n5 = await r5.toBlob(e4);
  return s3(e4), { blob: n5, assetName: r5.assetName, assetType: o3 };
}
async function W(s5, e4, r5) {
  const { blob: n5, assetType: a4, assetName: c4 } = s5;
  let u3 = null;
  try {
    const s6 = await c3({ data: n5, name: c4 }, e4.url, r5);
    s3(r5), u3 = { assetType: a4, assetUploadId: s6.itemID };
  } catch (l4) {
    a(l4), ss().warnOnce(`Service ${e4.url} does not support the REST Uploads API.`);
  }
  if (!u3) {
    const s6 = await Wt(n5);
    if (s3(r5), !s6.isBase64)
      throw new n2();
    u3 = { assetType: a4, assetData: s6.data };
  }
  if (!u3)
    throw new p();
  return { item: u3, assetName: c4 };
}
function z(s5, e4, r5) {
  const o3 = i3(s5.length, r5 == null ? void 0 : r5.onProgress, "prepareAssetItems");
  return Promise.all(s5.map(async (s6, n5) => {
    const a4 = W(await s6, e4, { ...r5, onProgress: o3.makeOnProgress(n5) });
    return s3(r5), a4;
  }));
}
async function K(e4, r5, o3) {
  const n5 = a3(o3 == null ? void 0 : o3.onProgress);
  try {
    const n6 = await j(V(r5.parsedUrl.path, "uploadAssets"), { timeout: 0, query: { f: "json", assets: JSON.stringify(e4) }, method: "post", responseType: "json" });
    if (s3(o3), n6.data.uploadResults.length !== e4.length)
      throw new u2(e4.length, n6.data.uploadResults.length);
    return n6.data;
  } finally {
    n5.remove();
  }
}
function Q(s5, e4, t3) {
  const { success: r5 } = e4;
  if (!r5) {
    const { error: t4 } = e4;
    throw new c(s5.assetName, t4);
  }
  const { assetHash: o3 } = e4, { assetName: n5, item: { assetType: a4 } } = s5, { infoFor3D: { supportedFormats: i5 } } = t3, c4 = s4(a4, i5);
  if (!c4)
    throw new d(a4);
  return new i2(n5, c4, [new o(`${t3.parsedUrl.path}/assets/${o3}`, o3)]);
}
async function V2(s5, e4, t3) {
  var _a;
  const r5 = s5.map(({ assetName: s6, parts: e5 }) => ({ assetName: s6, assetHash: e5[0].partHash })), o3 = (_a = e4.capabilities) == null ? void 0 : _a.operations.supportsAsyncConvert3D, n5 = { f: "json", assets: JSON.stringify(r5), transportType: "esriTransportTypeUrl", targetFormat: t3, async: o3 }, i5 = V(e4.parsedUrl.path, "convert3D");
  let c4;
  try {
    c4 = (await (o3 ? Y : X)(i5, { query: n5, responseType: "json", timeout: 0 })).data;
  } catch (l4) {
    throw new l();
  }
  const { supportedFormats: u3 } = e4.infoFor3D;
  return c4.assets.map((s6) => {
    const e5 = u(s6.contentType, u3);
    if (!e5)
      throw new d(e5);
    return new i2(s6.assetName, s6.contentType, [new o(s6.assetURL, s6.assetHash)]);
  });
}
function X(e4, t3) {
  return j(e4, t3);
}
async function Y(e4, t3) {
  const o3 = (await j(e4, t3)).data.statusUrl;
  for (; ; ) {
    const e5 = (await j(o3, { query: { f: "json" }, responseType: "json" })).data;
    switch (e5.status) {
      case "Completed":
        return j(e5.resultUrl, { query: { f: "json" }, responseType: "json" });
      case "CompletedWithErrors":
        throw new Error(e5.status);
      case "Failed ImportChanges":
      case "InProgress":
      case "Pending":
      case "ExportAttachments":
      case "ExportChanges":
      case "ExportingData":
      case "ExportingSnapshot":
      case "ImportAttachments":
      case "ProvisioningReplica":
      case "UnRegisteringReplica":
        break;
      default:
        throw new Error();
    }
    await A(es);
  }
}
function Z(s5) {
  return !!s5.infoFor3D && !!s5.url;
}
function _(s5) {
  const { infoFor3D: e4 } = s5, t3 = u("model/gltf-binary", e4.supportedFormats) ?? i("glb", e4.supportedFormats);
  if (!t3)
    throw new t2();
  return t3;
}
function ss() {
  return s.getLogger("esri.layers.graphics.sources.support.uploadAssets");
}
var es = n(1e3);
export {
  O as uploadAssets
};
//# sourceMappingURL=uploadAssets-O4J5MD7J.js.map
