import {
  r
} from "./chunk-EC5POYCL.js";
import {
  s as s3
} from "./chunk-24NOAXOQ.js";
import {
  s as s2
} from "./chunk-FN47E7YK.js";
import {
  k
} from "./chunk-LXXF7K7W.js";
import {
  s
} from "./chunk-SBW6NNVI.js";
import {
  C,
  E,
  m,
  u,
  w
} from "./chunk-RFPH3ZTZ.js";
import {
  l
} from "./chunk-WGO3VFQP.js";

// node_modules/@arcgis/core/core/ReactiveMap.js
var s4 = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map(), this._observable = new s2();
  }
  get size() {
    return s(this._observable), this._map.size;
  }
  clear() {
    this._map.size > 0 && (this._map.clear(), this._observable.notify());
  }
  delete(e) {
    const t = this._map.delete(e);
    return t && this._observable.notify(), t;
  }
  entries() {
    return s(this._observable), this._map.entries();
  }
  forEach(t, s5) {
    s(this._observable), this._map.forEach((e, r2) => t.call(s5, e, r2, this), s5);
  }
  get(t) {
    return s(this._observable), this._map.get(t);
  }
  has(t) {
    return s(this._observable), this._map.has(t);
  }
  keys() {
    return s(this._observable), this._map.keys();
  }
  set(e, t) {
    return this._map.set(e, t), this._observable.notify(), this;
  }
  values() {
    return s(this._observable), this._map.values();
  }
  [Symbol.iterator]() {
    return s(this._observable), this._map[Symbol.iterator]();
  }
  get [Symbol.toStringTag]() {
    return this._map[Symbol.toStringTag];
  }
};

// node_modules/@arcgis/core/views/support/QueueProcessor.js
var l2 = class {
  constructor(e, s5) {
    this.item = e, this.controller = s5, this.promise = null;
  }
};
var _ = class {
  constructor(e) {
    this._schedule = null, this._task = null, this._deferreds = new s4(), this._controllers = new s4(), this._processingItems = new s4(), this._pausedSignal = r(false), this.concurrency = 1, e.concurrency && (this.concurrency = e.concurrency), this._queue = new s3(e.peeker), this.process = e.process;
    const s5 = e.scheduler;
    e.priority && s5 && (this._task = s5.registerTask(e.priority, this));
  }
  destroy() {
    this.clear(), this._schedule = l(this._schedule), this._task = l(this._task);
  }
  get updating() {
    var _a;
    return !!((_a = this._task) == null ? void 0 : _a.updating) || this.running;
  }
  get length() {
    return this._processingItems.size + this._queue.length;
  }
  abort(e) {
    const s5 = this._controllers.get(e);
    s5 && s5.abort();
  }
  clear() {
    this._queue.clear();
    const e = [];
    this._controllers.forEach((s5) => e.push(s5)), this._controllers.clear(), e.forEach((e2) => e2.abort()), this._processingItems.clear(), this._cancelNext();
  }
  forEach(e) {
    this._deferreds.forEach((s5, t) => e(t));
  }
  get(e) {
    const s5 = this._deferreds.get(e);
    return s5 ? s5.promise : void 0;
  }
  isOngoing(e) {
    return this._processingItems.has(e);
  }
  has(e) {
    return this._deferreds.has(e);
  }
  pause() {
    this._pausedSignal.value || (this._pausedSignal.value = true, this._cancelNext());
  }
  push(e, i) {
    const o = this.get(e);
    if (o)
      return o;
    const c = new AbortController();
    let n = null;
    i && (n = m(i, () => c.abort()));
    const u2 = () => {
      const s5 = this._processingItems.get(e);
      s5 && s5.controller.abort(), l3(), a.reject(u());
    }, l3 = () => {
      _2.remove(), null != n && n.remove(), this._deferreds.delete(e), this._controllers.delete(e), this._queue.remove(e), this._processingItems.delete(e), this._scheduleNext();
    }, _2 = w(c.signal, u2), a = C();
    return this._deferreds.set(e, a), this._controllers.set(e, c), a.promise.then(l3, l3), this._queue.push(e), this._scheduleNext(), a.promise;
  }
  last() {
    return this._queue.last();
  }
  peek() {
    return this._queue.peek();
  }
  popLast() {
    return this._queue.popLast();
  }
  reset() {
    const e = [];
    this._processingItems.forEach((s5) => e.push(s5)), this._processingItems.clear();
    for (const s5 of e)
      this._queue.push(s5.item), s5.controller.abort();
    this._scheduleNext();
  }
  resume() {
    this._pausedSignal.value && (this._pausedSignal.value = false, this._scheduleNext());
  }
  takeAll() {
    const e = [];
    for (; this._queue.length; )
      e.push(this._queue.pop());
    return this.clear(), e;
  }
  get running() {
    return !this._pausedSignal.value && this._queue.length > 0 && this._processingItems.size < this.concurrency;
  }
  runTask(e) {
    for (; !e.done && this._queue.length > 0 && this._processingItems.size < this.concurrency; )
      this._process(this._queue.pop()), e.madeProgress();
  }
  _scheduleNext() {
    this._task || this._pausedSignal.value || this._schedule || (this._schedule = k(() => {
      this._schedule = null, this._next();
    }));
  }
  _next() {
    for (; this._queue.length > 0 && this._processingItems.size < this.concurrency; )
      this._process(this._queue.pop());
  }
  _cancelNext() {
    this._schedule && (this._schedule.remove(), this._schedule = null);
  }
  _processResult(e, s5) {
    this._canProcessFulfillment(e) && (this._scheduleNext(), this._deferreds.get(e.item).resolve(s5));
  }
  _processError(e, s5) {
    this._canProcessFulfillment(e) && (this._scheduleNext(), this._deferreds.get(e.item).reject(s5));
  }
  _canProcessFulfillment(e) {
    return !!this._deferreds.get(e.item) && this._processingItems.get(e.item) === e;
  }
  _process(e) {
    if (null == e)
      return;
    let s5;
    const t = new AbortController(), r2 = new l2(e, t);
    this._processingItems.set(e, r2);
    try {
      s5 = this.process(e, t.signal);
    } catch (h) {
      this._processError(r2, h);
    }
    E(s5) ? (r2.promise = s5, s5.then((e2) => this._processResult(r2, e2), (e2) => this._processError(r2, e2))) : this._processResult(r2, s5);
  }
  get test() {
    return { update: (e) => this.runTask(e) };
  }
};

export {
  _
};
//# sourceMappingURL=chunk-2FFBPEOX.js.map
