import {
  a,
  c as c2,
  g,
  r as r4
} from "./chunk-MXOY2B3L.js";
import {
  r as r3
} from "./chunk-PRZWMTUS.js";
import {
  c2 as c
} from "./chunk-UTUG5XXJ.js";
import "./chunk-NB4VIBDC.js";
import {
  C,
  D
} from "./chunk-RCLKRKWR.js";
import {
  E,
  V as V2,
  p
} from "./chunk-5VOKVSCM.js";
import "./chunk-SD4PEUIA.js";
import "./chunk-TOWKJZW4.js";
import {
  m
} from "./chunk-SLEGPWAA.js";
import "./chunk-GLOKOXWD.js";
import {
  e as e2,
  o as o2
} from "./chunk-4OLZTDWK.js";
import {
  K,
  T
} from "./chunk-JYYKU27J.js";
import {
  e as e3,
  o as o3,
  r as r2
} from "./chunk-SKLWU2B3.js";
import "./chunk-2RN2AAP7.js";
import "./chunk-YHB3DQSV.js";
import "./chunk-SBUFDP7O.js";
import "./chunk-YVNEJWNQ.js";
import "./chunk-NDKHIQMD.js";
import "./chunk-G557TGXY.js";
import "./chunk-PJQIAD5D.js";
import "./chunk-WJ4LS3YG.js";
import {
  f as f2
} from "./chunk-F6MD5VOH.js";
import "./chunk-V2RPSCV3.js";
import "./chunk-LMT5JII2.js";
import "./chunk-4HKQSEUR.js";
import "./chunk-V3U4F2NL.js";
import "./chunk-ZB6PGKG5.js";
import "./chunk-OIIDE5GZ.js";
import "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import {
  M
} from "./chunk-MKW4ORPJ.js";
import {
  F,
  _2 as _,
  e2 as e,
  f,
  l,
  n,
  o,
  t,
  z
} from "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import "./chunk-FN47E7YK.js";
import "./chunk-Y5D433JZ.js";
import {
  x2 as x
} from "./chunk-QNOCEWCR.js";
import "./chunk-WURET5CW.js";
import "./chunk-QWPLZ3QH.js";
import {
  V
} from "./chunk-HLGIRLYQ.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import {
  ct
} from "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import "./chunk-LXXF7K7W.js";
import {
  r2 as r
} from "./chunk-SBW6NNVI.js";
import "./chunk-62CXLI6S.js";
import "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import {
  O
} from "./chunk-4V6374PV.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/glb.js
var t2;
!function(t3) {
  t3[t3.JSON = 1313821514] = "JSON", t3[t3.BIN = 5130562] = "BIN";
}(t2 || (t2 = {}));
var e4 = class _e {
  constructor(i4, r6) {
    if (!i4)
      throw new Error("GLB requires a JSON gltf chunk");
    this._length = _e.HEADER_SIZE, this._length += _e.CHUNK_HEADER_SIZE;
    const n2 = this._textToArrayBuffer(i4);
    if (this._length += this._alignTo(n2.byteLength, 4), r6 && (this._length += _e.CHUNK_HEADER_SIZE, this._length += r6.byteLength, r6.byteLength % 4))
      throw new Error("Expected BIN chunk length to be divisible by 4 at this point");
    this.buffer = new ArrayBuffer(this._length), this._outView = new DataView(this.buffer), this._writeHeader();
    const h = this._writeChunk(n2, 12, t2.JSON, 32);
    r6 && this._writeChunk(r6, h, t2.BIN);
  }
  _writeHeader() {
    this._outView.setUint32(0, _e.MAGIC, true), this._outView.setUint32(4, _e.VERSION, true), this._outView.setUint32(8, this._length, true);
  }
  _writeChunk(t3, e5, i4, r6 = 0) {
    const n2 = this._alignTo(t3.byteLength, 4);
    for (this._outView.setUint32(e5, n2, true), this._outView.setUint32(e5 += 4, i4, true), this._writeArrayBuffer(this._outView.buffer, t3, e5 += 4, 0, t3.byteLength), e5 += t3.byteLength; e5 % 4; )
      r6 && this._outView.setUint8(e5, r6), e5++;
    return e5;
  }
  _writeArrayBuffer(t3, e5, i4, r6, n2) {
    new Uint8Array(t3, i4, n2).set(new Uint8Array(e5, r6, n2), 0);
  }
  _textToArrayBuffer(t3) {
    return new TextEncoder().encode(t3).buffer;
  }
  _alignTo(t3, e5) {
    return e5 * Math.ceil(t3 / e5);
  }
};
e4.HEADER_SIZE = 12, e4.CHUNK_HEADER_SIZE = 8, e4.MAGIC = 1179937895, e4.VERSION = 2;

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/types.js
var E2;
var A;
var R;
var L;
var o4;
var I;
var N;
!function(E3) {
  E3[E3.External = 0] = "External", E3[E3.DataURI = 1] = "DataURI", E3[E3.GLB = 2] = "GLB";
}(E2 || (E2 = {})), function(E3) {
  E3[E3.External = 0] = "External", E3[E3.DataURI = 1] = "DataURI", E3[E3.GLB = 2] = "GLB";
}(A || (A = {})), function(E3) {
  E3[E3.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", E3[E3.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER";
}(R || (R = {})), function(E3) {
  E3.SCALAR = "SCALAR", E3.VEC2 = "VEC2", E3.VEC3 = "VEC3", E3.VEC4 = "VEC4", E3.MAT2 = "MAT2", E3.MAT3 = "MAT3", E3.MAT4 = "MAT4";
}(L || (L = {})), function(E3) {
  E3[E3.POINTS = 0] = "POINTS", E3[E3.LINES = 1] = "LINES", E3[E3.LINE_LOOP = 2] = "LINE_LOOP", E3[E3.LINE_STRIP = 3] = "LINE_STRIP", E3[E3.TRIANGLES = 4] = "TRIANGLES", E3[E3.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", E3[E3.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
}(o4 || (o4 = {})), function(E3) {
  E3.OPAQUE = "OPAQUE", E3.MASK = "MASK", E3.BLEND = "BLEND";
}(I || (I = {})), function(E3) {
  E3[E3.NoColor = 0] = "NoColor", E3[E3.FaceColor = 1] = "FaceColor", E3[E3.VertexColor = 2] = "VertexColor";
}(N || (N = {}));

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/bufferview.js
var i = class {
  constructor(t3, s5, i4, r6, n2) {
    this._buffer = t3, this._componentType = i4, this._dataType = r6, this._data = [], this._isFinalized = false, this._accessorIndex = -1, this._accessorAttribute = null, this._accessorMin = null, this._accessorMax = null, s5.bufferViews || (s5.bufferViews = []), this.index = s5.bufferViews.length, this._bufferView = { buffer: t3.index, byteLength: -1, target: n2 };
    const a4 = this._getElementSize();
    a4 >= 4 && n2 !== R.ELEMENT_ARRAY_BUFFER && (this._bufferView.byteStride = a4), s5.bufferViews.push(this._bufferView), this._numComponentsForDataType = this._calculateNumComponentsForDataType();
  }
  push(e5) {
    const t3 = this._data.length;
    if (this._data.push(e5), this._accessorIndex >= 0) {
      const s5 = t3 % this._numComponentsForDataType, i4 = this._accessorMin[s5];
      this._accessorMin[s5] = "number" != typeof i4 ? e5 : Math.min(i4, e5);
      const r6 = this._accessorMax[s5];
      this._accessorMax[s5] = "number" != typeof r6 ? e5 : Math.max(r6, e5);
    }
  }
  get dataSize() {
    return this._data.length * this._sizeComponentType();
  }
  get byteSize() {
    function e5(e6, t3) {
      return t3 * Math.ceil(e6 / t3);
    }
    return e5(this.dataSize, 4);
  }
  getByteOffset() {
    if (!this._isFinalized)
      throw new Error("Cannot get BufferView offset until it is finalized");
    return this._buffer.getByteOffset(this);
  }
  get byteOffset() {
    if (!this._isFinalized)
      throw new Error("Cannot get BufferView offset until it is finalized");
    return this._buffer.getByteOffset(this);
  }
  _createTypedArray(e5, t3) {
    switch (this._componentType) {
      case C.BYTE:
        return new Int8Array(e5, t3);
      case C.FLOAT:
        return new Float32Array(e5, t3);
      case C.SHORT:
        return new Int16Array(e5, t3);
      case C.UNSIGNED_BYTE:
        return new Uint8Array(e5, t3);
      case C.UNSIGNED_INT:
        return new Uint32Array(e5, t3);
      case C.UNSIGNED_SHORT:
        return new Uint16Array(e5, t3);
    }
  }
  writeOutToBuffer(e5, t3) {
    this._createTypedArray(e5, t3).set(this._data);
  }
  writeAsync(e5) {
    if (this._asyncWritePromise)
      throw new Error("Can't write multiple bufferView values asynchronously");
    return this._asyncWritePromise = e5.then((e6) => {
      const t3 = new Uint8Array(e6);
      for (let s5 = 0; s5 < t3.length; ++s5)
        this._data.push(t3[s5]);
      delete this._asyncWritePromise;
    }), this._asyncWritePromise;
  }
  startAccessor(e5) {
    if (this._accessorIndex >= 0)
      throw new Error("Accessor was started without ending the previous one");
    this._accessorIndex = this._data.length, this._accessorAttribute = e5;
    const t3 = this._numComponentsForDataType;
    this._accessorMin = new Array(t3), this._accessorMax = new Array(t3);
  }
  endAccessor() {
    if (this._accessorIndex < 0)
      throw new Error("An accessor was not started, but was attempted to be ended");
    const e5 = this._getElementSize(), t3 = this._numComponentsForDataType, i4 = (this._data.length - this._accessorIndex) / t3;
    if (i4 % 1)
      throw new Error("An accessor was ended with missing component values");
    for (let s5 = 0; s5 < this._accessorMin.length; ++s5)
      "number" != typeof this._accessorMin[s5] && (this._accessorMin[s5] = 0), "number" != typeof this._accessorMax[s5] && (this._accessorMax[s5] = 0);
    const r6 = { byteOffset: e5 * (this._accessorIndex / t3), componentType: this._componentType, count: i4, type: this._dataType, min: this._accessorMin, max: this._accessorMax, name: this._accessorAttribute };
    switch (this._accessorAttribute) {
      case "TEXCOORD_0":
      case "TEXCOORD_1":
      case "COLOR_0":
      case "WEIGHTS_0":
        switch (this._componentType) {
          case C.UNSIGNED_BYTE:
          case C.UNSIGNED_SHORT:
            r6.normalized = true;
        }
    }
    return this._accessorIndex = -1, this._accessorAttribute = null, this._accessorMin = null, this._accessorMax = null, r6;
  }
  get finalized() {
    return this._finalizedPromise ? this._finalizedPromise : this._isFinalized ? this._finalizedPromise = Promise.resolve() : this._finalizedPromise = new Promise((e5) => this._finalizedPromiseResolve = e5);
  }
  async finalize() {
    const e5 = this._bufferView, t3 = this._buffer.getViewFinalizePromises(this);
    this._asyncWritePromise && t3.push(this._asyncWritePromise), await Promise.allSettled(t3), this._isFinalized = true, e5.byteOffset = this.getByteOffset(), e5.byteLength = this.dataSize, this._finalizedPromiseResolve && this._finalizedPromiseResolve();
  }
  _getElementSize() {
    return this._sizeComponentType() * this._numComponentsForDataType;
  }
  _sizeComponentType() {
    switch (this._componentType) {
      case C.BYTE:
      case C.UNSIGNED_BYTE:
        return 1;
      case C.SHORT:
      case C.UNSIGNED_SHORT:
        return 2;
      case C.UNSIGNED_INT:
      case C.FLOAT:
        return 4;
    }
  }
  _calculateNumComponentsForDataType() {
    switch (this._dataType) {
      case L.SCALAR:
        return 1;
      case L.VEC2:
        return 2;
      case L.VEC3:
        return 3;
      case L.VEC4:
      case L.MAT2:
        return 4;
      case L.MAT3:
        return 9;
      case L.MAT4:
        return 16;
    }
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/buffer.js
var i2 = class {
  constructor(e5) {
    this._gltf = e5, this._bufferViews = [], this._isFinalized = false, e5.buffers || (e5.buffers = []), this.index = e5.buffers.length;
    const i4 = { byteLength: -1 };
    e5.buffers.push(i4), this._buffer = i4;
  }
  addBufferView(i4, t3, r6) {
    if (this._finalizePromise)
      throw new Error("Cannot add buffer view after fiinalizing buffer");
    const f6 = new i(this, this._gltf, i4, t3, r6);
    return this._bufferViews.push(f6), f6;
  }
  getByteOffset(e5) {
    let i4 = 0;
    for (const t3 of this._bufferViews) {
      if (t3 === e5)
        return i4;
      i4 += t3.byteSize;
    }
    throw new Error("Given bufferView was not present in this buffer");
  }
  getViewFinalizePromises(e5) {
    const i4 = [];
    for (const t3 of this._bufferViews) {
      if (e5 && t3 === e5)
        return i4;
      i4.push(t3.finalized);
    }
    return i4;
  }
  getArrayBuffer() {
    if (!this._isFinalized)
      throw new Error("Cannot get ArrayBuffer from Buffer before it is finalized");
    const e5 = this._getTotalSize(), i4 = new ArrayBuffer(e5);
    let t3 = 0;
    for (const r6 of this._bufferViews)
      r6.writeOutToBuffer(i4, t3), t3 += r6.byteSize;
    return i4;
  }
  finalize() {
    var _a;
    if (this._finalizePromise)
      throw new Error(`Buffer ${this.index} was already finalized`);
    return this._finalizePromise = Promise.allSettled(this.getViewFinalizePromises()).then(() => {
      this._isFinalized = true;
      const e5 = this.getArrayBuffer();
      this._buffer.byteLength = e5.byteLength, this._buffer.uri = e5;
    }), (_a = this._gltf.extras) == null ? void 0 : _a.promises.push(this._finalizePromise), this._finalizePromise;
  }
  _getTotalSize() {
    let e5 = 0;
    for (const i4 of this._bufferViews)
      e5 += i4.byteSize;
    return e5;
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/geometry.js
function r5(n2, t3) {
  if (n2.components)
    for (const e5 of n2.components)
      e5.faces && "smooth" === e5.shading && a2(e5, t3);
}
function a2(s5, i4) {
  null == i4.normal && (i4.normal = new Float32Array(i4.position.length));
  const r6 = s5.faces, { position: a4, normal: c4 } = i4, h = r6.length / 3;
  for (let o5 = 0; o5 < h; ++o5) {
    const s6 = 3 * r6[3 * o5], i5 = 3 * r6[3 * o5 + 1], p4 = 3 * r6[3 * o5 + 2], h2 = o(f3, a4[s6], a4[s6 + 1], a4[s6 + 2]), u2 = o(l2, a4[i5], a4[i5 + 1], a4[i5 + 2]), g2 = o(m2, a4[p4], a4[p4 + 1], a4[p4 + 2]), x2 = e(u2, u2, h2), v = e(g2, g2, h2), R2 = _(x2, x2, v);
    c4[s6] += R2[0], c4[s6 + 1] += R2[1], c4[s6 + 2] += R2[2], c4[i5] += R2[0], c4[i5 + 1] += R2[1], c4[i5 + 2] += R2[2], c4[p4] += R2[0], c4[p4 + 1] += R2[1], c4[p4 + 2] += R2[2];
  }
  for (let t3 = 0; t3 < c4.length; t3 += 3)
    o(p2, c4[t3], c4[t3 + 1], c4[t3 + 2]), z(p2, p2), c4[t3] = p2[0], c4[t3 + 1] = p2[1], c4[t3 + 2] = p2[2];
}
function c3(n2) {
  const { vertexSpace: t3 } = n2;
  if (t3.isRelative)
    return t3.getOriginPoint(n2.spatialReference);
  const { extent: e5 } = n2, o5 = e5.xmax - e5.width / 2, s5 = e5.ymax - e5.height / 2, r6 = e5.zmin;
  return new x({ x: o5, y: s5, z: r6, spatialReference: e5.spatialReference });
}
var f3 = n();
var l2 = n();
var m2 = n();
var p2 = n();

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/gltf.js
var L2 = s.getLogger("gltf");
var y = class {
  constructor(e5, t3, s5) {
    this.params = {}, this._materialMap = new Array(), this._imageMap = /* @__PURE__ */ new Map(), this._textureMap = /* @__PURE__ */ new Map(), this.gltf = { asset: { version: "2.0", copyright: e5.copyright, generator: e5.generator }, extras: { options: t3, binChunkBuffer: null, promises: [] } }, s5 && (this.params = s5), this._addScenes(e5);
  }
  _addScenes(e5) {
    this.gltf.scene = e5.defaultScene;
    const t3 = this.gltf.extras, s5 = t3.options.bufferOutputType === E2.GLB || t3.options.imageOutputType === A.GLB;
    s5 && (t3.binChunkBuffer = new i2(this.gltf)), e5.forEachScene((e6) => {
      this._addScene(e6);
    }), s5 && t3.binChunkBuffer.finalize();
  }
  _addScene(e5) {
    this.gltf.scenes || (this.gltf.scenes = []);
    const t3 = {};
    e5.name && (t3.name = e5.name), e5.forEachNode((e6) => {
      t3.nodes || (t3.nodes = []), t3.nodes.push(...this._addNodes(e6));
    }), this.gltf.scenes.push(t3);
  }
  _addNodes(e5) {
    this.gltf.nodes || (this.gltf.nodes = []);
    const t3 = {};
    e5.name && (t3.name = e5.name);
    const s5 = e5.translation;
    F(s5, f) || (t3.translation = t(s5));
    const r6 = e5.rotation;
    K(r6, o3) || (t3.rotation = r2(r6));
    const i4 = e5.scale;
    F(i4, l) || (t3.scale = t(i4));
    const a4 = this.gltf.nodes.length;
    if (this.gltf.nodes.push(t3), e5.mesh && e5.mesh.vertexAttributes.position) {
      const s6 = this._createMeshes(e5.mesh), r7 = [a4];
      if (1 === s6.length)
        this._addMesh(t3, s6[0]);
      else
        for (const e6 of s6) {
          const t4 = {};
          this._addMesh(t4, e6), r7.push(this.gltf.nodes.length), this.gltf.nodes.push(t4);
        }
      return r7;
    }
    return e5.forEachNode((e6) => {
      t3.children || (t3.children = []), t3.children.push(...this._addNodes(e6));
    }), [a4];
  }
  _addMesh(e5, t3) {
    var _a;
    (_a = this.gltf).meshes ?? (_a.meshes = []);
    const s5 = this.gltf.meshes.length;
    this.gltf.meshes.push(t3), e5.mesh = s5;
  }
  _createMeshes(t3) {
    const s5 = this.gltf.extras, r6 = s5.options.bufferOutputType === E2.GLB;
    let n2;
    n2 = r6 ? s5.binChunkBuffer : new i2(this.gltf), this.params.origin || (this.params.origin = c3(t3));
    const { ignoreLocalTransform: l3 } = this.params, c4 = l3 ? null : t3.transform, { vertexSpace: h, spatialReference: u2 } = t3, f6 = t3.vertexAttributes;
    let p4 = null;
    if ("local" === h.type) {
      const e5 = V(u2);
      f2(F2, (c4 == null ? void 0 : c4.localMatrix) ?? o2, [e5, e5, e5]), p4 = V2(f6, F2);
    } else {
      const e5 = l3 ? h.isRelative ? new m({ origin: t(h.origin) }) : new p() : h;
      p4 = E(f6, e5, c4, this.params.origin, { geographic: this.params.geographic, unit: "meters" });
    }
    if (null == p4)
      throw new s2("Error during gltf export.");
    f6.position && p4.position === f6.position && (p4.position = f6.position.slice()), f6.normal && p4.normal === f6.normal && (p4.normal = f6.normal.slice()), f6.tangent && p4.tangent === f6.tangent && (p4.tangent = f6.tangent.slice()), r5(t3, p4), this._flipYZAxis(p4);
    const _2 = n2.addBufferView(C.FLOAT, L.VEC3, R.ARRAY_BUFFER);
    let b, I2, N2, B;
    p4.normal && (b = n2.addBufferView(C.FLOAT, L.VEC3, R.ARRAY_BUFFER)), f6.uv && (I2 = n2.addBufferView(C.FLOAT, L.VEC2, R.ARRAY_BUFFER)), p4.tangent && (N2 = n2.addBufferView(C.FLOAT, L.VEC4, R.ARRAY_BUFFER)), f6.color && (B = n2.addBufferView(C.UNSIGNED_BYTE, L.VEC4, R.ARRAY_BUFFER)), _2.startAccessor("POSITION"), b && b.startAccessor("NORMAL"), I2 && I2.startAccessor("TEXCOORD_0"), N2 && N2.startAccessor("TANGENT"), B && B.startAccessor("COLOR_0");
    const C2 = p4.position.length / 3, { position: v, normal: L3, tangent: y2 } = p4, { color: j, uv: k } = f6;
    for (let e5 = 0; e5 < C2; ++e5)
      _2.push(v[3 * e5]), _2.push(v[3 * e5 + 1]), _2.push(v[3 * e5 + 2]), b && null != L3 && (b.push(L3[3 * e5]), b.push(L3[3 * e5 + 1]), b.push(L3[3 * e5 + 2])), I2 && null != k && (I2.push(k[2 * e5]), I2.push(k[2 * e5 + 1])), N2 && null != y2 && (N2.push(y2[4 * e5]), N2.push(y2[4 * e5 + 1]), N2.push(y2[4 * e5 + 2]), N2.push(y2[4 * e5 + 3])), B && null != j && (B.push(j[4 * e5]), B.push(j[4 * e5 + 1]), B.push(j[4 * e5 + 2]), B.push(j[4 * e5 + 3]));
    const V3 = _2.endAccessor(), D2 = this._addAccessor(_2.index, V3);
    let G, U, Y, P, z2;
    if (b) {
      const e5 = b.endAccessor();
      G = this._addAccessor(b.index, e5);
    }
    if (I2) {
      const e5 = I2.endAccessor();
      U = this._addAccessor(I2.index, e5);
    }
    if (N2) {
      const e5 = N2.endAccessor();
      Y = this._addAccessor(N2.index, e5);
    }
    if (B) {
      const e5 = B.endAccessor();
      P = this._addAccessor(B.index, e5);
    }
    const Z = [];
    return t3.components && t3.components.length > 0 && t3.components[0].faces ? (z2 = n2.addBufferView(C.UNSIGNED_INT, L.SCALAR, R.ELEMENT_ARRAY_BUFFER), this._addMeshVertexIndexed(z2, t3.components, Z, D2, G, U, Y, P)) : this._addMeshVertexNonIndexed(t3.components, Z, D2, G, U, Y, P), _2.finalize(), b && b.finalize(), I2 && I2.finalize(), N2 && N2.finalize(), z2 && z2.finalize(), B && B.finalize(), r6 || n2.finalize(), Z;
  }
  _flipYZAxis({ position: e5, normal: t3, tangent: s5 }) {
    this._flipYZBuffer(e5, 3), this._flipYZBuffer(t3, 3), this._flipYZBuffer(s5, 4);
  }
  _flipYZBuffer(e5, t3) {
    if (null != e5)
      for (let s5 = 1, r6 = 2; s5 < e5.length; s5 += t3, r6 += t3) {
        const t4 = e5[s5], i4 = e5[r6];
        e5[s5] = i4, e5[r6] = -t4;
      }
  }
  _addMaterial(e5) {
    if (null === e5)
      return;
    const t3 = this._materialMap.indexOf(e5);
    if (-1 !== t3)
      return t3;
    this.gltf.materials || (this.gltf.materials = []);
    const s5 = {};
    switch (e5.alphaMode) {
      case "mask":
        s5.alphaMode = I.MASK;
        break;
      case "auto":
      case "blend":
        s5.alphaMode = I.BLEND;
    }
    0.5 !== e5.alphaCutoff && (s5.alphaCutoff = e5.alphaCutoff), e5.doubleSided && (s5.doubleSided = e5.doubleSided), s5.pbrMetallicRoughness = {};
    const r6 = (e6) => e6 ** 2.1, i4 = (e6) => {
      const t4 = e6.toRgba();
      return t4[0] = r6(t4[0] / 255), t4[1] = r6(t4[1] / 255), t4[2] = r6(t4[2] / 255), t4;
    };
    if (null != e5.color && (s5.pbrMetallicRoughness.baseColorFactor = i4(e5.color)), null != e5.colorTexture && (s5.pbrMetallicRoughness.baseColorTexture = this._createTextureInfo(e5.colorTexture, e5.colorTextureTransform)), null != e5.normalTexture && (s5.normalTexture = this._createTextureInfo(e5.normalTexture, e5.normalTextureTransform)), e5 instanceof c) {
      if (null != e5.emissiveTexture && (s5.emissiveTexture = this._createTextureInfo(e5.emissiveTexture, e5.emissiveTextureTransform)), null != e5.emissiveColor) {
        const t4 = i4(e5.emissiveColor);
        s5.emissiveFactor = [t4[0], t4[1], t4[2]];
      }
      null != e5.occlusionTexture && (s5.occlusionTexture = this._createTextureInfo(e5.occlusionTexture, e5.occlusionTextureTransform)), null != e5.metallicRoughnessTexture && (s5.pbrMetallicRoughness.metallicRoughnessTexture = this._createTextureInfo(e5.metallicRoughnessTexture, e5.metallicRoughnessTextureTransform)), s5.pbrMetallicRoughness.metallicFactor = e5.metallic, s5.pbrMetallicRoughness.roughnessFactor = e5.roughness;
    } else
      s5.pbrMetallicRoughness.metallicFactor = 1, s5.pbrMetallicRoughness.roughnessFactor = 1, L2.warnOnce("Meshes exported to GLTF without MeshMaterialMetallicRoughness material will appear different when imported back.");
    const a4 = this.gltf.materials.length;
    return this.gltf.materials.push(s5), this._materialMap.push(e5), a4;
  }
  _createTextureInfo(e5, t3) {
    const s5 = { index: this._addTexture(e5) };
    return t3 ? (s5.extensions || (s5.extensions = {}), s5.extensions.KHR_texture_transform = { scale: t3.scale, offset: t3.offset, rotation: M(t3.rotation) }, s5) : s5;
  }
  _addTexture(e5) {
    const t3 = this.gltf.textures ?? [];
    return this.gltf.textures = t3, r(this._textureMap, e5, () => {
      const s5 = { sampler: this._addSampler(e5), source: this._addImage(e5) }, r6 = t3.length;
      return t3.push(s5), r6;
    });
  }
  _addImage(e5) {
    const t3 = this._imageMap.get(e5);
    if (null != t3)
      return t3;
    this.gltf.images || (this.gltf.images = []);
    const s5 = {};
    if (e5.url)
      s5.uri = e5.url;
    else {
      const t4 = e5.data;
      s5.extras = t4;
      for (let e6 = 0; e6 < this.gltf.images.length; ++e6)
        if (t4 === this.gltf.images[e6].extras)
          return e6;
      const r7 = this.gltf.extras;
      switch (r7.options.imageOutputType) {
        case A.GLB: {
          const e6 = r7.binChunkBuffer.addBufferView(C.UNSIGNED_BYTE, L.SCALAR);
          if (r3(t4))
            null != t4.data && e6.writeOutToBuffer(t4.data, 0);
          else {
            const r8 = r4(t4).then(({ data: e7, type: t5 }) => (s5.mimeType = t5, e7));
            e6.writeAsync(r8).then(() => {
              e6.finalize();
            });
          }
          s5.bufferView = e6.index;
          break;
        }
        case A.DataURI:
          if (r3(t4)) {
            L2.warnOnce("Image export for basis compressed textures not available.");
            break;
          }
          s5.uri = a(t4);
          break;
        default:
          if (r3(t4)) {
            L2.warnOnce("Image export for basis compressed textures not available.");
            break;
          }
          r7.promises.push(r4(t4).then(({ data: e6, type: t5 }) => {
            s5.uri = e6, s5.mimeType = t5;
          }));
      }
    }
    const r6 = this.gltf.images.length;
    return this.gltf.images.push(s5), this._imageMap.set(e5, r6), r6;
  }
  _addSampler(e5) {
    this.gltf.samplers || (this.gltf.samplers = []);
    let t3 = D.REPEAT, s5 = D.REPEAT;
    if ("string" == typeof e5.wrap)
      switch (e5.wrap) {
        case "clamp":
          t3 = D.CLAMP_TO_EDGE, s5 = D.CLAMP_TO_EDGE;
          break;
        case "mirror":
          t3 = D.MIRRORED_REPEAT, s5 = D.MIRRORED_REPEAT;
      }
    else {
      switch (e5.wrap.vertical) {
        case "clamp":
          s5 = D.CLAMP_TO_EDGE;
          break;
        case "mirror":
          s5 = D.MIRRORED_REPEAT;
      }
      switch (e5.wrap.horizontal) {
        case "clamp":
          t3 = D.CLAMP_TO_EDGE;
          break;
        case "mirror":
          t3 = D.MIRRORED_REPEAT;
      }
    }
    const r6 = { wrapS: t3, wrapT: s5 };
    for (let a4 = 0; a4 < this.gltf.samplers.length; ++a4)
      if (JSON.stringify(r6) === JSON.stringify(this.gltf.samplers[a4]))
        return a4;
    const i4 = this.gltf.samplers.length;
    return this.gltf.samplers.push(r6), i4;
  }
  _addAccessor(e5, t3) {
    this.gltf.accessors || (this.gltf.accessors = []);
    const s5 = { bufferView: e5, byteOffset: t3.byteOffset, componentType: t3.componentType, count: t3.count, type: t3.type, min: t3.min, max: t3.max, name: t3.name };
    t3.normalized && (s5.normalized = true);
    const r6 = this.gltf.accessors.length;
    return this.gltf.accessors.push(s5), r6;
  }
  _addMeshVertexIndexed(e5, t3, s5, r6, i4, a4, o5, n2) {
    const l3 = /* @__PURE__ */ new Map();
    for (const c4 of t3) {
      e5.startAccessor("INDICES");
      for (let s6 = 0; s6 < c4.faces.length; ++s6)
        e5.push(c4.faces[s6]);
      const t4 = e5.endAccessor(), h = { attributes: { POSITION: r6 }, indices: this._addAccessor(e5.index, t4), material: this._addMaterial(c4.material) };
      i4 && "flat" !== c4.shading && (h.attributes.NORMAL = i4), a4 && (h.attributes.TEXCOORD_0 = a4), o5 && "flat" !== c4.shading && (h.attributes.TANGENT = o5), n2 && (h.attributes.COLOR_0 = n2);
      const u2 = l3.get(c4.name);
      if (u2)
        u2.primitives.push(h);
      else {
        const e6 = { name: c4.name, primitives: [h] };
        l3.set(c4.name, e6), s5.push(e6);
      }
    }
  }
  _addMeshVertexNonIndexed(e5, t3, s5, r6, i4, a4, o5) {
    const n2 = { primitives: [] };
    t3.push(n2);
    const l3 = { attributes: { POSITION: s5 } };
    r6 && (l3.attributes.NORMAL = r6), i4 && (l3.attributes.TEXCOORD_0 = i4), a4 && (l3.attributes.TANGENT = a4), o5 && (l3.attributes.COLOR_0 = o5), e5 && (l3.material = this._addMaterial(e5[0].material)), n2.primitives.push(l3);
  }
};
var F2 = e2();

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/asset.js
var s3 = class {
  constructor() {
    this.copyright = "", this.defaultScene = 0, this.generator = "", this._scenes = [];
  }
  addScene(e5) {
    if (this._scenes.includes(e5))
      throw new Error("Scene already added");
    this._scenes.push(e5);
  }
  removeScene(s5) {
    O(this._scenes, s5);
  }
  forEachScene(e5) {
    this._scenes.forEach(e5);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/scene.js
var d = class {
  constructor() {
    this.name = "", this._nodes = [];
  }
  addNode(d2) {
    if (this._nodes.includes(d2))
      throw new Error("Node already added");
    this._nodes.push(d2);
  }
  forEachNode(d2) {
    this._nodes.forEach(d2);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/node.js
var i3 = class {
  constructor(s5) {
    this.mesh = s5, this.name = "", this.translation = n(), this.rotation = e3(), this.scale = t(l), this._nodes = [];
  }
  addNode(s5) {
    if (this._nodes.includes(s5))
      throw new Error("Node already added");
    this._nodes.push(s5);
  }
  forEachNode(s5) {
    this._nodes.forEach(s5);
  }
  set rotationAngles(t3) {
    T(this.rotation, t3[0], t3[1], t3[2]);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/index.js
var a3 = "model.gltf";
var f4 = "model.glb";
async function u(u2, p4, m3) {
  var _a;
  const c4 = new y(u2, p4 = p4 || {}, m3);
  let l3 = c4.params;
  l3 ? l3.origin || (l3.origin = new x({ x: -1, y: -1, z: -1 })) : l3 = { origin: new x({ x: -1, y: -1, z: -1 }) };
  const g2 = l3.origin, y2 = c4.gltf, d2 = ((_a = y2.extras) == null ? void 0 : _a.promises) ?? [];
  let j = 1, x2 = 1, b = null;
  await Promise.allSettled(d2);
  const w = { origin: g2 };
  delete y2.extras;
  const B = "number" == typeof p4.jsonSpacing ? p4.jsonSpacing : 4, h = JSON.stringify(y2, (e5, t3) => {
    if ("extras" !== e5) {
      if (t3 instanceof ArrayBuffer) {
        if (g(t3))
          switch (p4.imageOutputType) {
            case A.DataURI:
            case A.GLB:
              break;
            case A.External:
            default: {
              const e6 = `img${x2}.png`;
              return x2++, w[e6] = t3, e6;
            }
          }
        switch (p4.bufferOutputType) {
          case E2.DataURI:
            return c2(t3);
          case E2.GLB:
            if (b)
              throw new Error("Already encountered an ArrayBuffer, there should only be one in the GLB format.");
            return void (b = t3);
          case E2.External:
          default: {
            const e6 = `data${j}.bin`;
            return j++, w[e6] = t3, e6;
          }
        }
      }
      return t3;
    }
  }, B);
  return p4.bufferOutputType === E2.GLB || p4.imageOutputType === A.GLB ? w[f4] = new e4(h, b).buffer : w[a3] = h, w;
}
function p3(e5, t3) {
  return u(e5, { bufferOutputType: E2.GLB, imageOutputType: A.GLB, jsonSpacing: 0 }, t3);
}

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/gltfexport.js
var s4 = class {
  constructor(e5, o5) {
    this._file = { type: "model/gltf-binary", data: e5 }, this.origin = o5;
  }
  buffer() {
    return Promise.resolve(this._file);
  }
  download(o5) {
    ct(new Blob([this._file.data], { type: this._file.type }), o5);
  }
};
function f5(e5, f6) {
  const d2 = new s3(), l3 = new d();
  return d2.addScene(l3), l3.addNode(new i3(e5)), p3(d2, f6).then((e6) => new s4(e6[f4], e6.origin));
}
export {
  f5 as toBinaryGLTF
};
//# sourceMappingURL=gltfexport-UGKDI426.js.map
