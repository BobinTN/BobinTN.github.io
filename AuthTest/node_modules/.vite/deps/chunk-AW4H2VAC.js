import {
  i as i3
} from "./chunk-LXYMQMWX.js";
import {
  i as i2
} from "./chunk-XJLKESB7.js";
import {
  o
} from "./chunk-IUQHF7KZ.js";
import {
  f,
  i
} from "./chunk-6B7VJB6C.js";
import {
  S
} from "./chunk-2D3PORS4.js";
import {
  j
} from "./chunk-WZPOQGKL.js";
import {
  s3 as s
} from "./chunk-WJ3HJKNC.js";

// node_modules/@arcgis/core/layers/save/utils.js
function l(t, r, o2) {
  const a = o2(t);
  if (!a.isValid)
    throw new s(`${r}:invalid-parameters`, a.errorMessage, { layer: t });
}
async function p(e) {
  const { layer: t, errorNamePrefix: r, validateLayer: o2 } = e;
  await t.load(), l(t, r, o2);
}
function m(e, t) {
  return `Layer (title: ${e.title}, id: ${e.id}) of type '${e.declaredClass}' ${t}`;
}
function c(t) {
  const { item: r, itemType: o2, errorNamePrefix: a, layer: i4, validateItem: n } = t;
  if (i3(r), r.type !== o2)
    throw new s(`${a}:portal-item-wrong-type`, `Portal item type should be "${o2}"`, { item: r, layer: i4 });
  if (n) {
    const t2 = n(r);
    if (!t2.isValid)
      throw new s(`${a}:invalid-parameters`, t2.errorMessage, { layer: i4 });
  }
}
function d(t) {
  const { layer: r, errorNamePrefix: o2 } = t, { portalItem: a } = r;
  if (!a)
    throw new s(`${o2}:portal-item-not-set`, m(r, "requires the portalItem property to be set"));
  if (!a.loaded)
    throw new s(`${o2}:portal-item-not-loaded`, m(r, "cannot be saved to a portal item that does not exist or is inaccessible"));
  c({ ...t, item: a });
}
function u(e) {
  const { newItem: t, itemType: a } = e;
  let i4 = S.from(t);
  return i4.id && (i4 = i4.clone(), i4.id = null), i4.type ?? (i4.type = a), i4.portal ?? (i4.portal = j.getDefault()), c({ ...e, item: i4 }), i4;
}
function f2(t, r) {
  let o2 = (t.messages ?? []).filter(({ type: e }) => "error" === e).map(({ name: t2, message: r2, details: o3 }) => new s(t2, r2, o3));
  if (t.blockedRelativeUrls && (o2 = o2.concat(t.blockedRelativeUrls.map((t2) => new s("url:unsupported", `Relative url '${t2}' is not supported`)))), (r == null ? void 0 : r.ignoreUnsupported) && (o2 = o2.filter(({ name: e }) => "layer:unsupported" !== e && "symbol:unsupported" !== e && "symbol-layer:unsupported" !== e && "property:unsupported" !== e && "url:unsupported" !== e)), o2.length > 0)
    throw new s("layer-write:unsupported", "Failed to save layer due to unsupported or invalid content. See 'details.errors' for more detailed information", { errors: o2 });
}
async function y(e, t, r) {
  var _a;
  "beforeSave" in e && "function" == typeof e.beforeSave && await e.beforeSave();
  const o2 = e.write({}, t);
  return await Promise.all(((_a = t.resources) == null ? void 0 : _a.pendingOperations) ?? []), f2(t, r), o2;
}
function w(e) {
  i(e, f.JSAPI), e.typeKeywords && (e.typeKeywords = e.typeKeywords.filter((e2, t, r) => r.indexOf(e2) === t));
}
async function v(e, t, r) {
  var _a;
  const o2 = e.portal;
  await o2.signIn(), await ((_a = o2.user) == null ? void 0 : _a.addItem({ item: e, data: t, folder: r == null ? void 0 : r.folder }));
}
async function I(e, r) {
  const { layer: o2, createItemData: i4, createJSONContext: n, saveResources: s2 } = e;
  await p(e), d(e);
  const l2 = o2.portalItem, m2 = n ? n(l2) : o(l2), c2 = await y(o2, m2, r), u2 = await i4({ layer: o2, layerJSON: c2 }, l2);
  return w(l2), await l2.update({ data: u2 }), i2(m2), await (s2 == null ? void 0 : s2(l2, m2)), l2;
}
async function b(e, r) {
  const { layer: o2, createItemData: i4, createJSONContext: n, setItemProperties: s2, saveResources: l2 } = e;
  await p(e);
  const m2 = u(e), c2 = n ? n(m2) : o(m2), d2 = await y(o2, c2, r), f3 = await i4({ layer: o2, layerJSON: d2 }, m2);
  return await s2(o2, m2), w(m2), await v(m2, f3, r), o2.portalItem = m2, i2(c2), await (l2 == null ? void 0 : l2(m2, c2)), m2;
}

export {
  l,
  m,
  d,
  u,
  y,
  w,
  v,
  I,
  b
};
//# sourceMappingURL=chunk-AW4H2VAC.js.map
