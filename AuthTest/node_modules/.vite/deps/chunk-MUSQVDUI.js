import {
  o
} from "./chunk-OG2GBCUQ.js";
import {
  A,
  O,
  V,
  W,
  Y,
  le,
  ne,
  q,
  s as s2,
  s2 as s4,
  se as se2,
  t as t2
} from "./chunk-HR42LBYN.js";
import {
  u as u3
} from "./chunk-3S7E6CPQ.js";
import {
  G,
  L,
  P,
  S,
  b,
  c as c2,
  e as e3,
  k,
  p,
  s as s3,
  t as t3,
  u as u4,
  w,
  x
} from "./chunk-XI27PUTI.js";
import {
  e as e2,
  i,
  n
} from "./chunk-BUMLJETN.js";
import {
  a as a2
} from "./chunk-OPV4AZKI.js";
import {
  ae,
  se
} from "./chunk-XFC7DZXI.js";
import {
  u as u2
} from "./chunk-G557TGXY.js";
import {
  n as n2,
  u as u5
} from "./chunk-3DSKWYU4.js";
import {
  m
} from "./chunk-IPCIO3PX.js";
import {
  e,
  u
} from "./chunk-EIY2DYTV.js";
import {
  t
} from "./chunk-OIIDE5GZ.js";
import {
  a,
  c,
  s2 as s
} from "./chunk-WJ3HJKNC.js";

// node_modules/@arcgis/core/symbols/cim/quantizeTime.js
var t4 = 0.05;
function n3(n6) {
  return Math.max(Math.round(n6 / t4), 1) * t4;
}
var e4 = /* @__PURE__ */ new Set(["StartTimeOffset", "Duration", "RepeatDelay"]);
function a3(t5, a5) {
  return e4.has(a5) ? n3(t5) : t5;
}

// node_modules/@arcgis/core/symbols/cim/SDFHelper.js
function l(t5) {
  var _a;
  if (!t5)
    return null;
  switch (t5.type) {
    case "CIMPointSymbol": {
      const o3 = t5.symbolLayers;
      return o3 && 1 === o3.length ? l(o3[0]) : null;
    }
    case "CIMVectorMarker": {
      const o3 = t5.markerGraphics;
      if (!o3 || 1 !== o3.length)
        return null;
      const n6 = o3[0];
      if (!n6)
        return null;
      const r2 = n6.geometry;
      if (!r2)
        return null;
      const l3 = n6.symbol;
      return !l3 || "CIMPolygonSymbol" !== l3.type && "CIMLineSymbol" !== l3.type || ((_a = l3.symbolLayers) == null ? void 0 : _a.some((t6) => !!t6.effects)) ? null : { geom: r2, asFill: "CIMPolygonSymbol" === l3.type };
    }
    case "sdf":
      return { geom: t5.geom, asFill: t5.asFill };
  }
  return null;
}
function e5(t5) {
  return t5 ? t5.rings ? t5.rings : t5.paths ? t5.paths : void 0 !== t5.xmin && void 0 !== t5.ymin && void 0 !== t5.xmax && void 0 !== t5.ymax ? [[[t5.xmin, t5.ymin], [t5.xmin, t5.ymax], [t5.xmax, t5.ymax], [t5.xmax, t5.ymin], [t5.xmin, t5.ymin]]] : null : null;
}
function i2(t5) {
  let o3 = 1 / 0, r2 = -1 / 0, l3 = 1 / 0, e7 = -1 / 0;
  for (const n6 of t5)
    for (const t6 of n6)
      t6[0] < o3 && (o3 = t6[0]), t6[0] > r2 && (r2 = t6[0]), t6[1] < l3 && (l3 = t6[1]), t6[1] > e7 && (e7 = t6[1]);
  return new t2(o3, l3, r2 - o3, e7 - l3);
}
function s5(t5) {
  let o3 = 1 / 0, n6 = -1 / 0, r2 = 1 / 0, l3 = -1 / 0;
  for (const e7 of t5)
    for (const t6 of e7)
      t6[0] < o3 && (o3 = t6[0]), t6[0] > n6 && (n6 = t6[0]), t6[1] < r2 && (r2 = t6[1]), t6[1] > l3 && (l3 = t6[1]);
  return [o3, r2, n6, l3];
}
function f(t5) {
  return t5 ? t5.rings ? s5(t5.rings) : t5.paths ? s5(t5.paths) : m(t5) ? [t5.xmin, t5.ymin, t5.xmax, t5.ymax] : null : null;
}
function m2(t5, o3, n6, l3, e7) {
  const [i3, s6, f2, m3] = t5;
  if (f2 < i3 || m3 < s6)
    return [0, 0, 0];
  const a5 = f2 - i3, u7 = m3 - s6, c4 = 128, h2 = ae, y = Math.floor(0.5 * (0.5 * c4 - h2)), x2 = (c4 - 2 * (y + h2)) / Math.max(a5, u7), M = Math.round(a5 * x2) + 2 * y, g = Math.round(u7 * x2) + 2 * y;
  let p2 = 1;
  if (o3) {
    p2 = g / x2 / (o3.ymax - o3.ymin);
  }
  let d = 0, b2 = 0, w2 = 1;
  l3 && (e7 ? o3 && n6 && o3.ymax - o3.ymin > 0 && (w2 = (o3.xmax - o3.xmin) / (o3.ymax - o3.ymin), d = l3.x / (n6 * w2), b2 = l3.y / n6) : (d = l3.x, b2 = l3.y)), o3 && (d = 0.5 * (o3.xmax + o3.xmin) + d * (o3.xmax - o3.xmin), b2 = 0.5 * (o3.ymax + o3.ymin) + b2 * (o3.ymax - o3.ymin)), d -= i3, b2 -= s6, d *= x2, b2 *= x2, d += y, b2 += y;
  let F = d / M - 0.5, j2 = b2 / g - 0.5;
  return e7 && n6 && (F *= n6 * w2, j2 *= n6), [p2, F, j2];
}
function a4(t5) {
  const o3 = e5(t5.geom), n6 = i2(o3), l3 = 128, s6 = ae, f2 = Math.floor(0.5 * (0.5 * l3 - s6)), m3 = (l3 - 2 * (f2 + s6)) / Math.max(n6.width, n6.height), a5 = Math.round(n6.width * m3) + 2 * f2, y = Math.round(n6.height * m3) + 2 * f2, x2 = [];
  for (const r2 of o3)
    if (r2 && r2.length > 1) {
      const o4 = [];
      for (const l4 of r2) {
        let [r3, e7] = l4;
        r3 -= n6.x, e7 -= n6.y, r3 *= m3, e7 *= m3, r3 += f2 - 0.5, e7 += f2 - 0.5, t5.asFill ? o4.push([r3, e7]) : o4.push([Math.round(r3), Math.round(e7)]);
      }
      if (t5.asFill) {
        const t6 = o4.length - 1;
        o4[0][0] === o4[t6][0] && o4[0][1] === o4[t6][1] || o4.push(o4[0]);
      }
      x2.push(o4);
    }
  const M = u6(x2, a5, y, f2);
  return t5.asFill && c3(x2, a5, y, f2, M), [h(M, f2), a5, y];
}
function u6(t5, o3, n6, r2) {
  const l3 = o3 * n6, e7 = new Array(l3), i3 = r2 * r2 + 1;
  for (let s6 = 0; s6 < l3; ++s6)
    e7[s6] = i3;
  for (const s6 of t5) {
    const t6 = s6.length;
    for (let l4 = 1; l4 < t6; ++l4) {
      const t7 = s6[l4 - 1], i4 = s6[l4];
      let f2, m3, a5, u7;
      t7[0] < i4[0] ? (f2 = t7[0], m3 = i4[0]) : (f2 = i4[0], m3 = t7[0]), t7[1] < i4[1] ? (a5 = t7[1], u7 = i4[1]) : (a5 = i4[1], u7 = t7[1]);
      let c4 = Math.floor(f2) - r2, h2 = Math.floor(m3) + r2, y = Math.floor(a5) - r2, x2 = Math.floor(u7) + r2;
      c4 < 0 && (c4 = 0), h2 > o3 && (h2 = o3), y < 0 && (y = 0), x2 > n6 && (x2 = n6);
      const M = i4[0] - t7[0], g = i4[1] - t7[1], p2 = M * M + g * g;
      for (let r3 = c4; r3 < h2; r3++)
        for (let l5 = y; l5 < x2; l5++) {
          let s7, f3, m4 = (r3 - t7[0]) * M + (l5 - t7[1]) * g;
          m4 < 0 ? (s7 = t7[0], f3 = t7[1]) : m4 > p2 ? (s7 = i4[0], f3 = i4[1]) : (m4 /= p2, s7 = t7[0] + m4 * M, f3 = t7[1] + m4 * g);
          const a6 = (r3 - s7) * (r3 - s7) + (l5 - f3) * (l5 - f3), u8 = (n6 - l5 - 1) * o3 + r3;
          a6 < e7[u8] && (e7[u8] = a6);
        }
    }
  }
  for (let s6 = 0; s6 < l3; ++s6)
    e7[s6] = Math.sqrt(e7[s6]);
  return e7;
}
function c3(t5, o3, n6, r2, l3) {
  for (const e7 of t5) {
    const t6 = e7.length;
    for (let i3 = 1; i3 < t6; ++i3) {
      const t7 = e7[i3 - 1], s6 = e7[i3];
      let f2, m3, a5, u7;
      t7[0] < s6[0] ? (f2 = t7[0], m3 = s6[0]) : (f2 = s6[0], m3 = t7[0]), t7[1] < s6[1] ? (a5 = t7[1], u7 = s6[1]) : (a5 = s6[1], u7 = t7[1]);
      let c4 = Math.floor(f2), h2 = Math.floor(m3) + 1, y = Math.floor(a5), x2 = Math.floor(u7) + 1;
      c4 < r2 && (c4 = r2), h2 > o3 - r2 && (h2 = o3 - r2), y < r2 && (y = r2), x2 > n6 - r2 && (x2 = n6 - r2);
      for (let e8 = y; e8 < x2; ++e8) {
        if (t7[1] > e8 == s6[1] > e8)
          continue;
        const i4 = (n6 - e8 - 1) * o3;
        for (let o4 = c4; o4 < h2; ++o4)
          o4 < (s6[0] - t7[0]) * (e8 - t7[1]) / (s6[1] - t7[1]) + t7[0] && (l3[i4 + o4] = -l3[i4 + o4]);
        for (let t8 = r2; t8 < c4; ++t8)
          l3[i4 + t8] = -l3[i4 + t8];
      }
    }
  }
}
function h(o3, n6) {
  const r2 = 2 * n6, l3 = o3.length, e7 = new Uint8Array(4 * l3);
  for (let i3 = 0; i3 < l3; ++i3) {
    const n7 = 0.5 - o3[i3] / r2;
    o(n7, e7, 4 * i3);
  }
  return e7;
}

// node_modules/@arcgis/core/symbols/cim/effects/CIMEffectHelper.js
var n4 = 96 / 72;
var l2 = class {
  static executeEffects(t5, e7, l3, c4) {
    const f2 = n4, m3 = se2(t5);
    let p2 = new s2(e7);
    for (const o3 of t5) {
      const t6 = A(o3);
      t6 && (p2 = t6.execute(p2, o3, f2, l3, c4, m3));
    }
    return p2;
  }
  static applyEffects(n6, l3, c4) {
    if (!n6)
      return l3;
    const f2 = se2(n6);
    let m3, p2 = new s2(a2.fromJSONCIM(l3));
    for (const t5 of n6) {
      const e7 = A(t5);
      e7 && (p2 = e7.execute(p2, t5, 1, null, c4, f2));
    }
    const u7 = [];
    let i3 = null;
    for (; m3 = p2.next(); )
      u7.push(...t(m3)), i3 = m3.geometryType;
    return 0 === u7.length || null === i3 ? null : "esriGeometryPolygon" === i3 ? { rings: u7 } : { paths: u7 };
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/grouping.js
function e6(e7, o3) {
  let r2;
  if ("string" == typeof e7)
    r2 = c(e7 + `-seed(${o3})`);
  else {
    let t5 = 12;
    r2 = e7 ^ o3;
    do {
      r2 = 107 * (r2 >> 8 ^ r2) + t5 | 0;
    } while (0 != --t5);
  }
  return (1 + r2 / (1 << 31)) / 2;
}
function o2(t5) {
  return Math.floor(e6(t5, r) * n5);
}
var r = 53290320;
var n5 = 10;

// node_modules/@arcgis/core/symbols/cim/cimAnalyzer.js
var E = s.getLogger("esri.symbols.cim.cimAnalyzer");
function T(e7) {
  switch (e7) {
    case "Butt":
      return e2.BUTT;
    case "Square":
      return e2.SQUARE;
    default:
      return e2.ROUND;
  }
}
function $(e7) {
  switch (e7) {
    case "Bevel":
      return n.BEVEL;
    case "Miter":
      return n.MITER;
    default:
      return n.ROUND;
  }
}
function G2(e7) {
  const t5 = e7.markerPlacement;
  return t5 && t5.angleToLine ? i.MAP : i.SCREEN;
}
var j = class {
  constructor(e7, t5) {
    this._cimLayers = [], this._poMap = {}, this._primitiveOverrides = [], this._resourceManager = e7, this._info = t5;
  }
  async analyzeSymbolReference(e7, t5, i3) {
    if (this._cimLayers = i3 ?? [], !e7)
      return this._cimLayers;
    if (e7.primitiveOverrides) {
      this._primitiveOverrides = e7.primitiveOverrides, this._poMap = {};
      const t6 = [], i4 = this._info;
      for (const e8 of this._primitiveOverrides) {
        const r3 = e8.valueExpressionInfo;
        if (r3 && i4) {
          const o4 = r3.expression, n6 = n2(o4, i4.spatialReference, i4.fields).then((t7) => {
            null != t7 && this._setPoMap(e8.primitiveName, e8.propertyName, t7);
          });
          t6.push(n6);
        } else
          null != e8.value && this._setPoMap(e8.primitiveName, e8.propertyName, e8.value);
        t6.length > 0 && await Promise.all(t6);
      }
    }
    const r2 = e7.symbol, o3 = [];
    return ne.fetchResources(r2, this._resourceManager, o3), o3.length > 0 && await Promise.all(o3), this._analyzeSymbol(r2, t5), this._cimLayers;
  }
  _analyzeSymbol(e7, t5) {
    switch (e7 == null ? void 0 : e7.type) {
      case "CIMPointSymbol":
      case "CIMLineSymbol":
      case "CIMPolygonSymbol":
        this._analyzeMultiLayerSymbol(e7, t5, 1, 0, 0, 0);
    }
  }
  _analyzeMultiLayerSymbol(e7, t5, i3, r2, o3, n6) {
    const a5 = e7 == null ? void 0 : e7.symbolLayers;
    if (!a5)
      return;
    const s6 = e7.effects;
    let l3 = i.SCREEN;
    const c4 = ne.getSize(e7) ?? 0;
    "CIMPointSymbol" === e7.type && "Map" === e7.angleAlignment && (l3 = i.MAP);
    const m3 = "CIMPolygonSymbol" === e7.type;
    let f2 = a5.length;
    for (; f2--; ) {
      const h2 = a5[f2];
      if (!h2 || false === h2.enable)
        continue;
      let u7;
      (s6 == null ? void 0 : s6.length) && (u7 = [...s6]);
      const p2 = h2.effects;
      (p2 == null ? void 0 : p2.length) && (s6 ? u7.push(...p2) : u7 = [...p2]);
      const d = [];
      let v;
      le.findEffectOverrides(u7, this._primitiveOverrides, d), v = d.length > 0 ? this._createEffectsOverrideFunction(u7, d) : u7;
      const _ = [];
      switch (le.findApplicableOverrides(h2, this._primitiveOverrides, _), h2.type) {
        case "CIMSolidFill":
          this._analyzeSolidFill(h2, v);
          break;
        case "CIMPictureFill":
          this._analyzePictureFill(h2, v);
          break;
        case "CIMHatchFill":
          this._analyzeHatchFill(h2, v);
          break;
        case "CIMGradientFill":
          this._analyzeGradientFill(h2, v);
          break;
        case "CIMSolidStroke":
          this._analyzeSolidStroke(h2, v, m3, c4);
          break;
        case "CIMPictureStroke":
          this._analyzePictureStroke(h2, v, m3, c4);
          break;
        case "CIMGradientStroke":
          this._analyzeGradientStroke(h2, v, m3, c4);
          break;
        case "CIMCharacterMarker":
        case "CIMPictureMarker":
        case "CIMVectorMarker": {
          "CIMLineSymbol" === e7.type && (l3 = G2(h2));
          const a6 = [], s7 = h2.primitiveName;
          s7 && a6.push(s7), this._analyzeMarker(h2, v, null, a6, l3, c4, 1, t5, i3, r2, o3, n6);
          break;
        }
        default:
          E.error("Cannot analyze CIM layer", h2.type);
      }
    }
  }
  _analyzeSolidFill(e7, t5) {
    const i3 = e7.primitiveName, r2 = u4(e7.color), [o3, n6] = this._analyzePrimitiveOverrides(i3, t5, null, null), s6 = c(JSON.stringify(e7) + n6).toString();
    this._cimLayers.push({ type: "fill", templateHash: s6, materialHash: o3 ? () => s6 : s6, cim: e7, materialOverrides: null, colorLocked: !!e7.colorLocked, color: this._createOverrideFunction(i3, "Color", r2, U), height: 0, angle: 0, offsetX: 0, offsetY: 0, scaleX: 1, effects: t5, applyRandomOffset: false, sampleAlphaOnly: true });
  }
  _analyzePictureFill(e7, t5) {
    const i3 = e7.primitiveName, r2 = p(e7), [o3, n6] = this._analyzePrimitiveOverrides(i3, t5, null, null), s6 = c(JSON.stringify(e7) + n6).toString(), l3 = c(`${e7.url}${JSON.stringify(e7.colorSubstitutions)}`).toString(), m3 = b(e7.height, V);
    let f2 = b(e7.scaleX, 1);
    if ("width" in e7 && "number" == typeof e7.width) {
      const t6 = e7.width;
      let i4 = 1;
      const r3 = this._resourceManager.getResource(e7.url);
      null != r3 && (i4 = r3.width / r3.height), f2 /= i4 * (m3 / t6);
    }
    this._cimLayers.push({ type: "fill", templateHash: s6, materialHash: o3 ? () => l3 : l3, cim: e7, materialOverrides: null, colorLocked: !!e7.colorLocked, effects: t5, color: this._createOverrideFunction(i3, "TintColor", r2, U), height: this._createOverrideFunction(i3, "Height", m3), scaleX: this._createOverrideFunction(i3, "ScaleX", f2), angle: this._createOverrideFunction(i3, "Rotation", b(e7.rotation)), offsetX: this._createOverrideFunction(i3, "OffsetX", b(e7.offsetX)), offsetY: this._createOverrideFunction(i3, "OffsetY", b(e7.offsetY)), url: e7.url, applyRandomOffset: false, sampleAlphaOnly: false });
  }
  _analyzeHatchFill(e7, t5) {
    var _a, _b;
    const i3 = e7.primitiveName, r2 = this._analyzeMaterialOverrides(i3, ["Rotation", "OffsetX", "OffsetY"]);
    let [o3, n6] = this._analyzePrimitiveOverrides(i3, t5, null, null);
    const s6 = c(JSON.stringify(e7) + n6).toString(), l3 = c(`${e7.separation}${JSON.stringify(e7.lineSymbol)}`).toString();
    let c4 = { r: 255, g: 255, b: 255, a: 1 }, f2 = false;
    const h2 = (_b = (_a = e7.lineSymbol) == null ? void 0 : _a.symbolLayers) == null ? void 0 : _b.find((e8) => {
      var _a2;
      return "CIMSolidStroke" === e8.type && null != ((_a2 = this._poMap[e8.primitiveName]) == null ? void 0 : _a2.Color);
    });
    if (h2) {
      c4 = u4(h2.color), c4 = this._createOverrideFunction(h2.primitiveName, "Color", c4, U);
      const e8 = "function" == typeof c4;
      o3 = o3 || e8, f2 = null != h2.color || e8;
    }
    this._cimLayers.push({ type: "fill", templateHash: s6, materialHash: o3 && r2 ? this._createMaterialHashFunction(l3, r2) : l3, cim: e7, materialOverrides: r2, colorLocked: !!e7.colorLocked, effects: t5, color: c4, height: this._createOverrideFunction(i3, "Separation", b(e7.separation, Y)), scaleX: 1, angle: this._createOverrideFunction(i3, "Rotation", b(e7.rotation)), offsetX: this._createOverrideFunction(i3, "OffsetX", b(e7.offsetX)), offsetY: this._createOverrideFunction(i3, "OffsetY", b(e7.offsetY)), applyRandomOffset: false, sampleAlphaOnly: true, hasUnresolvedReplacementColor: !f2 });
  }
  _analyzeGradientFill(e7, t5) {
    const i3 = e7.primitiveName, [r2, o3] = this._analyzePrimitiveOverrides(i3, t5, null, null), n6 = c(JSON.stringify(e7) + o3).toString();
    this._cimLayers.push({ type: "fill", templateHash: n6, materialHash: r2 ? () => n6 : n6, cim: e7, materialOverrides: null, colorLocked: !!e7.colorLocked, effects: t5, color: { r: 128, g: 128, b: 128, a: 1 }, height: 0, angle: 0, offsetX: 0, offsetY: 0, scaleX: 1, applyRandomOffset: false, sampleAlphaOnly: false });
  }
  _analyzeSolidStroke(e7, t5, i3, r2) {
    const o3 = e7.primitiveName, n6 = u4(e7.color), s6 = b(e7.width, O), l3 = T(e7.capStyle), c4 = $(e7.joinStyle), m3 = e7.miterLimit, [h2, u7] = this._analyzePrimitiveOverrides(o3, t5, null, null), p2 = c(JSON.stringify(e7) + u7).toString();
    let y, d;
    if (t5 && t5 instanceof Array && t5.length > 0) {
      const e8 = t5[t5.length - 1];
      if ("CIMGeometricEffectDashes" === e8.type && "NoConstraint" === e8.lineDashEnding && null === e8.offsetAlongLine) {
        const e9 = (t5 = [...t5]).pop();
        y = e9.dashTemplate, d = e9.scaleDash;
      }
    }
    this._cimLayers.push({ type: "line", templateHash: p2, materialHash: h2 ? () => p2 : p2, cim: e7, materialOverrides: null, isOutline: i3, colorLocked: !!e7.colorLocked, effects: t5, color: this._createOverrideFunction(o3, "Color", n6, U), width: this._createOverrideFunction(o3, "Width", s6), cap: this._createOverrideFunction(o3, "CapStyle", l3), join: this._createOverrideFunction(o3, "JoinStyle", c4), miterLimit: m3 && this._createOverrideFunction(o3, "MiterLimit", m3), referenceWidth: r2, zOrder: D(e7.name), dashTemplate: y, scaleDash: d, sampleAlphaOnly: true });
  }
  _analyzePictureStroke(e7, t5, i3, r2) {
    const o3 = c(`${e7.url}${JSON.stringify(e7.colorSubstitutions)}`).toString(), n6 = e7.primitiveName, s6 = p(e7), l3 = b(e7.width, O), c4 = T(e7.capStyle), m3 = $(e7.joinStyle), h2 = e7.miterLimit, [u7, p2] = this._analyzePrimitiveOverrides(n6, t5, null, null), y = c(JSON.stringify(e7) + p2).toString();
    this._cimLayers.push({ type: "line", templateHash: y, materialHash: u7 ? () => o3 : o3, cim: e7, materialOverrides: null, isOutline: i3, colorLocked: !!e7.colorLocked, effects: t5, color: this._createOverrideFunction(n6, "TintColor", s6, U), width: this._createOverrideFunction(n6, "Width", l3), cap: this._createOverrideFunction(n6, "CapStyle", c4), join: this._createOverrideFunction(n6, "JoinStyle", m3), miterLimit: h2 && this._createOverrideFunction(n6, "MiterLimit", h2), referenceWidth: r2, zOrder: D(e7.name), dashTemplate: null, scaleDash: false, url: e7.url, sampleAlphaOnly: false });
  }
  _analyzeGradientStroke(e7, t5, i3, r2) {
    const o3 = e7.primitiveName, n6 = b(e7.width, O), s6 = T(e7.capStyle), l3 = $(e7.joinStyle), c4 = e7.miterLimit, [m3, h2] = this._analyzePrimitiveOverrides(o3, t5, null, null), u7 = c(JSON.stringify(e7) + h2).toString();
    this._cimLayers.push({ type: "line", templateHash: u7, materialHash: m3 ? () => u7 : u7, cim: e7, materialOverrides: null, isOutline: i3, colorLocked: !!e7.colorLocked, effects: t5, color: { r: 128, g: 128, b: 128, a: 1 }, width: this._createOverrideFunction(o3, "Width", n6), cap: this._createOverrideFunction(o3, "CapStyle", s6), join: this._createOverrideFunction(o3, "JoinStyle", l3), miterLimit: c4 && this._createOverrideFunction(o3, "MiterLimit", c4), referenceWidth: r2, zOrder: D(e7.name), dashTemplate: null, scaleDash: false, sampleAlphaOnly: false });
  }
  _analyzeMarker(e7, t5, i3, r2, o3, n6, a5, s6, l3, c4, m3, f2, u7 = false) {
    if (this._analyzeMarkerInsidePolygon(e7, t5))
      return;
    const p2 = b(e7.size, q), y = b(e7.rotation), d = b(e7.offsetX), v = b(e7.offsetY);
    let _ = this._createOverrideFunction(e7.primitiveName, "Size", p2), O2 = this._createOverrideFunction(e7.primitiveName, "Rotation", y), S2 = this._createOverrideFunction(e7.primitiveName, "OffsetX", d), g = this._createOverrideFunction(e7.primitiveName, "OffsetY", v);
    _ = this._transformSize(_, a5), O2 = this._transformRotation(O2, !!e7.rotateClockwise, c4);
    const M = this._transformOffsetX(S2, g, c4, a5, m3), k2 = this._transformOffsetY(S2, g, c4, a5, f2);
    switch (S2 = M, g = k2, e7.type) {
      case "CIMPictureMarker":
        this._analyzePictureMarker(e7, t5, i3, r2, o3, n6, _, O2, S2, g, e7.colorLocked || u7);
        break;
      case "CIMVectorMarker":
        this._analyzeVectorMarker(e7, t5, i3, r2, o3, n6, a5, s6, _, O2, S2, g, e7.colorLocked || u7);
    }
  }
  _analyzeMarkerInsidePolygon(e7, t5) {
    const { markerPlacement: i3, type: r2 } = e7;
    if (!i3 || "CIMMarkerPlacementInsidePolygon" !== i3.type)
      return false;
    if ("CIMVectorMarker" === r2 || "CIMPictureMarker" === r2) {
      const o4 = e7.primitiveName;
      if (o4) {
        const [e8, i4] = this._analyzePrimitiveOverrides([o4], t5, null, null);
        if (e8)
          return false;
      }
      const n6 = i3.primitiveName;
      if (n6) {
        const [e8, i4] = this._analyzePrimitiveOverrides([n6], t5, null, null);
        if (e8)
          return false;
      }
      if ("CIMVectorMarker" === r2) {
        const { markerGraphics: t6 } = e7;
        if (t6)
          for (const e8 of t6) {
            const { symbol: t7 } = e8;
            if ("CIMPolygonSymbol" === (t7 == null ? void 0 : t7.type) && t7.symbolLayers) {
              const { symbolLayers: e9 } = t7;
              for (const t8 of e9)
                if ("CIMSolidStroke" === t8.type)
                  return false;
            }
          }
      } else {
        const { animatedSymbolProperties: t6 } = e7;
        if (t6)
          return false;
      }
    }
    const o3 = i3, s6 = Math.abs(o3.stepX), l3 = Math.abs(o3.stepY);
    if (0 === s6 || 0 === l3)
      return true;
    const c4 = /* @__PURE__ */ new Set(["Rotation", "OffsetX", "OffsetY"]), m3 = this._primitiveOverrides.filter((t6) => t6.primitiveName !== e7.primitiveName || !c4.has(t6.propertyName)), f2 = "url" in e7 && "string" == typeof e7.url ? e7.url : void 0, h2 = c(JSON.stringify(e7)).toString();
    let u7, p2, y = null;
    if ("Random" === i3.gridType) {
      const e8 = e(se), t6 = Math.max(Math.floor(e8 / s6), 1), i4 = Math.max(Math.floor(e8 / l3), 1);
      u7 = l3 * i4, y = (e9) => e9 ? e9 * i4 : 0;
      p2 = t6 * s6 / u7;
    } else
      i3.shiftOddRows ? (u7 = 2 * l3, y = (e8) => e8 ? 2 * e8 : 0, p2 = s6 / l3 * 0.5) : (u7 = l3, y = null, p2 = s6 / l3);
    const d = p(e7);
    return this._cimLayers.push({ type: "fill", templateHash: h2, materialHash: h2, cim: e7, materialOverrides: m3, colorLocked: !!e7.colorLocked, effects: t5, color: d, height: this._createOverrideFunction(o3.primitiveName, "StepY", u7, y), scaleX: p2, angle: o3.gridAngle, offsetX: b(o3.offsetX), offsetY: b(o3.offsetY), url: f2, applyRandomOffset: "Random" === i3.gridType, sampleAlphaOnly: !f2, hasUnresolvedReplacementColor: true }), true;
  }
  _analyzePictureMarker(e7, t5, i3, r2, o3, n6, s6, l3, c4, m3, f2) {
    let h2 = b(e7.scaleX, 1);
    const u7 = p(e7), p2 = c(`${e7.url}${JSON.stringify(e7.colorSubstitutions)}${JSON.stringify(e7.animatedSymbolProperties)}`).toString();
    i3 || (i3 = this._createMarkerPlacementOverrideFunction(e7.markerPlacement));
    const y = this._createAnimatedSymbolPropertiesOverrideFunction(e7.animatedSymbolProperties), [d, v] = this._analyzePrimitiveOverrides(r2, t5, i3, y), _ = c(JSON.stringify(e7) + v).toString(), O2 = e7.anchorPoint ?? { x: 0, y: 0 };
    if ("width" in e7 && "number" == typeof e7.width) {
      const t6 = e7.width;
      let i4 = 1;
      const r3 = this._resourceManager.getResource(e7.url);
      null != r3 && (i4 = r3.width / r3.height);
      h2 /= i4 * (b(e7.size) / t6);
    }
    function S2(e8, t6) {
      return null != y ? t3(y, e8, t6) : null;
    }
    const g = e7.animatedSymbolProperties && true === e7.animatedSymbolProperties.randomizeStartTime ? (e8, t6, i4, r3) => {
      const o4 = o2(r3 ?? 0), n7 = S2(e8, t6);
      return p2 + `-MATERIALGROUP(${o4})-ASP(${JSON.stringify(n7)})`;
    } : d ? (e8, t6) => {
      const i4 = S2(e8, t6);
      return p2 + `-ASP(${JSON.stringify(i4)})`;
    } : p2;
    this._cimLayers.push({ type: "marker", templateHash: _, materialHash: g, cim: e7, materialOverrides: null, colorLocked: !!e7.colorLocked || !!f2, effects: t5, scaleSymbolsProportionally: false, alignment: o3, size: s6, scaleX: this._createOverrideFunction(e7.primitiveName, "ScaleX", h2), rotation: l3, offsetX: c4, offsetY: m3, color: this._createOverrideFunction(e7.primitiveName, "TintColor", u7, U), anchorPoint: { x: O2.x, y: O2.y }, isAbsoluteAnchorPoint: "Relative" !== e7.anchorPointUnits, outlineColor: { r: 0, g: 0, b: 0, a: 0 }, outlineWidth: 0, frameHeight: 0, rotateClockwise: false, referenceSize: n6, sizeRatio: 1, markerPlacement: i3, url: e7.url, animatedSymbolProperties: y });
  }
  _analyzeVectorMarker(e7, t5, i3, r2, o3, n6, a5, s6, l3, c4, m3, f2, h2) {
    const u7 = e7.markerGraphics;
    if (!u7)
      return;
    const p2 = e7.frame;
    let y = 0, d = 1;
    e7.scaleSymbolsProportionally && p2 && (y = p2.ymax - p2.ymin, d = this._transformSize(l3, 1 / y)), d = this._transformSize(d, a5), i3 || (i3 = this._createMarkerPlacementOverrideFunction(e7.markerPlacement));
    for (const v of u7)
      if (v) {
        const a6 = v.symbol;
        if (!a6)
          continue;
        const u8 = v.primitiveName;
        u8 && r2.push(u8);
        let _ = m3, O2 = f2;
        if (("CIMPointSymbol" === a6.type || "CIMTextSymbol" === a6.type) && p2) {
          let t6 = 0, i4 = 0;
          const r3 = v.geometry;
          "x" in r3 && "y" in r3 && (t6 += r3.x - 0.5 * (p2.xmin + p2.xmax), i4 += r3.y - 0.5 * (p2.ymin + p2.ymax));
          const o4 = e7.anchorPoint;
          o4 && ("Absolute" === e7.anchorPointUnits ? (t6 -= o4.x, i4 -= o4.y) : p2 && (t6 -= (p2.xmax - p2.xmin) * o4.x, i4 -= (p2.ymax - p2.ymin) * o4.y)), _ = this._transformOffsetX(t6, i4, c4, d, m3), O2 = this._transformOffsetY(t6, i4, c4, d, f2);
        }
        switch (a6.type) {
          case "CIMPointSymbol":
          case "CIMLineSymbol":
          case "CIMPolygonSymbol":
            s6 || q2(a6) ? this._analyzeMultiLayerGraphicNonSDF(e7, t5, i3, null, v, r2, o3, n6, y, !!h2 || !!e7.colorLocked) : this._analyzeMultiLayerGraphic(e7, t5, i3, null, v, r2, o3, n6, y, d, l3, c4, _, O2, !!h2 || !!e7.colorLocked);
            break;
          case "CIMTextSymbol":
            this._analyzeTextGraphic(e7, t5, i3, v, r2, o3, n6, y, d, l3, c4, _, O2, !!h2 || !!e7.colorLocked);
        }
        u8 && r2.pop();
      }
  }
  _analyzeMultiLayerGraphic(e7, t5, i3, r2, o3, n6, s6, l3, c4, m3, f2, h2, u7, p2, y) {
    const d = o3.symbol, v = d.symbolLayers;
    if (!v)
      return;
    let _ = v.length;
    if (B(v))
      return void this._analyzeCompositeMarkerGraphic(e7, t5, i3, r2, o3, v, n6, s6, l3, c4, f2, h2, u7, p2, !!y || !!e7.colorLocked);
    const O2 = this._resourceManager.geometryEngine, k2 = l2.applyEffects(d.effects, o3.geometry, O2);
    if (k2)
      for (; _--; ) {
        const d2 = v[_];
        if (!d2 || false === d2.enable)
          continue;
        const b2 = d2.primitiveName;
        switch (b2 && n6.push(b2), d2.type) {
          case "CIMSolidFill":
          case "CIMSolidStroke": {
            const m4 = l2.applyEffects(d2.effects, k2, O2), v2 = f(m4);
            if (!v2)
              continue;
            const _2 = "Relative" !== e7.anchorPointUnits, [C, F, I] = m2(v2, e7.frame, e7.size, e7.anchorPoint, _2), w2 = "CIMSolidFill" === d2.type, x2 = { type: "sdf", geom: m4, asFill: w2 }, A2 = d2.path, R = w2 ? u4(P(d2)) : null == A2 ? u4(w(d2)) : { r: 0, g: 0, b: 0, a: 0 }, H = w2 ? { r: 0, g: 0, b: 0, a: 0 } : u4(w(d2)), J = L(d2) ?? 0;
            if (!w2 && !J)
              break;
            const Y2 = o3.primitiveName;
            let E2 = null;
            w2 && !d2.colorLocked && (E2 = this._createOverrideFunction(Y2, "FillColor", R, U));
            let T2 = null;
            w2 || d2.colorLocked || (T2 = this._createOverrideFunction(Y2, "StrokeColor", H, U));
            const $2 = this._createOverrideFunction(Y2, "StrokeWidth", J);
            let G3 = false, j2 = "";
            for (const e8 of this._primitiveOverrides)
              n6.includes(e8.primitiveName) && (null != e8.value ? j2 += `-${e8.primitiveName}-${e8.propertyName}-${JSON.stringify(e8.value)}` : e8.valueExpressionInfo && (G3 = true));
            (null != t5 && "function" == typeof t5 || null != i3 && "function" == typeof i3) && (G3 = true), (e3(f2) || e3(h2) || e3(u7) || e3(p2)) && (G3 = true);
            const D2 = JSON.stringify({ ...e7, markerGraphics: null }), W3 = c(JSON.stringify(x2) + A2).toString(), V3 = c(JSON.stringify(o3) + JSON.stringify(d2) + D2 + j2).toString();
            this._cimLayers.push({ type: "marker", templateHash: V3, materialHash: G3 ? () => W3 : W3, cim: x2, materialOverrides: null, colorLocked: !!d2.colorLocked || !!y, effects: t5, scaleSymbolsProportionally: !!e7.scaleSymbolsProportionally, alignment: s6, anchorPoint: { x: F, y: I }, isAbsoluteAnchorPoint: _2, size: f2, rotation: h2, offsetX: u7, offsetY: p2, scaleX: 1, frameHeight: c4, rotateClockwise: false, referenceSize: l3, sizeRatio: C, color: e3(E2) ? E2 : this._createOverrideFunction(b2, "Color", R, U), outlineColor: e3(T2) ? T2 : this._createOverrideFunction(b2, "Color", H, U), outlineWidth: e3($2) ? $2 : this._createOverrideFunction(b2, "Width", J), markerPlacement: i3, animatedSymbolProperties: r2, path: A2 });
            break;
          }
          case "CIMVectorMarker":
            d2.markerPlacement ? this._analyzeMultiLayerGraphicNonSDF(e7, t5, i3, r2, o3, n6, s6, l3, c4, !!y || !!d2.colorLocked) : this._analyzeMarker(d2, t5, i3, n6, s6, l3, m3, false, f2, h2, u7, p2, !!y || !!e7.colorLocked);
            break;
          default:
            this._analyzeMultiLayerGraphicNonSDF(e7, t5, i3, r2, o3, n6, s6, l3, c4, !!y || !!e7.colorLocked);
        }
        b2 && n6.pop();
      }
  }
  _analyzeTextGraphic(e7, i3, r2, o3, n6, s6, l3, c4, m3, h2, p2, d, v, _) {
    var _a;
    const O2 = [];
    le.findApplicableOverrides(o3, this._primitiveOverrides, O2);
    const S2 = o3.geometry;
    if (!("x" in S2) || !("y" in S2))
      return;
    const g = o3.symbol, k2 = k(g), X = S(g.fontStyleName), H = u3(g.fontFamilyName);
    g.font = { family: H, decoration: k2, ...X };
    let J = b(g.height, W), Y2 = b(g.angle), E2 = b(g.offsetX), T2 = b(g.offsetY);
    J = this._transformSize(J, m3), Y2 = this._transformRotation(Y2, false, p2);
    const $2 = this._transformOffsetX(E2, T2, p2, m3, d), G3 = this._transformOffsetY(E2, T2, p2, m3, v);
    E2 = $2, T2 = G3;
    const j2 = u4(P(g));
    let D2 = u4(w(g)), W3 = L(g) ?? 0;
    W3 || (D2 = u4(P(g.haloSymbol)), W3 = b(g.haloSize)), W3 = this._transformSize(W3, m3);
    let V3 = false;
    if ((_a = g.symbol) == null ? void 0 : _a.symbolLayers)
      for (const t5 of g.symbol.symbolLayers) {
        null != P(t5) && (V3 = !!t5.colorLocked);
      }
    const B2 = o3.primitiveName;
    let q3 = null;
    V3 || (q3 = this._createOverrideFunction(B2, "Color", j2, U));
    let K = null, Q = null, Z = 0;
    if (g.callout && "CIMBackgroundCallout" === g.callout.type) {
      const e8 = g.callout;
      if (e8.backgroundSymbol) {
        const t5 = e8.backgroundSymbol.symbolLayers;
        if (t5)
          for (const e9 of t5)
            "CIMSolidFill" === e9.type ? K = u4(e9.color) : "CIMSolidStroke" === e9.type && (Q = u4(e9.color), Z = b(e9.width, O));
      }
    }
    const [ee, te] = this._analyzePrimitiveOverrides(n6, i3, r2, null), ie = JSON.stringify(e7.effects) + Number(e7.colorLocked || _).toString() + JSON.stringify(e7.anchorPoint) + e7.anchorPointUnits + JSON.stringify(e7.markerPlacement) + e7.size.toString(), re = c(JSON.stringify(o3) + ie + te).toString();
    let oe = this._createOverrideFunction(o3.primitiveName, "TextString", o3.textString ?? "", s3, g.textCase);
    if (null == oe)
      return;
    const { fontStyleName: ne2 } = g, ae2 = H + (ne2 ? "-" + ne2.toLowerCase() : "-regular"), se3 = ae2;
    "string" == typeof oe && oe.includes("[") && g.fieldMap && (oe = c2(g.fieldMap, oe, g.textCase)), this._cimLayers.push({ type: "text", templateHash: re, materialHash: ee || "function" == typeof oe || /\[(.*?)\]/.test(oe) ? (e8, t5, i4) => se3 + "-" + t3(oe, e8, t5, i4) : se3 + "-" + c(oe), cim: g, materialOverrides: null, colorLocked: !!_ || !!V3, effects: i3, alignment: s6, anchorPoint: { x: 0, y: 0 }, isAbsoluteAnchorPoint: "Relative" !== e7.anchorPointUnits, fontName: ae2, decoration: k2, weight: X.weight, style: X.style, size: J, angle: Y2, offsetX: E2, offsetY: T2, horizontalAlignment: x(g.horizontalAlignment), verticalAlignment: G(g.verticalAlignment), text: oe, color: e3(q3) ? q3 : j2, outlineColor: D2, outlineSize: W3, backgroundColor: K, borderLineColor: Q, borderLineWidth: Z, lineWidth: null, referenceSize: l3, sizeRatio: 1, markerPlacement: r2 });
  }
  _analyzeMultiLayerGraphicNonSDF(e7, t5, i3, r2, n6, s6, l3, c4, m3, f2) {
    const u7 = this._buildSimpleMarker(e7, n6), y = e7.primitiveName, d = this._analyzeMaterialOverrides(y, ["Rotation", "OffsetX", "OffsetY"]), [v, _] = this._analyzePrimitiveOverrides(s6, null, null, null), [O2, S2, g] = ne.getTextureAnchor(u7, this._resourceManager), M = b(e7.rotation), k2 = b(e7.offsetX), N = b(e7.offsetY), P2 = c(JSON.stringify(u7) + _).toString(), z = d && d.length > 0 || null != t5 && "function" == typeof t5;
    this._cimLayers.push({ type: "marker", templateHash: P2, materialHash: z && d ? this._createMaterialHashFunction(P2, d) : P2, cim: u7, materialOverrides: d, colorLocked: !!e7.colorLocked || !!f2, effects: t5, scaleSymbolsProportionally: !!e7.scaleSymbolsProportionally, alignment: l3, anchorPoint: { x: O2, y: S2 }, isAbsoluteAnchorPoint: false, size: b(e7.size, q), rotation: this._createOverrideFunction(y, "Rotation", M), offsetX: this._createOverrideFunction(y, "OffsetX", k2), offsetY: this._createOverrideFunction(y, "OffsetY", N), color: { r: 255, g: 255, b: 255, a: 1 }, outlineColor: { r: 0, g: 0, b: 0, a: 0 }, outlineWidth: 0, scaleX: 1, frameHeight: m3, rotateClockwise: !!e7.rotateClockwise, referenceSize: c4, sizeRatio: g / u(e7.size), markerPlacement: i3, animatedSymbolProperties: r2, avoidSDFRasterization: true });
  }
  _buildSimpleMarker(e7, t5) {
    return { type: e7.type, enable: true, name: e7.name, colorLocked: e7.colorLocked, primitiveName: e7.primitiveName, anchorPoint: e7.anchorPoint, anchorPointUnits: e7.anchorPointUnits, offsetX: 0, offsetY: 0, rotateClockwise: e7.rotateClockwise, rotation: 0, size: e7.size, billboardMode3D: e7.billboardMode3D, depth3D: e7.depth3D, frame: e7.frame, markerGraphics: [t5], scaleSymbolsProportionally: e7.scaleSymbolsProportionally, respectFrame: e7.respectFrame, clippingPath: e7.clippingPath };
  }
  _analyzeCompositeMarkerGraphic(e7, t5, i3, r2, o3, n6, s6, l3, c4, m3, h2, u7, p2, y, d) {
    const v = o3.geometry, _ = n6[0], O2 = n6[1], k2 = f(v);
    if (!k2)
      return;
    const N = "Relative" !== e7.anchorPointUnits, [P2, z, C] = m2(k2, e7.frame, e7.size, e7.anchorPoint, N), F = { type: "sdf", geom: v, asFill: true }, I = O2.path, w2 = O2.primitiveName, x2 = _.primitiveName, A2 = u4(O2.color), R = u4(_.color), X = b(_.width, O), H = o3.primitiveName;
    let J = null;
    O2.colorLocked || d || (J = this._createOverrideFunction(H, "FillColor", A2, U));
    let Y2 = null;
    _.colorLocked || d || (Y2 = this._createOverrideFunction(H, "StrokeColor", R, U));
    const E2 = this._createOverrideFunction(H, "StrokeWidth", X);
    let T2 = false, $2 = "";
    for (const a5 of this._primitiveOverrides)
      (a5.primitiveName === w2 || a5.primitiveName === x2 || s6.includes(a5.primitiveName)) && (null != a5.value ? $2 += `-${a5.primitiveName}-${a5.propertyName}-${JSON.stringify(a5.value)}` : a5.valueExpressionInfo && (T2 = true));
    null != i3 && "function" == typeof i3 && (T2 = true), (e3(h2) || e3(u7) || e3(p2) || e3(y)) && (T2 = true);
    const G3 = JSON.stringify({ ...e7, markerGraphics: null }), j2 = c(JSON.stringify(F) + I).toString(), D2 = c(JSON.stringify(o3) + JSON.stringify(O2) + JSON.stringify(_) + G3 + $2).toString();
    this._cimLayers.push({ type: "marker", templateHash: D2, materialHash: T2 ? () => j2 : j2, cim: F, materialOverrides: null, colorLocked: !!d, effects: t5, scaleSymbolsProportionally: !!e7.scaleSymbolsProportionally, alignment: l3, anchorPoint: { x: z, y: C }, isAbsoluteAnchorPoint: N, size: h2, rotation: u7, offsetX: p2, offsetY: y, scaleX: 1, frameHeight: m3, rotateClockwise: false, referenceSize: c4, sizeRatio: P2, color: e3(J) ? J : this._createOverrideFunction(w2, "Color", A2, U), outlineColor: e3(Y2) ? Y2 : this._createOverrideFunction(x2, "Color", R, U), outlineWidth: e3(E2) ? E2 : this._createOverrideFunction(x2, "Width", X), markerPlacement: i3, path: I, animatedSymbolProperties: r2 });
  }
  _createMaterialHashFunction(e7, t5) {
    var _a;
    const i3 = (_a = this._info) == null ? void 0 : _a.geometryType;
    if (i3) {
      const e8 = this._poMap;
      for (const r2 of t5) {
        if (r2.valueExpressionInfo) {
          const t6 = e8[r2.primitiveName] && e8[r2.primitiveName][r2.propertyName];
          t6 instanceof u5 && (r2.fn = (e9, r3, o3) => s4(t6, e9, { $view: o3 }, i3, r3));
        }
      }
    }
    return (i4, r2, o3) => {
      for (const e8 of t5)
        e8.fn && (e8.value = e8.fn(i4, r2, o3));
      return c(e7 + le.buildOverrideKey(t5)).toString();
    };
  }
  _setPoMap(e7, t5, i3) {
    let r2;
    this._poMap[e7] ? r2 = this._poMap[e7] : (r2 = {}, this._poMap[e7] = r2), r2[t5] = i3;
  }
  _createOverrideFunction(e7, t5, i3, r2, o3) {
    var _a;
    if (null == e7)
      return i3;
    const n6 = this._poMap[e7];
    if (null == n6)
      return i3;
    const a5 = n6[t5];
    if ("string" == typeof a5 || "number" == typeof a5 || a5 instanceof Array)
      return r2 ? r2.call(null, a5, o3) : a5;
    const s6 = (_a = this._info) == null ? void 0 : _a.geometryType;
    return null != a5 && a5 instanceof u5 && null != s6 ? (e8, t6, n7) => {
      let l3 = s4(a5, e8, { $view: n7 }, s6, t6);
      return null !== l3 && r2 && (l3 = r2.call(null, l3, o3)), null !== l3 ? l3 : i3;
    } : i3;
  }
  _createEffectsOverrideFunction(e7, t5) {
    var _a;
    const r2 = this._poMap, o3 = (_a = this._info) == null ? void 0 : _a.geometryType;
    for (const i3 of t5) {
      if (i3.valueExpressionInfo && o3) {
        const e8 = r2[i3.primitiveName] && r2[i3.primitiveName][i3.propertyName];
        e8 instanceof u5 && (i3.fn = (t6, i4, r3) => s4(e8, t6, { $view: r3 }, o3, i4));
      }
    }
    return (r3, o4, n6) => {
      for (const e8 of t5)
        e8.fn && (e8.value = e8.fn(r3, o4, n6));
      const a5 = [];
      for (let s6 of e7) {
        const e8 = s6 == null ? void 0 : s6.primitiveName;
        if (e8) {
          let r4 = false;
          for (const o5 of t5)
            if (o5.primitiveName === e8) {
              const e9 = W2(o5.propertyName);
              null != o5.value && o5.value !== s6[e9] && (r4 || (s6 = a(s6), r4 = true), s6[e9] = o5.value);
            }
        }
        a5.push(s6);
      }
      return a5;
    };
  }
  _createMarkerPlacementOverrideFunction(e7) {
    var _a;
    const t5 = [];
    if (le.findApplicableOverrides(e7, this._primitiveOverrides, t5), null == e7 || 0 === t5.length)
      return e7;
    const r2 = this._poMap, o3 = (_a = this._info) == null ? void 0 : _a.geometryType;
    for (const i3 of t5) {
      if (i3.valueExpressionInfo && o3) {
        const e8 = r2[i3.primitiveName] && r2[i3.primitiveName][i3.propertyName];
        e8 instanceof u5 && (i3.fn = (t6, i4, r3) => s4(e8, t6, { $view: r3 }, o3, i4));
      }
    }
    return (r3, o4, n6) => {
      for (const e8 of t5)
        e8.fn && (e8.value = e8.fn(r3, o4, n6));
      const a5 = a(e7), s6 = e7.primitiveName;
      for (const e8 of t5)
        if (e8.primitiveName === s6) {
          const t6 = W2(e8.propertyName);
          null != e8.value && e8.value !== a5[t6] && (a5[t6] = e8.value);
        }
      return a5;
    };
  }
  _createAnimatedSymbolPropertiesOverrideFunction(e7) {
    var _a;
    const t5 = [];
    if (le.findApplicableOverrides(e7, this._primitiveOverrides, t5), null == e7 || 0 === t5.length)
      return e7;
    const r2 = (_a = this._info) == null ? void 0 : _a.geometryType;
    if (r2) {
      const e8 = this._poMap;
      for (const i3 of t5) {
        if (i3.valueExpressionInfo) {
          const t6 = e8[i3.primitiveName] && e8[i3.primitiveName][i3.propertyName];
          t6 instanceof u5 && (i3.fn = (e9, i4, o3) => s4(t6, e9, { $view: o3 }, r2, i4));
        }
      }
    }
    return (r3, o3, n6) => {
      for (const e8 of t5)
        e8.fn && (e8.value = e8.fn(r3, o3, n6));
      const a5 = a(e7), s6 = e7.primitiveName;
      for (const e8 of t5)
        if (e8.primitiveName === s6) {
          const t6 = W2(e8.propertyName);
          if (null != e8.value) {
            const i3 = a3(e8.value, e8.propertyName);
            i3 !== a5[t6] && (a5[t6] = i3);
          }
        }
      return a5;
    };
  }
  _analyzePrimitiveOverrides(e7, t5, i3, r2) {
    let o3 = false, n6 = "";
    "string" == typeof e7 && (e7 = [e7]);
    for (const a5 of this._primitiveOverrides)
      (e7 == null ? void 0 : e7.includes(a5.primitiveName)) && (null != a5.value ? n6 += `-${a5.primitiveName}-${a5.propertyName}-${JSON.stringify(a5.value)}` : a5.valueExpressionInfo && (o3 = true));
    return null != t5 && "function" == typeof t5 && (o3 = true), null != i3 && "function" == typeof i3 && (o3 = true), null != r2 && "function" == typeof r2 && (o3 = true), [o3, n6];
  }
  _analyzeMaterialOverrides(e7, t5) {
    return this._primitiveOverrides.filter((i3) => i3.primitiveName !== e7 || !t5.includes(i3.propertyName));
  }
  _transformSize(e7, t5) {
    return e3(e7) || e3(t5) ? (i3, r2, o3) => (e3(e7) ? e7(i3, r2, o3) : e7) * (e3(t5) ? t5(i3, r2, o3) : t5) : e7 * t5;
  }
  _transformRotation(e7, t5, i3) {
    return e3(e7) || e3(i3) ? (r2, o3, n6) => {
      const a5 = e3(e7) ? e7(r2, o3, n6) : e7, s6 = e3(i3) ? i3(r2, o3, n6) : i3;
      return t5 ? s6 - a5 : s6 + a5;
    } : t5 ? i3 - e7 : i3 + e7;
  }
  _transformOffsetX(e7, t5, i3, r2, o3) {
    if (!(e3(e7) || e3(t5) || e3(i3) || e3(r2) || e3(o3))) {
      const n6 = i3 * Math.PI / 180;
      if (n6) {
        const i4 = Math.cos(n6), a5 = Math.sin(n6);
        return (i4 * e7 - a5 * t5) * r2 + o3;
      }
      return e7 * r2 + o3;
    }
    return (n6, a5, s6) => {
      let l3 = e3(i3) ? i3(n6, a5, s6) : i3;
      const c4 = e3(r2) ? r2(n6, a5, s6) : r2, m3 = e3(e7) ? e7(n6, a5, s6) : e7, f2 = e3(o3) ? o3(n6, a5, s6) : o3;
      if (l3) {
        l3 *= Math.PI / 180;
        return (Math.cos(l3) * m3 - Math.sin(l3) * (e3(t5) ? t5(n6, a5, s6) : t5)) * c4 + f2;
      }
      return m3 * c4 + f2;
    };
  }
  _transformOffsetY(e7, t5, i3, r2, o3) {
    if (!(e3(e7) || e3(t5) || e3(i3) || e3(r2) || e3(o3))) {
      const n6 = i3 * Math.PI / 180;
      if (n6) {
        const i4 = Math.cos(n6);
        return (Math.sin(n6) * e7 + i4 * t5) * r2 + o3;
      }
      return t5 * r2 + o3;
    }
    return (n6, a5, s6) => {
      let l3 = e3(i3) ? i3(n6, a5, s6) : i3;
      const c4 = e3(r2) ? r2(n6, a5, s6) : r2, m3 = e3(t5) ? t5(n6, a5, s6) : t5, f2 = e3(o3) ? o3(n6, a5, s6) : o3;
      if (l3) {
        l3 *= Math.PI / 180;
        const t6 = Math.cos(l3);
        return (Math.sin(l3) * (e3(e7) ? e7(n6, a5, s6) : e7) + t6 * m3) * c4 + f2;
      }
      return m3 * c4 + f2;
    };
  }
};
function D(e7) {
  if (e7 && 0 === e7.indexOf("Level_")) {
    const t5 = parseInt(e7.substr(6), 10);
    if (!isNaN(t5))
      return t5;
  }
  return 0;
}
function U(t5) {
  if (!t5 || 0 === t5.length)
    return null;
  const i3 = new u2(t5).toRgba();
  return { r: i3[0], g: i3[1], b: i3[2], a: i3[3] };
}
function W2(e7) {
  return e7 ? e7.charAt(0).toLowerCase() + e7.substr(1) : e7;
}
function V2(e7, t5) {
  if (!t5 || 0 === t5.length)
    return e7;
  const r2 = a(e7);
  return le.applyOverrides(r2, t5), r2;
}
var B = (e7) => e7 && 2 === e7.length && e7[0].enable && e7[1].enable && "CIMSolidStroke" === e7[0].type && "CIMSolidFill" === e7[1].type && null == e7[0].path && null == e7[1].path && !e7[0].effects && !e7[1].effects;
function q2(e7) {
  const t5 = e7.symbolLayers;
  if (!t5 || 2 !== t5.length)
    return false;
  const i3 = t5.find((e8) => {
    var _a;
    return (_a = e8.effects) == null ? void 0 : _a.find((e9) => "CIMGeometricEffectDashes" === e9.type);
  }), r2 = t5.find((e8) => {
    var _a;
    return (_a = e8.effects) == null ? void 0 : _a.find((e9) => "CIMGeometricEffectAddControlPoints" === e9.type);
  });
  return !!i3 && !!r2;
}

export {
  l2 as l,
  l as l2,
  a4 as a,
  e6 as e,
  o2 as o,
  j,
  V2 as V
};
//# sourceMappingURL=chunk-MUSQVDUI.js.map
