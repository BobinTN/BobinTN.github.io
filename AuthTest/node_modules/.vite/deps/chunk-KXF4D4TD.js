import {
  x
} from "./chunk-DT2VHQBL.js";
import {
  b,
  j,
  l
} from "./chunk-QN7I7LNY.js";
import {
  e as e2
} from "./chunk-3RBII4KE.js";
import {
  i
} from "./chunk-WJ4LS3YG.js";
import {
  r
} from "./chunk-QWPLZ3QH.js";
import {
  f
} from "./chunk-NSRXJNTS.js";
import {
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  a,
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import {
  has
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/layers/support/ExpressionInfo.js
var p = class extends i(f) {
  constructor(r2) {
    super(r2), this.expression = null, this.title = null, this.returnType = null;
  }
};
e([y({ type: String, json: { write: true } })], p.prototype, "expression", void 0), e([y({ type: String, json: { write: true } })], p.prototype, "title", void 0), e([y({ type: String, json: { write: true } })], p.prototype, "returnType", void 0), p = e([c("esri.layers.support.ExpressionInfo")], p);
var i2 = p;

// node_modules/@arcgis/core/layers/support/AggregateField.js
var p2;
var n = p2 = class extends f {
  constructor(t) {
    super(t), this.isAutoGenerated = false, this.name = null, this.alias = null, this.onStatisticField = null, this.onStatisticExpression = null, this.statisticType = null;
  }
  clone() {
    return new p2({ name: this.name, alias: this.alias, isAutoGenerated: this.isAutoGenerated, onStatisticExpression: a(this.onStatisticExpression), onStatisticField: this.onStatisticField, statisticType: this.statisticType });
  }
};
e([y({ type: Boolean, json: { write: true } })], n.prototype, "isAutoGenerated", void 0), e([y({ type: String, json: { write: true } })], n.prototype, "name", void 0), e([y({ type: String, json: { write: true } })], n.prototype, "alias", void 0), e([y({ type: String, json: { write: true } })], n.prototype, "onStatisticField", void 0), e([y({ type: i2, json: { write: true } })], n.prototype, "onStatisticExpression", void 0), e([y({ type: String, json: { write: true } })], n.prototype, "statisticType", void 0), n = p2 = e([c("esri.layers.support.AggregateField")], n);
var a2 = n;

// node_modules/@arcgis/core/views/2d/engine/LevelDependentSizeVariable.js
var l2;
var n2 = l2 = class extends b {
  writeLevels(e3, s3, i3) {
    for (const t in e3) {
      const e4 = this.levels[t];
      return void (s3.stops = e4);
    }
  }
  clone() {
    var _a, _b;
    return new l2({ axis: this.axis, field: this.field, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, maxDataValue: this.maxDataValue, maxSize: e2(this.maxSize) ? this.maxSize.clone() : this.maxSize, minDataValue: this.minDataValue, minSize: e2(this.minSize) ? this.minSize.clone() : this.minSize, normalizationField: this.normalizationField, stops: (_a = this.stops) == null ? void 0 : _a.map((e3) => e3.clone()), target: this.target, useSymbolValue: this.useSymbolValue, valueRepresentation: this.valueRepresentation, valueUnit: this.valueUnit, legendOptions: (_b = this.legendOptions) == null ? void 0 : _b.clone(), levels: a(this.levels) });
  }
};
e([y()], n2.prototype, "levels", void 0), e([r("levels")], n2.prototype, "writeLevels", null), n2 = l2 = e([c("esri.views.2d.engine.LevelDependentSizeVariable")], n2);

// node_modules/@arcgis/core/views/2d/layers/support/clusterUtils.js
var o = s.getLogger("esri.views.2d.layers.support.clusterUtils");
has.add("esri-cluster-arcade-enabled", true);
var p3 = has("esri-cluster-arcade-enabled");
var c2 = (e3, r2, s3, i3, n3) => {
  const t = r2.clone();
  if (!b2(t))
    return t;
  if (t.authoringInfo || (t.authoringInfo = new j()), t.authoringInfo.isAutoGenerated = true, "visualVariables" in t) {
    const r3 = (t.visualVariables || []).filter((e4) => "$view.scale" !== e4.valueExpression), a3 = d(r3);
    r3.forEach((r4) => {
      "rotation" === r4.type ? r4.field ? r4.field = E(e3, r4.field, "avg_angle", "number") : r4.valueExpression && (r4.field = x2(e3, r4.valueExpression, "avg_angle", "number"), r4.valueExpression = null) : r4.normalizationField ? (r4.field = E(e3, r4.field, "avg_norm", "number", r4.normalizationField), r4.normalizationField = null) : r4.field ? r4.field = E(e3, r4.field, "avg", "number") : r4.valueExpression && (r4.field = x2(e3, r4.valueExpression, "avg", "number"), r4.valueExpression = null);
    }), null == a3 && !m(r3) && n3 && (r3.push(v(s3, i3)), t.dynamicClusterSize = true), t.visualVariables = r3;
  }
  switch (t.type) {
    case "simple":
      break;
    case "pie-chart":
      for (const r3 of t.attributes)
        r3.field ? r3.field = E(e3, r3.field, "sum", "number") : r3.valueExpression && (r3.field = x2(e3, r3.valueExpression, "sum", "number"), r3.valueExpression = null);
      break;
    case "unique-value":
      t.field ? t.field = E(e3, t.field, "mode", "string") : t.valueExpression && (t.field = x2(e3, t.valueExpression, "mode", "string"), t.valueExpression = null);
      break;
    case "class-breaks":
      t.normalizationField ? (t.field = E(e3, t.field, "avg_norm", "number", t.normalizationField), t.normalizationField = null) : t.field ? t.field = E(e3, t.field, "avg", "number") : t.valueExpression && (t.field = x2(e3, t.valueExpression, "avg", "number"), t.valueExpression = null);
  }
  return t;
};
var d = (e3) => {
  for (const r2 of e3)
    if ("size" === r2.type)
      return r2;
  return null;
};
function f2(e3, r2, s3) {
  const i3 = e3.clone();
  let n3 = false;
  if ("visualVariables" in i3) {
    const e4 = (i3.visualVariables || []).filter((e5) => "$view.scale" !== e5.valueExpression);
    null == d(e4) && (i3.visualVariables || (i3.visualVariables = []), i3.visualVariables.push(v(r2, s3)), i3.dynamicClusterSize = true, n3 = true);
  }
  return { renderer: i3, didInject: n3 };
}
var m = (e3) => {
  for (const r2 of e3)
    if ("cluster_count" === r2.field)
      return true;
  return false;
};
var v = (e3, r2) => {
  const s3 = [new l({ value: 0, size: 0 }), new l({ value: 1 })];
  if (null == r2)
    return new b({ field: "cluster_count", stops: [...s3, new l({ value: 2, size: 0 })] });
  const i3 = Object.keys(r2).reduce((i4, n3) => ({ ...i4, [n3]: [...s3, new l({ value: Math.max(2, r2[n3].minValue), size: e3.clusterMinSize }), new l({ value: Math.max(3, r2[n3].maxValue), size: e3.clusterMaxSize })] }), {});
  return new n2({ field: "cluster_count", levels: i3 });
};
var b2 = (r2) => {
  const s3 = (s4) => o.error(new s2("Unsupported-renderer", s4, { renderer: r2 }));
  if (!r2)
    return false;
  switch (r2.type) {
    case "unique-value":
      if (r2.field2 || r2.field3)
        return s3("FeatureReductionCluster does not support multi-field UniqueValueRenderers"), false;
      break;
    case "class-breaks":
      if (r2.normalizationField) {
        const e3 = r2.normalizationType;
        if ("field" !== e3)
          return s3(`FeatureReductionCluster does not support a normalizationType of ${e3}`), false;
      }
      break;
    case "simple":
    case "pie-chart":
      break;
    default:
      return s3(`FeatureReductionCluster does not support renderers of type ${r2.type}`), false;
  }
  if (!p3) {
    if ("valueExpression" in r2 && r2.valueExpression)
      return s3("FeatureReductionCluster does not currently support renderer.valueExpression. Support will be added in a future release"), false;
    if (("visualVariables" in r2 && r2.visualVariables || []).some((e3) => !(!("valueExpression" in e3) || !e3.valueExpression)))
      return s3("FeatureReductionCluster does not currently support visualVariables with a valueExpression. Support will be added in a future release"), false;
  }
  return true;
};
function g(e3, r2, i3) {
  switch (e3) {
    case "sum":
      return `cluster_sum_${r2}`;
    case "avg":
    case "avg_angle":
      return `cluster_avg_${r2}`;
    case "mode":
      return `cluster_type_${r2}`;
    case "avg_norm": {
      const e4 = i3, n3 = "field", a3 = r2.toLowerCase() + ",norm:" + n3 + "," + e4.toLowerCase();
      return "cluster_avg_" + x(a3);
    }
  }
}
function x2(e3, r2, a3, t) {
  const l3 = x(r2), u = "mode" === a3 ? `cluster_type_${l3}` : "sum" === a3 ? `cluster_sum_${l3}` : `cluster_avg_${l3}`;
  return e3.some((e4) => e4.name === u) || e3.push(new a2({ name: u, isAutoGenerated: true, onStatisticExpression: new i2({ expression: r2, returnType: t }), statisticType: a3 })), u;
}
function E(e3, r2, s3, a3, t) {
  if ("cluster_count" === r2 || e3.some((e4) => e4.name === r2))
    return r2;
  const l3 = g(s3, r2, t);
  return e3.some((e4) => e4.name === l3) || ("avg_norm" === s3 ? e3.push(new a2({ name: l3, isAutoGenerated: true, onStatisticExpression: new i2({ expression: `$feature.${r2} / $feature.${t}`, returnType: a3 }), statisticType: "avg" })) : e3.push(new a2({ name: l3, isAutoGenerated: true, onStatisticField: r2, statisticType: s3 }))), l3;
}

export {
  a2 as a,
  c2 as c,
  d,
  f2 as f,
  v,
  b2 as b
};
//# sourceMappingURL=chunk-KXF4D4TD.js.map
