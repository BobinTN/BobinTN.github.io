import {
  m as m2,
  u
} from "./chunk-ZKKM4KJT.js";
import {
  i as i3
} from "./chunk-LXYMQMWX.js";
import {
  i as i2
} from "./chunk-XJLKESB7.js";
import "./chunk-QLCCKKQG.js";
import "./chunk-673OQ2U7.js";
import {
  n,
  p
} from "./chunk-NLUGPPK2.js";
import {
  S as S2
} from "./chunk-P5GW5DPX.js";
import {
  a,
  f as f2,
  i,
  s as s2
} from "./chunk-6B7VJB6C.js";
import "./chunk-RHT6WWRD.js";
import "./chunk-EUGXS5RE.js";
import {
  U,
  j,
  w as w2
} from "./chunk-KVSZM7R6.js";
import "./chunk-KX2F2CD3.js";
import "./chunk-UNONG753.js";
import "./chunk-OFRZSMZB.js";
import "./chunk-IATM3RCE.js";
import "./chunk-GRHSIT57.js";
import "./chunk-PJQIAD5D.js";
import "./chunk-IPCIO3PX.js";
import "./chunk-EIY2DYTV.js";
import "./chunk-F6MD5VOH.js";
import {
  b
} from "./chunk-AOJ6OCPK.js";
import "./chunk-LMT5JII2.js";
import {
  h,
  m
} from "./chunk-A43TI6AT.js";
import {
  S
} from "./chunk-2D3PORS4.js";
import "./chunk-4HKQSEUR.js";
import "./chunk-V3U4F2NL.js";
import "./chunk-ZB6PGKG5.js";
import "./chunk-OIIDE5GZ.js";
import "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import "./chunk-APYNYYQC.js";
import {
  w
} from "./chunk-TBSVVR6M.js";
import "./chunk-6TJWLWLO.js";
import "./chunk-K6C6RVSV.js";
import "./chunk-JUZJCTW2.js";
import "./chunk-423VNHLR.js";
import "./chunk-FN47E7YK.js";
import {
  j as j2
} from "./chunk-WZPOQGKL.js";
import "./chunk-CCXEAKIM.js";
import "./chunk-Y5D433JZ.js";
import {
  R
} from "./chunk-QNOCEWCR.js";
import "./chunk-WURET5CW.js";
import {
  f
} from "./chunk-QWPLZ3QH.js";
import {
  d2 as d
} from "./chunk-HLGIRLYQ.js";
import "./chunk-N2K4VRZH.js";
import "./chunk-WL4VPODY.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import {
  I,
  W
} from "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import "./chunk-LXXF7K7W.js";
import "./chunk-SBW6NNVI.js";
import "./chunk-62CXLI6S.js";
import "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  s3 as s
} from "./chunk-WJ3HJKNC.js";
import "./chunk-4V6374PV.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/webdoc/webdocSaveUtils.js
var I2 = ["NatGeo_World_Map", "Ocean_Basemap", "USA_Topo_Maps", "World_Imagery", "World_Street_Map", "World_Terrain_Base", "World_Topo_Map", "World_Hillshade", "Canvas/World_Light_Gray_Base", "Canvas/World_Light_Gray_Reference", "Canvas/World_Dark_Gray_Base", "Canvas/World_Dark_Gray_Reference", "Ocean/World_Ocean_Base", "Ocean/World_Ocean_Reference", "Reference/World_Boundaries_and_Places", "Reference/World_Reference_Overlay", "Reference/World_Transportation"].map((e) => e.toLowerCase());
async function j3(e, t, a2) {
  a2 ?? (a2 = {}), S3(e, t), await w(() => !t.updatingFromView), await t.load(), await k(t), await m2(t), await T(e, t);
  const i4 = t.portalItem, n2 = I(i4.itemUrl), s3 = { origin: "web-map", messages: [], writtenProperties: [], url: n2, portal: i4.portal || j2.getDefault(), portalItem: i4, verifyItemRelativeUrls: n2 ? { rootPath: n2.path, writtenUrls: [] } : null, blockedRelativeUrls: [], resources: { toAdd: [], toUpdate: [], toKeep: [], pendingOperations: [] } }, l = t.write({}, s3);
  return await Promise.all(s3.resources.pendingOperations), D(e, s3, a2), await E(t, i4), await ue(e, t, i4, l, s3), await Promise.all([t.updateItemThumbnail(), u(t.resourceReferences, s3, null)]), i4;
}
async function A(e, t, o, a2) {
  a2 ?? (a2 = {});
  const i4 = M(e, o);
  await w(() => !t.updatingFromView), await t.load(), await k(t), await m2(t), await T(e, t);
  const n2 = { origin: "web-map", messages: [], writtenProperties: [], url: null, portal: i4.portal, portalItem: i4, blockedRelativeUrls: [], resources: { toAdd: [], toUpdate: [], toKeep: [], pendingOperations: [] } }, s3 = t.write({}, n2);
  await Promise.all(n2.resources.pendingOperations), D(e, n2, a2), await z(t, i4);
  const l = t.getThumbnailState();
  return await me(e, t, i4, s3, n2, a2) && (t.resourceReferences.portalItem = i4), t.restoreThumbnailFromState(l), await Promise.all([t.updateItemThumbnail(), u(t.resourceReferences, n2, null)]), i4;
}
function S3(t, r) {
  if (!r.portalItem)
    throw new s(`${t.name}:portal-item-not-set`, "Portal item to save to has not been set on the WebMap");
  i3(r.portalItem), O(t, r.portalItem);
}
function O(t, r) {
  if (r.type !== t.itemType)
    throw new s(`${t.name}:portal-item-wrong-type`, `Portal item needs to have type "${t.itemType}"`);
}
async function T(t, o) {
  var _a;
  if (!((_a = o.basemap) == null ? void 0 : _a.baseLayers.length))
    throw new s(`${t.name}:save`, "Map does not have a valid basemap with a base layer.");
  let a2 = null;
  if (await w(() => {
    const e = U(o.initialViewProperties, o.basemap);
    return a2 = e.spatialReference, !e.updating;
  }), !d(a2, o.initialViewProperties.spatialReference))
    throw new s(`${t.name}:save`, "The spatial reference of the basemap is not compatible with the one from the map.", { expected: o.initialViewProperties.spatialReference, actual: a2 });
}
function M(e, t) {
  let r = S.from(t);
  return r.id && (r = r.clone(), r.id = null), r.type || (r.type = e.itemType), r.portal || (r.portal = j2.getDefault()), i3(r), O(e, r), r;
}
function k(e) {
  const t = [];
  return e.basemap && t.push(e.basemap.load()), e.ground && t.push(e.ground.load()), Promise.allSettled(t).then(() => {
  });
}
function D(t, r, o) {
  let a2 = (r.messages ?? []).filter((e) => "error" === e.type).map((t2) => new s(t2.name, t2.message, t2.details));
  if (r.blockedRelativeUrls && (a2 = a2.concat(r.blockedRelativeUrls.map((t2) => new s("url:unsupported", `Relative url '${t2}' is not supported in Web Map`)))), o.ignoreUnsupported && (a2 = a2.filter((e) => "layer:unsupported" !== e.name && "symbol:unsupported" !== e.name && "symbol-layer:unsupported" !== e.name && "property:unsupported" !== e.name && "url:unsupported" !== e.name)), a2.length > 0)
    throw new s(`${t.name}:save`, "Failed to save webmap due to unsupported or invalid content. See 'details.errors' for more detailed information", { errors: a2 });
}
async function E(e, t) {
  t.extent = await ne(e.portalItem, e.initialViewProperties.viewpoint.targetGeometry), await Q(e, t);
}
var V = f2.JSAPI;
var C = "CollectorDisabled";
var G = "Collector";
var L = "Data Editing";
var $ = "OfflineDisabled";
var B = "Offline";
var K = "Workforce Project";
var x = "Workforce Worker";
var F = "Workforce Dispatcher";
var N = "Offline Map Areas";
var H = "FieldMapsDisabled";
var J = f2.DEVELOPER_BASEMAP;
var q = "UtilityNetwork";
async function z(e, t) {
  a(t, C), a(t, H), a(t, f2.METADATA), a(t, $), a(t, N), a(t, F), a(t, K), a(t, x), await E(e, t);
}
async function Q(e, t) {
  i(t, V), await X(e), te(e, t), re(e, t), oe(e, t), ae(e, t), ie(e, t), t.typeKeywords && (t.typeKeywords = t.typeKeywords.filter((e2, t2, r) => r.indexOf(e2) === t2));
}
function X(e) {
  const t = Y(e).map((e2) => e2.load()).toArray();
  return Promise.allSettled(t).then(() => {
  });
}
function Y(e) {
  return e.allLayers.concat(e.allTables);
}
function Z(e) {
  return Y(e).some((e2) => e2.loaded && h(e2) && e2.capabilities.operations.supportsEditing && e2.editingEnabled && ("subtype-group" !== e2.type || e2.sublayers.some((e3) => e3.editingEnabled)));
}
function ee(e) {
  return Y(e).filter((e2) => "group" !== e2.type).every((t) => t.loaded && pe(e, t));
}
function te(e, t) {
  s2(t, C) || s2(t, K) || s2(t, x) || s2(t, F) || !Z(e) ? a(t, G) : i(t, G);
}
function re(e, t) {
  Z(e) ? i(t, L) : a(t, L);
}
function oe(e, t) {
  !s2(t, $) && ee(e) ? i(t, B) : a(t, B);
}
function ae(e, t) {
  w2(e.basemap) ? i(t, J) : a(t, J);
}
function ie(e, t) {
  var _a;
  ((_a = e.utilityNetworks) == null ? void 0 : _a.length) ? i(t, q) : a(t, q);
}
async function ne(e, t) {
  const r = t.clone().normalize();
  let o;
  if (r.length > 1)
    for (const a2 of r)
      o ? a2.width > o.width && (o = a2) : o = a2;
  else
    o = r[0];
  return se(e, o);
}
async function se(e, t) {
  const r = t.spatialReference;
  if (r.isWGS84)
    return t.clone();
  if (r.isWebMercator)
    return R(t);
  const { getGeometryServiceURL: o } = await import("./geometryServiceUtils-VYVVCT63.js"), a2 = await o(e), i4 = new p();
  i4.geometries = [t], i4.outSpatialReference = f.WGS84;
  return (await n(a2, i4))[0];
}
function le(e) {
  return m(e) || "map-notes" === e.type || "route" === e.type;
}
function pe(e, t) {
  return h(t) && t.capabilities.operations.supportsSync || le(t) && !t.portalItem || ("tile" === t.type || "vector-tile" === t.type) && (t.capabilities.operations.supportsExportTiles || ce(t) || j(t)) && t.spatialReference.equals(e.initialViewProperties.spatialReference);
}
function ce(e) {
  return "tile" === e.type && (b(e.url) && I2.some((t) => {
    var _a;
    return (_a = e.url) == null ? void 0 : _a.toLowerCase().includes("/" + t + "/");
  }));
}
async function ue(e, t, r, o, a2) {
  await r.update({ data: o }), we(e, t, r, o, a2);
}
async function me(t, r, o, a2, i4, n2) {
  const s3 = r.portalItem, l = { item: s3, authenticated: !(!(s3 == null ? void 0 : s3.id) || !s3.portal.user) }, p2 = o.portal;
  await p2.signIn();
  const { copyAllowed: c, itemReloaded: u2 } = await de(l, p2);
  if (l.authenticated || (l.authenticated = u2), !c)
    throw new s(`${t.name}:save-as-copy-not-allowed`, "Owner of this map does not allow others to save a copy");
  const m3 = await fe(o, l, a2, n2);
  return r.portalItem = o, we(t, r, o, a2, i4), m3;
}
async function de(e, t) {
  var _a;
  const { item: r, authenticated: o } = e;
  return (r == null ? void 0 : r.id) && ((_a = r.typeKeywords) == null ? void 0 : _a.includes("useOnly")) ? r.portal.portalHostname !== t.portalHostname ? { copyAllowed: false, itemReloaded: false } : (o || await r.reload(), { copyAllowed: "admin" === r.itemControl || "update" === r.itemControl, itemReloaded: true }) : { copyAllowed: true, itemReloaded: false };
}
async function fe(e, t, r, o) {
  var _a;
  const i4 = e.portal, { item: n2 } = t, { folder: s3, copyAllResources: l } = o;
  let p2 = false;
  if (l && (n2 == null ? void 0 : n2.id) && W(n2.portal.url, i4.url) && parseInt(n2.portal.currentVersion, 10) >= 2023) {
    const { total: e2 } = await n2.fetchResources();
    p2 = !!e2;
  }
  if (p2) {
    const t2 = await n2.copy({ copyResources: "all", folder: s3 });
    e.id = t2.id, e.portal = t2.portal;
    const o2 = e.toJSON();
    await e.load(), e.read(o2), await e.update({ data: r });
  } else
    await ((_a = i4.user) == null ? void 0 : _a.addItem({ item: e, folder: s3, data: r }));
  return p2;
}
function we(e, r, a2, n2, s3) {
  S2.prototype.read.call(r, { version: n2.version, authoringApp: n2.authoringApp, authoringAppVersion: n2.authoringAppVersion }, { origin: e.origin, ignoreDefaults: true, url: a2.itemUrl ? I(a2.itemUrl) : void 0 }), i2(s3), r.resourceInfo = n2;
}
export {
  j3 as save,
  A as saveAs
};
//# sourceMappingURL=webdocSaveUtils-LCLRRXUL.js.map
