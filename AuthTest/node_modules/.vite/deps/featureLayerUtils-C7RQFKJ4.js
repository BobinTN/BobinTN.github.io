import {
  I,
  b,
  d,
  l as l2,
  m,
  u as u2,
  v,
  w,
  y
} from "./chunk-AW4H2VAC.js";
import "./chunk-LXYMQMWX.js";
import {
  i as i2
} from "./chunk-XJLKESB7.js";
import "./chunk-QLCCKKQG.js";
import {
  o
} from "./chunk-IUQHF7KZ.js";
import {
  t
} from "./chunk-ID2FHQ3Y.js";
import "./chunk-3U7MSH5S.js";
import {
  a as a2
} from "./chunk-6DA3YN7V.js";
import {
  a,
  f,
  i,
  l,
  u
} from "./chunk-6B7VJB6C.js";
import {
  p
} from "./chunk-AOJ6OCPK.js";
import "./chunk-LMT5JII2.js";
import {
  h
} from "./chunk-A43TI6AT.js";
import "./chunk-2D3PORS4.js";
import "./chunk-4HKQSEUR.js";
import "./chunk-V3U4F2NL.js";
import "./chunk-ZB6PGKG5.js";
import "./chunk-OIIDE5GZ.js";
import "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import "./chunk-FN47E7YK.js";
import "./chunk-WZPOQGKL.js";
import "./chunk-CCXEAKIM.js";
import "./chunk-Y5D433JZ.js";
import "./chunk-QNOCEWCR.js";
import "./chunk-WURET5CW.js";
import "./chunk-QWPLZ3QH.js";
import "./chunk-HLGIRLYQ.js";
import "./chunk-N2K4VRZH.js";
import "./chunk-WL4VPODY.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import "./chunk-LXXF7K7W.js";
import "./chunk-SBW6NNVI.js";
import "./chunk-62CXLI6S.js";
import "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  s3 as s
} from "./chunk-WJ3HJKNC.js";
import {
  g,
  k
} from "./chunk-4V6374PV.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/save/featureLayerUtils.js
var L = "Feature Service";
var P = "feature-layer-utils";
var E = `${P}-save`;
var $ = `${P}-save-as`;
var A = `${P}-saveall`;
var N = `${P}-saveall-as`;
function g2(e) {
  return { isValid: h(e) && ("feature" !== e.type || !e.dynamicDataSource), errorMessage: "Feature layer should be a layer or table in a map or feature service" };
}
function x(e) {
  const a3 = [], r = [];
  for (const { layer: t2, layerJSON: o2 } of e)
    t2.isTable ? r.push(o2) : a3.push(o2);
  return { layers: a3, tables: r };
}
function j(e) {
  return x([e]);
}
async function O(e, a3) {
  return /\/\d+\/?$/.test(e.url) ? j(a3[0]) : U(a3, e);
}
async function U(e, a3) {
  if (!a3)
    return e.reverse(), x(e);
  const { layer: { url: r, customParameters: t2, apiKey: o2 } } = e[0];
  let s2 = await a3.fetchData("json");
  null != (s2 == null ? void 0 : s2.layers) && null != (s2 == null ? void 0 : s2.tables) || (s2 = await F(s2, { url: r ?? "", customParameters: t2, apiKey: o2 }, e.map((e2) => e2.layer.layerId)));
  for (const n of e)
    K(n.layer, n.layerJSON, s2);
  return s2;
}
async function F(e, a3, r) {
  e || (e = {}), e.layers || (e.layers = []), e.tables || (e.tables = []);
  const { url: t2, customParameters: o2, apiKey: s2 } = a3, { serviceJSON: n, layersJSON: l3 } = await t(t2, { customParameters: o2, apiKey: s2 }), i3 = J(e.layers, n.layers, r), c = J(e.tables, n.tables, r);
  e.layers = i3.itemResources, e.tables = c.itemResources;
  const u3 = [...i3.added, ...c.added], p2 = l3 ? [...l3.layers, ...l3.tables] : [];
  return await M(e, u3, t2, p2), e;
}
function J(a3, r, t2) {
  const o2 = g(a3, r, (e, a4) => e.id === a4.id);
  a3 = a3.filter((e) => !o2.removed.some((a4) => a4.id === e.id));
  const s2 = o2.added;
  return s2.forEach(({ id: e }) => {
    a3.push({ id: e });
  }), { itemResources: a3, added: s2.filter(({ id: e }) => !t2.includes(e)) };
}
async function M(e, a3, r, t2) {
  const o2 = await R(a3), s2 = a3.map(({ id: e2, type: a4 }) => new (o2.get(a4))({ url: r, layerId: e2, sourceJSON: t2.find(({ id: a5 }) => a5 === e2) }));
  await Promise.allSettled(s2.map((e2) => e2.load())), s2.forEach((a4) => {
    const { layerId: r2, loaded: t3, defaultPopupTemplate: o3 } = a4;
    if (!t3 || null == o3)
      return;
    const s3 = { id: r2, popupInfo: o3.toJSON() };
    "ArcGISFeatureLayer" !== a4.operationalLayerType && (s3.layerType = a4.operationalLayerType), K(a4, s3, e);
  });
}
async function R(e) {
  const a3 = [];
  e.forEach(({ type: e2 }) => {
    const r2 = D(e2), t3 = a2[r2];
    a3.push(t3());
  });
  const r = await Promise.all(a3), t2 = /* @__PURE__ */ new Map();
  return e.forEach(({ type: e2 }, a4) => {
    t2.set(e2, r[a4]);
  }), t2;
}
function D(e) {
  let a3;
  switch (e) {
    case "Feature Layer":
    case "Table":
      a3 = "FeatureLayer";
      break;
    case "Oriented Imagery Layer":
      a3 = "OrientedImageryLayer";
  }
  return a3;
}
function K(e, a3, r) {
  e.isTable ? Y(r.tables, a3) : Y(r.layers, a3);
}
function Y(e, a3) {
  const r = e.findIndex(({ id: e2 }) => e2 === a3.id);
  -1 === r ? e.push(a3) : e[r] = a3;
}
function _(e, a3) {
  if (!e.length)
    throw new s(`${a3}:missing-parameters`, "'layers' array should contain at least one feature layer");
}
function z(e, a3) {
  const t2 = e.map((e2) => e2.portalItem.id);
  if (new Set(t2).size > 1)
    throw new s(`${a3}:invalid-parameters`, "All layers in the 'layers' array should be loaded from the same portal item");
}
function G(e, a3) {
  const t2 = e.map((e2) => e2.layerId);
  if (new Set(t2).size !== t2.length)
    throw new s(`${a3}:invalid-parameters`, "'layers' array should contain only one instance each of layer or table in a feature service");
}
async function B(e) {
  _(e, A), await Promise.all(e.map((e2) => e2.load()));
  for (const a3 of e)
    l2(a3, A, g2), d({ layer: a3, itemType: L, errorNamePrefix: A });
  z(e, A), G(e, A);
}
async function k2(e, a3) {
  const { url: r, layerId: t2, title: o2, fullExtent: s2, isTable: n } = e, l3 = p(r);
  a3.url = "FeatureServer" === (l3 == null ? void 0 : l3.serverType) ? r : `${r}/${t2}`, a3.title || (a3.title = o2), a3.extent = null, n || null == s2 || (a3.extent = await l(s2)), a(a3, f.METADATA), a(a3, f.MULTI_LAYER), i(a3, f.SINGLE_LAYER), n && i(a3, f.TABLE);
}
function C(e, a3) {
  for (const n of e) {
    const t3 = n.parsedUrl.path, o3 = p(t3), s3 = o3 == null ? void 0 : o3.url.path;
    if (!s3)
      throw new s(`${a3}:invalid-parameters`, m(n, `has unsupported url pattern: ${t3}`), { layer: n });
    const l3 = o3 == null ? void 0 : o3.serverType;
    if ("FeatureServer" !== l3 && "MapServer" !== l3)
      throw new s(`${a3}:invalid-parameters`, m(n, `has unsupported server type: ${l3}`), { layer: n });
    if ("MapServer" === l3 && e.length > 1)
      throw new s(`${a3}:invalid-parameters`, "Only one layer or table in a map service can be saved");
  }
  const t2 = p(e[0].parsedUrl.path), o2 = t2 == null ? void 0 : t2.url.path, s2 = e.every((e2) => {
    const a4 = p(e2.parsedUrl.path);
    return (a4 == null ? void 0 : a4.url.path) === o2;
  });
  if (!s2)
    throw new s(`${a3}:invalid-parameters`, "'layers' array should only contain layers or tables that belong to the same feature service");
}
async function V(e) {
  _(e, N), await Promise.all(e.map((e2) => e2.load()));
  for (const a3 of e)
    l2(a3, N, g2);
  C(e, N), G(e, N);
}
async function q(e, r) {
  let t2 = 0, o2 = 0;
  for (const { isTable: a3 } of r)
    a3 ? o2++ : t2++;
  const s2 = r[0].parsedUrl.path, l3 = p(s2);
  if (e.url = "FeatureServer" === (l3 == null ? void 0 : l3.serverType) ? l3.url.path : s2, e.title || (e.title = l3.title), e.extent = null, t2 > 0) {
    const t3 = r.map((e2) => e2.fullExtent).filter(k).reduce((e2, a3) => e2.clone().union(a3));
    t3 && (e.extent = await l(t3));
  }
  a(e, f.METADATA), u(e, f.MULTI_LAYER, r.length > 1), u(e, f.SINGLE_LAYER, 1 === r.length), u(e, f.TABLE, o2 > 0 && 0 === t2), w(e);
}
async function H(e, a3) {
  return I({ layer: e, itemType: L, validateLayer: g2, createItemData: (e2, a4) => O(a4, [e2]), errorNamePrefix: E }, a3);
}
async function Q(e, a3) {
  await B(e);
  const r = e[0].portalItem, o2 = o(r), l3 = await Promise.all(e.map((e2) => y(e2, o2, a3))), i3 = await O(r, e.map((e2, a4) => ({ layer: e2, layerJSON: l3[a4] })));
  return w(r), await r.update({ data: i3 }), await Promise.all(e.slice(1).map((e2) => e2.portalItem.reload())), i2(o2), r.clone();
}
async function W(e, a3, r) {
  return b({ layer: e, itemType: L, validateLayer: g2, createItemData: (e2, a4) => Promise.resolve(j(e2)), errorNamePrefix: $, newItem: a3, setItemProperties: k2 }, r);
}
async function X(e, a3, r) {
  await V(e);
  const o2 = u2({ itemType: L, errorNamePrefix: N, newItem: a3 }), n = o(o2), l3 = await Promise.all(e.map((e2) => y(e2, n, r))), u3 = await U(e.map((e2, a4) => ({ layer: e2, layerJSON: l3[a4] })));
  await q(o2, e), await v(o2, u3, r);
  for (const t2 of e)
    t2.portalItem = o2.clone();
  return i2(n), o2;
}
export {
  H as save,
  Q as saveAll,
  X as saveAllAs,
  W as saveAs
};
//# sourceMappingURL=featureLayerUtils-C7RQFKJ4.js.map
