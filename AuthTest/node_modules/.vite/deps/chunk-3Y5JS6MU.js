import {
  e as e3
} from "./chunk-MPQZTJY3.js";
import {
  r
} from "./chunk-GPOJ5GQM.js";
import {
  c as c4
} from "./chunk-VLDVHSJX.js";
import {
  E as E2
} from "./chunk-A6KO3R3G.js";
import {
  T,
  e2
} from "./chunk-T56C4ORZ.js";
import {
  l,
  l2,
  n as n3
} from "./chunk-DMXA3RSU.js";
import {
  i as i2
} from "./chunk-7PBKZJWC.js";
import {
  f
} from "./chunk-TJGMKUCX.js";
import {
  K as K2,
  V,
  W
} from "./chunk-UMP4LYVN.js";
import {
  t
} from "./chunk-HR42LBYN.js";
import {
  L as L2,
  S as S2
} from "./chunk-TREPTI6V.js";
import {
  E,
  F,
  G as G2,
  H,
  I,
  J,
  K,
  P,
  Q,
  R,
  S,
  U as U2,
  c,
  de,
  z
} from "./chunk-XFC7DZXI.js";
import {
  D,
  L,
  U
} from "./chunk-RCLKRKWR.js";
import {
  c as c2,
  f as f2
} from "./chunk-KXF4D4TD.js";
import {
  c as c3
} from "./chunk-MJTRXEE4.js";
import {
  a
} from "./chunk-SEKLTVY5.js";
import {
  n as n4
} from "./chunk-JLSYG6MV.js";
import {
  e
} from "./chunk-76KPSQLT.js";
import {
  n as n2
} from "./chunk-B7TIRUHV.js";
import {
  o as o2,
  s as s4
} from "./chunk-EY7PGBJG.js";
import {
  i,
  s as s3
} from "./chunk-YVNEJWNQ.js";
import {
  n
} from "./chunk-SZAJDZCO.js";
import {
  o,
  u as u2
} from "./chunk-EIY2DYTV.js";
import {
  j
} from "./chunk-OIIDE5GZ.js";
import {
  u
} from "./chunk-3XSRVKBX.js";
import {
  G
} from "./chunk-HLGIRLYQ.js";
import {
  C
} from "./chunk-RFPH3ZTZ.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import {
  has,
  k
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/views/2d/layers/features/support/rendererUtils.js
var s5 = 8;
var l3 = s5 - 2;
var a2 = s.getLogger("esri.views.2d.layers.features.support.rendererUtils");
var n5 = (e6) => {
  var _a;
  if (!("visualVariables" in e6) || !((_a = e6.visualVariables) == null ? void 0 : _a.length))
    return e6;
  const r4 = e6.clone(), t3 = r4.visualVariables.map((e7) => u3(e7) ? p(e7) : e7);
  return r4.visualVariables = t3, r4;
};
function i3(e6) {
  return e6.map((e7) => u3(e7) ? p(e7.clone()) : e7);
}
function u3(e6) {
  return ("size" === e6.type || "color" === e6.type || "opacity" === e6.type) && null != e6.stops;
}
function p(e6) {
  return e6.stops = m(e6.type, e6.stops ?? []), e6;
}
function c5(e6, r4, t3) {
  return (1 - t3) * e6 + t3 * r4;
}
function f3(e6, r4) {
  const [o3, ...s7] = r4, a4 = s7.pop(), n8 = s7[0].value, i7 = s7[s7.length - 1].value, u5 = (i7 - n8) / l3, p3 = [];
  for (let l4 = n8; l4 < i7; l4 += u5) {
    let o4 = 0;
    for (; l4 >= s7[o4].value; )
      o4++;
    const a5 = s7[o4], n9 = r4[o4 - 1], i8 = l4 - n9.value, u6 = a5.value === n9.value ? 1 : i8 / (a5.value - n9.value);
    if ("color" === e6) {
      const e7 = s7[o4], t3 = r4[o4 - 1], a6 = e7.color.clone();
      a6.r = c5(t3.color.r, a6.r, u6), a6.g = c5(t3.color.g, a6.g, u6), a6.b = c5(t3.color.b, a6.b, u6), a6.a = c5(t3.color.a, a6.a, u6), p3.push({ value: l4, color: a6, label: e7.label });
    } else if ("size" === e6) {
      const e7 = s7[o4], a6 = r4[o4 - 1], n10 = o(e7.size), i9 = c5(o(a6.size), n10, u6);
      p3.push({ value: l4, size: i9, label: e7.label });
    } else {
      const e7 = s7[o4], t3 = c5(r4[o4 - 1].opacity, e7.opacity, u6);
      p3.push({ value: l4, opacity: t3, label: e7.label });
    }
  }
  return [o3, ...p3, a4];
}
function b(e6) {
  const [r4, ...t3] = e6, o3 = t3.pop();
  for (; t3.length > l3; ) {
    let e7 = 0, r5 = 0;
    for (let o4 = 1; o4 < t3.length; o4++) {
      const s7 = t3[o4 - 1], l4 = t3[o4], a4 = Math.abs(l4.value - s7.value);
      a4 > r5 && (r5 = a4, e7 = o4);
    }
    t3.splice(e7, 1);
  }
  return [r4, ...t3, o3];
}
function m(e6, r4) {
  return r4.length <= s5 ? r4 : (a2.warn(`Found ${r4.length} Visual Variable stops, but MapView only supports ${s5}. Displayed stops will be simplified.`), r4.length > 2 * s5 ? f3(e6, r4) : b(r4));
}
function g() {
  if (has("heatmap-force-raster"))
    return "raster";
  const { supportsTextureFloat: e6, supportsTextureHalfFloat: r4, supportsColorBufferFloat: t3, supportsColorBufferFloatBlend: s7, supportsColorBufferHalfFloat: l4 } = n4("2d");
  return e6 && t3 && s7 || r4 && l4 ? "symbol" : has("heatmap-allow-raster-fallback") ? "raster" : "none";
}
function h(r4) {
  if (!r4)
    return true;
  switch (r4.type) {
    case "dot-density":
      if (!n4("2d").supportsTextureFloat)
        return a2.error(new s2("webgl-missing-extension", "Missing WebGL extension OES_Texture_Float which is required for DotDensity")), false;
      break;
    case "heatmap": {
      const r5 = g();
      if ("none" === r5 || "raster" === r5 && !has("heatmap-force-raster")) {
        const t3 = n4("2d"), s7 = ["supportsTextureFloat", "supportsTextureHalfFloat", "supportsColorBufferFloat", "supportsColorBufferFloatBlend", "supportsColorBufferHalfFloat"].filter((e6) => !t3[e6]).join(", ");
        if ("none" === r5)
          return a2.errorOnce(new s2("webgl-missing-extension", `Missing WebGL${t3.type} requirements for Heatmap: ${s7}`)), false;
        "raster" === r5 && a2.warnOnce(`Missing WebGL${t3.type} requirements for accelerated Heatmap: ${s7}. Feature support may be limited.`);
      }
      break;
    }
  }
  return true;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/util/vvFlagUtils.js
function e4(e6) {
  if (!e6)
    return L2.NONE;
  let r4 = 0;
  for (const i7 of e6)
    if ("size" === i7.type) {
      const t3 = l2(i7);
      r4 |= t3, "outline" === i7.target && (r4 |= t3 << 4);
    } else
      "color" === i7.type ? r4 |= L2.COLOR : "opacity" === i7.type ? r4 |= L2.OPACITY : "rotation" === i7.type && (r4 |= L2.ROTATION);
  return r4;
}

// node_modules/@arcgis/core/views/2d/layers/graphics/graphicsUtils.js
var c6 = 512;
var f4 = 50;
function g2(e6, t3) {
  const n8 = G(t3);
  if (!n8)
    return null;
  const [o3, s7] = n8.valid;
  return e6[2] > s7 ? [u([e6[0], e6[1], s7, e6[3]]), u([o3, e6[1], o3 + e6[2] - s7, e6[3]])] : e6[0] < o3 ? [u([o3, e6[1], e6[2], e6[3]]), u([s7 - (o3 - e6[0]), e6[1], s7, e6[3]])] : null;
}
function u4(e6) {
  return "text" === e6 || "esriTS" === e6;
}
function p2(e6) {
  return "simple-marker" === e6 || "picture-marker" === e6 || "esriSMS" === e6 || "esriPMS" === e6;
}
function h2(e6) {
  switch (e6.geometry.type) {
    case "point":
    case "multipoint":
      return 0;
    case "polyline":
      return 1;
    case "polygon":
    case "extent":
      return 2;
  }
  return 0;
}
function x(e6) {
  if (!e6)
    return null;
  const { xmin: t3, ymin: i7, xmax: r4, ymax: o3, spatialReference: s7 } = e6;
  return new j({ rings: [[[t3, i7], [t3, o3], [r4, o3], [r4, i7], [t3, i7]]], spatialReference: s7 });
}

// node_modules/@arcgis/core/views/2d/layers/features/support/pixelBuffering.js
function m2(t3, e6) {
  if (!("visualVariables" in t3))
    return 0;
  if (!t3.hasVisualVariables("size"))
    return 0;
  const r4 = t3.getVisualVariablesForType("size");
  if (!r4[0])
    return 0;
  const i7 = r4[0];
  if (e6 && "cluster_count" === i7.field && "cluster" === e6.type)
    return e6.clusterMaxSize;
  if ("outline" === i7.target)
    return 0;
  if ("stops" === i7.transformationType)
    return i7.stops.map((t4) => t4.size).reduce(g3, 0);
  if ("clamped-linear" === i7.transformationType) {
    let t4 = -1 / 0, e7 = -1 / 0;
    return t4 = "number" == typeof i7.maxSize ? i7.maxSize : i7.maxSize.stops.map((t5) => t5.size).reduce(g3, 0), e7 = "number" == typeof i7.minSize ? i7.minSize : i7.minSize.stops.map((t5) => t5.size).reduce(g3, 0), Math.max(t4, e7);
  }
  return "real-world-size" === i7.transformationType ? 30 : void 0;
}
var y = { sdf: true, code: 99, metrics: z.metrics, rect: new t(0, 0, 24, 24), page: 0, textureBinding: 2 };
function g3(t3, e6) {
  return Math.max(t3, e6);
}

// node_modules/@arcgis/core/views/2d/layers/features/schemaUtils.js
var x2 = s.getLogger("esri.views.2d.layers.features.schemaUtils");
var h3 = "ValidationError";
function v(e6) {
  return e6;
}
function T2(e6, t3) {
  let r4 = 0, i7 = 0, n8 = S2.DEFAULT;
  if (null != e6) {
    if (i7 = m2(e6, t3), "visualVariables" in e6 && (r4 = e4(e6.visualVariables || []), "dot-density" === e6.type && (n8 = S2.DOT_DENSITY)), "heatmap" === e6.type && (n8 = S2.HEATMAP), "dictionary" === e6.type)
      return { maxVVSize: i7, vvFlags: r4, symbologyType: S2.DEFAULT };
    if ("pie-chart" === e6.type)
      return { maxVVSize: i7, vvFlags: r4, symbologyType: S2.PIE_CHART };
    if (n8 !== S2.DOT_DENSITY && n8 !== S2.HEATMAP) {
      const t4 = e6.getSymbols();
      "backgroundFillSymbol" in e6 && e6.backgroundFillSymbol && t4.push(e6.backgroundFillSymbol);
      let r5 = true, i8 = true;
      for (const e7 of t4)
        if ("cim" !== e7.type && "web-style" !== e7.type || (i8 = false), "simple-fill" === e7.type || "picture-fill" === e7.type) {
          const t5 = e7.outline, n9 = t5 && "none" !== t5.style && "solid" !== t5.style, s7 = "simple-fill" === e7.type && "none" !== e7.style && "solid" !== e7.style;
          n9 && (r5 = false), ("picture-fill" === e7.type || s7 || n9) && (i8 = false);
        }
      r5 ? n8 = i8 ? S2.OUTLINE_FILL_SIMPLE : S2.OUTLINE_FILL : i8 && (n8 = S2.SIMPLE);
    }
  }
  return { vvFlags: r4, maxVVSize: i7, symbologyType: n8 };
}
var S4 = null;
function w2(e6) {
  if (has("esri-2d-update-debug")) {
    const t3 = E3(e6, true);
    console.debug("Created new schema", t3), console.debug("Schema diff", a(S4, t3)), S4 = t3;
  }
  return E3(e6);
}
function E3(e6, t3 = false) {
  var _a, _b;
  try {
    const r4 = R2(e6, t3), i7 = D2(e6), s7 = {};
    r4.map((t4) => F2(s7, e6, t4));
    const l4 = null != e6.subtypeCode ? `${e6.subtypeField} = ${e6.subtypeCode}` : null, o3 = n(e6.definitionExpression, l4);
    return { source: { definitionExpression: o3, fields: e6.fields.map((e7) => e7.toJSON()), gdbVersion: e6.gdbVersion, historicMoment: (_a = e6.historicMoment) == null ? void 0 : _a.getTime(), outFields: e6.availableFields, pixelBuffer: e6.pixelBuffer, spatialReference: e6.spatialReference.toJSON(), timeExtent: (_b = e6.timeExtent) == null ? void 0 : _b.toJSON(), customParameters: e6.customParameters }, attributes: { fields: {}, indexCount: 0 }, processors: r4, tileRenderer: i7, targets: s7 };
  } catch (r4) {
    if (r4.fieldName === h3)
      return x2.error(r4), null;
    throw r4;
  }
}
function F2(e6, r4, i7) {
  switch (i7.target) {
    case "feature":
      return void O(e6, V2(r4), i7);
    case "aggregate": {
      if (!("featureReduction" in r4))
        return;
      const n8 = r4.featureReduction;
      switch (n8 == null ? void 0 : n8.type) {
        case "selection":
          throw new s2(h3, "Mapview does not support `selection` reduction type", n8);
        case "binning":
          return O(e6, V2(r4), i7), void N(e6, n8, r4.fields.map((e7) => e7.toJSON()), i7);
        case "cluster":
          return O(e6, V2(r4), i7), void L3(e6, n8, r4.fields.map((e7) => e7.toJSON()), i7);
      }
    }
  }
}
function I2(e6, t3) {
  var _a, _b;
  for (const r4 in t3) {
    const i7 = t3[r4];
    if (i7.target !== e6.name)
      continue;
    const n8 = e6.attributes[r4];
    if (n8 == null ? void 0 : n8.context) {
      const e7 = n8.context;
      e7.mesh = e7.mesh || ((_a = i7.context) == null ? void 0 : _a.mesh), e7.storage = e7.storage || ((_b = i7.context) == null ? void 0 : _b.storage);
    } else
      e6.attributes[r4] = i7;
  }
  return e6;
}
function V2(e6) {
  var _a, _b, _c;
  return [((_a = e6.filter) == null ? void 0 : _a.toJSON()) ?? null, ((_c = (_b = e6.featureEffect) == null ? void 0 : _b.filter) == null ? void 0 : _c.toJSON()) ?? null];
}
function O(e6, t3, r4) {
  return e6.feature || (e6.feature = { name: "feature", input: "source", filters: t3, attributes: {} }), I2(e6.feature, r4.attributes.fields), e6;
}
function z2(e6, r4) {
  const { onStatisticExpression: i7, onStatisticField: n8, statisticType: s7 } = e6;
  switch (s7) {
    case "min":
    case "max":
    case "avg":
    case "avg_angle":
    case "sum":
    case "count":
      return "esriFieldTypeDouble";
    case "mode": {
      if (i7) {
        const { returnType: r5 } = i7;
        return r5 ? "string" === r5 ? "esriFieldTypeString" : "esriFieldTypeDouble" : (x2.error(new s2(h3, "Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined", e6)), "esriFieldTypeString");
      }
      const s8 = r4.find((e7) => e7.name === n8);
      return s8 ? s8.type : (x2.error(new s2(h3, "Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined", e6)), "esriFieldTypeString");
    }
  }
}
function N(e6, t3, r4, i7) {
  return e6.aggregate || (e6.aggregate = { name: "aggregate", type: "bin", filters: null, input: "feature", params: { fixedBinLevel: t3.fixedBinLevel, fields: (t3.fields ?? []).map((e7) => ({ ...e7.toJSON(), type: z2(e7, r4) })) }, attributes: {} }), I2(e6.aggregate, i7.attributes.fields), e6;
}
function L3(e6, t3, r4, n8) {
  const s7 = n8.aggregateFields ?? [], l4 = /* @__PURE__ */ new Set();
  for (const i7 of s7)
    l4.add(i7.name);
  for (const i7 of (t3 == null ? void 0 : t3.fields) ?? [])
    l4.has(i7.name) || s7.push(i7);
  return e6.aggregate || (e6.aggregate = { name: "aggregate", type: "cluster", input: "feature", filters: null, attributes: {}, params: { clusterRadius: u2(t3.clusterRadius / 2), clusterPixelBuffer: 64 * Math.ceil(u2(t3.clusterMaxSize) / 64), fields: s7.map((e7) => ({ ...e7.toJSON(), type: z2(e7, r4) })) } }), I2(e6.aggregate, n8.attributes.fields), e6;
}
function M(e6, t3) {
  return t3.field ? j2(e6, { ...t3, type: "field", field: t3.field }) : t3.valueExpression ? j2(e6, { ...t3, type: "expression", valueExpression: t3.valueExpression }) : { field: void 0, fieldIndex: void 0 };
}
function j2(e6, t3) {
  switch (t3.type) {
    case "expression": {
      const r4 = v(t3.valueExpression);
      if (!e6.fields[r4]) {
        const i7 = e6.indexCount++;
        e6.fields[r4] = { ...t3, name: r4, fieldIndex: i7 };
      }
      return { fieldIndex: e6.fields[r4].fieldIndex };
    }
    case "label-expression": {
      const r4 = v(JSON.stringify(t3.label));
      if (!e6.fields[r4]) {
        const i7 = e6.indexCount++;
        e6.fields[r4] = { ...t3, name: r4, fieldIndex: i7 };
      }
      return { fieldIndex: e6.fields[r4].fieldIndex };
    }
    case "field": {
      const r4 = t3.field;
      return "aggregate" === t3.target && e6.fields[r4] || (e6.fields[r4] = { ...t3, name: r4 }), { field: r4 };
    }
    case "statistic":
      return e6.fields[t3.name] = { ...t3 }, { field: t3.name };
  }
}
function R2(e6, t3 = false) {
  const r4 = new Array();
  let i7 = 0;
  return r4.push(A(e6, i7++, t3)), r4;
}
function U3(e6, t3, r4, i7, n8, s7 = false) {
  const l4 = j2(e6, { type: "label-expression", target: r4, context: { mesh: true }, resultType: "string", label: { labelExpression: t3.labelExpression, labelExpressionInfo: t3.labelExpressionInfo ? { expression: t3.labelExpressionInfo.expression } : null, symbol: !!t3.symbol, where: t3.where } }), { fieldIndex: o3 } = l4;
  return { ...i2(t3, n8, s7), fieldIndex: o3, target: r4, index: i7 };
}
function B(e6, r4, i7) {
  var _a;
  const n8 = "featureReduction" in r4 && r4.featureReduction;
  if (!n8)
    return { fields: [], labels: [], matcher: void 0, rendererOverride: void 0 };
  const s7 = "aggregate", o3 = [];
  let a4 = null, u5 = e3(r4.geometryType), d2 = [], p3 = null;
  if (n8)
    switch (n8.type) {
      case "selection":
        return x2.error(new s2(h3, "Mapview does not support `selection` reduction type", n8)), { fields: [], labels: [], matcher: void 0, rendererOverride: void 0 };
      case "cluster":
      case "binning":
        if (o3.push(...n8.fields ?? []), "cluster" === n8.type ? u5 = "esriGeometryPoint" : "binning" === n8.type && (u5 = "esriGeometryPolygon"), n8.renderer && !((_a = n8.renderer.authoringInfo) == null ? void 0 : _a.isAutoGenerated)) {
          if ("cluster" === n8.type) {
            const { renderer: e7 } = f2(n8.renderer, n8, null);
            p3 = e7;
          } else
            p3 = n8.renderer;
          const t3 = T2(n8.renderer, n8);
          a4 = _(e6, s7, n8.renderer, t3, i7), d2 = n8 && n8.labelsVisible && n8.labelingInfo || [];
        } else if ("cluster" === n8.type) {
          if (p3 = c2(o3, r4.renderer, n8, null, true), n8.symbol) {
            const e7 = T2(p3, n8);
            a4 = { type: "simple", symbol: i2(n8.symbol, e7, i7), symbologyType: e7.symbologyType };
          }
          d2 = n8 && n8.labelsVisible && n8.labelingInfo || [];
        }
    }
  k2(e6, o3);
  return { labels: c3(d2, "binning" === n8.type ? "esriGeometryPolygon" : u5), matcher: a4, fields: o3, rendererOverride: p3 };
}
function A(e6, r4, i7 = false) {
  var _a;
  const n8 = { indexCount: 0, fields: {} }, s7 = "featureReduction" in e6 ? e6.featureReduction ?? void 0 : void 0, a4 = s7 ? "aggregate" : "feature";
  if ("sublayers" in e6) {
    const r5 = { type: "subtype", subtypeField: e6.subtypeField, renderers: {}, symbologyType: S2.DEFAULT }, s8 = { type: "subtype", mapping: {}, target: "feature", subtypeField: e6.subtypeField }, l4 = { type: "subtype", classes: {} }, u6 = { type: "symbol", target: "feature", aggregateFields: [], attributes: n8, storage: s8, mesh: { matcher: r5, aggregateMatcher: null, labels: l4, sortKey: null } }, f6 = /* @__PURE__ */ new Set();
    let p4 = 0;
    for (const { renderer: c7, subtypeCode: y3, labelingInfo: m5, labelsVisible: g5 } of e6.sublayers) {
      let e7 = 0;
      "visualVariables" in c7 && c7.visualVariables && (c7.visualVariables.some((e8) => "rotation" !== e8.type) && x2.warnOnce("SubtypeGroupLayer currently only supports rotation visualVariables. All other visualVariable types will be ignored."), e7 = e4(c7.visualVariables.filter((e8) => "size" !== e8.type)));
      const u7 = { symbologyType: S2.DEFAULT, vvFlags: e7, maxVVSize: 0 }, b3 = _(n8, a4, c7, u7, i7), v3 = C2(n8, a4, c7), T3 = g5 && m5;
      if ("dictionary" === b3.type)
        throw new s2(h3, "Dictionary renderer is not supported in subtype layers");
      if ("subtype" === b3.type)
        throw new s2(h3, "Nested subtype renderers is not supported");
      if (null != v3 && "subtype" === v3.type)
        throw new s2(h3, "Nested subtype storage is not supported");
      if (null != (v3 == null ? void 0 : v3.attributeMapping))
        throw new s2(h3, "Non-visual-variable attributes are not supported in subtype layers");
      if ("heatmap" === b3.type)
        throw new s2(h3, "Heatmaps are not supported in subtype layers");
      if ("pie-chart" === b3.type)
        throw new s2(h3, "Pie-charts are not supported in subtype layers");
      if (f6.has(y3))
        throw new s2(h3, "Subtype codes for sublayers must be unique");
      f6.add(y3), r5.renderers[y3] = b3, s8.mapping[y3] = v3, T3 && (l4.classes[y3] = T3.map((e8) => U3(n8, e8, "feature", p4++, u7, i7)));
    }
    return u6;
  }
  if ("heatmap" === ((_a = e6.renderer) == null ? void 0 : _a.type) && "raster" === g()) {
    const { radius: t3, fieldOffset: r5, field: i8 } = e6.renderer;
    return { type: "heatmap", aggregateFields: [], attributes: n8, target: a4, storage: null, mesh: { radius: t3, fieldOffset: r5, field: M(n8, { target: a4, field: i8, resultType: "numeric" }).field } };
  }
  const u5 = B(n8, e6, i7), f5 = e3(e6.geometryType), p3 = u5.rendererOverride ?? e6.renderer, y2 = T2(p3, s7), m4 = _(n8, a4, p3, y2, i7), g4 = C2(n8, a4, p3), v2 = P2(n8, e6.orderBy, e6.renderer, s7), S6 = e6.labelsVisible && e6.labelingInfo || [], w3 = c3(S6, f5);
  let E5 = 0;
  const F3 = [...w3.map((e7) => U3(n8, e7, "feature", E5++, y2, i7)), ...u5.labels.map((e7) => U3(n8, e7, "aggregate", E5++, y2, i7))];
  return { type: "symbol", target: a4, attributes: n8, aggregateFields: u5.fields, storage: g4, mesh: { matcher: m4, labels: { type: "simple", classes: F3 }, aggregateMatcher: u5.matcher, sortKey: v2 } };
}
function D2(e6) {
  var _a;
  return "heatmap" === ((_a = e6.renderer) == null ? void 0 : _a.type) && "raster" === g() ? { type: "heatmap" } : { type: "symbol" };
}
function P2(e6, r4, i7, n8) {
  if (null != n8)
    return null;
  if (null != r4 && r4.length) {
    r4.length > 1 && x2.warn(`Layer rendering currently only supports ordering by 1 orderByInfo, but found ${r4.length}. All but the first will be discarded`);
    const i8 = r4[0], n9 = "ascending" === i8.order ? "asc" : "desc";
    if (i8.field)
      return { field: i8.field, order: n9 };
    if (i8.valueExpression) {
      return { fieldIndex: j2(e6, { type: "expression", target: "feature", valueExpression: i8.valueExpression, resultType: "numeric" }).fieldIndex, order: n9 };
    }
    return x2.error(new s2(h3, "Expected to find a field or valueExpression for OrderByInfo", i8)), null;
  }
  if (null != i7 && "unique-value" === i7.type && i7.orderByClassesEnabled) {
    return { byRenderer: true, order: "asc" };
  }
  return null;
}
function k2(e6, t3) {
  const r4 = { mesh: true, storage: true };
  for (const i7 of t3) {
    const { name: t4, onStatisticField: n8, onStatisticExpression: s7, statisticType: l4 } = i7;
    let o3, a4;
    const u5 = "numeric", d2 = "feature";
    if (s7) {
      a4 = j2(e6, { type: "expression", target: d2, valueExpression: s7.expression, resultType: u5 }).fieldIndex;
    } else {
      o3 = j2(e6, { type: "field", target: d2, field: n8 }).field;
    }
    j2(e6, { type: "statistic", target: "aggregate", name: t4, context: r4, inField: o3, inFieldIndex: a4, statisticType: l4 });
  }
}
function C2(e6, t3, r4) {
  let i7;
  switch (r4.type) {
    case "simple":
    case "class-breaks":
    case "unique-value":
    case "dictionary":
      i7 = { visualVariables: true, attributes: null };
      break;
    default:
      i7 = c4(r4).getStorageSpec(r4);
  }
  return J2(e6, t3, i7, r4);
}
function J2(e6, t3, r4, i7) {
  if (null == r4)
    return null;
  const { visualVariables: n8, attributes: s7 } = r4;
  let l4 = null;
  n8 && "visualVariables" in i7 && (l4 = q(e6, t3, i7.visualVariables));
  const o3 = null != l4 ? 4 : 0;
  let a4 = null;
  return null != s7 && (a4 = s7.map((r5, i8) => {
    const { field: n9, fieldIndex: s8 } = M(e6, { valueExpression: r5.valueExpression, field: r5.field, resultType: "numeric", target: t3 });
    return { binding: i8 + o3, field: n9, fieldIndex: s8 };
  })), { type: "simple", target: t3, attributeMapping: a4, vvMapping: l4 };
}
function q(t3, r4, i7) {
  if (!(i7 == null ? void 0 : i7.length))
    return [];
  const n8 = { storage: true }, s7 = "numeric";
  return i3(i7).map((e6) => {
    const i8 = V(e6.type), { field: l4, fieldIndex: o3 } = M(t3, { target: r4, valueExpression: e6.valueExpression, field: e6.field, context: n8, resultType: s7 });
    switch (e6.type) {
      case "size":
        return "$view.scale" === e6.valueExpression ? null : { type: "size", binding: i8, field: l4, fieldIndex: o3, normalizationField: M(t3, { target: r4, field: e6.normalizationField, context: n8, resultType: s7 }).field, valueRepresentation: e6.valueRepresentation ?? null };
      case "color":
        return { type: "color", binding: i8, field: l4, fieldIndex: o3, normalizationField: M(t3, { target: r4, field: e6.normalizationField, context: n8, resultType: s7 }).field };
      case "opacity":
        return { type: "opacity", binding: i8, field: l4, fieldIndex: o3, normalizationField: M(t3, { target: r4, field: e6.normalizationField, context: n8, resultType: s7 }).field };
      case "rotation":
        return { type: "rotation", binding: i8, field: l4, fieldIndex: o3 };
    }
  }).filter(k);
}
function _(e6, t3, r4, i7, n8 = false) {
  const s7 = e6 ?? { indexCount: 0, fields: {} };
  switch (r4.type) {
    case "simple":
    case "dot-density":
      return G3(s7, r4, i7, n8);
    case "class-breaks":
      return $(s7, t3, r4, i7, n8);
    case "unique-value":
      return K3(s7, t3, r4, i7, n8);
    case "dictionary":
      return Y(s7, r4, i7, n8);
    case "heatmap":
      return Q2(s7, r4, i7, n8);
    case "pie-chart":
      return H2(s7, r4, i7, n8);
  }
}
function G3(e6, t3, r4, i7 = false) {
  const n8 = t3.getSymbols(), s7 = n8.length ? n8[0] : null;
  return { type: "simple", symbol: i2(s7, r4, i7), symbologyType: r4.symbologyType };
}
function H2(e6, t3, r4, i7 = false) {
  const n8 = t3.getSymbols(), s7 = n8[0], l4 = n8.length > 1 ? n8[1] : null;
  return { type: "pie-chart", markerSymbol: i2(s7, r4, i7), fillSymbol: i2(l4, r4, i7), symbologyType: r4.symbologyType };
}
function $(e6, t3, r4, i7, n8 = false) {
  const s7 = { mesh: true, use: "renderer.field" }, l4 = r4.backgroundFillSymbol, { field: o3, fieldIndex: a4 } = M(e6, { target: t3, field: r4.field, valueExpression: r4.valueExpression, resultType: "numeric", context: s7 }), u5 = r4.normalizationType, d2 = "log" === u5 ? "esriNormalizeByLog" : "percent-of-total" === u5 ? "esriNormalizeByPercentOfTotal" : "field" === u5 ? "esriNormalizeByField" : null, p3 = r4.classBreakInfos.map((e7) => ({ symbol: i2(e7.symbol, i7, n8), min: e7.minValue, max: e7.maxValue })).sort((e7, t4) => e7.min - t4.min);
  return { type: "interval", attributes: e6.fields, field: o3, fieldIndex: a4, backgroundFillSymbol: i2(l4, i7, n8), defaultSymbol: i2(r4.defaultSymbol, i7, n8), intervals: p3, normalizationField: r4.normalizationField, normalizationTotal: r4.normalizationTotal, normalizationType: d2, isMaxInclusive: r4.isMaxInclusive, symbologyType: i7.symbologyType };
}
function K3(e6, r4, i7, n8, s7 = false) {
  const l4 = [], o3 = i7.backgroundFillSymbol, a4 = { target: r4, context: { mesh: true }, resultType: "string" };
  if (i7.field && "string" != typeof i7.field)
    throw new s2(h3, "Expected renderer.field to be a string", i7);
  const { field: u5, fieldIndex: d2 } = M(e6, { ...a4, field: i7.field, valueExpression: i7.valueExpression });
  for (const t3 of i7.uniqueValueInfos ?? [])
    l4.push({ value: "" + t3.value, symbol: i2(t3.symbol, n8, s7) });
  return { type: "map", attributes: e6.fields, field: u5, fieldIndex: d2, field2: M(e6, { ...a4, field: i7.field2 }).field, field3: M(e6, { ...a4, field: i7.field3 }).field, fieldDelimiter: i7.fieldDelimiter ?? void 0, backgroundFillSymbol: i2(o3, n8), defaultSymbol: i2(i7.defaultSymbol, n8), map: l4, symbologyType: n8.symbologyType };
}
function Y(e6, t3, r4, i7 = false) {
  return { type: "dictionary", config: t3.config, fieldMap: t3.fieldMap, scaleExpression: t3.scaleExpression, url: t3.url, symbolOptions: r4, symbologyType: r4.symbologyType };
}
function Q2(e6, t3, r4, i7 = false) {
  const n8 = t3.getSymbols(), s7 = n8.length ? n8[0] : null;
  return { type: "heatmap", symbol: i2(s7, r4, i7), symbologyType: r4.symbologyType };
}

// node_modules/@arcgis/core/views/2d/engine/webgl/AttributeStoreView.js
var E4 = s.getLogger("esri.views.2d.engine.webgl.AttributeStoreView");
var S5 = n3(l, E4);
var A2 = class {
  constructor(t3, e6, i7) {
    this._texture = null, this._lastTexture = null, this._fbos = {}, this.texelSize = 4;
    const { buffer: s7, pixelType: r4, textureOnly: a4 } = t3, n8 = W(r4);
    this.shared = i7, this.pixelType = r4, this.size = e6, this.textureOnly = a4, a4 || (this.data = new n8(s7)), this._resetRange();
  }
  destroy() {
    var _a;
    (_a = this._texture) == null ? void 0 : _a.dispose();
    for (const t3 in this._fbos) {
      const e6 = this._fbos[t3];
      e6 && ("0" === t3 && e6.detachColorTexture(), e6.dispose()), this._fbos[t3] = null;
    }
    this._texture = null;
  }
  get _textureDesc() {
    const t3 = new e2();
    return t3.wrapMode = D.CLAMP_TO_EDGE, t3.samplingMode = L.NEAREST, t3.dataType = this.pixelType, t3.width = this.size, t3.height = this.size, t3;
  }
  setData(t3, e6, i7) {
    const s7 = f(t3), r4 = this.data, a4 = s7 * this.texelSize + e6;
    !r4 || a4 >= r4.length || (r4[a4] = i7, this.dirtyStart = Math.min(this.dirtyStart, s7), this.dirtyEnd = Math.max(this.dirtyEnd, s7));
  }
  getData(t3, e6) {
    if (null == this.data)
      return null;
    const i7 = f(t3) * this.texelSize + e6;
    return !this.data || i7 >= this.data.length ? null : this.data[i7];
  }
  getTexture(t3) {
    return this._texture ?? this._initTexture(t3);
  }
  getFBO(t3, e6 = 0) {
    if (!this._fbos[e6]) {
      const i7 = 0 === e6 ? this.getTexture(t3) : this._textureDesc;
      this._fbos[e6] = new E2(t3, i7);
    }
    return this._fbos[e6];
  }
  get locked() {
    return !(this.pixelType !== U.UNSIGNED_BYTE || !this.shared || this.textureOnly || !has("esri-atomics") || !this.data) && 1 === Atomics.load(this.data, 0);
  }
  get hasDirty() {
    const t3 = this.dirtyStart;
    return this.dirtyEnd >= t3;
  }
  updateTexture(e6, i7) {
    if (!this.locked) {
      try {
        const i8 = this.dirtyStart, s7 = this.dirtyEnd;
        if (!this.hasDirty)
          return;
        this._resetRange();
        const r4 = this.data.buffer, a4 = this.getTexture(e6), n8 = 4, d2 = (i8 - i8 % this.size) / this.size, h5 = (s7 - s7 % this.size) / this.size, u5 = d2, o3 = this.size, l4 = h5, p3 = d2 * this.size * n8, x3 = (o3 + l4 * this.size) * n8 - p3, _2 = W(this.pixelType), c7 = new _2(r4, p3 * _2.BYTES_PER_ELEMENT, x3), f5 = this.size, T3 = l4 - u5 + 1;
        if (T3 > this.size)
          return void E4.error(new s2("mapview-webgl", "Out-of-bounds index when updating AttributeData"));
        a4.updateData(0, 0, u5, f5, T3, c7);
      } catch (s7) {
      }
      i7();
    }
  }
  update(t3) {
    const { data: e6, start: i7, end: s7 } = t3;
    if (null != e6 && null != this.data) {
      const s8 = this.data, r4 = i7 * this.texelSize;
      for (let i8 = 0; i8 < e6.length; i8++) {
        const a4 = 1 << i8 % this.texelSize;
        t3.layout & a4 && (s8[r4 + i8] = e6[i8]);
      }
    }
    this.dirtyStart = Math.min(this.dirtyStart, i7), this.dirtyEnd = Math.max(this.dirtyEnd, s7);
  }
  resize(t3, e6) {
    const i7 = this.size;
    if (this.size = e6, this.textureOnly)
      return void (i7 !== this.size && (this._lastTexture = this._texture, this._texture = null));
    const s7 = W(this.pixelType);
    this.destroy(), this.data = new s7(t3.buffer);
  }
  _resetRange() {
    this.dirtyStart = 2147483647, this.dirtyEnd = 0;
  }
  _initTexture(t3) {
    const e6 = new T(t3, this._textureDesc, this.data ?? void 0);
    if (null != this._lastTexture && this._fbos[0]) {
      const i7 = this._lastTexture.descriptor.width, s7 = this._lastTexture.descriptor.height, r4 = this._lastTexture.descriptor.dataType, a4 = this._lastTexture.descriptor.pixelFormat, n8 = this.getFBO(t3), d2 = K2(r4), h5 = new (W(r4))(new ArrayBuffer(i7 * s7 * d2 * this.texelSize)), u5 = t3.getBoundFramebufferObject(), { x: o3, y: l4, width: p3, height: x3 } = t3.getViewport();
      t3.bindFramebuffer(n8), n8.readPixels(0, 0, i7, s7, a4, r4, h5), e6.updateData(0, 0, 0, 2 * i7, s7 / 2, h5), t3.setViewport(o3, l4, p3, x3), t3.bindFramebuffer(u5);
    }
    return this.destroy(), this._texture = e6, this._texture;
  }
};
var j3 = class {
  constructor(t3) {
    this._onUpdate = t3, this._initialized = false, this._forceNextUpload = false, this._locked = false;
  }
  initialize(t3) {
    const { blocks: e6, shared: i7, size: s7 } = t3;
    if (this.shared = i7, this.size = s7, S5("Initializing AttributeStoreView", t3), null == this._data)
      this._data = e6.map((t4) => null != t4 ? new A2(t4, s7, i7) : null);
    else
      for (let r4 = 0; r4 < this._data.length; r4++) {
        const t4 = this._data[r4], a4 = e6[r4];
        null != a4 && (null == t4 ? this._data[r4] = new A2(a4, s7, i7) : t4.resize(a4, s7));
      }
    this._initialized = true;
  }
  destroy() {
    var _a;
    for (const t3 of this._data ?? [])
      t3 == null ? void 0 : t3.destroy();
    (_a = this._defaultTexture) == null ? void 0 : _a.dispose();
  }
  isEmpty() {
    return null == this._data;
  }
  isUpdating() {
    const t3 = null != this._pendingAttributeUpdate, e6 = t3;
    return has("esri-2d-log-updating") && console.log(`Updating AttributeStoreView ${e6}
  -> hasPendingUpdate ${t3}`), e6;
  }
  getBlock(t3) {
    if (null == this._data)
      return null;
    return this._data[t3];
  }
  setLabelMinZoom(t3, e6) {
    this.setData(t3, 0, 1, e6);
  }
  getLabelMinZoom(t3) {
    return this.getData(t3, 0, 1, 255);
  }
  getFilterFlags(t3) {
    return this.getData(t3, 0, 0, 0);
  }
  getVVSize(t3) {
    return this.getData(t3, S, 0, 0);
  }
  getData(t3, e6, i7, s7) {
    if (!this._data)
      return 0;
    const r4 = this._data[e6];
    if (null == r4)
      return 0;
    const a4 = r4.getData(t3, i7);
    return null != a4 ? a4 : s7;
  }
  setData(t3, e6, i7, s7) {
    this._data[e6].setData(t3, i7, s7);
  }
  lockTextureUpload() {
    this._locked = true;
  }
  unlockTextureUpload() {
    this._locked = false;
  }
  forceTextureUpload() {
    this._forceNextUpload = true;
  }
  async requestUpdate(e6) {
    if (this._pendingAttributeUpdate)
      return void E4.error(new s2("mapview-webgl", "Tried to update attribute data with a pending update"));
    const s7 = C();
    return S5("AttributeStoreView Update Requested", e6), this._pendingAttributeUpdate = { data: e6, resolver: s7 }, this._onUpdate(), s7.promise;
  }
  update() {
    if (this._initialized && null != this._pendingAttributeUpdate) {
      has("esri-2d-update-debug") && console.debug("AttributeStoreView::update");
      const { data: t3, resolver: e6 } = this._pendingAttributeUpdate, i7 = this._data;
      for (let s7 = 0; s7 < t3.blocks.length; s7++) {
        const e7 = t3.blocks[s7], r4 = i7[s7];
        null != r4 && null != e7 && (S5(`Updating block ${s7}`, e7), r4.update(e7));
      }
      this._pendingAttributeUpdate = null, e6(), this._onUpdate();
    }
  }
  bindTextures(t3, e6 = true) {
    var _a, _b, _c, _d, _e, _f, _g;
    const i7 = this._getDefaultTexture(t3);
    if (!this._initialized)
      return t3.bindTexture(i7, E), void (e6 && (t3.bindTexture(i7, F), t3.bindTexture(i7, G2), t3.bindTexture(i7, H), t3.bindTexture(i7, I), t3.bindTexture(i7, J), t3.bindTexture(i7, K)));
    const c7 = this._data;
    if (!this._locked || this._forceNextUpload) {
      for (const e7 of c7)
        e7 == null ? void 0 : e7.updateTexture(t3, () => this._onUpdate());
      this._forceNextUpload = false;
    }
    t3.bindTexture(((_a = c7[P]) == null ? void 0 : _a.getTexture(t3)) ?? i7, E), e6 && (t3.bindTexture(((_b = c7[R]) == null ? void 0 : _b.getTexture(t3)) ?? i7, K), t3.bindTexture(((_c = c7[Q]) == null ? void 0 : _c.getTexture(t3)) ?? i7, F), t3.bindTexture(((_d = c7[S]) == null ? void 0 : _d.getTexture(t3)) ?? i7, G2), t3.bindTexture(((_e = c7[U2]) == null ? void 0 : _e.getTexture(t3)) ?? i7, H), t3.bindTexture(((_f = c7[I]) == null ? void 0 : _f.getTexture(t3)) ?? i7, I), t3.bindTexture(((_g = c7[J]) == null ? void 0 : _g.getTexture(t3)) ?? i7, J));
  }
  _getDefaultTexture(t3) {
    if (null == this._defaultTexture) {
      const e6 = new e2();
      e6.wrapMode = D.CLAMP_TO_EDGE, e6.samplingMode = L.NEAREST, e6.width = 1, e6.height = 1, this._defaultTexture = new T(t3, e6, new Uint8Array(4));
    }
    return this._defaultTexture;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/FreeList.js
var t2 = class _t {
  constructor(a4) {
    if (this.next = null, !Array.isArray(a4))
      return void (this.data = a4);
    this.data = a4[0];
    let e6 = this;
    for (let n8 = 1; n8 < a4.length; n8++)
      e6.next = new _t([a4[n8]]), e6 = e6.next;
  }
  *values() {
    let t3 = this;
    for (; t3; )
      yield t3.data, t3 = t3.next;
  }
  forEach(t3) {
    let a4 = this;
    for (; a4; )
      t3(a4.data), a4 = a4.next;
  }
  find(t3) {
    var _a;
    return t3(this.data) ? this : (_a = this.next) == null ? void 0 : _a.find(t3);
  }
  max(t3, a4 = this) {
    const e6 = t3(this.data) > t3(a4.data) ? this : a4;
    return this.next ? this.next.max(t3, e6) : e6;
  }
  remove(t3, a4 = null) {
    var _a;
    return this === t3 ? a4 ? (a4.next = this.next, a4) : this.next : ((_a = this.next) == null ? void 0 : _a.remove(t3, this)) ?? null;
  }
  get last() {
    return this.next ? this.next.last : this;
  }
};
var a3 = class {
  constructor(a4) {
    this._head = null, null != a4 && (this._head = new t2(a4));
  }
  get head() {
    return this._head;
  }
  maxAvailableSpace() {
    if (null == this._head)
      return 0;
    const t3 = this._head.max((t4) => t4.end - t4.start);
    return t3.data.end - t3.data.start;
  }
  firstFit(t3) {
    if (null == this._head)
      return null;
    let a4 = null, e6 = this._head;
    for (; e6; ) {
      const n8 = e6.data.end - e6.data.start;
      if (n8 === t3)
        return a4 ? a4.next = e6.next : this._head = e6.next, e6.data.start;
      if (n8 > t3) {
        const a5 = e6.data.start;
        return e6.data.start += t3, a5;
      }
      a4 = e6, e6 = e6.next;
    }
    return null;
  }
  free(a4, e6) {
    const n8 = a4 + e6;
    if (null == this._head) {
      const e7 = new t2({ start: a4, end: n8 });
      return void (this._head = e7);
    }
    if (n8 <= this._head.data.start) {
      if (n8 === this._head.data.start)
        return void (this._head.data.start -= e6);
      const r5 = new t2({ start: a4, end: n8 });
      return r5.next = this._head, void (this._head = r5);
    }
    let r4 = this._head, s7 = r4.next;
    for (; s7; ) {
      if (s7.data.start >= n8) {
        if (r4.data.end === a4) {
          if (r4.data.end += e6, r4.data.end === s7.data.start) {
            const t3 = s7.data.end - s7.data.start;
            return r4.data.end += t3, void (r4.next = s7.next);
          }
          return;
        }
        if (s7.data.start === n8)
          return void (s7.data.start -= e6);
        const d3 = new t2({ start: a4, end: n8 });
        return d3.next = r4.next, void (r4.next = d3);
      }
      r4 = s7, s7 = s7.next;
    }
    if (a4 === r4.data.end)
      return void (r4.data.end += e6);
    const d2 = new t2({ start: a4, end: n8 });
    r4.next = d2;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLTile.js
var h4 = class {
  acquire(s7) {
    return { refCount: 1, version: -1, labelMat2d: n2(), tileMat3: e(), dvs: e() };
  }
  release(s7) {
  }
};
var m3 = class _m extends r {
  constructor(s7, t3, r4, e6) {
    super(s7, t3, r4, e6, c, c);
  }
  destroy() {
    super.destroy(), this._transforms && _m.TransformCache.release(this.key.hash);
  }
  setTransform(i7) {
    const o3 = this.resolution / i7.resolution, n8 = this.transforms.tileMat3, [h5, m4] = i7.toScreenNoRotation([0, 0], [this.x, this.y]), c7 = this.width / this.rangeX * o3, f5 = this.height / this.rangeY * o3;
    s3(n8, c7, 0, 0, 0, f5, 0, h5, m4, 1), i(this.transforms.dvs, i7.displayViewMat3, n8);
    const d2 = this.transforms.labelMat2d, l4 = window.devicePixelRatio, u5 = s4(n2(), c7 * l4, 0, 0, f5 * l4, h5 * l4, m4 * l4);
    o2(d2, i7.viewMat2d, u5);
  }
  _createTransforms() {
    return _m.TransformCache.acquire(this.key.hash);
  }
};
m3.TransformCache = new h4();

// node_modules/@arcgis/core/views/2d/engine/webgl/FeatureDisplayList.js
var e5 = class {
  constructor(t3, e6, n8, i7, a4) {
    this.target = t3, this.geometryType = e6, this.materialKey = n8, this.indexFrom = i7, this.indexCount = a4;
  }
  get indexEnd() {
    return this.indexFrom + this.indexCount;
  }
  extend(t3) {
    this.indexCount += t3;
  }
};
var n7 = class _n {
  constructor(t3, e6) {
    this.geometryType = 0, this._target = t3, this.geometryType = e6;
  }
  static from(t3, e6, i7, a4) {
    const d2 = new _n(t3, e6);
    if (null != a4)
      for (const n8 of a4)
        i7.seekIndex(n8), d2.addRecord(i7);
    else
      for (; i7.next(); )
        d2.addRecord(i7);
    return d2;
  }
  addRecord(n8) {
    const i7 = this._target, a4 = this.geometryType, d2 = n8.materialKey;
    let s7 = n8.indexFrom, r4 = n8.indexCount;
    const o3 = n8.vertexFrom, l4 = n8.vertexCount;
    if (r4 || (s7 = o3, r4 = l4), null == this._head) {
      const n9 = new e5(i7, a4, d2, s7, r4);
      return void (this._head = new t2(n9));
    }
    let h5 = null, x3 = this._head;
    for (; x3; ) {
      if (s7 < x3.data.indexFrom)
        return this._insert(d2, s7, r4, h5, x3);
      h5 = x3, x3 = x3.next;
    }
    this._insert(d2, s7, r4, h5, null);
  }
  forEach(t3) {
    null != this._head && this._head.forEach(t3);
  }
  *infos() {
    if (null != this._head)
      for (const t3 of this._head.values())
        yield t3;
  }
  _insert(n8, i7, a4, d2, s7) {
    if (null == d2 && null == s7) {
      const d3 = new e5(this._target, this.geometryType, n8, i7, a4);
      this._head = new t2(d3);
    }
    return null == d2 && null != s7 ? this._insertAtHead(n8, i7, a4, s7) : null != d2 && null == s7 ? this._insertAtEnd(n8, i7, a4, d2) : null != d2 && null != s7 ? this._insertAtMiddle(n8, i7, a4, d2, s7) : void 0;
  }
  _insertAtHead(n8, i7, a4, d2) {
    const s7 = i7 + a4;
    if (n8 === d2.data.materialKey && s7 === d2.data.indexFrom)
      d2.data.indexFrom = i7, d2.data.indexCount += a4;
    else {
      const s8 = new e5(this._target, this.geometryType, n8, i7, a4);
      this._head = new t2(s8), this._head.next = d2;
    }
  }
  _insertAtEnd(n8, i7, a4, d2) {
    if (d2.data.materialKey === n8 && d2.data.indexEnd === i7)
      d2.data.indexCount += a4;
    else {
      const s7 = new e5(this._target, this.geometryType, n8, i7, a4), r4 = new t2(s7);
      d2.next = r4;
    }
  }
  _insertAtMiddle(n8, i7, a4, d2, s7) {
    const r4 = i7 + a4;
    if (d2.data.materialKey === n8 && d2.data.indexEnd === i7)
      d2.data.indexCount += a4, d2.data.materialKey === s7.data.materialKey && d2.data.indexEnd === s7.data.indexFrom && (d2.data.indexCount += s7.data.indexCount, d2.next = s7.next);
    else if (n8 === s7.data.materialKey && r4 === s7.data.indexFrom)
      s7.data.indexFrom = i7, s7.data.indexCount += a4;
    else {
      const r5 = new e5(this._target, this.geometryType, n8, i7, a4), o3 = new t2(r5);
      d2.next = o3, o3.next = s7;
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/DisplayRecordReader.js
var s6 = 2147483647;
var r3 = class _r {
  constructor(t3) {
    this._head = t3, this._cursor = t3;
  }
  static from(t3, e6 = 0, s7 = t3.byteLength / i6.BYTES_PER_RECORD - e6) {
    const _2 = new i6(new Int32Array(t3, e6 * i6.BYTES_PER_RECORD, s7 * i6.ELEMENTS_PER_RECORD));
    return new _r(_2);
  }
  size() {
    let t3 = this._cursor, e6 = 0;
    for (; t3; )
      e6 += t3.size(), t3 = t3._link;
    return e6;
  }
  get id() {
    return this._cursor.id;
  }
  set id(t3) {
    this._cursor.id = t3;
  }
  get materialKey() {
    return this._cursor.materialKey;
  }
  set materialKey(t3) {
    this._cursor.materialKey = t3;
  }
  get insertAfter() {
    return this._cursor.insertAfter;
  }
  get indexFrom() {
    return this._cursor.indexFrom;
  }
  set indexFrom(t3) {
    this._cursor.indexFrom = t3;
  }
  get indexCount() {
    return this._cursor.indexCount;
  }
  set indexCount(t3) {
    this._cursor.indexCount = t3;
  }
  get vertexFrom() {
    return this._cursor.vertexFrom;
  }
  set vertexFrom(t3) {
    this._cursor.vertexFrom = t3;
  }
  get vertexCount() {
    return this._cursor.vertexCount;
  }
  set vertexCount(t3) {
    this._cursor.vertexCount = t3;
  }
  get sortKey() {
    return this._cursor.sortKey;
  }
  set sortKey(t3) {
    this._cursor.sortKey = t3;
  }
  get index() {
    return this._cursor._indexStart + this._cursor._index;
  }
  seekIndex(t3) {
    let e6 = t3;
    for (this._cursor = this._head; this._cursor; ) {
      const t4 = this._cursor.size();
      if (e6 < t4)
        return this._cursor._index = e6, true;
      e6 -= t4, this._cursor = this._cursor._link;
    }
    return false;
  }
  forEach(t3) {
    const e6 = this.getCursor();
    for (; e6.next(); )
      t3(e6);
  }
  link(t3) {
    if (!this._head)
      return void (this._head = t3._head);
    let e6 = this._head;
    for (; e6._link; )
      e6 = e6._link;
    e6._link = t3._head, e6._link._indexStart = e6._indexStart + e6.size();
  }
  getCursor() {
    return this.copy();
  }
  getDrawInfo(t3, s7) {
    return new e5(t3, s7, this.materialKey, this.indexFrom, this.indexCount);
  }
  lookup(t3) {
    for (this._cursor = this._head; this._cursor && !this._cursor.lookup(t3); ) {
      if (!this._cursor._link)
        return false;
      this._cursor = this._cursor._link;
    }
    return !!this._cursor;
  }
  copy() {
    var _a;
    const t3 = new _r((_a = this._head) == null ? void 0 : _a.copy());
    if (!t3._head)
      return t3;
    let e6 = t3._head, s7 = t3._head._link;
    for (; s7; )
      e6._link = s7.copy(), e6 = s7, s7 = e6._link;
    return t3;
  }
  next() {
    return !!this._cursor && (!!this._cursor.next() || !!this._cursor._link && (this._cursor = this._cursor._link, this.next()));
  }
  peekId() {
    return this._cursor.peekId() ?? this._cursor._link.peekId();
  }
  delete(t3) {
    let e6 = this._head, s7 = null;
    for (; e6; ) {
      if (e6.delete(t3))
        return e6.isEmpty() && (null != s7 && (s7._link = e6._link), e6 === this._head && (this._head = e6._link), e6 === this._cursor && (this._cursor = e6._link)), true;
      s7 = e6, e6 = e6._link;
    }
    return false;
  }
};
r3.ELEMENTS_PER_RECORD = de, r3.BYTES_PER_RECORD = r3.ELEMENTS_PER_RECORD * Int32Array.BYTES_PER_ELEMENT;
var i6 = class _i {
  constructor(t3) {
    this._link = null, this._index = -1, this._indexStart = 0, this._packedRecordsF32 = null, this._deletedCount = 0, this._offsets = { instance: null }, this._packedRecords = t3;
  }
  static from(t3, e6 = 0, s7 = t3.byteLength / this.BYTES_PER_RECORD - e6) {
    return new _i(new Int32Array(t3, e6 * this.BYTES_PER_RECORD, s7 * this.ELEMENTS_PER_RECORD));
  }
  delete(t3) {
    const e6 = this._index, r4 = this.lookup(t3);
    if (r4)
      for (this.id = s6, ++this._deletedCount; this.next() && this.id === t3; )
        this.id = s6, ++this._deletedCount;
    return this._index = e6, r4;
  }
  isEmpty() {
    return this._deletedCount === this.size();
  }
  link(t3) {
    this._link ? this._link.link(t3) : this._link = t3;
  }
  lookup(t3) {
    if (null == this._offsets.instance) {
      this._offsets.instance = /* @__PURE__ */ new Map();
      const t4 = this.copy();
      t4._index = -1;
      let e7 = 0;
      for (; t4.next(); )
        t4.id !== e7 && (this._offsets.instance.set(t4.id, t4._index), e7 = t4.id);
    }
    if (!this._offsets.instance.has(t3))
      return false;
    const e6 = this._index;
    return this._index = this._offsets.instance.get(t3), this.id !== s6 || (this._index = e6, false);
  }
  get id() {
    return this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD];
  }
  set id(t3) {
    this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD] = t3;
  }
  get materialKey() {
    return this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD + 1];
  }
  set materialKey(t3) {
    this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD + 1] = t3;
  }
  get insertAfter() {
    return this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD + 2];
  }
  get indexFrom() {
    return this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD + 3];
  }
  set indexFrom(t3) {
    this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD + 3] = t3;
  }
  get indexCount() {
    return this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD + 4];
  }
  set indexCount(t3) {
    this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD + 4] = t3;
  }
  get vertexFrom() {
    return this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD + 5];
  }
  set vertexFrom(t3) {
    this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD + 5] = t3;
  }
  get vertexCount() {
    return this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD + 6];
  }
  set vertexCount(t3) {
    this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD + 6] = t3;
  }
  get sortKey() {
    return this._packedRecordsF32 || (this._packedRecordsF32 = new Float32Array(this._packedRecords.buffer)), this._packedRecordsF32[this._index * _i.ELEMENTS_PER_RECORD + 7];
  }
  set sortKey(t3) {
    this._packedRecordsF32 || (this._packedRecordsF32 = new Float32Array(this._packedRecords.buffer)), this._packedRecordsF32[this._index * _i.ELEMENTS_PER_RECORD + 7] = t3;
  }
  get index() {
    return this._index;
  }
  size() {
    return this._packedRecords.length / _i.ELEMENTS_PER_RECORD;
  }
  next() {
    for (; ++this._index < this.size() && this.id === s6; )
      ;
    return this._index < this.size();
  }
  peekId() {
    const t3 = (this._index + 1) * _i.ELEMENTS_PER_RECORD;
    return t3 >= this._packedRecords.length ? 0 : this._packedRecords[t3];
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const t3 = new _i(this._packedRecords);
    return t3._indexStart = this._indexStart, t3._link = this._link, t3._index = this._index, t3._offsets = this._offsets, t3._deletedCount = this._deletedCount, t3;
  }
};
i6.ELEMENTS_PER_RECORD = de, i6.BYTES_PER_RECORD = i6.ELEMENTS_PER_RECORD * Int32Array.BYTES_PER_ELEMENT;

export {
  a3 as a,
  m3 as m,
  n7 as n,
  r3 as r,
  c6 as c,
  f4 as f,
  g2 as g,
  u4 as u,
  p2 as p,
  h2 as h,
  x,
  n5 as n2,
  h as h2,
  T2 as T,
  w2 as w,
  _,
  j3 as j
};
//# sourceMappingURL=chunk-3Y5JS6MU.js.map
