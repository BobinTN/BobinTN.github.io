import {
  j,
  x
} from "./chunk-57KRYRCY.js";
import {
  $,
  H,
  K,
  P,
  U,
  bt,
  dt,
  ht
} from "./chunk-747B2TEO.js";
import {
  t as t2
} from "./chunk-5WG7GACT.js";
import {
  R
} from "./chunk-LOGPPZUD.js";
import {
  f,
  m,
  p,
  s as s4,
  v
} from "./chunk-IPCIO3PX.js";
import {
  D
} from "./chunk-4HKQSEUR.js";
import {
  l2 as l
} from "./chunk-OIIDE5GZ.js";
import {
  Z,
  o,
  r,
  t
} from "./chunk-Y5D433JZ.js";
import {
  A,
  N,
  W,
  d2 as d,
  ee,
  s3
} from "./chunk-HLGIRLYQ.js";
import {
  s as s2
} from "./chunk-EUTNDAIV.js";
import {
  s3 as s
} from "./chunk-WJ3HJKNC.js";

// node_modules/@arcgis/core/layers/graphics/data/queryUtils.js
var R2 = new s2({ esriSRUnit_Meter: "meters", esriSRUnit_Kilometer: "kilometers", esriSRUnit_Foot: "feet", esriSRUnit_StatuteMile: "miles", esriSRUnit_NauticalMile: "nautical-miles", esriSRUnit_USNauticalMile: "us-nautical-miles" });
var g = Object.freeze({});
async function S(e3, t5, i2) {
  const { outFields: r3, orderByFields: n3, groupByFieldsForStatistics: o3, outStatistics: s6 } = e3;
  if (r3)
    for (let a2 = 0; a2 < r3.length; a2++)
      r3[a2] = r3[a2].trim();
  if (n3)
    for (let a2 = 0; a2 < n3.length; a2++)
      n3[a2] = n3[a2].trim();
  if (o3)
    for (let a2 = 0; a2 < o3.length; a2++)
      o3[a2] = o3[a2].trim();
  if (s6)
    for (let a2 = 0; a2 < s6.length; a2++)
      s6[a2].onStatisticField && (s6[a2].onStatisticField = s6[a2].onStatisticField.trim());
  return e3.geometry && !e3.outSR && (e3.outSR = e3.geometry.spatialReference), j2(e3, t5, i2);
}
async function j2(e3, t5, i2) {
  var _a;
  if (!e3)
    return null;
  let { where: o3 } = e3;
  if (e3.where = o3 = o3 == null ? void 0 : o3.trim(), (!o3 || /^1 *= *1$/.test(o3) || t5 && t5 === o3) && (e3.where = null), !e3.geometry)
    return e3;
  let s6 = await d2(e3);
  if (e3.distance = 0, e3.units = null, "esriSpatialRelEnvelopeIntersects" === e3.spatialRel) {
    const { spatialReference: t6 } = e3.geometry;
    s6 = l(s6), s6.spatialReference = t6;
  }
  if (s6) {
    await x(s6.spatialReference, i2), s6 = x2(s6, i2);
    const t6 = (await R(p(s6)))[0];
    if (null == t6)
      throw g;
    const r3 = "quantizationParameters" in e3 && ((_a = e3.quantizationParameters) == null ? void 0 : _a.tolerance) || "maxAllowableOffset" in e3 && e3.maxAllowableOffset || 0, o4 = r3 && w(s6, i2) ? { densificationStep: 8 * r3 } : void 0, a2 = t6.toJSON(), m3 = j(a2, a2.spatialReference, i2, o4);
    if (!m3)
      throw g;
    m3.spatialReference = i2, e3.geometry = m3;
  }
  return e3;
}
function w(e3, t5) {
  if (!e3)
    return false;
  const r3 = e3.spatialReference;
  return (m(e3) || f(e3) || s4(e3)) && !d(r3, t5) && !D(r3, t5);
}
function x2(e3, t5) {
  const i2 = e3.spatialReference;
  return w(e3, t5) && m(e3) ? { spatialReference: i2, rings: [[[e3.xmin, e3.ymin], [e3.xmin, e3.ymax], [e3.xmax, e3.ymax], [e3.xmax, e3.ymin], [e3.xmin, e3.ymin]]] } : e3;
}
async function d2(e3) {
  const { distance: i2, units: r3 } = e3, n3 = e3.geometry;
  if (null == i2 || "vertexAttributes" in n3)
    return n3;
  const o3 = n3.spatialReference, s6 = r3 ? R2.fromJSON(r3) : ee(o3), a2 = o3 && (A(o3) || s3(o3)) ? n3 : await x(o3, N).then(() => j(n3, N));
  return (await U2())(a2.spatialReference, a2, i2, s6);
}
async function U2() {
  return (await import("./geometryEngineJSON-CKCDO7TD.js")).geodesicBuffer;
}

// node_modules/@arcgis/core/geometry/support/intersects.js
function s5(s6) {
  return "mesh" === s6 ? o : Z(s6);
}

// node_modules/@arcgis/core/layers/graphics/contains.js
function n(n3, t5) {
  return n3 ? t5 ? 4 : 3 : t5 ? 3 : 2;
}
function t3(n3, t5, r3, e3) {
  return o2(n3, t5, r3, e3.coords[0], e3.coords[1]);
}
function r2(t5, r3, e3, c2, u3, f5) {
  const s6 = n(u3, f5), { coords: i2, lengths: l3 } = c2;
  if (!l3)
    return false;
  for (let n3 = 0, d3 = 0; n3 < l3.length; n3++, d3 += s6)
    if (!o2(t5, r3, e3, i2[d3], i2[d3 + 1]))
      return false;
  return true;
}
function o2(t5, r3, o3, c2, u3) {
  if (!t5)
    return false;
  const f5 = n(r3, o3), { coords: s6, lengths: i2 } = t5;
  let l3 = false, d3 = 0;
  for (const n3 of i2)
    l3 = e(l3, s6, f5, d3, n3, c2, u3), d3 += n3 * f5;
  return l3;
}
function e(n3, t5, r3, o3, e3, c2, u3) {
  let f5 = n3, s6 = o3;
  for (let i2 = o3, l3 = o3 + e3 * r3; i2 < l3; i2 += r3) {
    s6 = i2 + r3, s6 === l3 && (s6 = o3);
    const n4 = t5[i2], e4 = t5[i2 + 1], d3 = t5[s6], g3 = t5[s6 + 1];
    (e4 < u3 && g3 >= u3 || g3 < u3 && e4 >= u3) && n4 + (u3 - e4) / (g3 - e4) * (d3 - n4) < c2 && (f5 = !f5);
  }
  return f5;
}

// node_modules/@arcgis/core/layers/graphics/data/geometryUtils.js
var u = new t2();
var f3 = new t2();
var m2 = new t2();
var c = { esriGeometryPoint: P, esriGeometryPolyline: $, esriGeometryPolygon: H, esriGeometryMultipoint: U };
function y2(r3, t5, o3, i2 = r3.hasZ, s6 = r3.hasM) {
  if (null == t5)
    return null;
  const l3 = r3.hasZ && i2, u3 = r3.hasM && s6;
  if (o3) {
    const f5 = ht(m2, t5, r3.hasZ, r3.hasM, "esriGeometryPoint", o3, i2, s6);
    return P(f5, l3, u3);
  }
  return P(t5, l3, u3);
}
function a(e3, o3, i2, s6, l3, y3, a2 = o3, h4 = i2) {
  var _a, _b, _c;
  const p4 = o3 && a2, G4 = i2 && h4, g3 = null != s6 ? "coords" in s6 ? s6 : s6.geometry : null;
  if (null == g3)
    return null;
  if (l3) {
    let t5 = dt(f3, g3, o3, i2, e3, l3, a2, h4);
    return y3 && (t5 = ht(m2, t5, p4, G4, e3, y3)), ((_a = c[e3]) == null ? void 0 : _a.call(c, t5, p4, G4)) ?? null;
  }
  if (y3) {
    const r3 = ht(m2, g3, o3, i2, e3, y3, a2, h4);
    return ((_b = c[e3]) == null ? void 0 : _b.call(c, r3, p4, G4)) ?? null;
  }
  return bt(u, g3, o3, i2, a2, h4), ((_c = c[e3]) == null ? void 0 : _c.call(c, u, p4, G4)) ?? null;
}
function h2(n3) {
  return n3 && p3 in n3 ? JSON.parse(JSON.stringify(n3, G2)) : n3;
}
var p3 = "_geVersion";
var G2 = (n3, e3) => n3 !== p3 ? e3 : void 0;

// node_modules/@arcgis/core/layers/graphics/data/spatialQuerySupport.js
var f4 = "unsupported-query";
var R3 = { esriSpatialRelIntersects: "intersects", esriSpatialRelContains: "contains", esriSpatialRelCrosses: "crosses", esriSpatialRelDisjoint: "disjoint", esriSpatialRelEnvelopeIntersects: "intersects", esriSpatialRelIndexIntersects: null, esriSpatialRelOverlaps: "overlaps", esriSpatialRelTouches: "touches", esriSpatialRelWithin: "within", esriSpatialRelRelation: null };
var S2 = { spatialRelationship: { esriSpatialRelIntersects: true, esriSpatialRelContains: true, esriSpatialRelWithin: true, esriSpatialRelCrosses: true, esriSpatialRelDisjoint: true, esriSpatialRelTouches: true, esriSpatialRelOverlaps: true, esriSpatialRelEnvelopeIntersects: true, esriSpatialRelIndexIntersects: false, esriSpatialRelRelation: false }, queryGeometry: { esriGeometryPoint: true, esriGeometryMultipoint: true, esriGeometryPolyline: true, esriGeometryPolygon: true, esriGeometryEnvelope: true }, layerGeometry: { esriGeometryPoint: true, esriGeometryMultipoint: true, esriGeometryPolyline: true, esriGeometryPolygon: true, esriGeometryEnvelope: false } };
function G3(e3) {
  return null != e3 && true === S2.spatialRelationship[e3];
}
function g2(e3) {
  return null != e3 && true === S2.queryGeometry[v(e3)];
}
function j3(e3) {
  return null != e3 && true === S2.layerGeometry[e3];
}
function h3() {
  return import("./geometryEngineJSON-CKCDO7TD.js");
}
function v2(e3, n3, l3, c2, f5) {
  if (f(n3) && "esriGeometryPoint" === l3 && ("esriSpatialRelIntersects" === e3 || "esriSpatialRelContains" === e3)) {
    const e4 = K(new t2(), n3, false, false);
    return Promise.resolve((r3) => t3(e4, false, false, r3));
  }
  if (f(n3) && "esriGeometryMultipoint" === l3) {
    const r3 = K(new t2(), n3, false, false);
    if ("esriSpatialRelContains" === e3)
      return Promise.resolve((e4) => r2(r3, false, false, e4, c2, f5));
  }
  if (m(n3) && "esriGeometryPoint" === l3 && ("esriSpatialRelIntersects" === e3 || "esriSpatialRelContains" === e3))
    return Promise.resolve((e4) => t(n3, a(l3, c2, f5, e4)));
  if (m(n3) && "esriGeometryMultipoint" === l3 && "esriSpatialRelContains" === e3)
    return Promise.resolve((e4) => r(n3, a(l3, c2, f5, e4)));
  if (m(n3) && "esriSpatialRelIntersects" === e3) {
    const e4 = s5(l3);
    return Promise.resolve((r3) => e4(n3, a(l3, c2, f5, r3)));
  }
  return h3().then((r3) => {
    const t5 = r3[R3[e3]].bind(null, n3.spatialReference, n3);
    return (e4) => t5(a(l3, c2, f5, e4));
  });
}
async function P2(r3, t5, i2) {
  var _a;
  const { spatialRel: s6, geometry: o3 } = r3;
  if (o3) {
    if (!G3(s6))
      throw new s(f4, "Unsupported query spatial relationship", { query: r3 });
    if (W(o3.spatialReference) && W(i2)) {
      if (!g2(o3))
        throw new s(f4, "Unsupported query geometry type", { query: r3 });
      if (!j3(t5))
        throw new s(f4, "Unsupported layer geometry type", { query: r3 });
      if (r3.outSR)
        return x((_a = r3.geometry) == null ? void 0 : _a.spatialReference, r3.outSR);
    }
  }
}
function I(e3) {
  if (m(e3))
    return true;
  if (f(e3)) {
    for (const r3 of e3.rings) {
      if (5 !== r3.length)
        return false;
      if (r3[0][0] !== r3[1][0] || r3[0][0] !== r3[4][0] || r3[2][0] !== r3[3][0] || r3[0][1] !== r3[3][1] || r3[0][1] !== r3[4][1] || r3[1][1] !== r3[2][1])
        return false;
    }
    return true;
  }
  return false;
}

// node_modules/@arcgis/core/layers/graphics/data/timeSupport.js
async function n2(n3, t5) {
  if (!n3)
    return null;
  const l3 = t5.featureAdapter, { startTimeField: u3, endTimeField: e3 } = n3;
  let r3 = Number.POSITIVE_INFINITY, i2 = Number.NEGATIVE_INFINITY;
  if (u3 && e3)
    await t5.forEach((n4) => {
      const t6 = l3.getAttribute(n4, u3), o3 = l3.getAttribute(n4, e3);
      null == t6 || isNaN(t6) || (r3 = Math.min(r3, t6)), null == o3 || isNaN(o3) || (i2 = Math.max(i2, o3));
    });
  else {
    const n4 = u3 || e3;
    await t5.forEach((t6) => {
      const u4 = l3.getAttribute(t6, n4);
      null == u4 || isNaN(u4) || (r3 = Math.min(r3, u4), i2 = Math.max(i2, u4));
    });
  }
  return { start: r3, end: i2 };
}
function t4(n3, t5, r3) {
  var _a;
  if (!t5 || !n3)
    return null;
  const { startTimeField: i2, endTimeField: o3 } = n3;
  if (!i2 && !o3)
    return null;
  const { start: s6, end: a2 } = t5;
  if (null === s6 && null === a2)
    return null;
  if (void 0 === s6 && void 0 === a2)
    return e2();
  const c2 = ((_a = r3.getAttributeAsTimestamp) == null ? void 0 : _a.bind(r3)) ?? r3.getAttribute.bind(r3);
  return i2 && o3 ? l2(c2, i2, o3, s6, a2) : u2(c2, i2 || o3, s6, a2);
}
function l2(n3, t5, l3, u3, e3) {
  return null != u3 && null != e3 ? (r3) => {
    const i2 = n3(r3, t5), o3 = n3(r3, l3);
    return (null == i2 || i2 <= e3) && (null == o3 || o3 >= u3);
  } : null != u3 ? (t6) => {
    const e4 = n3(t6, l3);
    return null == e4 || e4 >= u3;
  } : null != e3 ? (l4) => {
    const u4 = n3(l4, t5);
    return null == u4 || u4 <= e3;
  } : void 0;
}
function u2(n3, t5, l3, u3) {
  return null != l3 && null != u3 && l3 === u3 ? (u4) => n3(u4, t5) === l3 : null != l3 && null != u3 ? (e3) => {
    const r3 = n3(e3, t5);
    return null != r3 && r3 >= l3 && r3 <= u3;
  } : null != l3 ? (u4) => {
    const e3 = n3(u4, t5);
    return null != e3 && e3 >= l3;
  } : null != u3 ? (l4) => {
    const e3 = n3(l4, t5);
    return null != e3 && e3 <= u3;
  } : void 0;
}
function e2() {
  return () => false;
}

export {
  y2 as y,
  a,
  h2 as h,
  g,
  S,
  j2 as j,
  v2 as v,
  P2 as P,
  I,
  n2 as n,
  t4 as t
};
//# sourceMappingURL=chunk-K4NVR6KM.js.map
