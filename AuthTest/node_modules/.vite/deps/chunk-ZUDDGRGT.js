import {
  L,
  e
} from "./chunk-JSBCPI3K.js";
import {
  a
} from "./chunk-6DA3YN7V.js";
import {
  t
} from "./chunk-T2S5L26W.js";
import {
  S
} from "./chunk-2D3PORS4.js";
import {
  V
} from "./chunk-JUZJCTW2.js";

// node_modules/@arcgis/core/portal/support/featureCollectionUtils.js
function e2(e3) {
  return t2(e3, "notes");
}
function r(e3) {
  return t2(e3, "markup");
}
function n(e3) {
  return t2(e3, "route");
}
function t2(e3, r2) {
  return !(!e3.layerType || "ArcGISFeatureLayer" !== e3.layerType) && e3.featureCollectionType === r2;
}

// node_modules/@arcgis/core/layers/support/layersCreator.js
async function c(e3, r2, a2) {
  if (!r2)
    return;
  const t3 = [];
  for (const i of r2)
    t3.push(g(i, a2));
  const y = await Promise.allSettled(t3);
  for (const i of y)
    "rejected" === i.status || i.value && e3.add(i.value);
}
var l = { ArcGISDimensionLayer: "DimensionLayer", ArcGISFeatureLayer: "FeatureLayer", ArcGISImageServiceLayer: "ImageryLayer", ArcGISMapServiceLayer: "MapImageLayer", PointCloudLayer: "PointCloudLayer", ArcGISSceneServiceLayer: "SceneLayer", IntegratedMeshLayer: "IntegratedMeshLayer", OGCFeatureLayer: "OGCFeatureLayer", BuildingSceneLayer: "BuildingSceneLayer", ArcGISTiledElevationServiceLayer: "ElevationLayer", ArcGISTiledImageServiceLayer: "ImageryTileLayer", ArcGISTiledMapServiceLayer: "TileLayer", GroupLayer: "GroupLayer", GeoJSON: "GeoJSONLayer", WebTiledLayer: "WebTileLayer", CSV: "CSVLayer", VectorTileLayer: "VectorTileLayer", WFS: "WFSLayer", WMS: "WMSLayer", DefaultTileLayer: "TileLayer", KML: "KMLLayer", RasterDataLayer: "UnsupportedLayer", Voxel: "VoxelLayer", LineOfSightLayer: "LineOfSightLayer" };
var s = { ArcGISTiledElevationServiceLayer: "ElevationLayer", DefaultTileLayer: "ElevationLayer", RasterDataElevationLayer: "UnsupportedLayer" };
var p = { ArcGISFeatureLayer: "FeatureLayer" };
var S2 = { ArcGISTiledMapServiceLayer: "TileLayer", ArcGISTiledImageServiceLayer: "ImageryTileLayer", OpenStreetMap: "OpenStreetMapLayer", WebTiledLayer: "WebTileLayer", VectorTileLayer: "VectorTileLayer", ArcGISImageServiceLayer: "UnsupportedLayer", WMS: "UnsupportedLayer", ArcGISMapServiceLayer: "UnsupportedLayer", ArcGISSceneServiceLayer: "SceneLayer", DefaultTileLayer: "TileLayer" };
var u = { ArcGISAnnotationLayer: "UnsupportedLayer", ArcGISDimensionLayer: "UnsupportedLayer", ArcGISFeatureLayer: "FeatureLayer", ArcGISImageServiceLayer: "ImageryLayer", ArcGISImageServiceVectorLayer: "ImageryLayer", ArcGISMapServiceLayer: "MapImageLayer", ArcGISStreamLayer: "StreamLayer", ArcGISTiledImageServiceLayer: "ImageryTileLayer", ArcGISTiledMapServiceLayer: "TileLayer", BingMapsAerial: "BingMapsLayer", BingMapsRoad: "BingMapsLayer", BingMapsHybrid: "BingMapsLayer", CSV: "CSVLayer", DefaultTileLayer: "TileLayer", GeoRSS: "GeoRSSLayer", GeoJSON: "GeoJSONLayer", GroupLayer: "GroupLayer", KML: "KMLLayer", MediaLayer: "MediaLayer", OGCFeatureLayer: "OGCFeatureLayer", OrientedImageryLayer: "OrientedImageryLayer", SubtypeGroupLayer: "SubtypeGroupLayer", VectorTileLayer: "VectorTileLayer", WFS: "WFSLayer", WMS: "WMSLayer", WebTiledLayer: "WebTileLayer" };
var d = { ArcGISFeatureLayer: "FeatureLayer" };
var I = { ArcGISImageServiceLayer: "ImageryLayer", ArcGISImageServiceVectorLayer: "ImageryLayer", ArcGISMapServiceLayer: "MapImageLayer", ArcGISTiledImageServiceLayer: "ImageryTileLayer", ArcGISTiledMapServiceLayer: "TileLayer", OpenStreetMap: "OpenStreetMapLayer", VectorTileLayer: "VectorTileLayer", WebTiledLayer: "WebTileLayer", BingMapsAerial: "BingMapsLayer", BingMapsRoad: "BingMapsLayer", BingMapsHybrid: "BingMapsLayer", WMS: "WMSLayer", DefaultTileLayer: "TileLayer" };
var m = { ...u, LinkChartLayer: "LinkChartLayer" };
var f = { ...d };
var T = { ...I };
async function g(e3, r2) {
  return G(await M(e3, r2), e3, r2);
}
async function G(e3, r2, a2) {
  const t3 = new e3();
  return t3.read(r2, a2.context), "group" === t3.type && ("GroupLayer" === r2.layerType ? await w(t3, r2, a2) : v(r2) ? h(t3, r2, a2.context) : A(r2) && await C(t3, r2, a2.context)), await t(t3, a2.context), t3;
}
async function M(e3, n2) {
  var _a, _b;
  const c2 = n2.context, l2 = b(c2);
  let s2 = e3.layerType || e3.type;
  !s2 && (n2 == null ? void 0 : n2.defaultLayerType) && (s2 = n2.defaultLayerType);
  const p2 = l2[s2];
  let S3 = p2 ? a[p2] : a.UnknownLayer;
  if (v(e3)) {
    const y = c2 == null ? void 0 : c2.portal;
    if (e3.itemId) {
      const i = new S({ id: e3.itemId, portal: y });
      await i.load();
      const L2 = (await L(i, new e())).className || "UnknownLayer";
      S3 = a[L2];
    }
  } else
    "ArcGISFeatureLayer" === s2 ? e2(e3) || r(e3) ? S3 = a.MapNotesLayer : n(e3) ? S3 = a.RouteLayer : A(e3) && (S3 = a.GroupLayer) : ((_a = e3.wmtsInfo) == null ? void 0 : _a.url) && e3.wmtsInfo.layerIdentifier ? S3 = a.WMTSLayer : "WFS" === s2 && "2.0.0" !== ((_b = e3.wfsInfo) == null ? void 0 : _b.version) && (S3 = a.UnsupportedLayer);
  return S3();
}
function A(e3) {
  var _a, _b;
  if ("ArcGISFeatureLayer" !== e3.layerType || v(e3))
    return false;
  return (((_b = (_a = e3.featureCollection) == null ? void 0 : _a.layers) == null ? void 0 : _b.length) ?? 0) > 1;
}
function v(e3) {
  return "Feature Collection" === e3.type;
}
function b(e3) {
  let r2;
  switch (e3.origin) {
    case "web-scene":
      switch (e3.layerContainerType) {
        case "basemap":
          r2 = S2;
          break;
        case "ground":
          r2 = s;
          break;
        case "tables":
          r2 = p;
          break;
        default:
          r2 = l;
      }
      break;
    case "link-chart":
      switch (e3.layerContainerType) {
        case "basemap":
          r2 = T;
          break;
        case "tables":
          r2 = f;
          break;
        default:
          r2 = m;
      }
      break;
    default:
      switch (e3.layerContainerType) {
        case "basemap":
          r2 = I;
          break;
        case "tables":
          r2 = d;
          break;
        default:
          r2 = u;
      }
  }
  return r2;
}
async function w(r2, a2, t3) {
  const y = new V(), i = c(y, Array.isArray(a2.layers) ? a2.layers : [], t3);
  try {
    try {
      if (await i, "group" === r2.type)
        return r2.layers.addMany(y), r2;
    } catch (L2) {
      r2.destroy();
      for (const e3 of y)
        e3.destroy();
      throw L2;
    }
  } catch (L2) {
    throw L2;
  }
}
function h(e3, r2, a2) {
  r2.itemId && (e3.portalItem = new S({ id: r2.itemId, portal: a2 == null ? void 0 : a2.portal }), e3.when(() => {
    var _a, _b;
    const t3 = (t4) => {
      var _a2, _b2;
      const y = t4.layerId;
      F(t4, e3, r2, y, a2);
      const i = (_b2 = (_a2 = r2.featureCollection) == null ? void 0 : _a2.layers) == null ? void 0 : _b2[y];
      i && t4.read(i, a2);
    };
    (_a = e3.layers) == null ? void 0 : _a.forEach(t3), (_b = e3.tables) == null ? void 0 : _b.forEach(t3);
  }));
}
async function C(e3, r2, t3) {
  var _a;
  const y = a.FeatureLayer, i = await y(), L2 = r2.featureCollection, o = L2 == null ? void 0 : L2.showLegend, n2 = (_a = L2 == null ? void 0 : L2.layers) == null ? void 0 : _a.map((a2, y2) => {
    const L3 = new i();
    L3.read(a2, t3);
    const n3 = { ...t3, ignoreDefaults: true };
    return F(L3, e3, r2, y2, n3), null != o && L3.read({ showLegend: o }, n3), L3;
  });
  e3.layers.addMany(n2 ?? []);
}
function F(e3, r2, a2, t3, y) {
  var _a;
  e3.read({ id: `${r2.id}-sublayer-${t3}`, visibility: ((_a = a2.visibleLayers) == null ? void 0 : _a.includes(t3)) ?? true }, y);
}

export {
  c,
  w
};
//# sourceMappingURL=chunk-ZUDDGRGT.js.map
