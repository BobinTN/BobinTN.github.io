import {
  M,
  f,
  m,
  u as u3,
  y
} from "./chunk-XI27PUTI.js";
import {
  i
} from "./chunk-SA3C7GIT.js";
import {
  e
} from "./chunk-CSWPLQ7Q.js";
import {
  S2 as S,
  p,
  x
} from "./chunk-4NU7FZD7.js";
import {
  u as u2
} from "./chunk-G557TGXY.js";
import {
  u
} from "./chunk-EIY2DYTV.js";
import {
  l
} from "./chunk-YTH6VA7N.js";
import {
  a
} from "./chunk-6TJWLWLO.js";
import {
  a as a2
} from "./chunk-SJZIFARA.js";
import {
  j
} from "./chunk-R5DM4YAB.js";

// node_modules/@arcgis/core/symbols/support/cimSymbolUtils.js
function l2(e3, t, o, r) {
  if (e3)
    if ("CIMTextSymbol" !== e3.type) {
      if (o && e3.effects)
        for (const o2 of e3.effects)
          y2(o2, t);
      if (e3.symbolLayers)
        for (const o2 of e3.symbolLayers)
          switch (o2.type) {
            case "CIMPictureMarker":
            case "CIMVectorMarker":
              m2(o2, t, r);
              break;
            case "CIMPictureStroke":
            case "CIMSolidStroke":
              !(r == null ? void 0 : r.preserveOutlineWidth) && o2.width && (o2.width *= t);
              break;
            case "CIMPictureFill":
              o2.height && (o2.height *= t), o2.offsetX && (o2.offsetX *= t), o2.offsetY && (o2.offsetY *= t);
              break;
            case "CIMHatchFill":
              l2(o2.lineSymbol, t, true, { ...r, preserveOutlineWidth: false }), o2.offsetX && (o2.offsetX *= t), o2.offsetY && (o2.offsetY *= t), o2.separation && (o2.separation *= t);
          }
    } else
      null != e3.height && (e3.height *= t);
}
function m2(e3, t, o) {
  if (e3 && (e3.markerPlacement && M2(e3.markerPlacement, t), e3.offsetX && (e3.offsetX *= t), e3.offsetY && (e3.offsetY *= t), e3.anchorPoint && "Absolute" === e3.anchorPointUnits && (e3.anchorPoint = { x: e3.anchorPoint.x * t, y: e3.anchorPoint.y * t }), e3.size = null != e3.size ? e3.size * t : 0, "CIMVectorMarker" === e3.type && e3.markerGraphics))
    for (const r of e3.markerGraphics)
      e3.scaleSymbolsProportionally || l2(r.symbol, t, true, o);
}
function M2(e3, t) {
  switch (m(e3) && e3.offset && (e3.offset *= t), e3.type) {
    case "CIMMarkerPlacementAlongLineRandomSize":
    case "CIMMarkerPlacementAlongLineSameSize":
      if (e3.customEndingOffset && (e3.customEndingOffset *= t), e3.offsetAlongLine && (e3.offsetAlongLine *= t), e3.placementTemplate && e3.placementTemplate.length) {
        const o = e3.placementTemplate.map((e4) => e4 * t);
        e3.placementTemplate = o;
      }
      break;
    case "CIMMarkerPlacementAlongLineVariableSize":
      if (e3.maxRandomOffset && (e3.maxRandomOffset *= t), e3.placementTemplate && e3.placementTemplate.length) {
        const o = e3.placementTemplate.map((e4) => e4 * t);
        e3.placementTemplate = o;
      }
      break;
    case "CIMMarkerPlacementOnLine":
      e3.startPointOffset && (e3.startPointOffset *= t);
      break;
    case "CIMMarkerPlacementAtExtremities":
      e3.offsetAlongLine && (e3.offsetAlongLine *= t);
      break;
    case "CIMMarkerPlacementAtMeasuredUnits":
    case "CIMMarkerPlacementOnVertices":
      break;
    case "CIMMarkerPlacementAtRatioPositions":
      e3.beginPosition && (e3.beginPosition *= t), e3.endPosition && (e3.endPosition *= t);
      break;
    case "CIMMarkerPlacementPolygonCenter":
      e3.offsetX && (e3.offsetX *= t), e3.offsetY && (e3.offsetY *= t);
      break;
    case "CIMMarkerPlacementInsidePolygon":
      e3.offsetX && (e3.offsetX *= t), e3.offsetY && (e3.offsetY *= t), e3.stepX && (e3.stepX *= t), e3.stepY && (e3.stepY *= t);
  }
}
function y2(e3, t) {
  switch (e3.type) {
    case "CIMGeometricEffectArrow":
    case "CIMGeometricEffectDonut":
      e3.width && (e3.width *= t);
      break;
    case "CIMGeometricEffectBuffer":
      e3.size && (e3.size *= t);
      break;
    case "CIMGeometricEffectCut":
      e3.beginCut && (e3.beginCut *= t), e3.endCut && (e3.endCut *= t), e3.middleCut && (e3.middleCut *= t);
      break;
    case "CIMGeometricEffectDashes":
      if (e3.customEndingOffset && (e3.customEndingOffset *= t), e3.offsetAlongLine && (e3.offsetAlongLine *= t), e3.dashTemplate && e3.dashTemplate.length) {
        const o = e3.dashTemplate.map((e4) => e4 * t);
        e3.dashTemplate = o;
      }
      break;
    case "CIMGeometricEffectExtension":
    case "CIMGeometricEffectJog":
    case "CIMGeometricEffectRadial":
      e3.length && (e3.length *= t);
      break;
    case "CIMGeometricEffectMove":
      e3.offsetX && (e3.offsetX *= t), e3.offsetY && (e3.offsetY *= t);
      break;
    case "CIMGeometricEffectOffset":
    case "CIMGeometricEffectOffsetTangent":
      e3.offset && (e3.offset *= t);
      break;
    case "CIMGeometricEffectRegularPolygon":
      e3.radius && (e3.radius *= t);
      break;
    case "CIMGeometricEffectTaperedPolygon":
      e3.fromWidth && (e3.fromWidth *= t), e3.length && (e3.length *= t), e3.toWidth && (e3.toWidth *= t);
      break;
    case "CIMGeometricEffectWave":
      e3.amplitude && (e3.amplitude *= t), e3.period && (e3.period *= t);
  }
}
function C2(o) {
  const r = [];
  return u4(f(o), r), r.length ? new u2(u3(r[0])) : null;
}
function u4(e3, t) {
  var _a;
  if (!e3)
    return;
  let n2;
  n2 = "CIMTextSymbol" === e3.type ? e3.symbol : e3;
  const a5 = "CIMPolygonSymbol" === e3.type;
  if (n2 == null ? void 0 : n2.symbolLayers) {
    for (const i2 of n2.symbolLayers)
      if (!(i2.colorLocked || a5 && (M(i2) || y(i2) && i2.markerPlacement && m(i2.markerPlacement))))
        switch (i2.type) {
          case "CIMPictureMarker":
          case "CIMPictureStroke":
          case "CIMPictureFill":
            i2.tintColor && b(t, i2.tintColor);
            break;
          case "CIMVectorMarker":
            (_a = i2.markerGraphics) == null ? void 0 : _a.forEach((e4) => {
              u4(e4.symbol, t);
            });
            break;
          case "CIMSolidStroke":
          case "CIMSolidFill":
            b(t, i2.color);
            break;
          case "CIMHatchFill":
            u4(i2.lineSymbol, t);
        }
  }
}
function b(e3, t) {
  for (const o of e3)
    if (o.join(".") === t.join("."))
      return;
  e3.push(t);
}

// node_modules/@arcgis/core/symbols/support/gfxUtils.js
var n = "picture-fill";
var l3 = "simple-fill";
var c = "simple-line";
var a3 = "simple-marker";
var m3 = "text";
var p2 = "cim";
var u5 = new e(1e3);
function f2(t) {
  const r = t.style;
  let o = null;
  if (t)
    switch (t.type) {
      case a3:
        "cross" !== r && "x" !== r && (o = t.color);
        break;
      case l3:
        "solid" === r ? o = t.color : "none" !== r && (o = { type: "pattern", x: 0, y: 0, src: a2(`esri/symbols/patterns/${r}.png`), width: 5, height: 5 });
        break;
      case n:
        o = { type: "pattern", src: t.url, width: u(t.width) * t.xscale, height: u(t.height) * t.yscale, x: u(t.xoffset), y: u(t.yoffset) };
        break;
      case m3:
        o = t.color;
        break;
      case p2:
        o = C2(t);
    }
  return o;
}
function h(e3, t) {
  const o = e3 + "-" + t;
  return void 0 !== u5.get(o) ? Promise.resolve(u5.get(o)) : j(e3, { responseType: "image" }).then((e4) => {
    const r = e4.data, s = r.naturalWidth, i2 = r.naturalHeight, n2 = document.createElement("canvas");
    n2.width = s, n2.height = i2;
    const l4 = n2.getContext("2d");
    l4.fillStyle = t, l4.fillRect(0, 0, s, i2), l4.globalCompositeOperation = "destination-in", l4.drawImage(r, 0, 0);
    const c2 = n2.toDataURL();
    return u5.put(o, c2), c2;
  });
}
function y3(e3) {
  if (!e3)
    return null;
  let t = null;
  switch (e3.type) {
    case l3:
    case n:
    case a3:
      t = y3(e3.outline);
      break;
    case c: {
      const r = u(e3.width);
      null != e3.style && "none" !== e3.style && 0 !== r && (t = { color: e3.color, style: d(e3.style), width: r, cap: e3.cap, join: "miter" === e3.join ? u(e3.miterLimit) : e3.join });
      break;
    }
    default:
      t = null;
  }
  return t;
}
var d = (() => {
  const e3 = {};
  return (t) => {
    if (e3[t])
      return e3[t];
    const r = t.replaceAll("-", "");
    return e3[t] = r, r;
  };
})();
var g = new u2([128, 128, 128]);

// node_modules/@arcgis/core/symbols/support/utils.js
var a4 = new u2("white");
function y4(e3) {
  if (null == e3 || !("symbolLayers" in e3) || null == e3.symbolLayers)
    return false;
  switch (e3.type) {
    case "point-3d":
      return e3.symbolLayers.some((e4) => "object" === e4.type);
    case "line-3d":
      return e3.symbolLayers.some((e4) => "path" === e4.type);
    case "polygon-3d":
      return e3.symbolLayers.some((e4) => "object" === e4.type || "extrude" === e4.type);
    default:
      return false;
  }
}
function p3(e3) {
  var _a;
  return ((_a = e3.resource) == null ? void 0 : _a.href) ?? "";
}
function h2(n2, r) {
  if (!n2)
    return null;
  let l4 = null;
  return x(n2) ? l4 = b2(n2) : S(n2) && (l4 = "cim" === n2.type ? C2(n2) : n2.color ? new u2(n2.color) : null), l4 ? w(l4, r) : null;
}
function b2(t) {
  const o = t.symbolLayers;
  if (!o)
    return null;
  let n2 = null;
  return o.forEach((e3) => {
    var _a;
    "object" === e3.type && ((_a = e3.resource) == null ? void 0 : _a.href) || (n2 = "water" === e3.type ? e3.color : e3.material ? e3.material.color : null);
  }), n2 ? new u2(n2) : null;
}
function w(t, o) {
  if (null == o || null == t)
    return t;
  const n2 = t.toRgba();
  return n2[3] = n2[3] * o, new u2(n2);
}
function d2(e3, t, o) {
  const n2 = e3.symbolLayers;
  if (!n2)
    return;
  const r = (e4) => w(t = t ?? e4 ?? (null != o ? a4 : null), o);
  n2.forEach((e4) => {
    var _a, _b;
    if ("object" !== e4.type || !((_a = e4.resource) == null ? void 0 : _a.href) || t)
      if ("water" === e4.type)
        e4.color = r(e4.color);
      else {
        const t2 = null != e4.material ? e4.material.color : null, n3 = r(t2);
        null == e4.material ? e4.material = new p({ color: n3 }) : e4.material.color = n3, null != o && "outline" in e4 && null != ((_b = e4.outline) == null ? void 0 : _b.color) && (e4.outline.color = w(e4.outline.color, o));
      }
  });
}
function j2(e3, t, o) {
  var _a;
  (t = t ?? e3.color) && (e3.color = w(t, o)), null != o && "outline" in e3 && ((_a = e3.outline) == null ? void 0 : _a.color) && (e3.outline.color = w(e3.outline.color, o));
}
function k(n2, r, l4) {
  n2 && (r || null != l4) && (r && (r = new u2(r)), x(n2) ? d2(n2, r, l4) : S(n2) && j2(n2, r, l4));
}
async function g2(e3, t) {
  const o = e3.symbolLayers;
  o && await a(o, async (e4) => L(e4, t));
}
async function L(e3, t) {
  switch (e3.type) {
    case "extrude":
      x2(e3, t);
      break;
    case "icon":
    case "line":
    case "text":
      z(e3, t);
      break;
    case "path":
      v(e3, t);
      break;
    case "object":
      await U(e3, t);
  }
}
function z(e3, t) {
  const o = S2(t);
  null != o && (e3.size = o);
}
function S2(e3) {
  for (const t of e3)
    if ("number" == typeof t)
      return t;
  return null;
}
function x2(e3, t) {
  e3.size = "number" == typeof t[2] ? t[2] : 0;
}
async function U(e3, t) {
  const { resourceSize: o, symbolSize: n2 } = await O(e3), r = E(t, o, n2);
  e3.width = C3(t[0], n2[0], o[0], r), e3.depth = C3(t[1], n2[1], o[1], r), e3.height = C3(t[2], n2[2], o[2], r);
}
function v(e3, t) {
  const o = E(t, l, [e3.width, void 0, e3.height]);
  e3.width = C3(t[0], e3.width, 1, o), e3.height = C3(t[2], e3.height, 1, o);
}
function E(e3, t, o) {
  for (let n2 = 0; n2 < 3; n2++) {
    const r = e3[n2];
    switch (r) {
      case "symbol-value": {
        const e4 = o[n2];
        return null != e4 ? e4 / t[n2] : 1;
      }
      case "proportional":
        break;
      default:
        if (r && t[n2])
          return r / t[n2];
    }
  }
  return 1;
}
async function O(e3) {
  const { computeObjectLayerResourceSize: t } = await import("./symbolLayerUtils-4TYV6LFF.js"), o = await t(e3, 10), { width: n2, height: r, depth: l4 } = e3, i2 = [n2, l4, r];
  let c2 = 1;
  for (let s = 0; s < 3; s++) {
    const e4 = i2[s];
    if (null != e4) {
      c2 = e4 / o[s];
      break;
    }
  }
  for (let s = 0; s < 3; s++)
    null == i2[s] && (i2[s] = o[s] * c2);
  return { resourceSize: o, symbolSize: i2 };
}
function C3(e3, t, o, n2) {
  switch (e3) {
    case "proportional":
      return o * n2;
    case "symbol-value":
      return null != t ? t : o;
    default:
      return e3;
  }
}
function M3(e3, t) {
  const o = S2(t);
  if (null != o)
    switch (e3.type) {
      case "simple-marker":
        e3.size = o;
        break;
      case "picture-marker": {
        const t2 = e3.width / e3.height;
        t2 > 1 ? (e3.width = o, e3.height = o * t2) : (e3.width = o * t2, e3.height = o);
        break;
      }
      case "simple-line":
        e3.width = o;
        break;
      case "text":
        e3.font.size = o;
    }
}
async function R(e3, n2) {
  if (e3 && n2)
    return x(e3) ? g2(e3, n2) : void (S(e3) && M3(e3, n2));
}
function D(e3, n2, r) {
  if (e3 && null != n2)
    if (x(e3)) {
      const t = e3.symbolLayers;
      t && t.forEach((e4) => {
        if (e4 && "object" === e4.type)
          switch (r) {
            case "tilt":
              e4.tilt = n2;
              break;
            case "roll":
              e4.roll = n2;
              break;
            default:
              e4.heading = n2;
          }
      });
    } else
      S(e3) && ("simple-marker" !== e3.type && "picture-marker" !== e3.type && "text" !== e3.type || (e3.angle = n2));
}
function I(e3) {
  if (!e3)
    return null;
  const t = e3.effects.filter((e4) => "bloom" !== e4.type).map((e4) => e4.toJSON());
  return i(t);
}
async function N(e3, t) {
  const o = await e3.fetchSymbol(t);
  return o || e3.fetchCIMSymbol(t);
}

export {
  m2 as m,
  f2 as f,
  h,
  y3 as y,
  d,
  g,
  y4 as y2,
  p3 as p,
  h2,
  k,
  R,
  D,
  I,
  N
};
//# sourceMappingURL=chunk-M4XZJQJO.js.map
