import {
  t as t2
} from "./chunk-ID2FHQ3Y.js";
import {
  l
} from "./chunk-4LVXP3AZ.js";
import {
  t
} from "./chunk-3U7MSH5S.js";
import {
  a
} from "./chunk-6DA3YN7V.js";
import {
  d,
  p as p2
} from "./chunk-AOJ6OCPK.js";
import "./chunk-LMT5JII2.js";
import {
  p
} from "./chunk-A43TI6AT.js";
import "./chunk-2D3PORS4.js";
import "./chunk-WZPOQGKL.js";
import "./chunk-CCXEAKIM.js";
import "./chunk-Y5D433JZ.js";
import "./chunk-QNOCEWCR.js";
import "./chunk-WURET5CW.js";
import "./chunk-QWPLZ3QH.js";
import "./chunk-HLGIRLYQ.js";
import "./chunk-N2K4VRZH.js";
import "./chunk-WL4VPODY.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import {
  I,
  bt
} from "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import "./chunk-LXXF7K7W.js";
import "./chunk-SBW6NNVI.js";
import "./chunk-62CXLI6S.js";
import "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  s3 as s
} from "./chunk-WJ3HJKNC.js";
import "./chunk-4V6374PV.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/support/arcgisLayers.js
var u = { FeatureLayer: true, SceneLayer: true };
async function y(e) {
  var _a;
  const r = (_a = e.properties) == null ? void 0 : _a.customParameters, a2 = await p3(e.url, r), t3 = { ...e.properties, url: e.url };
  if (a2.layers.length + a2.tables.length === 0)
    return null != a2.layerId && (t3.layerId = a2.layerId), null != a2.sourceJSON && (t3.sourceJSON = a2.sourceJSON), new a2.Constructor(t3);
  const s2 = new (0, (await import("./GroupLayer-W7ZWY7RU.js")).default)({ title: a2.parsedUrl.title });
  return await f(s2, a2, t3), s2;
}
function m(e, r) {
  return e ? e.find((e2) => e2.id === r) : null;
}
async function f(e, r, a2) {
  function t3(e2, r2, t4, s3) {
    const n = { ...a2, layerId: r2, sublayerTitleMode: "service-name" };
    return null != e2 && (n.url = e2), null != t4 && (n.sourceJSON = t4), s3(n);
  }
  const s2 = r.sublayerConstructorProvider;
  for (const { id: n, serverUrl: l2 } of r.layers) {
    const a3 = m(r.sublayerInfos, n), o = (a3 && (s2 == null ? void 0 : s2(a3))) ?? r.Constructor, i = t3(l2, n, a3, (e2) => new o(e2));
    e.add(i);
  }
  if (r.tables.length) {
    const a3 = await b("FeatureLayer");
    r.tables.forEach(({ id: s3, serverUrl: n }) => {
      const l2 = t3(n, s3, m(r.tableInfos, s3), (e2) => new a3(e2));
      e.tables.add(l2);
    });
  }
}
async function p3(r, a2) {
  var _a, _b, _c, _d, _e, _f, _g;
  let s2 = p2(r);
  if (null == s2 && (s2 = await d2(r, a2)), null == s2)
    throw new s("arcgis-layers:url-mismatch", "The url '${url}' is not a valid arcgis resource", { url: r });
  const { serverType: n, sublayer: l2 } = s2;
  let i;
  const y2 = { FeatureServer: "FeatureLayer", StreamServer: "StreamLayer", VectorTileServer: "VectorTileLayer" }, m2 = "FeatureServer" === n, f2 = "SceneServer" === n, p4 = { parsedUrl: s2, Constructor: null, layerId: m2 || f2 ? l2 ?? void 0 : void 0, layers: [], tables: [] };
  switch (n) {
    case "MapServer":
      if (null != l2)
        i = "FeatureLayer";
      else {
        i = await h(r, a2) ? "TileLayer" : "MapImageLayer";
      }
      break;
    case "ImageServer": {
      const e = await t(r, { customParameters: a2 }), { tileInfo: t3, cacheType: s3 } = e;
      i = t3 ? "LERC" !== ((_a = t3 == null ? void 0 : t3.format) == null ? void 0 : _a.toUpperCase()) || s3 && "elevation" !== s3.toLowerCase() ? "ImageryTileLayer" : "ElevationLayer" : "ImageryLayer";
      break;
    }
    case "SceneServer": {
      const e = await t(s2.url.path, { customParameters: a2 });
      if (i = "SceneLayer", e) {
        const r2 = e == null ? void 0 : e.layers;
        if ("Voxel" === (e == null ? void 0 : e.layerType))
          i = "VoxelLayer";
        else if (r2 == null ? void 0 : r2.length) {
          const e2 = (_b = r2[0]) == null ? void 0 : _b.layerType;
          null != e2 && null != p[e2] && (i = p[e2]);
        }
      }
      break;
    }
    case "FeatureServer":
      if (i = "FeatureLayer", null != l2) {
        const e = await t(r, { customParameters: a2 });
        p4.sourceJSON = e, "Oriented Imagery Layer" === e.type && (i = "OrientedImageryLayer");
      }
      break;
    default:
      i = y2[n];
  }
  if (u[i] && null == l2) {
    const e = await S(r, n, a2);
    m2 && (p4.sublayerInfos = e.layerInfos, p4.tableInfos = e.tableInfos);
    if (1 !== e.layers.length + e.tables.length)
      p4.layers = e.layers, p4.tables = e.tables, m2 && ((_c = e.layerInfos) == null ? void 0 : _c.length) && (p4.sublayerConstructorProvider = await I2(e.layerInfos));
    else if (m2 || f2) {
      const r2 = ((_d = e.layerInfos) == null ? void 0 : _d[0]) ?? ((_e = e.tableInfos) == null ? void 0 : _e[0]);
      p4.layerId = ((_f = e.layers[0]) == null ? void 0 : _f.id) ?? ((_g = e.tables[0]) == null ? void 0 : _g.id), p4.sourceJSON = r2, m2 && "Oriented Imagery Layer" === (r2 == null ? void 0 : r2.type) && (i = "OrientedImageryLayer");
    }
  }
  return p4.Constructor = await b(i), p4;
}
async function d2(e, t3) {
  var _a;
  const n = await t(e, { customParameters: t3 });
  let l2 = null, o = null;
  const i = n.type;
  if ("Feature Layer" === i || "Table" === i ? (l2 = "FeatureServer", o = n.id ?? null) : "indexedVector" === i ? l2 = "VectorTileServer" : n.hasOwnProperty("mapName") ? l2 = "MapServer" : n.hasOwnProperty("bandCount") && n.hasOwnProperty("pixelSizeX") ? l2 = "ImageServer" : n.hasOwnProperty("maxRecordCount") && n.hasOwnProperty("allowGeometryUpdates") ? l2 = "FeatureServer" : n.hasOwnProperty("streamUrls") ? l2 = "StreamServer" : v(n) ? (l2 = "SceneServer", o = n.id) : n.hasOwnProperty("layers") && v((_a = n.layers) == null ? void 0 : _a[0]) && (l2 = "SceneServer"), !l2)
    return null;
  const u2 = null != o ? d(e) : null;
  return { title: null != u2 && n.name || bt(e), serverType: l2, sublayer: o, url: { path: null != u2 ? u2.serviceUrl : I(e).path } };
}
function v(e) {
  return null != e && e.hasOwnProperty("store") && e.hasOwnProperty("id") && "number" == typeof e.id;
}
async function S(e, r, a2) {
  let t3, s2, n = false;
  switch (r) {
    case "FeatureServer": {
      const r2 = await t2(e, { customParameters: a2 });
      n = !!r2.layersJSON, t3 = r2.layersJSON || r2.serviceJSON;
      break;
    }
    case "SceneServer": {
      const r2 = await w(e, a2);
      t3 = r2.serviceInfo, s2 = r2.tableServerUrl;
      break;
    }
    default:
      t3 = await t(e, { customParameters: a2 });
  }
  const o = t3 == null ? void 0 : t3.layers, i = t3 == null ? void 0 : t3.tables;
  return { layers: (o == null ? void 0 : o.map((e2) => ({ id: e2.id })).reverse()) || [], tables: (i == null ? void 0 : i.map((e2) => ({ serverUrl: s2, id: e2.id })).reverse()) || [], layerInfos: n ? o : [], tableInfos: n ? i : [] };
}
async function w(e, r) {
  var _a;
  const a2 = await t(e, { customParameters: r }), t3 = (_a = a2.layers) == null ? void 0 : _a[0];
  if (!t3)
    return { serviceInfo: a2 };
  try {
    const { serverUrl: t4 } = await l(e), s2 = await t(t4, { customParameters: r }).catch(() => null);
    return s2 && (a2.tables = s2.tables), { serviceInfo: a2, tableServerUrl: t4 };
  } catch {
    return { serviceInfo: a2 };
  }
}
async function b(e) {
  return (0, a[e])();
}
async function h(e, r) {
  return (await t(e, { customParameters: r })).tileInfo;
}
async function I2(e) {
  const r = [], a2 = [];
  if (e.forEach((e2) => {
    const { type: t4 } = e2;
    "Oriented Imagery Layer" === t4 ? (r.push(t4), a2.push(b("OrientedImageryLayer"))) : (r.push(t4), a2.push(b("FeatureLayer")));
  }), !a2.length)
    return;
  const t3 = await Promise.all(a2), s2 = /* @__PURE__ */ new Map();
  return r.forEach((e2, r2) => {
    s2.set(e2, t3[r2]);
  }), (e2) => s2.get(e2.type);
}
export {
  y as fromUrl
};
//# sourceMappingURL=arcgisLayers-6HSECZ3U.js.map
