import {
  i as i2
} from "./chunk-FBWFFZ74.js";
import {
  r as r7
} from "./chunk-GPOJ5GQM.js";
import "./chunk-VLDVHSJX.js";
import {
  m,
  u as u3
} from "./chunk-TXY7QCH7.js";
import "./chunk-ULPUCHVC.js";
import {
  f as f3
} from "./chunk-BV5PCIP6.js";
import {
  e as e8
} from "./chunk-R72HXU5Y.js";
import "./chunk-BXZIEADJ.js";
import {
  h as h3
} from "./chunk-A6KO3R3G.js";
import {
  T as T2,
  e2 as e7
} from "./chunk-T56C4ORZ.js";
import {
  c as c3,
  e as e5,
  t as t2
} from "./chunk-N3XMQQIW.js";
import {
  l as l3
} from "./chunk-GWXJUB3T.js";
import {
  E,
  I as I2
} from "./chunk-X2WF3O7G.js";
import {
  a as a4,
  i,
  l as l2,
  n,
  r as r5
} from "./chunk-MGMW5F44.js";
import "./chunk-XZLDDXLF.js";
import "./chunk-DSGGSKRZ.js";
import "./chunk-OG2GBCUQ.js";
import "./chunk-UMP4LYVN.js";
import "./chunk-W3TATJ3S.js";
import "./chunk-LJAHTUH5.js";
import "./chunk-NS7I2ZSY.js";
import {
  t
} from "./chunk-L2VCMOKZ.js";
import "./chunk-PHDOV32N.js";
import {
  T
} from "./chunk-TREPTI6V.js";
import "./chunk-Z26DT4RT.js";
import "./chunk-BUMLJETN.js";
import "./chunk-XFC7DZXI.js";
import "./chunk-PPQAHSM4.js";
import {
  D,
  F,
  G,
  I,
  O,
  R
} from "./chunk-RCLKRKWR.js";
import {
  r as r4
} from "./chunk-OYPRFNII.js";
import "./chunk-747B2TEO.js";
import "./chunk-4NEWABLH.js";
import "./chunk-FW2Y26A2.js";
import "./chunk-5WG7GACT.js";
import "./chunk-P3R45ANF.js";
import {
  a as a3,
  s as s2
} from "./chunk-SEKLTVY5.js";
import {
  e as e3
} from "./chunk-CSWPLQ7Q.js";
import "./chunk-KWSMYM7P.js";
import "./chunk-6BFXMZEZ.js";
import "./chunk-AMSVADDY.js";
import "./chunk-HIMMLBO7.js";
import {
  e as e6,
  r as r6
} from "./chunk-76KPSQLT.js";
import "./chunk-MVXU4PVF.js";
import "./chunk-5L3L57TJ.js";
import {
  y as y2
} from "./chunk-HHX6IUJQ.js";
import "./chunk-2FFBPEOX.js";
import {
  h as h2
} from "./chunk-XHP7ONEC.js";
import {
  l
} from "./chunk-X2Y3P2BF.js";
import {
  e as e4
} from "./chunk-GJ4KNHRS.js";
import "./chunk-6M5DUIJQ.js";
import "./chunk-CMGHBCKF.js";
import {
  M,
  f as f2,
  h,
  r as r3
} from "./chunk-YVNEJWNQ.js";
import "./chunk-NDKHIQMD.js";
import "./chunk-XUD6H4VO.js";
import {
  j as j2
} from "./chunk-CQMEHG4P.js";
import "./chunk-GZTU5O23.js";
import {
  r as r2
} from "./chunk-EC5POYCL.js";
import {
  p
} from "./chunk-IYXYJAVC.js";
import "./chunk-NCLD32JB.js";
import "./chunk-24NOAXOQ.js";
import {
  c as c2
} from "./chunk-B3RXTW72.js";
import "./chunk-DCYI44X2.js";
import "./chunk-JHJVOI7Q.js";
import "./chunk-4NU7FZD7.js";
import "./chunk-WYZCKLOR.js";
import "./chunk-S6NERLXF.js";
import "./chunk-MLRHWRJQ.js";
import "./chunk-H4ZZ5S37.js";
import "./chunk-G557TGXY.js";
import "./chunk-IRNKV32L.js";
import "./chunk-IATM3RCE.js";
import "./chunk-GRHSIT57.js";
import "./chunk-PJQIAD5D.js";
import "./chunk-GAWSWBHO.js";
import "./chunk-SZAJDZCO.js";
import "./chunk-3DSKWYU4.js";
import "./chunk-ZZYUEH57.js";
import "./chunk-VTWXDFFD.js";
import "./chunk-IPCIO3PX.js";
import "./chunk-EIY2DYTV.js";
import "./chunk-WJ4LS3YG.js";
import "./chunk-F6MD5VOH.js";
import "./chunk-V2RPSCV3.js";
import "./chunk-LMT5JII2.js";
import "./chunk-OIIDE5GZ.js";
import {
  u as u2
} from "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import "./chunk-TBSVVR6M.js";
import "./chunk-6TJWLWLO.js";
import "./chunk-H7BKONNV.js";
import "./chunk-K6C6RVSV.js";
import "./chunk-KBJ5Z4R2.js";
import "./chunk-JUZJCTW2.js";
import "./chunk-423VNHLR.js";
import "./chunk-FN47E7YK.js";
import "./chunk-XZS3Q5K4.js";
import "./chunk-WZPOQGKL.js";
import "./chunk-CCXEAKIM.js";
import "./chunk-Y5D433JZ.js";
import "./chunk-QNOCEWCR.js";
import "./chunk-WURET5CW.js";
import "./chunk-QWPLZ3QH.js";
import {
  d2 as d
} from "./chunk-HLGIRLYQ.js";
import "./chunk-N2K4VRZH.js";
import "./chunk-WL4VPODY.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import {
  Et,
  j
} from "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import {
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  C,
  a as a2,
  b,
  f
} from "./chunk-RFPH3ZTZ.js";
import {
  e as e2,
  r,
  u
} from "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  a,
  s2 as s
} from "./chunk-WJ3HJKNC.js";
import {
  A
} from "./chunk-4V6374PV.js";
import "./chunk-A34O4XB5.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/RectangleBinPack.js
var e9 = class {
  constructor(e11, t8) {
    this._width = 0, this._height = 0, this._free = [], this._width = e11, this._height = t8, this._free.push(new t(0, 0, e11, t8));
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  allocate(e11, t8) {
    if (e11 > this._width || t8 > this._height)
      return new t();
    let i7 = null, s7 = -1;
    for (let h6 = 0; h6 < this._free.length; ++h6) {
      const w2 = this._free[h6];
      e11 <= w2.width && t8 <= w2.height && (null === i7 || w2.y <= i7.y && w2.x <= i7.x) && (i7 = w2, s7 = h6);
    }
    return null === i7 ? new t() : (this._free.splice(s7, 1), i7.width < i7.height ? (i7.width > e11 && this._free.push(new t(i7.x + e11, i7.y, i7.width - e11, t8)), i7.height > t8 && this._free.push(new t(i7.x, i7.y + t8, i7.width, i7.height - t8))) : (i7.width > e11 && this._free.push(new t(i7.x + e11, i7.y, i7.width - e11, i7.height)), i7.height > t8 && this._free.push(new t(i7.x, i7.y + t8, e11, i7.height - t8))), new t(i7.x, i7.y, e11, t8));
  }
  release(h6) {
    for (let e11 = 0; e11 < this._free.length; ++e11) {
      const t8 = this._free[e11];
      if (t8.y === h6.y && t8.height === h6.height && t8.x + t8.width === h6.x)
        t8.width += h6.width;
      else if (t8.x === h6.x && t8.width === h6.width && t8.y + t8.height === h6.y)
        t8.height += h6.height;
      else if (h6.y === t8.y && h6.height === t8.height && h6.x + h6.width === t8.x)
        t8.x = h6.x, t8.width += h6.width;
      else {
        if (h6.x !== t8.x || h6.width !== t8.width || h6.y + h6.height !== t8.y)
          continue;
        t8.y = h6.y, t8.height += h6.height;
      }
      this._free.splice(e11, 1), this.release(h6);
    }
    this._free.push(h6);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphMosaic.js
var n2 = class {
  constructor(e11, s7, i7) {
    this.width = 0, this.height = 0, this._dirties = [], this._glyphData = [], this._currentPage = 0, this._glyphIndex = {}, this._textures = [], this._rangePromises = /* @__PURE__ */ new Map(), this.width = e11, this.height = s7, this._glyphSource = i7, this._binPack = new e9(e11 - 4, s7 - 4), this._glyphData.push(new Uint8Array(e11 * s7)), this._dirties.push(true), this._textures.push(void 0);
  }
  getGlyphItems(s7, i7) {
    const h6 = [], r12 = this._glyphSource, n6 = /* @__PURE__ */ new Set(), o6 = 1 / 256;
    for (const t8 of i7) {
      const e11 = Math.floor(t8 * o6);
      n6.add(e11);
    }
    const a7 = [];
    return n6.forEach((t8) => {
      const e11 = s7 + t8;
      if (this._rangePromises.has(e11))
        a7.push(this._rangePromises.get(e11));
      else {
        const i8 = r12.getRange(s7, t8).then(() => {
          this._rangePromises.delete(e11);
        }, () => {
          this._rangePromises.delete(e11);
        });
        this._rangePromises.set(e11, i8), a7.push(i8);
      }
    }), Promise.all(a7).then(() => {
      let n7 = this._glyphIndex[s7];
      n7 || (n7 = {}, this._glyphIndex[s7] = n7);
      for (const o7 of i7) {
        const i8 = n7[o7];
        if (i8) {
          h6[o7] = { sdf: true, rect: i8.rect, metrics: i8.metrics, page: i8.page, code: o7 };
          continue;
        }
        const a8 = r12.getGlyph(s7, o7);
        if (!(a8 == null ? void 0 : a8.metrics))
          continue;
        const l9 = a8.metrics;
        let c6;
        if (0 === l9.width)
          c6 = new t(0, 0, 0, 0);
        else {
          const e11 = 3, s8 = l9.width + 2 * e11, i9 = l9.height + 2 * e11;
          let h7 = s8 % 4 ? 4 - s8 % 4 : 4, r13 = i9 % 4 ? 4 - i9 % 4 : 4;
          1 === h7 && (h7 = 5), 1 === r13 && (r13 = 5), c6 = this._binPack.allocate(s8 + h7, i9 + r13), c6.isEmpty && (this._dirties[this._currentPage] || (this._glyphData[this._currentPage] = null), this._currentPage = this._glyphData.length, this._glyphData.push(new Uint8Array(this.width * this.height)), this._dirties.push(true), this._textures.push(void 0), this._binPack = new e9(this.width - 4, this.height - 4), c6 = this._binPack.allocate(s8 + h7, i9 + r13));
          const n8 = this._glyphData[this._currentPage], o8 = a8.bitmap;
          let g, _2;
          if (o8)
            for (let t8 = 0; t8 < i9; t8++) {
              g = s8 * t8, _2 = this.width * (c6.y + t8 + 1) + c6.x;
              for (let t9 = 0; t9 < s8; t9++)
                n8[_2 + t9 + 1] = o8.at(g + t9);
            }
        }
        n7[o7] = { rect: c6, metrics: l9, tileIDs: null, page: this._currentPage }, h6[o7] = { sdf: true, rect: c6, metrics: l9, page: this._currentPage, code: o7 }, this._dirties[this._currentPage] = true;
      }
      return h6;
    });
  }
  removeGlyphs(t8) {
    for (const e11 in this._glyphIndex) {
      const s7 = this._glyphIndex[e11];
      if (!s7)
        continue;
      let i7;
      for (const e12 in s7)
        if (i7 = s7[e12], i7.tileIDs.delete(t8), 0 === i7.tileIDs.size) {
          const t9 = this._glyphData[i7.page], h6 = i7.rect;
          let r12, n6;
          for (let e13 = 0; e13 < h6.height; e13++)
            for (r12 = this.width * (h6.y + e13) + h6.x, n6 = 0; n6 < h6.width; n6++)
              t9[r12 + n6] = 0;
          delete s7[e12], this._dirties[i7.page] = true;
        }
    }
  }
  bind(t8, e11, n6, o6 = 0) {
    if (!this._textures[n6]) {
      const e12 = new e7();
      e12.pixelFormat = G.ALPHA, e12.wrapMode = D.CLAMP_TO_EDGE, e12.width = this.width, e12.height = this.height, this._textures[n6] = new T2(t8, e12, new Uint8Array(this.width * this.height));
    }
    const a7 = this._textures[n6];
    a7.setSamplingMode(e11), this._dirties[n6] && a7.setData(this._glyphData[n6]), t8.bindTexture(a7, o6), this._dirties[n6] = false;
  }
  destroy() {
    this.dispose();
  }
  dispose() {
    this._glyphData.length = 0, this._binPack = null;
    for (const t8 of this._textures)
      t8 && t8.dispose();
    this._textures.length = 0;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphSource.js
var s3 = class {
  constructor(t8) {
    if (this._metrics = [], !t8)
      return void (this._allBitmaps = null);
    const e11 = /* @__PURE__ */ new Map();
    let s7 = 0;
    for (; t8.next(); )
      switch (t8.tag()) {
        case 1: {
          const a8 = t8.getMessage();
          for (; a8.next(); )
            switch (a8.tag()) {
              case 3: {
                const t9 = a8.getMessage();
                let r13, n6, i7, c6, o6, g, h6;
                for (; t9.next(); )
                  switch (t9.tag()) {
                    case 1:
                      r13 = t9.getUInt32();
                      break;
                    case 2:
                      n6 = t9.getBytes();
                      break;
                    case 3:
                      i7 = t9.getUInt32();
                      break;
                    case 4:
                      c6 = t9.getUInt32();
                      break;
                    case 5:
                      o6 = t9.getSInt32();
                      break;
                    case 6:
                      g = t9.getSInt32();
                      break;
                    case 7:
                      h6 = t9.getUInt32();
                      break;
                    default:
                      t9.skip();
                  }
                if (t9.release(), r13) {
                  const t10 = (n6 == null ? void 0 : n6.length) ?? 0;
                  this._metrics[r13] = { width: i7, height: c6, left: o6, top: g, advance: h6, startOffset: s7, length: t10 }, e11.set(r13, n6), s7 += t10;
                }
                break;
              }
              default:
                a8.skip();
            }
          a8.release();
          break;
        }
        default:
          t8.skip();
      }
    const a7 = new Uint8Array(s7), r12 = this._metrics;
    for (const [n6, i7] of e11) {
      const { startOffset: t9, length: e12 } = r12[n6];
      if (i7)
        for (let s8 = 0; s8 < e12; ++s8)
          a7[t9 + s8] = i7[s8];
    }
    this._allBitmaps = a7;
  }
  getMetrics(t8) {
    return this._metrics[t8];
  }
  getBitmap(t8) {
    if (!this._allBitmaps)
      return;
    const e11 = this._metrics[t8];
    if (void 0 === e11)
      return;
    const { startOffset: s7, length: a7 } = e11;
    return 0 !== a7 ? new n3(this._allBitmaps, s7, a7) : void 0;
  }
};
var a5 = class {
  constructor() {
    this._ranges = [];
  }
  get ranges() {
    return this._ranges;
  }
  getRange(t8) {
    return this._ranges[t8];
  }
  addRange(t8, e11) {
    this._ranges[t8] = e11;
  }
};
var r8 = class {
  constructor(t8) {
    this._glyphInfo = {}, this._baseURL = t8;
  }
  getRange(a7, r12) {
    const n6 = this._getFontStack(a7);
    if (n6.getRange(r12))
      return Promise.resolve();
    const i7 = 256 * r12, c6 = i7 + 255;
    if (this._baseURL) {
      const o6 = this._baseURL.replace("{fontstack}", a7).replace("{range}", i7 + "-" + c6);
      return j(o6, { responseType: "array-buffer" }).then((t8) => {
        n6.addRange(r12, new s3(new r4(new Uint8Array(t8.data), new DataView(t8.data))));
      }).catch(() => {
        n6.addRange(r12, new s3());
      });
    }
    return n6.addRange(r12, new s3()), Promise.resolve();
  }
  getGlyph(t8, e11) {
    const s7 = this._getFontStack(t8);
    if (!s7)
      return;
    const a7 = Math.floor(e11 / 256), r12 = s7.getRange(a7);
    return r12 ? { metrics: r12.getMetrics(e11), bitmap: r12.getBitmap(e11) } : void 0;
  }
  _getFontStack(t8) {
    let e11 = this._glyphInfo[t8];
    return e11 || (e11 = this._glyphInfo[t8] = new a5()), e11;
  }
};
var n3 = class {
  constructor(t8, e11, s7) {
    this._array = t8, this._start = e11, this.length = s7;
  }
  at(t8) {
    return 0 <= t8 && t8 < this.length ? this._array[this._start + t8] : void 0;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/SpriteMosaic.js
var r9 = "dasharray-";
var o = class _o {
  constructor(t8, e11, s7 = 0) {
    this._size = [], this._mosaicsData = [], this._textures = [], this._dirties = [], this._maxItemSize = 0, this._currentPage = 0, this._pageWidth = 0, this._pageHeight = 0, this._mosaicRects = {}, this.pixelRatio = 1, (t8 <= 0 || e11 <= 0) && console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"), this._pageWidth = t8, this._pageHeight = e11, s7 > 0 && (this._maxItemSize = s7), this._binPack = new e9(t8 - 4, e11 - 4);
  }
  destroy() {
    this.dispose();
  }
  dispose() {
    this._binPack = null, this._mosaicsData.length = 0, this._mosaicRects = {};
    for (const t8 of this._textures)
      t8 && t8.dispose();
    this._textures.length = 0;
  }
  getWidth(t8) {
    return t8 >= this._size.length ? -1 : this._size[t8][0];
  }
  getHeight(t8) {
    return t8 >= this._size.length ? -1 : this._size[t8][1];
  }
  getPageSize(t8) {
    return t8 >= this._size.length ? null : this._size[t8];
  }
  setSpriteSource(t8) {
    if (this.dispose(), this.pixelRatio = t8.devicePixelRatio, 0 === this._mosaicsData.length) {
      this._binPack = new e9(this._pageWidth - 4, this._pageHeight - 4);
      const t9 = Math.floor(this._pageWidth), e11 = Math.floor(this._pageHeight), s7 = new Uint32Array(t9 * e11);
      this._mosaicsData[0] = s7, this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0);
    }
    this._sprites = t8;
  }
  getSpriteItem(t8, i7 = false) {
    let e11, s7, h6 = this._mosaicRects[t8];
    if (h6)
      return h6;
    if (!this._sprites || "loaded" !== this._sprites.loadStatus)
      return null;
    if (t8 && t8.startsWith(r9) ? ([e11, s7] = this._rasterizeDash(t8), i7 = true) : e11 = this._sprites.getSpriteInfo(t8), !(e11 == null ? void 0 : e11.width) || !e11.height || e11.width < 0 || e11.height < 0)
      return null;
    const a7 = e11.width, o6 = e11.height, [n6, _2, g] = this._allocateImage(a7, o6);
    return n6.width <= 0 ? null : (this._copy(n6, e11, _2, g, i7, s7), h6 = { rect: n6, width: a7, height: o6, sdf: e11.sdf, simplePattern: false, pixelRatio: e11.pixelRatio, page: _2 }, this._mosaicRects[t8] = h6, h6);
  }
  getSpriteItems(t8) {
    const i7 = {};
    for (const e11 of t8)
      i7[e11.name] = this.getSpriteItem(e11.name, e11.repeat);
    return i7;
  }
  getMosaicItemPosition(t8, i7) {
    const e11 = this.getSpriteItem(t8, i7), s7 = e11 && e11.rect;
    if (!s7)
      return null;
    s7.width = e11.width, s7.height = e11.height;
    const h6 = e11.width, a7 = e11.height, r12 = 2;
    return { tl: [s7.x + r12, s7.y + r12], br: [s7.x + r12 + h6, s7.y + r12 + a7], page: e11.page };
  }
  bind(t8, i7, e11 = 0, r12 = 0) {
    if (e11 >= this._size.length || e11 >= this._mosaicsData.length)
      return;
    if (!this._textures[e11]) {
      const i8 = new e7();
      i8.wrapMode = D.CLAMP_TO_EDGE, i8.width = this._size[e11][0], i8.height = this._size[e11][1], this._textures[e11] = new T2(t8, i8, new Uint8Array(this._mosaicsData[e11].buffer));
    }
    const o6 = this._textures[e11];
    o6.setSamplingMode(i7), this._dirties[e11] && o6.setData(new Uint8Array(this._mosaicsData[e11].buffer)), t8.bindTexture(o6, r12), this._dirties[e11] = false;
  }
  static _copyBits(t8, i7, e11, s7, h6, a7, r12, o6, n6, _2, g) {
    let c6 = s7 * i7 + e11, l9 = o6 * a7 + r12;
    if (g) {
      l9 -= a7;
      for (let r13 = -1; r13 <= _2; r13++, c6 = ((r13 + _2) % _2 + s7) * i7 + e11, l9 += a7)
        for (let i8 = -1; i8 <= n6; i8++)
          h6[l9 + i8] = t8[c6 + (i8 + n6) % n6];
    } else
      for (let p3 = 0; p3 < _2; p3++) {
        for (let i8 = 0; i8 < n6; i8++)
          h6[l9 + i8] = t8[c6 + i8];
        c6 += i7, l9 += a7;
      }
  }
  _copy(t8, i7, e11, s7, h6, a7) {
    if (!this._sprites || "loaded" !== this._sprites.loadStatus || e11 >= this._mosaicsData.length)
      return;
    const r12 = new Uint32Array(a7 ? a7.buffer : this._sprites.image.buffer), n6 = this._mosaicsData[e11];
    n6 && r12 || console.error("Source or target images are uninitialized!");
    const _2 = 2, g = a7 ? i7.width : this._sprites.width;
    _o._copyBits(r12, g, i7.x, i7.y, n6, s7[0], t8.x + _2, t8.y + _2, i7.width, i7.height, h6), this._dirties[e11] = true;
  }
  _allocateImage(t8, s7) {
    t8 += 2, s7 += 2;
    const h6 = Math.max(t8, s7);
    if (this._maxItemSize && this._maxItemSize < h6) {
      const i7 = new t(0, 0, t8, s7);
      return this._mosaicsData.push(new Uint32Array(t8 * s7)), this._dirties.push(true), this._size.push([t8, s7]), this._textures.push(void 0), [i7, this._mosaicsData.length - 1, [t8, s7]];
    }
    let a7 = t8 % 4 ? 4 - t8 % 4 : 4, r12 = s7 % 4 ? 4 - s7 % 4 : 4;
    1 === a7 && (a7 = 5), 1 === r12 && (r12 = 5);
    const o6 = this._binPack.allocate(t8 + a7, s7 + r12);
    return o6.width <= 0 ? (this._dirties[this._currentPage] || (this._mosaicsData[this._currentPage] = null), this._currentPage = this._mosaicsData.length, this._mosaicsData.push(new Uint32Array(this._pageWidth * this._pageHeight)), this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0), this._binPack = new e9(this._pageWidth - 4, this._pageHeight - 4), this._allocateImage(t8, s7)) : [o6, this._currentPage, [this._pageWidth, this._pageHeight]];
  }
  _rasterizeDash(i7) {
    const e11 = /\[(.*?)\]/, s7 = i7.match(e11);
    if (!s7)
      return null;
    const h6 = s7[1].split(",").map(Number), a7 = i7.slice(i7.lastIndexOf("-") + 1), [r12, o6, n6] = e8(h6, a7);
    return [{ x: 0, y: 0, width: o6, height: n6, sdf: true, pixelRatio: 1 }, new Uint8Array(r12.buffer)];
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileHandler.js
var u4 = class {
  constructor(t8, e11, s7) {
    this._layer = t8, this._styleRepository = e11, this.devicePixelRatio = s7, this._spriteMosaic = null, this._glyphMosaic = null, this._connection = null, this._spriteSourceAbortController = null, this._startOptionsInputSignal = null, this._inputSignalEventListener = null;
  }
  destroy() {
    var _a, _b, _c;
    (_a = this._connection) == null ? void 0 : _a.close(), this._connection = null, this._styleRepository = null, this._layer = null, (_b = this._spriteMosaic) == null ? void 0 : _b.destroy(), this._spriteMosaic = null, this._glyphMosaic = null, this._spriteSourceAbortController = e2(this._spriteSourceAbortController), this._spriteSourcePromise = null, this._inputSignalEventListener && ((_c = this._startOptionsInputSignal) == null ? void 0 : _c.removeEventListener("abort", this._inputSignalEventListener)), this._startOptionsInputSignal = null, this._inputSignalEventListener = null;
  }
  get spriteMosaic() {
    return this._spriteSourcePromise.then(() => this._spriteMosaic);
  }
  get glyphMosaic() {
    return this._glyphMosaic;
  }
  async start(t8) {
    this._requestSprite(t8);
    const s7 = this._layer.currentStyleInfo.glyphsUrl, r12 = new r8(s7 ? Et(s7, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    this._glyphMosaic = new n2(1024, 1024, r12), this._broadcastPromise = p("WorkerTileHandler", { client: this, schedule: t8.schedule, signal: t8.signal }).then((s8) => {
      var _a;
      if (this._layer && ((_a = this._connection) == null ? void 0 : _a.close(), this._connection = s8, this._layer && !this._connection.closed)) {
        const r13 = s8.broadcast("setStyle", this._layer.currentStyleInfo.style, t8);
        Promise.all(r13).catch((t9) => f(t9));
      }
    });
  }
  _requestSprite(t8) {
    var _a, _b;
    (_a = this._spriteSourceAbortController) == null ? void 0 : _a.abort();
    const e11 = new AbortController();
    this._spriteSourceAbortController = e11;
    const r12 = t8 == null ? void 0 : t8.signal;
    this._inputSignalEventListener && ((_b = this._startOptionsInputSignal) == null ? void 0 : _b.removeEventListener("abort", this._inputSignalEventListener)), this._startOptionsInputSignal = null, r12 && (this._inputSignalEventListener = h4(e11), r12.addEventListener("abort", this._inputSignalEventListener, { once: true }));
    const { signal: i7 } = e11, o6 = { ...t8, signal: i7 };
    this._spriteSourcePromise = this._layer.loadSpriteSource(this.devicePixelRatio, o6), this._spriteSourcePromise.then((t9) => {
      a2(i7), this._spriteMosaic = new o(1024, 1024, 250), this._spriteMosaic.setSpriteSource(t9);
    });
  }
  async updateStyle(t8) {
    return await this._broadcastPromise, this._broadcastPromise = Promise.all(this._connection.broadcast("updateStyle", t8)), this._broadcastPromise;
  }
  setSpriteSource(t8) {
    const e11 = new o(1024, 1024, 250);
    return e11.setSpriteSource(t8), this._spriteMosaic = e11, this._spriteSourcePromise = Promise.resolve(t8), this._spriteSourceAbortController = null, e11;
  }
  async setStyle(t8, e11) {
    await this._broadcastPromise, this._styleRepository = t8, this._requestSprite();
    const s7 = new r8(this._layer.currentStyleInfo.glyphsUrl ? Et(this._layer.currentStyleInfo.glyphsUrl, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    return this._glyphMosaic = new n2(1024, 1024, s7), this._broadcastPromise = Promise.all(this._connection.broadcast("setStyle", e11)), this._broadcastPromise;
  }
  fetchTileData(t8, e11) {
    return this._getRefKeys(t8, e11).then((t9) => {
      const s7 = this._layer.sourceNameToSource, r12 = [];
      for (const e12 in s7)
        r12.push(e12);
      return this._getSourcesData(r12, t9, e11);
    });
  }
  parseTileData(t8, e11) {
    const s7 = t8 && t8.data;
    if (!s7)
      return Promise.resolve(null);
    const { sourceName2DataAndRefKey: r12, transferList: i7 } = s7;
    return 0 === Object.keys(r12).length ? Promise.resolve(null) : this._broadcastPromise.then(() => this._connection.invoke("createTileAndParse", { key: t8.key.id, sourceName2DataAndRefKey: r12, styleLayerUIDs: t8.styleLayerUIDs }, { ...e11, transferList: i7 }));
  }
  async getSprites(t8) {
    return await this._spriteSourcePromise, this._spriteMosaic.getSpriteItems(t8);
  }
  getGlyphs(t8) {
    return this._glyphMosaic.getGlyphItems(t8.font, t8.codePoints);
  }
  async _getTilePayload(t8, e11, s7) {
    const i7 = e4.pool.acquire(t8.id), o6 = this._layer.sourceNameToSource[e11], { level: n6, row: l9, col: a7 } = i7;
    e4.pool.release(i7);
    try {
      return { protobuff: await o6.requestTile(n6, l9, a7, s7), sourceName: e11 };
    } catch (u5) {
      if (b(u5))
        throw u5;
      return { protobuff: null, sourceName: e11 };
    }
  }
  _getRefKeys(t8, e11) {
    const s7 = this._layer.sourceNameToSource, r12 = new Array();
    for (const i7 in s7) {
      const o6 = s7[i7].getRefKey(t8, e11);
      r12.push(o6);
    }
    return Promise.allSettled(r12);
  }
  _getSourcesData(t8, e11, s7) {
    const r12 = [];
    for (let i7 = 0; i7 < e11.length; i7++) {
      const o6 = e11[i7], n6 = "fulfilled" === o6.status ? o6.value : null;
      if (null == n6 || null == t8[i7])
        r12.push(null);
      else {
        const e12 = this._getTilePayload(n6, t8[i7], s7);
        r12.push(e12);
      }
    }
    return Promise.allSettled(r12).then((t9) => {
      const s8 = {}, r13 = [];
      for (let i7 = 0; i7 < t9.length; i7++) {
        const o6 = t9[i7], n6 = "fulfilled" === o6.status ? o6.value : null, l9 = n6 == null ? void 0 : n6.protobuff;
        if (!n6 || !(l9 == null ? void 0 : l9.byteLength))
          continue;
        const a7 = e11[i7], c6 = "fulfilled" === a7.status ? a7.value : null;
        if (c6) {
          const t10 = c6.id;
          s8[n6.sourceName] = { refKey: t10, protobuff: l9 }, r13.push(l9);
        }
      }
      return { sourceName2DataAndRefKey: s8, transferList: r13 };
    });
  }
};
function h4(t8) {
  return () => t8.abort();
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileManager.js
var l4 = 512;
var s4 = 1e-6;
var r10 = (e11, i7) => e11 + 1 / (1 << 2 * i7);
var o2 = class {
  constructor(i7, t8) {
    this._tiles = /* @__PURE__ */ new Map(), this._tileCache = new e3(40, (e11) => e11.dispose()), this._viewSize = [0, 0], this._visibleTiles = /* @__PURE__ */ new Map(), this.acquireTile = i7.acquireTile, this.releaseTile = i7.releaseTile, this.tileInfoView = i7.tileInfoView, this._container = t8;
  }
  destroy() {
    for (const [e11, i7] of this._tiles)
      i7.dispose();
    this._tiles = null, this._tileCache.clear(), this._tileCache = null;
  }
  update(e11) {
    this._updateCacheSize(e11);
    const l9 = this.tileInfoView, s7 = l9.getTileCoverage(e11.state, 0, true, "smallest");
    if (!s7)
      return true;
    const { spans: r12, lodInfo: o6 } = s7, { level: n6 } = o6, a7 = this._tiles, c6 = /* @__PURE__ */ new Set(), h6 = /* @__PURE__ */ new Set();
    for (const { row: i7, colFrom: _2, colTo: f5 } of r12)
      for (let e12 = _2; e12 <= f5; e12++) {
        const l10 = e4.getId(n6, i7, o6.normalizeCol(e12), o6.getWorldForColumn(e12)), s8 = this._getOrAcquireTile(l10);
        c6.add(l10), s8.processed() ? this._addToContainer(s8) : h6.add(new e4(l10));
      }
    for (const [i7, t8] of a7)
      t8.isCoverage = c6.has(i7);
    for (const i7 of h6)
      this._findPlaceholdersForMissingTiles(i7, c6);
    let d3 = false;
    for (const [i7, t8] of a7)
      t8.neededForCoverage = c6.has(i7), t8.neededForCoverage || t8.isHoldingForFade && l9.intersects(s7, t8.key) && c6.add(i7), t8.isFading && (d3 = true);
    for (const [i7, t8] of this._tiles)
      c6.has(i7) || this._releaseTile(i7);
    return l.pool.release(s7), !d3;
  }
  clear() {
    this._tiles.clear(), this._tileCache.clear(), this._visibleTiles.clear();
  }
  clearCache() {
    this._tileCache.clear();
  }
  _findPlaceholdersForMissingTiles(e11, i7) {
    const t8 = [];
    for (const [s7, r12] of this._tiles)
      this._addPlaceholderChild(t8, r12, e11, i7);
    const l9 = t8.reduce(r10, 0);
    Math.abs(1 - l9) < s4 || this._addPlaceholderParent(e11.id, i7);
  }
  _addPlaceholderChild(e11, i7, t8, l9) {
    i7.key.level <= t8.level || !i7.hasData() || a6(t8, i7.key) && (this._addToContainer(i7), l9.add(i7.id), e11.push(i7.key.level - t8.level));
  }
  _addPlaceholderParent(e11, i7) {
    const t8 = this._tiles;
    let l9 = e11;
    for (; ; ) {
      if (l9 = n4(l9), !l9 || i7.has(l9))
        return;
      const e12 = t8.get(l9);
      if (e12 && e12.hasData())
        return this._addToContainer(e12), void i7.add(e12.id);
    }
  }
  _getOrAcquireTile(e11) {
    let i7 = this._tiles.get(e11);
    return i7 || (i7 = this._tileCache.pop(e11), i7 || (i7 = this.acquireTile(new e4(e11))), this._tiles.set(e11, i7), i7);
  }
  _releaseTile(e11) {
    const i7 = this._tiles.get(e11);
    this.releaseTile(i7), this._removeFromContainer(i7), this._tiles.delete(e11), i7.hasData() ? this._tileCache.put(e11, i7, 1) : i7.dispose();
  }
  _addToContainer(e11) {
    let i7;
    const t8 = [], l9 = this._container;
    if (l9.contains(e11))
      return;
    const s7 = this._visibleTiles;
    for (const [r12, o6] of s7)
      this._canConnectDirectly(e11, o6) && t8.push(o6), null == i7 && this._canConnectDirectly(o6, e11) && (i7 = o6);
    if (null != i7) {
      for (const l10 of t8)
        i7.childrenTiles.delete(l10), e11.childrenTiles.add(l10), l10.parentTile = e11;
      i7.childrenTiles.add(e11), e11.parentTile = i7;
    } else
      for (const r12 of t8)
        e11.childrenTiles.add(r12), r12.parentTile = e11;
    s7.set(e11.id, e11), l9.addChild(e11);
  }
  _removeFromContainer(e11) {
    if (this._visibleTiles.delete(e11.id), this._container.removeChild(e11), null != e11.parentTile) {
      e11.parentTile.childrenTiles.delete(e11);
      for (const i7 of e11.childrenTiles)
        null != e11.parentTile && e11.parentTile.childrenTiles.add(i7);
    }
    for (const i7 of e11.childrenTiles)
      i7.parentTile = e11.parentTile;
    e11.parentTile = null, e11.childrenTiles.clear();
  }
  _canConnectDirectly(e11, i7) {
    const t8 = e11.key;
    let { level: l9, row: s7, col: r12, world: o6 } = i7.key;
    const n6 = this._visibleTiles;
    for (; l9 > 0; ) {
      if (l9--, s7 >>= 1, r12 >>= 1, t8.level === l9 && t8.row === s7 && t8.col === r12 && t8.world === o6)
        return true;
      if (n6.has(`${l9}/${s7}/${r12}/${o6}`))
        return false;
    }
    return false;
  }
  _updateCacheSize(e11) {
    const i7 = e11.state.size;
    if (i7[0] === this._viewSize[0] && i7[1] === this._viewSize[1])
      return;
    const t8 = Math.ceil(i7[0] / l4) + 1, s7 = Math.ceil(i7[1] / l4) + 1;
    this._viewSize[0] = i7[0], this._viewSize[1] = i7[1], this._tileCache.maxSize = 5 * t8 * s7;
  }
};
function n4(e11) {
  const [i7, t8, l9, s7] = e11.split("/"), r12 = parseInt(i7, 10);
  return 0 === r12 ? null : `${r12 - 1}/${parseInt(t8, 10) >> 1}/${parseInt(l9, 10) >> 1}/${parseInt(s7, 10)}`;
}
function a6(e11, i7) {
  const t8 = i7.level - e11.level;
  return e11.row === i7.row >> t8 && e11.col === i7.col >> t8 && e11.world === i7.world;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/core.js
var t3 = class {
  constructor(t8) {
    this.xTile = 0, this.yTile = 0, this.hash = 0, this.priority = 1, this.colliders = [], this.textVertexRanges = [], this.iconVertexRanges = [], this.tile = t8;
  }
};
var s5 = class {
  constructor() {
    this.tileSymbols = [], this.parts = [{ startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }, { startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }], this.show = false;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/util.js
function s6(t8, e11, s7, o6, l9, i7) {
  const r12 = s7 - l9;
  if (r12 >= 0)
    return (e11 >> r12) + (o6 - (i7 << r12)) * (t8 >> r12);
  const n6 = -r12;
  return e11 - (i7 - (o6 << n6)) * (t8 >> n6) << n6;
}
var o3 = class {
  constructor(t8, e11, s7) {
    this._rows = Math.ceil(e11 / s7), this._columns = Math.ceil(t8 / s7), this._cellSize = s7, this.cells = new Array(this._rows);
    for (let o6 = 0; o6 < this._rows; o6++) {
      this.cells[o6] = new Array(this._columns);
      for (let t9 = 0; t9 < this._columns; t9++)
        this.cells[o6][t9] = [];
    }
  }
  getCell(t8, e11) {
    const s7 = Math.min(Math.max(Math.floor(e11 / this._cellSize), 0), this._rows - 1), o6 = Math.min(Math.max(Math.floor(t8 / this._cellSize), 0), this._columns - 1);
    return this.cells[s7] && this.cells[s7][o6] || null;
  }
  getCellSpan(t8, e11, s7, o6) {
    return [Math.min(Math.max(Math.floor(t8 / this._cellSize), 0), this.columns - 1), Math.min(Math.max(Math.floor(e11 / this._cellSize), 0), this.rows - 1), Math.min(Math.max(Math.floor(s7 / this._cellSize), 0), this.columns - 1), Math.min(Math.max(Math.floor(o6 / this._cellSize), 0), this.rows - 1)];
  }
  get cellSize() {
    return this._cellSize;
  }
  get columns() {
    return this._columns;
  }
  get rows() {
    return this._rows;
  }
};
function l5(t8, s7, o6, l9, i7, r12) {
  const n6 = s7[l9++];
  for (let a7 = 0; a7 < n6; a7++) {
    const n7 = new t3(r12);
    n7.xTile = s7[l9++], n7.yTile = s7[l9++], n7.hash = s7[l9++], n7.priority = s7[l9++];
    const a8 = s7[l9++];
    for (let t9 = 0; t9 < a8; t9++) {
      const t10 = s7[l9++], e11 = s7[l9++], i8 = s7[l9++], r13 = s7[l9++], a9 = !!s7[l9++], c7 = s7[l9++], h7 = o6[l9++], f5 = o6[l9++], u5 = s7[l9++], m4 = s7[l9++];
      n7.colliders.push({ xTile: t10, yTile: e11, dxPixels: i8, dyPixels: r13, hard: a9, partIndex: c7, width: u5, height: m4, minLod: h7, maxLod: f5 });
    }
    const c6 = t8[l9++];
    for (let e11 = 0; e11 < c6; e11++)
      n7.textVertexRanges.push([t8[l9++], t8[l9++]]);
    const h6 = t8[l9++];
    for (let e11 = 0; e11 < h6; e11++)
      n7.iconVertexRanges.push([t8[l9++], t8[l9++]]);
    i7.push(n7);
  }
  return l9;
}
function i3(t8, e11, s7) {
  for (const [o6, l9] of t8.symbols)
    r11(t8, e11, s7, l9, o6);
}
function r11(e11, s7, o6, l9, i7) {
  const r12 = e11.layerData.get(i7);
  if (r12.type === E.SYMBOL) {
    for (const t8 of l9) {
      const s8 = t8.unique;
      let l10;
      if (t8.selectedForRendering) {
        const t9 = s8.parts[0], i8 = t9.startOpacity, r13 = t9.targetOpacity;
        e11.allSymbolsFadingOut = e11.allSymbolsFadingOut && 0 === r13;
        const n6 = o6 ? Math.floor(127 * i8) | r13 << 7 : r13 ? 255 : 0;
        l10 = n6 << 24 | n6 << 16 | n6 << 8 | n6;
      } else
        l10 = 0;
      for (const [e12, o7] of t8.iconVertexRanges)
        for (let t9 = e12; t9 < e12 + o7; t9 += 4)
          r12.iconOpacity[t9 / 4] = l10;
      if (t8.selectedForRendering) {
        const t9 = s8.parts[1], i8 = t9.startOpacity, r13 = t9.targetOpacity;
        e11.allSymbolsFadingOut = e11.allSymbolsFadingOut && 0 === r13;
        const n6 = o6 ? Math.floor(127 * i8) | r13 << 7 : r13 ? 255 : 0;
        l10 = n6 << 24 | n6 << 16 | n6 << 8 | n6;
      } else
        l10 = 0;
      for (const [e12, o7] of t8.textVertexRanges)
        for (let t9 = e12; t9 < e12 + o7; t9 += 4)
          r12.textOpacity[t9 / 4] = l10;
    }
    r12.lastOpacityUpdate = s7, r12.opacityChanged = true;
  }
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/RenderBucket.js
var o4 = class {
  constructor(t8, e11) {
    this.layerUIDs = [], this.isDestroyed = false, this._data = t8;
    let r12 = 1;
    const n6 = new Uint32Array(t8);
    this.layerUIDs = [];
    const s7 = n6[r12++];
    for (let i7 = 0; i7 < s7; i7++)
      this.layerUIDs[i7] = n6[r12++];
    this.bufferDataOffset = r12, e11 && (this.layer = e11.getStyleLayerByUID(this.layerUIDs[0]));
  }
  get isPreparedForRendering() {
    return null == this._data;
  }
  get offset() {
    return this.bufferDataOffset;
  }
  get data() {
    return this._data;
  }
  destroy() {
    this.isDestroyed || (this.doDestroy(), this._data = null, this.isDestroyed = true);
  }
  prepareForRendering(t8) {
    null != this._data && (this.doPrepareForRendering(t8, this._data, this.bufferDataOffset), this._data = null);
  }
};
var h5 = class extends o4 {
  constructor(t8, e11) {
    super(t8, e11), this.type = E.LINE, this.lineIndexStart = 0, this.lineIndexCount = 0;
    const n6 = new Uint32Array(t8);
    let s7 = this.bufferDataOffset;
    this.lineIndexStart = n6[s7++], this.lineIndexCount = n6[s7++];
    const i7 = n6[s7++];
    if (i7 > 0) {
      this.patternMap = /* @__PURE__ */ new Map();
      for (let t9 = 0; t9 < i7; t9++) {
        const t10 = n6[s7++], e12 = n6[s7++], r12 = n6[s7++];
        this.patternMap.set(t10, [e12, r12]);
      }
    }
    this.bufferDataOffset = s7;
  }
  get memoryUsed() {
    var _a, _b;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.vao) == null ? void 0 : _b.usedMemory) ?? 0);
  }
  hasData() {
    return this.lineIndexCount > 0;
  }
  triangleCount() {
    return this.lineIndexCount / 3;
  }
  doDestroy() {
    this.vao = r(this.vao);
  }
  doPrepareForRendering(t8, e11, r12) {
    const n6 = new Uint32Array(e11), o6 = new Int32Array(n6.buffer), h6 = n6[r12++], f5 = h3.createVertex(t8, F.STATIC_DRAW, new Int32Array(o6.buffer, 4 * r12, h6));
    r12 += h6;
    const c6 = n6[r12++], l9 = h3.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n6.buffer, 4 * r12, c6));
    r12 += c6;
    const u5 = this.layer.lineMaterial;
    this.vao = new f3(t8, u5.getAttributeLocations(), u5.getLayoutInfo(), { geometry: f5 }, l9);
  }
};
var f4 = class extends o4 {
  constructor(t8, e11) {
    super(t8, e11), this.type = E.FILL, this.fillIndexStart = 0, this.fillIndexCount = 0, this.outlineIndexStart = 0, this.outlineIndexCount = 0;
    const n6 = new Uint32Array(t8);
    let s7 = this.bufferDataOffset;
    this.fillIndexStart = n6[s7++], this.fillIndexCount = n6[s7++], this.outlineIndexStart = n6[s7++], this.outlineIndexCount = n6[s7++];
    const i7 = n6[s7++];
    if (i7 > 0) {
      this.patternMap = /* @__PURE__ */ new Map();
      for (let t9 = 0; t9 < i7; t9++) {
        const t10 = n6[s7++], e12 = n6[s7++], r12 = n6[s7++];
        this.patternMap.set(t10, [e12, r12]);
      }
    }
    this.bufferDataOffset = s7;
  }
  get memoryUsed() {
    var _a, _b, _c;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.fillVAO) == null ? void 0 : _b.usedMemory) ?? 0) + (((_c = this.outlineVAO) == null ? void 0 : _c.usedMemory) ?? 0);
  }
  hasData() {
    return this.fillIndexCount > 0 || this.outlineIndexCount > 0;
  }
  triangleCount() {
    return (this.fillIndexCount + this.outlineIndexCount) / 3;
  }
  doDestroy() {
    this.fillVAO = r(this.fillVAO), this.outlineVAO = r(this.outlineVAO);
  }
  doPrepareForRendering(t8, e11, r12) {
    const n6 = new Uint32Array(e11), o6 = new Int32Array(n6.buffer), h6 = n6[r12++], f5 = h3.createVertex(t8, F.STATIC_DRAW, new Int32Array(o6.buffer, 4 * r12, h6));
    r12 += h6;
    const c6 = n6[r12++], l9 = h3.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n6.buffer, 4 * r12, c6));
    r12 += c6;
    const u5 = n6[r12++], y4 = h3.createVertex(t8, F.STATIC_DRAW, new Int32Array(o6.buffer, 4 * r12, u5));
    r12 += u5;
    const d3 = n6[r12++], A2 = h3.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n6.buffer, 4 * r12, d3));
    r12 += d3;
    const I3 = this.layer, g = I3.fillMaterial, p3 = I3.outlineMaterial;
    this.fillVAO = new f3(t8, g.getAttributeLocations(), g.getLayoutInfo(), { geometry: f5 }, l9), this.outlineVAO = new f3(t8, p3.getAttributeLocations(), p3.getLayoutInfo(), { geometry: y4 }, A2);
  }
};
var c4 = class extends o4 {
  constructor(t8, e11, s7) {
    super(t8, e11), this.type = E.SYMBOL, this.iconPerPageElementsMap = /* @__PURE__ */ new Map(), this.glyphPerPageElementsMap = /* @__PURE__ */ new Map(), this.symbolInstances = [], this.isIconSDF = false, this.opacityChanged = false, this.lastOpacityUpdate = 0, this.symbols = [];
    const i7 = new Uint32Array(t8), a7 = new Int32Array(t8), o6 = new Float32Array(t8);
    let h6 = this.bufferDataOffset;
    this.isIconSDF = !!i7[h6++];
    const f5 = i7[h6++];
    for (let r12 = 0; r12 < f5; r12++) {
      const t9 = i7[h6++], e12 = i7[h6++], r13 = i7[h6++];
      this.iconPerPageElementsMap.set(t9, [e12, r13]);
    }
    const c6 = i7[h6++];
    for (let r12 = 0; r12 < c6; r12++) {
      const t9 = i7[h6++], e12 = i7[h6++], r13 = i7[h6++];
      this.glyphPerPageElementsMap.set(t9, [e12, r13]);
    }
    const l9 = i7[h6++], u5 = i7[h6++];
    this.iconOpacity = new Int32Array(l9), this.textOpacity = new Int32Array(u5), h6 = l5(i7, a7, o6, h6, this.symbols, s7), this.bufferDataOffset = h6;
  }
  get memoryUsed() {
    var _a, _b, _c2;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.iconVAO) == null ? void 0 : _b.usedMemory) ?? 0) + (((_c2 = this.textVAO) == null ? void 0 : _c2.usedMemory) ?? 0) + A(this.iconOpacity) + A(this.textOpacity);
  }
  hasData() {
    return this.iconPerPageElementsMap.size > 0 || this.glyphPerPageElementsMap.size > 0;
  }
  triangleCount() {
    let t8 = 0;
    for (const [e11, r12] of this.iconPerPageElementsMap)
      t8 += r12[1];
    for (const [e11, r12] of this.glyphPerPageElementsMap)
      t8 += r12[1];
    return t8 / 3;
  }
  doDestroy() {
    this.iconVAO = r(this.iconVAO), this.textVAO = r(this.textVAO);
  }
  updateOpacityInfo() {
    if (!this.opacityChanged)
      return;
    this.opacityChanged = false;
    const t8 = this.iconOpacity, e11 = this.iconVAO.vertexBuffers.opacity;
    t8.length > 0 && t8.byteLength === e11.byteLength && e11.setSubData(t8, 0, 0, t8.length);
    const r12 = this.textOpacity, n6 = this.textVAO.vertexBuffers.opacity;
    r12.length > 0 && r12.byteLength === n6.byteLength && n6.setSubData(r12, 0, 0, r12.length);
  }
  doPrepareForRendering(t8, e11, r12) {
    const n6 = new Uint32Array(e11), o6 = new Int32Array(n6.buffer), h6 = n6[r12++], f5 = h3.createVertex(t8, F.STATIC_DRAW, new Int32Array(o6.buffer, 4 * r12, h6));
    r12 += h6;
    const c6 = n6[r12++], l9 = h3.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n6.buffer, 4 * r12, c6));
    r12 += c6;
    const u5 = n6[r12++], y4 = h3.createVertex(t8, F.STATIC_DRAW, new Int32Array(o6.buffer, 4 * r12, u5));
    r12 += u5;
    const d3 = n6[r12++], A2 = h3.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n6.buffer, 4 * r12, d3));
    r12 += d3;
    const I3 = h3.createVertex(t8, F.STATIC_DRAW, this.iconOpacity.buffer), g = h3.createVertex(t8, F.STATIC_DRAW, this.textOpacity.buffer), p3 = this.layer, x = p3.iconMaterial, b2 = p3.textMaterial;
    this.iconVAO = new f3(t8, x.getAttributeLocations(), x.getLayoutInfo(), { geometry: f5, opacity: I3 }, l9), this.textVAO = new f3(t8, b2.getAttributeLocations(), b2.getLayoutInfo(), { geometry: y4, opacity: g }, A2);
  }
};
var l6 = class extends o4 {
  constructor(t8, e11) {
    super(t8, e11), this.type = E.CIRCLE, this.circleIndexStart = 0, this.circleIndexCount = 0;
    const n6 = new Uint32Array(t8);
    let s7 = this.bufferDataOffset;
    this.circleIndexStart = n6[s7++], this.circleIndexCount = n6[s7++], this.bufferDataOffset = s7;
  }
  get memoryUsed() {
    var _a, _b;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.vao) == null ? void 0 : _b.usedMemory) ?? 0);
  }
  hasData() {
    return this.circleIndexCount > 0;
  }
  triangleCount() {
    return this.circleIndexCount / 3;
  }
  doDestroy() {
    this.vao = r(this.vao);
  }
  doPrepareForRendering(t8, e11, r12) {
    const n6 = new Uint32Array(e11), o6 = new Int32Array(n6.buffer), h6 = n6[r12++], f5 = h3.createVertex(t8, F.STATIC_DRAW, new Int32Array(o6.buffer, 4 * r12, h6));
    r12 += h6;
    const c6 = n6[r12++], l9 = h3.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n6.buffer, 4 * r12, c6));
    r12 += c6;
    const u5 = this.layer.circleMaterial;
    this.vao = new f3(t8, u5.getAttributeLocations(), u5.getLayoutInfo(), { geometry: f5 }, l9);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTile.js
var d2 = class _d extends r7 {
  constructor(e11, t8, s7, a7, r12, i7, o6, h6 = null) {
    super(e11, t8, s7, a7, r12, i7, 4096, 4096), this.styleRepository = o6, this._memCache = h6, this.type = "vector-tile", this._referenced = 0, this._hasSymbolBuckets = false, this._memoryUsedByLayerData = 0, this.layerData = /* @__PURE__ */ new Map(), this.status = "loading", this.allSymbolsFadingOut = false, this.lastOpacityUpdate = 0, this.symbols = /* @__PURE__ */ new Map(), this.isCoverage = false, this.neededForCoverage = false, this.decluttered = false, this.parentTile = null, this.childrenTiles = /* @__PURE__ */ new Set(), this._processed = false, this._referenced = 1, this.id = e11.id;
  }
  get hasSymbolBuckets() {
    return this._hasSymbolBuckets;
  }
  get isFading() {
    return this._hasSymbolBuckets && performance.now() - this.lastOpacityUpdate < e5;
  }
  get isHoldingForFade() {
    return this._hasSymbolBuckets && (!this.allSymbolsFadingOut || performance.now() - this.lastOpacityUpdate < e5);
  }
  get wasRequested() {
    return "errored" === this.status || "loaded" === this.status || "reloading" === this.status;
  }
  setData(e11) {
    this.changeDataImpl(e11), this.requestRender(), this.ready(), this._processed = true;
  }
  deleteLayerData(e11) {
    var _a;
    let t8 = false;
    for (const s7 of e11) {
      const e12 = this.layerData.get(s7);
      e12 && (this._memoryUsedByLayerData -= e12.memoryUsed, e12.type === E.SYMBOL && this.symbols.delete(s7) && (t8 = true), e12.destroy(), this.layerData.delete(s7));
    }
    (_a = this._memCache) == null ? void 0 : _a.updateSize(this.key.id, this, this._memoryUsedByLayerData), t8 && this.emit("symbols-changed"), this.requestRender();
  }
  processed() {
    return this._processed;
  }
  hasData() {
    return this.layerData.size > 0;
  }
  dispose() {
    "unloaded" !== this.status && (m2.delete(this), _d._destroyRenderBuckets(this.layerData), this.layerData = null, this._memoryUsedByLayerData = 0, this.destroy(), this.status = "unloaded");
  }
  release() {
    return 0 == --this._referenced && (this.dispose(), this.stage = null, true);
  }
  retain() {
    ++this._referenced;
  }
  get referenced() {
    return this._referenced;
  }
  get memoryUsed() {
    return this._memoryUsedByLayerData + 256;
  }
  changeDataImpl(e11) {
    var _a;
    let t8 = false;
    if (e11) {
      const { bucketsWithData: s7, emptyBuckets: a7 } = e11, r12 = this._createRenderBuckets(s7);
      if (a7 && a7.byteLength > 0) {
        const e12 = new Uint32Array(a7);
        for (const t9 of e12)
          this._deleteLayerData(t9);
      }
      for (const [e12, o6] of r12)
        this._deleteLayerData(e12), o6.type === E.SYMBOL && (this.symbols.set(e12, o6.symbols), t8 = true), this._memoryUsedByLayerData += o6.memoryUsed, this.layerData.set(e12, o6);
      (_a = this._memCache) == null ? void 0 : _a.updateSize(this.key.id, this, this.memoryUsed);
    }
    this._hasSymbolBuckets = false;
    for (const [s7, a7] of this.layerData)
      a7.type === E.SYMBOL && (this._hasSymbolBuckets = true);
    t8 && this.emit("symbols-changed");
  }
  attachWithContext(e11) {
    this.stage = { context: e11, trashDisplayObject(e12) {
      e12.processDetach();
    }, untrashDisplayObject: () => false };
  }
  setTransform(r12) {
    super.setTransform(r12);
    const i7 = this.resolution / (r12.resolution * r12.pixelRatio), o6 = this.width / this.rangeX * i7, h6 = this.height / this.rangeY * i7, n6 = [0, 0];
    r12.toScreen(n6, [this.x, this.y]);
    const l9 = this.transforms.tileUnitsToPixels;
    r3(l9), M(l9, l9, n6), h(l9, l9, Math.PI * r12.rotation / 180), f2(l9, l9, [o6, h6, 1]);
  }
  _createTransforms() {
    return { dvs: e6(), tileMat3: e6(), tileUnitsToPixels: e6() };
  }
  static _destroyRenderBuckets(e11) {
    if (!e11)
      return;
    const t8 = /* @__PURE__ */ new Set();
    for (const s7 of e11.values())
      t8.has(s7) || (s7.destroy(), t8.add(s7));
    e11.clear();
  }
  _createRenderBuckets(e11) {
    const t8 = /* @__PURE__ */ new Map(), s7 = /* @__PURE__ */ new Map();
    for (const a7 of e11) {
      const e12 = this._deserializeBucket(a7, s7);
      for (const s8 of e12.layerUIDs)
        t8.set(s8, e12);
    }
    return t8;
  }
  _deserializeBucket(e11, t8) {
    let s7 = t8.get(e11);
    if (s7)
      return s7;
    switch (new Uint32Array(e11)[0]) {
      case E.FILL:
        s7 = new f4(e11, this.styleRepository);
        break;
      case E.LINE:
        s7 = new h5(e11, this.styleRepository);
        break;
      case E.SYMBOL:
        s7 = new c4(e11, this.styleRepository, this);
        break;
      case E.CIRCLE:
        s7 = new l6(e11, this.styleRepository);
    }
    return t8.set(e11, s7), s7;
  }
  _deleteLayerData(e11) {
    if (!this.layerData.has(e11))
      return;
    const t8 = this.layerData.get(e11);
    this._memoryUsedByLayerData -= t8.memoryUsed, t8.destroy(), this.layerData.delete(e11);
  }
};
var m2 = /* @__PURE__ */ new Map();

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/jobs.js
function i4(e11, t8, n6, o6, i7, l9) {
  const { iconRotationAlignment: a7, textRotationAlignment: c6, iconTranslate: h6, iconTranslateAnchor: u5, textTranslate: d3, textTranslateAnchor: y4 } = o6;
  let x = 0;
  for (const g of e11.colliders) {
    const [e12, o7] = 0 === g.partIndex ? h6 : d3, m4 = 0 === g.partIndex ? u5 : y4, f5 = g.minLod <= l9 && l9 <= g.maxLod;
    x += f5 ? 0 : 1, g.enabled = f5, g.xScreen = g.xTile * i7[0] + g.yTile * i7[3] + i7[6], g.yScreen = g.xTile * i7[1] + g.yTile * i7[4] + i7[7], m4 === r5.MAP ? (g.xScreen += n6 * e12 - t8 * o7, g.yScreen += t8 * e12 + n6 * o7) : (g.xScreen += e12, g.yScreen += o7), l2.VIEWPORT === (0 === g.partIndex ? a7 : c6) ? (g.dxScreen = g.dxPixels, g.dyScreen = g.dyPixels) : (g.dxScreen = n6 * (g.dxPixels + g.width / 2) - t8 * (g.dyPixels + g.height / 2) - g.width / 2, g.dyScreen = t8 * (g.dxPixels + g.width / 2) + n6 * (g.dyPixels + g.height / 2) - g.height / 2);
  }
  e11.colliders.length > 0 && x === e11.colliders.length && (e11.unique.show = false);
}
var l7 = class {
  constructor(o6, r12, s7, i7, l9, a7) {
    this._symbols = o6, this._styleRepository = i7, this._zoom = l9, this._currentLayerCursor = 0, this._currentSymbolCursor = 0, this._styleProps = /* @__PURE__ */ new Map(), this._allNeededMatrices = /* @__PURE__ */ new Map(), this._gridIndex = new o3(r12, s7, t2), this._si = Math.sin(Math.PI * a7 / 180), this._co = Math.cos(Math.PI * a7 / 180);
    for (const t8 of o6)
      for (const n6 of t8.symbols)
        this._allNeededMatrices.has(n6.tile) || this._allNeededMatrices.set(n6.tile, r6(n6.tile.transforms.tileUnitsToPixels));
  }
  work(e11) {
    const t8 = this._gridIndex;
    function n6(e12) {
      const n7 = e12.xScreen + e12.dxScreen, o7 = e12.yScreen + e12.dyScreen, r12 = n7 + e12.width, s7 = o7 + e12.height, [i7, l9, a7, c6] = t8.getCellSpan(n7, o7, r12, s7);
      for (let h6 = l9; h6 <= c6; h6++)
        for (let e13 = i7; e13 <= a7; e13++) {
          const i8 = t8.cells[h6][e13];
          for (const e14 of i8) {
            const t9 = e14.xScreen + e14.dxScreen, i9 = e14.yScreen + e14.dyScreen, l10 = t9 + e14.width, a8 = i9 + e14.height;
            if (!(r12 < t9 || n7 > l10 || s7 < i9 || o7 > a8))
              return true;
          }
        }
      return false;
    }
    const o6 = performance.now();
    for (; this._currentLayerCursor < this._symbols.length; this._currentLayerCursor++, this._currentSymbolCursor = 0) {
      const t9 = this._symbols[this._currentLayerCursor], r12 = this._getProperties(t9.styleLayerUID);
      for (; this._currentSymbolCursor < t9.symbols.length; this._currentSymbolCursor++) {
        if (this._currentSymbolCursor % 100 == 99 && performance.now() - o6 > e11)
          return false;
        const s7 = t9.symbols[this._currentSymbolCursor];
        if (!s7.unique.show)
          continue;
        i4(s7, this._si, this._co, r12, this._allNeededMatrices.get(s7.tile), this._zoom);
        const l9 = s7.unique;
        if (!l9.show)
          continue;
        const { iconAllowOverlap: a7, iconIgnorePlacement: c6, textAllowOverlap: h6, textIgnorePlacement: u5 } = r12;
        for (const e12 of s7.colliders) {
          if (!e12.enabled)
            continue;
          const t10 = l9.parts[e12.partIndex];
          if (!t10.show)
            continue;
          !(e12.partIndex ? h6 : a7) && n6(e12) && (e12.hard ? l9.show = false : t10.show = false);
        }
        if (l9.show)
          for (const e12 of s7.colliders) {
            if (!e12.enabled)
              continue;
            if (e12.partIndex ? u5 : c6)
              continue;
            if (!l9.parts[e12.partIndex].show)
              continue;
            const t10 = e12.xScreen + e12.dxScreen, n7 = e12.yScreen + e12.dyScreen, o7 = t10 + e12.width, r13 = n7 + e12.height, [s8, i7, a8, h7] = this._gridIndex.getCellSpan(t10, n7, o7, r13);
            for (let l10 = i7; l10 <= h7; l10++)
              for (let t11 = s8; t11 <= a8; t11++) {
                this._gridIndex.cells[l10][t11].push(e12);
              }
          }
      }
    }
    return true;
  }
  _getProperties(e11) {
    const t8 = this._styleProps.get(e11);
    if (t8)
      return t8;
    const n6 = this._zoom, s7 = this._styleRepository.getStyleLayerByUID(e11), i7 = s7.getLayoutValue("symbol-placement", n6) !== n.POINT;
    let l9 = s7.getLayoutValue("icon-rotation-alignment", n6);
    l9 === l2.AUTO && (l9 = i7 ? l2.MAP : l2.VIEWPORT);
    let a7 = s7.getLayoutValue("text-rotation-alignment", n6);
    a7 === l2.AUTO && (a7 = i7 ? l2.MAP : l2.VIEWPORT);
    const c6 = s7.getPaintValue("icon-translate", n6), h6 = s7.getPaintValue("icon-translate-anchor", n6), u5 = s7.getPaintValue("text-translate", n6), d3 = s7.getPaintValue("text-translate-anchor", n6), y4 = { iconAllowOverlap: s7.getLayoutValue("icon-allow-overlap", n6), iconIgnorePlacement: s7.getLayoutValue("icon-ignore-placement", n6), textAllowOverlap: s7.getLayoutValue("text-allow-overlap", n6), textIgnorePlacement: s7.getLayoutValue("text-ignore-placement", n6), iconRotationAlignment: l9, textRotationAlignment: a7, iconTranslateAnchor: h6, iconTranslate: c6, textTranslateAnchor: d3, textTranslate: u5 };
    return this._styleProps.set(e11, y4), y4;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolDeclutterer.js
function t4(o6, t8) {
  if (o6.priority - t8.priority)
    return o6.priority - t8.priority;
  const e11 = o6.tile.key, i7 = t8.tile.key;
  return e11.world - i7.world ? e11.world - i7.world : e11.level - i7.level ? e11.level - i7.level : e11.row - i7.row ? e11.row - i7.row : e11.col - i7.col ? e11.col - i7.col : o6.xTile - t8.xTile ? o6.xTile - t8.xTile : o6.yTile - t8.yTile;
}
var e10 = class {
  get running() {
    return this._running;
  }
  constructor(o6, t8, e11, i7, s7, n6) {
    this._visibleTiles = o6, this._symbolRepository = t8, this._createCollisionJob = e11, this._assignTileSymbolsOpacity = i7, this._symbolLayerSorter = s7, this._isLayerVisible = n6, this._selectionJob = null, this._selectionJobCompleted = false, this._collisionJob = null, this._collisionJobCompleted = false, this._opacityJob = null, this._opacityJobCompleted = false, this._running = true;
  }
  setScreenSize(o6, t8) {
    this._screenWidth === o6 && this._screenHeight === t8 || this.restart(), this._screenWidth = o6, this._screenHeight = t8;
  }
  restart() {
    this._selectionJob = null, this._selectionJobCompleted = false, this._collisionJob = null, this._collisionJobCompleted = false, this._opacityJob = null, this._opacityJobCompleted = false, this._running = true;
  }
  continue(o6) {
    if (this._selectionJob || (this._selectionJob = this._createSelectionJob()), !this._selectionJobCompleted) {
      const t8 = performance.now();
      if (!this._selectionJob.work(o6))
        return false;
      if (this._selectionJobCompleted = true, 0 === (o6 = Math.max(0, o6 - (performance.now() - t8))))
        return false;
    }
    if (this._collisionJob || (this._collisionJob = this._createCollisionJob(this._selectionJob.sortedSymbols, this._screenWidth, this._screenHeight)), !this._collisionJobCompleted) {
      const t8 = performance.now();
      if (!this._collisionJob.work(o6))
        return false;
      if (this._collisionJobCompleted = true, 0 === (o6 = Math.max(0, o6 - (performance.now() - t8))))
        return false;
    }
    if (this._opacityJob || (this._opacityJob = this._createOpacityJob()), !this._opacityJobCompleted) {
      const t8 = performance.now();
      if (!this._opacityJob.work(o6))
        return false;
      if (this._opacityJobCompleted = true, 0 === (o6 = Math.max(0, o6 - (performance.now() - t8))))
        return false;
    }
    return this._running = false, true;
  }
  _createSelectionJob() {
    const o6 = this._symbolRepository.uniqueSymbols;
    for (let t8 = 0; t8 < o6.length; t8++) {
      const e12 = o6[t8];
      for (let o7 = 0; o7 < e12.uniqueSymbols.length; o7++) {
        const t9 = e12.uniqueSymbols[o7];
        for (const o8 of t9.tileSymbols)
          o8.selectedForRendering = false;
      }
    }
    const e11 = [];
    let i7 = 0, s7 = 0;
    const n6 = this._isLayerVisible;
    function r12(r13) {
      let l10;
      const c6 = performance.now();
      for (; s7 < o6.length; s7++, i7 = 0) {
        const t8 = o6[s7], h6 = t8.styleLayerUID;
        if (!n6(h6)) {
          e11[s7] || (e11[s7] = { styleLayerUID: h6, symbols: [] });
          continue;
        }
        e11[s7] = e11[s7] || { styleLayerUID: h6, symbols: [] };
        const a7 = e11[s7];
        for (; i7 < t8.uniqueSymbols.length; i7++) {
          if (l10 = t8.uniqueSymbols[i7], i7 % 100 == 99 && performance.now() - c6 > r13)
            return false;
          let o7 = null, e12 = false, s8 = false;
          for (const t9 of l10.tileSymbols)
            if (!s8 || !e12) {
              const i8 = t9.tile;
              (!o7 || i8.isCoverage || i8.neededForCoverage && !e12) && (o7 = t9, (i8.neededForCoverage || i8.isCoverage) && (s8 = true), i8.isCoverage && (e12 = true));
            }
          if (o7.selectedForRendering = true, s8) {
            a7.symbols.push(o7), l10.show = true;
            for (const o8 of l10.parts)
              o8.show = true;
          } else
            l10.show = false;
        }
      }
      for (const o7 of e11)
        o7.symbols.sort(t4);
      return true;
    }
    const l9 = this._symbolLayerSorter;
    return { work: r12, get sortedSymbols() {
      return e11.sort(l9);
    } };
  }
  _createOpacityJob() {
    const o6 = this._assignTileSymbolsOpacity, t8 = this._visibleTiles;
    let e11 = 0;
    function s7(t9, e12) {
      const n6 = t9.symbols;
      for (const [o7, s8] of n6)
        i5(s8, e12);
      o6(t9, e12);
      for (const o7 of t9.childrenTiles)
        s7(o7, e12);
    }
    return { work(o7) {
      const i7 = performance.now();
      for (; e11 < t8.length; e11++) {
        if (performance.now() - i7 > o7)
          return false;
        const n6 = t8[e11];
        if (null != n6.parentTile)
          continue;
        s7(n6, performance.now());
      }
      return true;
    } };
  }
};
function i5(t8, e11) {
  for (const i7 of t8) {
    const t9 = i7.unique;
    for (const i8 of t9.parts) {
      const s7 = i8.targetOpacity > 0.5 ? 1 : -1;
      i8.startOpacity += s7 * ((e11 - i8.startTime) / e5), i8.startOpacity = Math.min(Math.max(i8.startOpacity, 0), 1), i8.startTime = e11, i8.targetOpacity = t9.show && i8.show ? 1 : 0;
    }
  }
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolRepository.js
var l8 = 32;
var o5 = 8;
var t5 = 64;
var i6 = class {
  constructor(e11, s7, l9) {
    this.tileCoordRange = e11, this._visibleTiles = s7, this._createUnique = l9, this._tiles = /* @__PURE__ */ new Map(), this._uniqueSymbolsReferences = /* @__PURE__ */ new Map();
  }
  get uniqueSymbols() {
    return null == this._uniqueSymbolLayerArray && (this._uniqueSymbolLayerArray = this._createUniqueSymbolLayerArray()), this._uniqueSymbolLayerArray;
  }
  add(s7, i7) {
    this._uniqueSymbolLayerArray = null;
    let n6 = this._tiles.get(s7.id);
    n6 || (n6 = { symbols: /* @__PURE__ */ new Map() }, this._tiles.set(s7.id, n6));
    const r12 = /* @__PURE__ */ new Map();
    if (i7)
      for (const e11 of i7)
        n6.symbols.has(e11) && (r12.set(e11, n6.symbols.get(e11)), n6.symbols.delete(e11));
    else
      for (const [e11, l9] of s7.layerData)
        n6.symbols.has(e11) && (r12.set(e11, n6.symbols.get(e11)), n6.symbols.delete(e11));
    this._removeSymbols(r12);
    const y4 = s7.symbols, a7 = /* @__PURE__ */ new Map();
    for (const [f5, c6] of y4) {
      let s8 = c6.length;
      if (s8 >= l8) {
        let l9 = this.tileCoordRange;
        do {
          l9 /= 2, s8 /= 4;
        } while (s8 > o5 && l9 > t5);
        const i8 = new o3(this.tileCoordRange, this.tileCoordRange, l9);
        a7.set(f5, { flat: c6, index: i8 }), n6.symbols.set(f5, { flat: c6, index: i8 });
        for (const e11 of c6)
          i8.getCell(e11.xTile, e11.yTile).push(e11);
      } else
        a7.set(f5, { flat: c6 }), n6.symbols.set(f5, { flat: c6 });
    }
    this._addSymbols(s7.key, y4);
  }
  deleteStyleLayers(e11) {
    this._uniqueSymbolLayerArray = null;
    for (const [s7, l9] of this._tiles) {
      const o6 = /* @__PURE__ */ new Map();
      for (const s8 of e11)
        l9.symbols.has(s8) && (o6.set(s8, l9.symbols.get(s8)), l9.symbols.delete(s8));
      this._removeSymbols(o6), 0 === l9.symbols.size && this._tiles.delete(s7);
    }
  }
  removeTile(e11) {
    this._uniqueSymbolLayerArray = null;
    const s7 = this._tiles.get(e11.id);
    if (!s7)
      return;
    const l9 = /* @__PURE__ */ new Map();
    for (const [o6, t8] of e11.symbols)
      s7.symbols.has(o6) && (l9.set(o6, s7.symbols.get(o6)), s7.symbols.delete(o6));
    this._removeSymbols(l9), 0 === s7.symbols.size && this._tiles.delete(e11.id);
  }
  _removeSymbols(e11) {
    for (const [s7, { flat: l9 }] of e11)
      for (const e12 of l9) {
        const l10 = e12.unique, o6 = l10.tileSymbols, t8 = o6.length - 1;
        for (let s8 = 0; s8 < t8; s8++)
          if (o6[s8] === e12) {
            o6[s8] = o6[t8];
            break;
          }
        if (o6.length = t8, 0 === t8) {
          const e13 = this._uniqueSymbolsReferences.get(s7);
          e13.delete(l10), 0 === e13.size && this._uniqueSymbolsReferences.delete(s7);
        }
        e12.unique = null;
      }
  }
  _addSymbols(e11, s7) {
    if (0 === s7.size)
      return;
    const l9 = this._visibleTiles;
    for (const o6 of l9)
      o6.parentTile || o6.key.world !== e11.world || o6.key.level === e11.level && !o6.key.equals(e11) || this._matchSymbols(o6, e11, s7);
    for (const [o6, t8] of s7)
      for (const e12 of t8)
        if (null == e12.unique) {
          const s8 = this._createUnique();
          e12.unique = s8, s8.tileSymbols.push(e12);
          let l10 = this._uniqueSymbolsReferences.get(o6);
          l10 || (l10 = /* @__PURE__ */ new Set(), this._uniqueSymbolsReferences.set(o6, l10)), l10.add(s8);
        }
  }
  _matchSymbols(e11, l9, o6) {
    if (e11.key.level > l9.level) {
      const s7 = e11.key.level - l9.level;
      if (e11.key.row >> s7 !== l9.row || e11.key.col >> s7 !== l9.col)
        return;
    }
    if (l9.level > e11.key.level) {
      const s7 = l9.level - e11.key.level;
      if (l9.row >> s7 !== e11.key.row || l9.col >> s7 !== e11.key.col)
        return;
    }
    if (l9.equals(e11.key)) {
      for (const s7 of e11.childrenTiles)
        this._matchSymbols(s7, l9, o6);
      return;
    }
    const t8 = /* @__PURE__ */ new Map();
    for (const [i7, n6] of o6) {
      const o7 = [];
      for (const t9 of n6) {
        const i8 = s6(this.tileCoordRange, t9.xTile, l9.level, l9.col, e11.key.level, e11.key.col), n7 = s6(this.tileCoordRange, t9.yTile, l9.level, l9.row, e11.key.level, e11.key.row);
        i8 >= 0 && i8 < this.tileCoordRange && n7 >= 0 && n7 < this.tileCoordRange && o7.push({ symbol: t9, xTransformed: i8, yTransformed: n7 });
      }
      const r12 = [], y4 = e11.key.level < l9.level ? 1 : 1 << e11.key.level - l9.level, a7 = this._tiles.get(e11.id).symbols.get(i7);
      if (a7) {
        const e12 = a7.flat;
        for (const s7 of o7) {
          let l10, o8 = false;
          const t9 = s7.xTransformed, i8 = s7.yTransformed;
          l10 = null != a7.index ? a7.index.getCell(t9, i8) : e12;
          const n7 = s7.symbol, f5 = n7.hash;
          for (const e13 of l10)
            if (f5 === e13.hash && Math.abs(t9 - e13.xTile) <= y4 && Math.abs(i8 - e13.yTile) <= y4) {
              const s8 = e13.unique;
              n7.unique = s8, s8.tileSymbols.push(n7), o8 = true;
              break;
            }
          o8 || r12.push(n7);
        }
      }
      r12.length > 0 && t8.set(i7, r12);
    }
    for (const s7 of e11.childrenTiles)
      this._matchSymbols(s7, l9, t8);
  }
  _createUniqueSymbolLayerArray() {
    const e11 = this._uniqueSymbolsReferences, s7 = new Array(e11.size);
    let l9, o6 = 0;
    for (const [t8, i7] of e11) {
      const e12 = new Array(i7.size);
      l9 = 0;
      for (const s8 of i7)
        e12[l9++] = s8;
      s7[o6] = { styleLayerUID: t8, uniqueSymbols: e12 }, o6++;
    }
    return s7;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolFader.js
var n5 = 0.5;
var c5 = 1e-6;
var _ = class {
  constructor(e11, i7) {
    this.styleRepository = e11, this._tileToHandle = /* @__PURE__ */ new Map(), this._viewState = { scale: 0, rotation: 0, center: [0, 0], size: [0, 0] }, this._declutterViewState = { scale: 0, rotation: 0, center: [0, 0], size: [0, 0] }, this._completed = false, this._fading = r2(false), this._symbolRepository = new i6(4096, i7, () => new s5()), this._symbolDeclutterer = new e10(i7, this._symbolRepository, (t8, e12, i8) => new l7(t8, e12, i8, this.styleRepository, this._zoom, this._viewState.rotation), (t8, e12) => {
      t8.allSymbolsFadingOut = true, t8.lastOpacityUpdate = e12, i3(t8, e12, true), t8.decluttered = true, t8.requestRender();
    }, (t8, e12) => this.styleRepository.getStyleLayerByUID(t8.styleLayerUID).z - this.styleRepository.getStyleLayerByUID(e12.styleLayerUID).z, (t8) => {
      const e12 = this.styleRepository.getStyleLayerByUID(t8);
      if (this._zoom + c5 < e12.minzoom || this._zoom - c5 >= e12.maxzoom)
        return false;
      const i8 = e12.getLayoutProperty("visibility");
      return !i8 || i8.getValue() !== i.NONE;
    });
  }
  get fading() {
    return this._fading.value;
  }
  addTile(t8) {
    t8.decluttered = false, this._tileToHandle.set(t8, t8.on("symbols-changed", () => {
      this._symbolRepository.add(t8), this.restartDeclutter();
    })), this._symbolRepository.add(t8), this.restartDeclutter();
  }
  removeTile(t8) {
    const e11 = this._tileToHandle.get(t8);
    e11 && (this._symbolRepository.removeTile(t8), this.restartDeclutter(), e11.remove(), this._tileToHandle.delete(t8));
  }
  update(t8, e11) {
    return this._zoom = t8, this._viewState = { scale: e11.scale, rotation: e11.rotation, center: [e11.center[0], e11.center[1]], size: [e11.size[0], e11.size[1]] }, this._continueDeclutter(), this._completed;
  }
  restartDeclutter() {
    this._completed = false, this._symbolDeclutterer.restart(), this._notifyUnstable();
  }
  clear() {
    this._completed = false, this._symbolRepository = null, this._symbolDeclutterer.restart(), this._tileToHandle.forEach((t8) => t8.remove()), this._tileToHandle.clear();
  }
  get stale() {
    return this._zoom !== this._declutterZoom || this._viewState.size[0] !== this._declutterViewState.size[0] || this._viewState.size[1] !== this._declutterViewState.size[1] || this._viewState.scale !== this._declutterViewState.scale || this._viewState.rotation !== this._declutterViewState.rotation;
  }
  deleteStyleLayers(t8) {
    this._symbolRepository.deleteStyleLayers(t8);
  }
  _continueDeclutter() {
    this._completed && !this.stale || (this._symbolDeclutterer.running || (this._declutterZoom = this._zoom, this._declutterViewState.center[0] = this._viewState.center[0], this._declutterViewState.center[1] = this._viewState.center[1], this._declutterViewState.rotation = this._viewState.rotation, this._declutterViewState.scale = this._viewState.scale, this._declutterViewState.size[0] = this._viewState.size[0], this._declutterViewState.size[1] = this._viewState.size[1], this._symbolDeclutterer.restart()), this._symbolDeclutterer.setScreenSize(this._viewState.size[0], this._viewState.size[1]), this._completed = this._symbolDeclutterer.continue(c3), this._completed && this._scheduleNotifyStable());
  }
  _scheduleNotifyStable() {
    null != this._stableNotificationHandle && clearTimeout(this._stableNotificationHandle), this._stableNotificationHandle = setTimeout(() => {
      this._stableNotificationHandle = null, this._fading.value = false;
    }, (1 + n5) * e5);
  }
  _notifyUnstable() {
    null != this._stableNotificationHandle && (clearTimeout(this._stableNotificationHandle), this._stableNotificationHandle = null), this._fading.value = true;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/RenderableTile.js
var t6 = class extends r7 {
  _createTransforms() {
    return { dvs: e6(), tileMat3: e6() };
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTileContainer.js
var y3 = 1e-6;
function p2(e11, t8) {
  if (e11) {
    const s7 = e11.getLayoutProperty("visibility");
    if (!s7 || s7.getValue() !== i.NONE && (void 0 === e11.minzoom || e11.minzoom < t8 + y3) && (void 0 === e11.maxzoom || e11.maxzoom >= t8 - y3))
      return true;
  }
  return false;
}
var m3 = class extends i2 {
  constructor(e11) {
    super(e11), this._backgroundTiles = [], this._pointToCallbacks = /* @__PURE__ */ new Map();
  }
  destroy() {
    var _a, _b;
    this.removeAllChildren(), (_a = this._spriteMosaic) == null ? void 0 : _a.dispose(), this._spriteMosaic = null, (_b = this._glyphMosaic) == null ? void 0 : _b.dispose(), this._glyphMosaic = null, null != this._symbolFader && (this._symbolFader.clear(), this._symbolFader = null), this._styleRepository = null, this._backgroundTiles = [], this._pointToCallbacks.clear();
  }
  get fading() {
    var _a;
    return ((_a = this._symbolFader) == null ? void 0 : _a.fading) ?? false;
  }
  setStyleResources(e11, t8, r12) {
    this._spriteMosaic = e11, this._glyphMosaic = t8, this._styleRepository = r12, null == this._symbolFader && (this._symbolFader = new _(this._styleRepository, this.children)), this._symbolFader.styleRepository = r12;
  }
  setSpriteMosaic(e11) {
    var _a;
    (_a = this._spriteMosaic) == null ? void 0 : _a.dispose(), this._spriteMosaic = e11;
  }
  deleteStyleLayers(e11) {
    null != this._symbolFader && this._symbolFader.deleteStyleLayers(e11);
  }
  async hitTest(t8) {
    const s7 = C();
    return this._pointToCallbacks.set(t8, s7), this.requestRender(), s7.promise;
  }
  createRenderParams(e11) {
    return { ...super.createRenderParams(e11), renderPass: null, styleLayer: null, styleLayerUID: -1, glyphMosaic: this._glyphMosaic, spriteMosaic: this._spriteMosaic, hasClipping: !!this._clippingInfos };
  }
  doRender(e11) {
    !this.visible || e11.drawPhase !== T.MAP && e11.drawPhase !== T.DEBUG || void 0 === this._spriteMosaic || super.doRender(e11);
  }
  addChild(e11) {
    return super.addChild(e11), null != this._symbolFader ? this._symbolFader.addTile(e11) : e11.decluttered = true, this.requestRender(), e11;
  }
  removeChild(e11) {
    return null != this._symbolFader && this._symbolFader.removeTile(e11), this.requestRender(), super.removeChild(e11);
  }
  renderChildren(e11) {
    const { drawPhase: t8 } = e11;
    if (t8 !== T.DEBUG) {
      if (this._doRender(e11), this._pointToCallbacks.size > 0) {
        e11.drawPhase = T.HITTEST;
        const s7 = e11.painter.effects.hittestVTL;
        s7.bind(e11), this._doRender(e11), s7.draw(e11, this._pointToCallbacks), s7.unbind(e11), e11.drawPhase = t8;
      }
    } else
      super.renderChildren(e11);
  }
  removeAllChildren() {
    for (let e11 = 0; e11 < this.children.length; e11++) {
      const t8 = this.children[e11];
      null != this._symbolFader && this._symbolFader.removeTile(t8), t8.dispose();
    }
    super.removeAllChildren();
  }
  getStencilTarget() {
    return this.children.filter((e11) => e11.neededForCoverage && e11.hasData());
  }
  restartDeclutter() {
    null != this._symbolFader && this._symbolFader.restartDeclutter();
  }
  _doRender(e11) {
    const { context: t8 } = e11, s7 = this._styleRepository;
    if (!s7)
      return;
    const r12 = s7.layers;
    let i7 = true;
    e11.drawPhase === T.HITTEST && (i7 = false), s7.backgroundBucketIds.length > 0 && (e11.renderPass = "background", this._renderBackgroundLayers(e11, s7.backgroundBucketIds)), super.renderChildren(e11), e11.drawPhase === T.MAP && this._fade(e11.displayLevel, e11.state);
    const o6 = this.children.filter((e12) => e12.visible && e12.hasData());
    if (!o6 || 0 === o6.length)
      return t8.bindVAO(), t8.setStencilTestEnabled(true), void t8.setBlendingEnabled(true);
    for (const l9 of o6)
      l9.triangleCount = 0;
    t8.setStencilWriteMask(0), t8.setColorMask(true, true, true, true), t8.setStencilOp(I.KEEP, I.KEEP, I.REPLACE), t8.setStencilTestEnabled(true), t8.setBlendingEnabled(false), t8.setDepthTestEnabled(true), t8.setDepthWriteEnabled(true), t8.setDepthFunction(O.LEQUAL), t8.setClearDepth(1), t8.clear(t8.gl.DEPTH_BUFFER_BIT), e11.renderPass = "opaque";
    for (let l9 = r12.length - 1; l9 >= 0; l9--)
      this._renderStyleLayer(r12[l9], e11, o6);
    t8.setDepthWriteEnabled(false), t8.setBlendingEnabled(i7), t8.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), e11.renderPass = "translucent";
    for (let l9 = 0; l9 < r12.length; l9++)
      this._renderStyleLayer(r12[l9], e11, o6);
    t8.bindVAO(), t8.setStencilTestEnabled(true), t8.setBlendingEnabled(true);
  }
  _fade(e11, t8) {
    null != this._symbolFader && (this._symbolFader.update(e11, t8) || this.requestRender());
  }
  _renderStyleLayer(e11, t8, s7) {
    const { painter: l9, renderPass: o6 } = t8;
    if (void 0 === e11)
      return;
    const n6 = e11.getLayoutProperty("visibility");
    if (n6 && n6.getValue() === i.NONE)
      return;
    let a7;
    switch (e11.type) {
      case a4.BACKGROUND:
        return;
      case a4.FILL:
        if ("opaque" !== o6 && "translucent" !== t8.renderPass)
          return;
        a7 = "vtlFill";
        break;
      case a4.LINE:
        if ("translucent" !== o6)
          return;
        a7 = "vtlLine";
        break;
      case a4.CIRCLE:
        if ("translucent" !== o6)
          return;
        a7 = "vtlCircle";
        break;
      case a4.SYMBOL:
        if ("translucent" !== o6)
          return;
        a7 = "vtlSymbol";
    }
    if (s7 = e11.type === a4.SYMBOL ? s7.filter((e12) => e12.decluttered) : s7.filter((e12) => e12.neededForCoverage), "vtlSymbol" !== a7) {
      const r12 = t8.displayLevel;
      if (0 === s7.length || void 0 !== e11.minzoom && e11.minzoom >= r12 + y3 || void 0 !== e11.maxzoom && e11.maxzoom < r12 - y3)
        return;
    }
    const d3 = e11.uid;
    t8.styleLayerUID = d3, t8.styleLayer = e11;
    for (const r12 of s7)
      if (r12.layerData.has(d3)) {
        l9.renderObjects(t8, s7, a7);
        break;
      }
  }
  _renderBackgroundLayers(e11, s7) {
    const { context: r12, displayLevel: n6, painter: u5, state: y4 } = e11, m4 = this._styleRepository;
    let _2 = false;
    for (const t8 of s7) {
      if (m4.getLayerById(t8).type === a4.BACKGROUND && p2(m4.getLayerById(t8), n6)) {
        _2 = true;
        break;
      }
    }
    if (!_2)
      return;
    const b2 = this._tileInfoView.getTileCoverage(e11.state, 0, true, "smallest"), { spans: f5, lodInfo: g } = b2, { level: T3 } = g, E2 = u2(), C2 = [];
    if (this._renderPasses) {
      const t8 = this._renderPasses[0];
      null != this._clippingInfos && (t8.brushes[0].prepareState(e11), t8.brushes[0].drawMany(e11, this._clippingInfos));
    }
    const L = this._backgroundTiles;
    let v2, F2 = 0;
    for (const { row: i7, colFrom: l9, colTo: a7 } of f5)
      for (let e12 = l9; e12 <= a7; e12++) {
        if (F2 < L.length)
          v2 = L[F2], v2.key.set(T3, i7, g.normalizeCol(e12), g.getWorldForColumn(e12)), this._tileInfoView.getTileBounds(E2, v2.key, false), v2.x = E2[0], v2.y = E2[3], v2.resolution = this._tileInfoView.getTileResolution(T3);
        else {
          const s8 = new e4(T3, i7, g.normalizeCol(e12), g.getWorldForColumn(e12)), r13 = this._tileInfoView.getTileBounds(u2(), s8), l10 = this._tileInfoView.getTileResolution(T3);
          v2 = new t6(s8, l10, r13[0], r13[3], 512, 512, 4096, 4096), L.push(v2);
        }
        v2.setTransform(y4), C2.push(v2), F2++;
      }
    r12.setStencilWriteMask(0), r12.setColorMask(true, true, true, true), r12.setStencilOp(I.KEEP, I.KEEP, I.REPLACE), r12.setStencilFunction(O.EQUAL, 0, 255);
    let S = true;
    e11.drawPhase === T.HITTEST && (S = false), r12.setStencilTestEnabled(S);
    for (const t8 of s7) {
      const s8 = m4.getLayerById(t8);
      s8.type === a4.BACKGROUND && p2(s8, n6) && (e11.styleLayerUID = s8.uid, e11.styleLayer = s8, u5.renderObjects(e11, C2, "vtlBackground"));
    }
    l.pool.release(b2);
  }
};

// node_modules/@arcgis/core/views/2d/tiling/TileInfoViewPOT.js
var t7 = class extends h2 {
  constructor() {
    super(...arguments), this._fullCacheLodInfos = null, this._levelByScale = {};
  }
  getTileParentId(e11) {
    const l9 = e4.pool.acquire(e11), t8 = 0 === l9.level ? null : e4.getId(l9.level - 1, l9.row >> 1, l9.col >> 1, l9.world);
    return e4.pool.release(l9), t8;
  }
  getTileCoverage(e11, l9, s7 = true, t8) {
    const o6 = super.getTileCoverage(e11, l9, s7, t8);
    if (!o6)
      return o6;
    const i7 = 1 << o6.lodInfo.level;
    return o6.spans = o6.spans.filter((e12) => e12.row >= 0 && e12.row < i7), o6;
  }
  scaleToLevel(e11) {
    if (this._fullCacheLodInfos || this._initializeFullCacheLODs(this._lodInfos), this._levelByScale[e11])
      return this._levelByScale[e11];
    {
      const l9 = this._fullCacheLodInfos;
      if (e11 > l9[0].scale)
        return l9[0].level;
      let s7, t8;
      for (let o6 = 0; o6 < l9.length - 1; o6++)
        if (t8 = l9[o6 + 1], e11 > t8.scale)
          return s7 = l9[o6], s7.level + (s7.scale - e11) / (s7.scale - t8.scale);
      return l9[l9.length - 1].level;
    }
  }
  _initializeFullCacheLODs(l9) {
    let s7;
    if (0 === l9[0].level)
      s7 = l9.map((e11) => ({ level: e11.level, resolution: e11.resolution, scale: e11.scale }));
    else {
      const l10 = this.tileInfo.size[0], t8 = this.tileInfo.spatialReference;
      s7 = j2.create({ size: l10, spatialReference: t8 }).lods.map((e11) => ({ level: e11.level, resolution: e11.resolution, scale: e11.scale }));
    }
    for (let e11 = 0; e11 < s7.length; e11++)
      this._levelByScale[s7[e11].scale] = s7[e11].level;
    this._fullCacheLodInfos = s7;
  }
};

// node_modules/@arcgis/core/views/2d/layers/VectorTileLayerView2D.js
var v = class extends m(u3) {
  constructor() {
    super(...arguments), this._styleChanges = [], this._fetchQueue = null, this._parseQueue = null, this._tileHandlerPromise = null, this._isTileHandlerReady = false;
  }
  get fading() {
    var _a;
    return ((_a = this._vectorTileContainer) == null ? void 0 : _a.fading) ?? false;
  }
  async hitTest(e11, i7) {
    if (!this._tileHandlerPromise)
      return null;
    await this._tileHandlerPromise;
    const s7 = await this._vectorTileContainer.hitTest(i7);
    if (!s7 || 0 === s7.length)
      return null;
    const r12 = s7[0] - 1, a7 = this._styleRepository, l9 = a7.getStyleLayerByUID(r12);
    if (!l9)
      return null;
    const o6 = a7.getStyleLayerIndex(l9.id);
    return [{ type: "graphic", mapPoint: e11, layer: this.layer, graphic: new c2({ attributes: { layerId: o6, layerName: l9.id, layerUID: r12 }, layer: this.layer, sourceLayer: this.layer }) }];
  }
  update(e11) {
    if (this._tileHandlerPromise && this._isTileHandlerReady)
      return e11.pixelRatio !== this._tileHandler.devicePixelRatio ? (this._start(), void (this._tileHandler.devicePixelRatio = e11.pixelRatio)) : void (this._styleChanges.length > 0 ? this._tileHandlerPromise = this._applyStyleChanges() : (this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.state = e11.state, this._parseQueue.state = e11.state, this._tileManager.update(e11) || this.requestUpdate(), this._parseQueue.resume(), this._fetchQueue.resume()));
  }
  attach() {
    const { style: e11 } = this.layer.currentStyleInfo;
    this._styleRepository = new l3(e11), this._tileInfoView = new t7(this.layer.tileInfo, this.layer.fullExtent), this._vectorTileContainer = new m3(this._tileInfoView), this._tileHandler = new u4(this.layer, this._styleRepository, window.devicePixelRatio || 1), this.container.addChild(this._vectorTileContainer), this._start(), this.addAttachHandles([this.layer.on("paint-change", (e12) => {
      var _a, _b;
      if (e12.isDataDriven)
        this._styleChanges.push({ type: I2.PAINTER_CHANGED, data: e12 }), this.requestUpdate();
      else {
        const t8 = this._styleRepository, i7 = t8.getLayerById(e12.layer);
        if (!i7)
          return;
        const s7 = i7.type === a4.SYMBOL;
        t8.setPaintProperties(e12.layer, e12.paint), s7 && ((_a = this._vectorTileContainer) == null ? void 0 : _a.restartDeclutter()), (_b = this._vectorTileContainer) == null ? void 0 : _b.requestRender();
      }
    }), this.layer.on("layout-change", (e12) => {
      var _a, _b;
      const t8 = this._styleRepository, i7 = t8.getLayerById(e12.layer);
      if (!i7)
        return;
      const s7 = a3(i7.layout, e12.layout);
      if (null != s7) {
        if (s2(s7, "visibility") && 1 === D2(s7))
          return t8.setLayoutProperties(e12.layer, e12.layout), i7.type === a4.SYMBOL && ((_a = this._vectorTileContainer) == null ? void 0 : _a.restartDeclutter()), void ((_b = this._vectorTileContainer) == null ? void 0 : _b.requestRender());
        this._styleChanges.push({ type: I2.LAYOUT_CHANGED, data: e12 }), this.requestUpdate();
      }
    }), this.layer.on("style-layer-visibility-change", (e12) => {
      var _a, _b;
      const t8 = this._styleRepository, i7 = t8.getLayerById(e12.layer);
      i7 && (t8.setStyleLayerVisibility(e12.layer, e12.visibility), i7.type === a4.SYMBOL && ((_a = this._vectorTileContainer) == null ? void 0 : _a.restartDeclutter()), (_b = this._vectorTileContainer) == null ? void 0 : _b.requestRender());
    }), this.layer.on("style-layer-change", (e12) => {
      this._styleChanges.push({ type: I2.LAYER_CHANGED, data: e12 }), this.requestUpdate();
    }), this.layer.on("delete-style-layer", (e12) => {
      this._styleChanges.push({ type: I2.LAYER_REMOVED, data: e12 }), this.requestUpdate();
    }), this.layer.on("load-style", () => this._loadStyle()), this.layer.on("spriteSource-change", (e12) => {
      this._styleChanges.push({ type: I2.SPRITES_CHANGED, data: e12 });
      const t8 = this._styleRepository.layers;
      for (const i7 of t8)
        switch (i7.type) {
          case a4.SYMBOL:
            i7.getLayoutProperty("icon-image") && this._styleChanges.push({ type: I2.LAYOUT_CHANGED, data: { layer: i7.id, layout: i7.layout } });
            break;
          case a4.LINE:
            i7.getPaintProperty("line-pattern") && this._styleChanges.push({ type: I2.PAINTER_CHANGED, data: { layer: i7.id, paint: i7.paint, isDataDriven: i7.isPainterDataDriven() } });
            break;
          case a4.FILL:
            i7.getLayoutProperty("fill-pattern") && this._styleChanges.push({ type: I2.PAINTER_CHANGED, data: { layer: i7.id, paint: i7.paint, isDataDriven: i7.isPainterDataDriven() } });
        }
      this.requestUpdate();
    })]);
  }
  detach() {
    this._stop(), this.container.removeAllChildren(), this._vectorTileContainer = u(this._vectorTileContainer), this._tileHandler = u(this._tileHandler);
  }
  moveStart() {
    this.requestUpdate();
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this.requestUpdate();
  }
  supportsSpatialReference(e11) {
    var _a;
    return d((_a = this.layer.tileInfo) == null ? void 0 : _a.spatialReference, e11);
  }
  canResume() {
    let e11 = super.canResume();
    const { currentStyleInfo: t8 } = this.layer;
    if (e11 && (t8 == null ? void 0 : t8.layerDefinition)) {
      const i7 = this.view.scale, { minScale: s7, maxScale: r12 } = t8.layerDefinition;
      (t8 == null ? void 0 : t8.layerDefinition) && (s7 && s7 < i7 && (e11 = false), r12 && r12 > i7 && (e11 = false));
    }
    return e11;
  }
  isUpdating() {
    return this.fading;
  }
  acquireTile(e11) {
    const t8 = this._createVectorTile(e11);
    return this._updatingHandles.addPromise(this._fetchQueue.push(t8.key).then((e12) => this._parseQueue.push({ key: t8.key, data: e12 })).then((e12) => {
      t8.once("attach", () => this.requestUpdate()), t8.setData(e12), this.requestUpdate();
    }).catch((e12) => {
      b(e12) || s.getLogger(this).error(e12);
    })), t8;
  }
  releaseTile(e11) {
    const t8 = e11.key.id;
    this._fetchQueue.abort(t8), this._parseQueue.abort(t8), this.requestUpdate();
  }
  _start() {
    if (this._stop(), this._tileManager = new o2({ acquireTile: (e12) => this.acquireTile(e12), releaseTile: (e12) => this.releaseTile(e12), tileInfoView: this._tileInfoView }, this._vectorTileContainer), !this.layer.currentStyleInfo)
      return;
    const e11 = new AbortController(), t8 = this._tileHandler.start({ signal: e11.signal }).then(() => {
      this._fetchQueue = new y2({ tileInfoView: this._tileInfoView, process: (e12, t9) => this._getTileData(e12, t9), concurrency: 15 }), this._parseQueue = new y2({ tileInfoView: this._tileInfoView, process: (e12, t9) => this._parseTileData(e12, t9), concurrency: 8 }), this.requestUpdate(), this._isTileHandlerReady = true;
    });
    this._tileHandler.spriteMosaic.then((e12) => {
      this._vectorTileContainer.setStyleResources(e12, this._tileHandler.glyphMosaic, this._styleRepository), this.requestUpdate();
    }), this._tileHandlerAbortController = e11, this._tileHandlerPromise = t8;
  }
  _stop() {
    if (!this._tileHandlerAbortController || !this._vectorTileContainer)
      return;
    const e11 = this._tileHandlerAbortController;
    e11 && e11.abort(), this._tileHandlerPromise = null, this._isTileHandlerReady = false, this._fetchQueue = u(this._fetchQueue), this._parseQueue = u(this._parseQueue), this._tileManager = u(this._tileManager), this._vectorTileContainer.removeAllChildren();
  }
  async _getTileData(e11, t8) {
    return this._tileHandler.fetchTileData(e11, t8);
  }
  async _parseTileData(e11, t8) {
    return this._tileHandler.parseTileData(e11, t8);
  }
  async _applyStyleChanges() {
    this._isTileHandlerReady = false, this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.clear(), this._parseQueue.clear(), this._tileManager.clearCache();
    const e11 = this._styleChanges;
    try {
      await this._tileHandler.updateStyle(e11);
    } catch (l9) {
      s.getLogger(this).error("error applying vector-tiles style update", l9.message), this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true;
    }
    const t8 = this._styleRepository, i7 = /* @__PURE__ */ new Set();
    e11.forEach((e12) => {
      if (e12.type !== I2.LAYER_REMOVED)
        return;
      const s7 = e12.data, r13 = t8.getLayerById(s7.layer);
      r13 && i7.add(r13.uid);
    });
    const r12 = /* @__PURE__ */ new Set();
    e11.forEach((e12) => {
      let i8;
      switch (e12.type) {
        case I2.PAINTER_CHANGED:
          t8.setPaintProperties(e12.data.layer, e12.data.paint), i8 = e12.data.layer;
          break;
        case I2.LAYOUT_CHANGED:
          t8.setLayoutProperties(e12.data.layer, e12.data.layout), i8 = e12.data.layer;
          break;
        case I2.LAYER_REMOVED:
          return void t8.deleteStyleLayer(e12.data.layer);
        case I2.LAYER_CHANGED:
          t8.setStyleLayer(e12.data.layer, e12.data.index), i8 = e12.data.layer.id;
          break;
        case I2.SPRITES_CHANGED:
          this._vectorTileContainer.setSpriteMosaic(this._tileHandler.setSpriteSource(e12.data.spriteSource));
      }
      if (i8) {
        const e13 = t8.getLayerById(i8);
        e13 && r12.add(e13.uid);
      }
    });
    const a7 = this._vectorTileContainer.children;
    if (i7.size > 0) {
      const e12 = Array.from(i7);
      this._vectorTileContainer.deleteStyleLayers(e12);
      for (const t9 of a7)
        t9.deleteLayerData(e12);
    }
    if (this._fetchQueue.resume(), this._parseQueue.resume(), r12.size > 0) {
      const e12 = Array.from(r12), t9 = [];
      for (const i8 of a7) {
        const s7 = this._updatingHandles.addPromise(this._fetchQueue.push(i8.key).then((t10) => this._parseQueue.push({ key: i8.key, data: t10, styleLayerUIDs: e12 })).then((e13) => i8.setData(e13)));
        t9.push(s7);
      }
      await Promise.all(t9);
    }
    this._styleChanges = [], this._isTileHandlerReady = true, this.requestUpdate();
  }
  async _loadStyle() {
    const { style: e11 } = this.layer.currentStyleInfo, t8 = a(e11);
    this._isTileHandlerReady = false, this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.clear(), this._parseQueue.clear(), this._styleRepository = new l3(t8), this._vectorTileContainer.destroy(), this._tileManager.clear(), this._tileHandlerAbortController.abort(), this._tileHandlerAbortController = new AbortController();
    const { signal: s7 } = this._tileHandlerAbortController;
    try {
      this._tileHandlerPromise = this._tileHandler.setStyle(this._styleRepository, t8), await this._tileHandlerPromise;
    } catch (l9) {
      if (!b(l9))
        throw l9;
    }
    if (s7.aborted)
      return this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true, void this.requestUpdate();
    const r12 = await this._tileHandler.spriteMosaic;
    this._vectorTileContainer.setStyleResources(r12, this._tileHandler.glyphMosaic, this._styleRepository), this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true, this.requestUpdate();
  }
  _createVectorTile(e11) {
    const t8 = this._tileInfoView.getTileBounds(u2(), e11), i7 = this._tileInfoView.getTileResolution(e11.level);
    return new d2(e11, i7, t8[0], t8[3], 512, 512, this._styleRepository);
  }
};
function D2(e11) {
  if (null == e11)
    return 0;
  switch (e11.type) {
    case "partial":
      return Object.keys(e11.diff).length;
    case "complete":
      return Math.max(Object.keys(e11.oldValue).length, Object.keys(e11.newValue).length);
    case "collection":
      return Object.keys(e11.added).length + Object.keys(e11.changed).length + Object.keys(e11.removed).length;
  }
}
e([y()], v.prototype, "_isTileHandlerReady", void 0), v = e([c("esri.views.2d.layers.VectorTileLayerView2D")], v);
var w = v;
export {
  w as default
};
//# sourceMappingURL=VectorTileLayerView2D-V75SKNTL.js.map
