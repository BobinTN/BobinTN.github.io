import {
  b,
  l as l2,
  v
} from "./chunk-AC7J7MCW.js";
import "./chunk-IGVJ7QLR.js";
import {
  B,
  E,
  J,
  T,
  U,
  d,
  it,
  p as p2,
  s as s2
} from "./chunk-WM2YJJQZ.js";
import {
  m
} from "./chunk-TNBDWKFN.js";
import "./chunk-L7QWOCUD.js";
import "./chunk-ERRE3PWK.js";
import {
  i
} from "./chunk-YNB3DCUM.js";
import "./chunk-GLBAW5CR.js";
import "./chunk-53TKZQ46.js";
import "./chunk-VHDTZ7JB.js";
import "./chunk-PPQAHSM4.js";
import "./chunk-RCLKRKWR.js";
import "./chunk-4OLZTDWK.js";
import "./chunk-SKLWU2B3.js";
import "./chunk-2RN2AAP7.js";
import "./chunk-YHB3DQSV.js";
import "./chunk-ED5W63C6.js";
import {
  r as r3
} from "./chunk-AMSVADDY.js";
import "./chunk-CMGHBCKF.js";
import "./chunk-NDKHIQMD.js";
import "./chunk-F6MD5VOH.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import {
  A,
  g,
  n,
  p,
  q,
  r,
  r2,
  t,
  u2 as u,
  x
} from "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import {
  c,
  e2,
  l
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  s
} from "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-WJ3HJKNC.js";
import "./chunk-4V6374PV.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/geometry/support/clipRay.js
function a(r5) {
  return r5 ? { ray: d(r5.ray), c0: r5.c0, c1: r5.c1 } : { ray: d(), c0: 0, c1: Number.MAX_VALUE };
}
var A2 = new s2(() => a());

// node_modules/@arcgis/core/geometry/support/frustum.js
function N() {
  return [n(), n(), n(), n(), n(), n(), n(), n()];
}
function P(T3, _2) {
  for (let O2 = 0; O2 < v3; O2++) {
    const R2 = T3[O2];
    if (R2[0] * _2[0] + R2[1] * _2[1] + R2[2] * _2[2] + R2[3] >= _2[3])
      return false;
  }
  return true;
}
var l3;
var k2;
!function(T3) {
  T3[T3.LEFT = 0] = "LEFT", T3[T3.RIGHT = 1] = "RIGHT", T3[T3.BOTTOM = 2] = "BOTTOM", T3[T3.TOP = 3] = "TOP", T3[T3.NEAR = 4] = "NEAR", T3[T3.FAR = 5] = "FAR";
}(l3 || (l3 = {})), function(T3) {
  T3[T3.NEAR_BOTTOM_LEFT = 0] = "NEAR_BOTTOM_LEFT", T3[T3.NEAR_BOTTOM_RIGHT = 1] = "NEAR_BOTTOM_RIGHT", T3[T3.NEAR_TOP_RIGHT = 2] = "NEAR_TOP_RIGHT", T3[T3.NEAR_TOP_LEFT = 3] = "NEAR_TOP_LEFT", T3[T3.FAR_BOTTOM_LEFT = 4] = "FAR_BOTTOM_LEFT", T3[T3.FAR_BOTTOM_RIGHT = 5] = "FAR_BOTTOM_RIGHT", T3[T3.FAR_TOP_RIGHT = 6] = "FAR_TOP_RIGHT", T3[T3.FAR_TOP_LEFT = 7] = "FAR_TOP_LEFT";
}(k2 || (k2 = {}));
var h2 = { bottom: [k2.FAR_BOTTOM_RIGHT, k2.NEAR_BOTTOM_RIGHT, k2.NEAR_BOTTOM_LEFT, k2.FAR_BOTTOM_LEFT], near: [k2.NEAR_BOTTOM_LEFT, k2.NEAR_BOTTOM_RIGHT, k2.NEAR_TOP_RIGHT, k2.NEAR_TOP_LEFT], far: [k2.FAR_BOTTOM_RIGHT, k2.FAR_BOTTOM_LEFT, k2.FAR_TOP_LEFT, k2.FAR_TOP_RIGHT], right: [k2.NEAR_BOTTOM_RIGHT, k2.FAR_BOTTOM_RIGHT, k2.FAR_TOP_RIGHT, k2.NEAR_TOP_RIGHT], left: [k2.FAR_BOTTOM_LEFT, k2.NEAR_BOTTOM_LEFT, k2.NEAR_TOP_LEFT, k2.FAR_TOP_LEFT], top: [k2.FAR_TOP_LEFT, k2.NEAR_TOP_LEFT, k2.NEAR_TOP_RIGHT, k2.FAR_TOP_RIGHT] };
var v3 = 6;
var b3 = [r3(-1, -1, -1, 1), r3(1, -1, -1, 1), r3(1, 1, -1, 1), r3(-1, 1, -1, 1), r3(-1, -1, 1, 1), r3(1, -1, 1, 1), r3(1, 1, 1, 1), r3(-1, 1, 1, 1)];
var y2 = new s2(a);
var S = N();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Octree.js
var b4 = class _b {
  get bounds() {
    return this._root.bounds;
  }
  get halfSize() {
    return this._root.halfSize;
  }
  get root() {
    return this._root.node;
  }
  get maximumObjectsPerNode() {
    return this._maximumObjectsPerNode;
  }
  get maximumDepth() {
    return this._maximumDepth;
  }
  get objectCount() {
    return this._objectCount;
  }
  constructor(e4, t3) {
    this.objectToBoundingSphere = e4, this._maximumObjectsPerNode = 10, this._maximumDepth = 20, this._degenerateObjects = /* @__PURE__ */ new Set(), this._root = new g2(), this._objectCount = 0, t3 && (void 0 !== t3.maximumObjectsPerNode && (this._maximumObjectsPerNode = t3.maximumObjectsPerNode), void 0 !== t3.maximumDepth && (this._maximumDepth = t3.maximumDepth));
  }
  destroy() {
    this._degenerateObjects.clear(), g2.clearPool(), B2[0] = null, P2.prune(), H.prune();
  }
  add(e4, t3 = e4.length) {
    this._objectCount += t3, this._grow(e4, t3);
    const o2 = g2.acquire();
    for (let n2 = 0; n2 < t3; n2++) {
      const t4 = e4[n2];
      this._isDegenerate(t4) ? this._degenerateObjects.add(t4) : (o2.init(this._root), this._add(t4, o2));
    }
    g2.release(o2);
  }
  remove(e4, t3 = null) {
    this._objectCount -= e4.length;
    const o2 = g2.acquire();
    for (const n2 of e4) {
      const e5 = null != t3 ? t3 : T(this.objectToBoundingSphere(n2), w2);
      E2(e5[3]) ? (o2.init(this._root), this._remove(n2, e5, o2)) : this._degenerateObjects.delete(n2);
    }
    g2.release(o2), this._shrink();
  }
  update(e4, t3) {
    if (!E2(t3[3]) && this._isDegenerate(e4))
      return;
    const o2 = R(e4);
    this.remove(o2, t3), this.add(o2);
  }
  forEachAlongRay(e4, t3, o2) {
    const n2 = p2(e4, t3);
    this._forEachNode(this._root, (e5) => {
      if (!this._intersectsNode(n2, e5))
        return false;
      const t4 = e5.node;
      return t4.terminals.forAll((e6) => {
        this._intersectsObject(n2, e6) && o2(e6);
      }), null !== t4.residents && t4.residents.forAll((e6) => {
        this._intersectsObject(n2, e6) && o2(e6);
      }), true;
    });
  }
  forEachAlongRayWithVerticalOffset(e4, t3, o2, n2) {
    const i2 = p2(e4, t3);
    this._forEachNode(this._root, (e5) => {
      if (!this._intersectsNodeWithOffset(i2, e5, n2))
        return false;
      const t4 = e5.node;
      return t4.terminals.forAll((e6) => {
        this._intersectsObjectWithOffset(i2, e6, n2) && o2(e6);
      }), null !== t4.residents && t4.residents.forAll((e6) => {
        this._intersectsObjectWithOffset(i2, e6, n2) && o2(e6);
      }), true;
    });
  }
  forEach(e4) {
    this._forEachNode(this._root, (t3) => {
      const o2 = t3.node;
      return o2.terminals.forAll(e4), null !== o2.residents && o2.residents.forAll(e4), true;
    }), this._degenerateObjects.forEach(e4);
  }
  forEachDegenerateObject(e4) {
    this._degenerateObjects.forEach(e4);
  }
  findClosest(e4, t3, i2, s4 = () => true, r5 = 1 / 0) {
    let h3 = 1 / 0, a2 = 1 / 0, l4 = null;
    const u2 = T2(e4, t3), c3 = (o2) => {
      if (--r5, !s4(o2))
        return;
      const n2 = this.objectToBoundingSphere(o2);
      if (!P(i2, n2))
        return;
      const u3 = z(e4, t3, U(n2)), c4 = u3 - n2[3], m3 = u3 + n2[3];
      c4 < h3 && (h3 = c4, a2 = m3, l4 = o2);
    };
    return this._forEachNodeDepthOrdered(this._root, (s5) => {
      if (r5 <= 0 || !P(i2, s5.bounds))
        return false;
      g(v4, u2, s5.halfSize), u(v4, v4, s5.bounds);
      if (z(e4, t3, v4) > a2)
        return false;
      const h4 = s5.node;
      return h4.terminals.forAll((e5) => c3(e5)), null !== h4.residents && h4.residents.forAll((e5) => c3(e5)), true;
    }, e4, t3), l4;
  }
  forEachInDepthRange(e4, t3, i2, s4, r5, h3, a2) {
    let l4 = -1 / 0, u2 = 1 / 0;
    const c3 = { setRange: (e5) => {
      i2 === _b.DepthOrder.FRONT_TO_BACK ? (l4 = Math.max(l4, e5.near), u2 = Math.min(u2, e5.far)) : (l4 = Math.max(l4, -e5.far), u2 = Math.min(u2, -e5.near));
    } };
    c3.setRange(s4);
    const m3 = z(t3, i2, e4), _2 = T2(t3, i2), p3 = T2(t3, -i2), g3 = (e5) => {
      if (!a2(e5))
        return;
      const o2 = this.objectToBoundingSphere(e5), n2 = U(o2), s5 = z(t3, i2, n2) - m3, _3 = s5 - o2[3], p4 = s5 + o2[3];
      _3 > u2 || p4 < l4 || !P(h3, o2) || r5(e5, c3);
    };
    this._forEachNodeDepthOrdered(this._root, (e5) => {
      if (!P(h3, e5.bounds))
        return false;
      g(v4, _2, e5.halfSize), u(v4, v4, e5.bounds);
      if (z(t3, i2, v4) - m3 > u2)
        return false;
      g(v4, p3, e5.halfSize), u(v4, v4, e5.bounds);
      if (z(t3, i2, v4) - m3 < l4)
        return false;
      const s5 = e5.node;
      return s5.terminals.forAll((e6) => g3(e6)), null !== s5.residents && s5.residents.forAll((e6) => g3(e6)), true;
    }, t3, i2);
  }
  forEachNode(e4) {
    this._forEachNode(this._root, (t3) => e4(t3.node, t3.bounds, t3.halfSize, t3.depth));
  }
  forEachNeighbor(e4, t3) {
    const o2 = B(t3), n2 = U(t3), s4 = (t4) => {
      const s5 = this.objectToBoundingSphere(t4), r6 = B(s5), h4 = o2 + r6;
      return !(p(U(s5), n2) - h4 * h4 <= 0) || e4(t4);
    };
    let r5 = true;
    const h3 = (e5) => {
      r5 && (r5 = s4(e5));
    };
    this._forEachNode(this._root, (e5) => {
      const t4 = B(e5.bounds), s5 = o2 + t4;
      if (p(U(e5.bounds), n2) - s5 * s5 > 0)
        return false;
      const a2 = e5.node;
      return a2.terminals.forAll(h3), r5 && null !== a2.residents && a2.residents.forAll(h3), r5;
    }), r5 && this.forEachDegenerateObject(h3);
  }
  _intersectsNode(e4, t3) {
    return j(t3.bounds, 2 * -t3.halfSize, C), j(t3.bounds, 2 * t3.halfSize, y3), i(e4.origin, e4.direction, C, y3);
  }
  _intersectsNodeWithOffset(e4, t3, o2) {
    return j(t3.bounds, 2 * -t3.halfSize, C), j(t3.bounds, 2 * t3.halfSize, y3), o2.applyToMinMax(C, y3), i(e4.origin, e4.direction, C, y3);
  }
  _intersectsObject(e4, t3) {
    const o2 = this.objectToBoundingSphere(t3);
    return !(o2[3] > 0) || J(o2, e4);
  }
  _intersectsObjectWithOffset(e4, t3, o2) {
    const n2 = this.objectToBoundingSphere(t3);
    return !(n2[3] > 0) || J(o2.applyToBoundingSphere(n2), e4);
  }
  _forEachNode(e4, t3) {
    let o2 = g2.acquire().init(e4);
    const n2 = [o2];
    for (; 0 !== n2.length; ) {
      if (o2 = n2.pop(), t3(o2) && !o2.isLeaf())
        for (let e5 = 0; e5 < o2.node.children.length; e5++) {
          o2.node.children[e5] && n2.push(g2.acquire().init(o2).advance(e5));
        }
      g2.release(o2);
    }
  }
  _forEachNodeDepthOrdered(e4, t3, o2, n2 = _b.DepthOrder.FRONT_TO_BACK) {
    let i2 = g2.acquire().init(e4);
    const s4 = [i2];
    for (N2(o2, n2, K); 0 !== s4.length; ) {
      if (i2 = s4.pop(), t3(i2) && !i2.isLeaf())
        for (let e5 = 7; e5 >= 0; --e5) {
          const t4 = K[e5];
          i2.node.children[t4] && s4.push(g2.acquire().init(i2).advance(t4));
        }
      g2.release(i2);
    }
  }
  _remove(e4, t3, o2) {
    P2.clear();
    const n2 = o2.advanceTo(t3, (e5, t4) => {
      P2.push(e5.node), P2.push(t4);
    }) ? o2.node.terminals : o2.node.residents;
    if (n2.removeUnordered(e4), 0 === n2.length)
      for (let i2 = P2.length - 2; i2 >= 0; i2 -= 2) {
        const e5 = P2.data[i2], t4 = P2.data[i2 + 1];
        if (!this._purge(e5, t4))
          break;
      }
  }
  _nodeIsEmpty(e4) {
    if (0 !== e4.terminals.length)
      return false;
    if (null !== e4.residents)
      return 0 === e4.residents.length;
    for (let t3 = 0; t3 < e4.children.length; t3++)
      if (e4.children[t3])
        return false;
    return true;
  }
  _purge(e4, o2) {
    return o2 >= 0 && (e4.children[o2] = null), !!this._nodeIsEmpty(e4) && (null === e4.residents && (e4.residents = new l({ shrink: true })), true);
  }
  _add(e4, t3) {
    t3.advanceTo(this.objectToBoundingSphere(e4)) ? t3.node.terminals.push(e4) : (t3.node.residents.push(e4), t3.node.residents.length > this._maximumObjectsPerNode && t3.depth < this._maximumDepth && this._split(t3));
  }
  _split(e4) {
    const t3 = e4.node.residents;
    e4.node.residents = null;
    for (let o2 = 0; o2 < t3.length; o2++) {
      const n2 = g2.acquire().init(e4);
      this._add(t3.at(o2), n2), g2.release(n2);
    }
  }
  _grow(e4, t3) {
    if (0 !== t3 && (x2(e4, t3, (e5) => this.objectToBoundingSphere(e5), k3), E2(k3[3]) && !this._fitsInsideTree(k3)))
      if (this._nodeIsEmpty(this._root.node))
        T(k3, this._root.bounds), this._root.halfSize = 1.25 * this._root.bounds[3], this._root.updateBoundsRadiusFromHalfSize();
      else {
        const e5 = this._rootBoundsForRootAsSubNode(k3);
        this._placingRootViolatesMaxDepth(e5) ? this._rebuildTree(k3, e5) : this._growRootAsSubNode(e5), g2.release(e5);
      }
  }
  _rebuildTree(e4, t3) {
    r2(q2, t3.bounds), q2[3] = t3.halfSize, x2([e4, q2], 2, (e5) => e5, I);
    const o2 = g2.acquire().init(this._root);
    this._root.initFrom(null, I, I[3]), this._root.increaseHalfSize(1.25), this._forEachNode(o2, (e5) => (this.add(e5.node.terminals.data, e5.node.terminals.length), null !== e5.node.residents && this.add(e5.node.residents.data, e5.node.residents.length), true)), g2.release(o2);
  }
  _placingRootViolatesMaxDepth(e4) {
    const t3 = Math.log(e4.halfSize / this._root.halfSize) * Math.LOG2E;
    let o2 = 0;
    return this._forEachNode(this._root, (e5) => (o2 = Math.max(o2, e5.depth), o2 + t3 <= this._maximumDepth)), o2 + t3 > this._maximumDepth;
  }
  _rootBoundsForRootAsSubNode(e4) {
    const t3 = e4[3], o2 = e4;
    let n2 = -1 / 0;
    const i2 = this._root.bounds, s4 = this._root.halfSize;
    for (let h3 = 0; h3 < 3; h3++) {
      const e5 = i2[h3] - s4 - (o2[h3] - t3), r6 = o2[h3] + t3 - (i2[h3] + s4), a2 = Math.max(0, Math.ceil(e5 / (2 * s4))), d3 = Math.max(0, Math.ceil(r6 / (2 * s4))) + 1, l4 = 2 ** Math.ceil(Math.log(a2 + d3) * Math.LOG2E);
      n2 = Math.max(n2, l4), L[h3].min = a2, L[h3].max = d3;
    }
    for (let h3 = 0; h3 < 3; h3++) {
      let e5 = L[h3].min, t4 = L[h3].max;
      const o3 = (n2 - (e5 + t4)) / 2;
      e5 += Math.ceil(o3), t4 += Math.floor(o3);
      const r6 = i2[h3] - s4 - e5 * s4 * 2;
      F2[h3] = r6 + (t4 + e5) * s4;
    }
    const r5 = n2 * s4;
    return F2[3] = r5 * A3, g2.acquire().initFrom(null, F2, r5, 0);
  }
  _growRootAsSubNode(e4) {
    const t3 = this._root.node;
    r2(k3, this._root.bounds), k3[3] = this._root.halfSize, this._root.init(e4), e4.advanceTo(k3, null, true), e4.node.children = t3.children, e4.node.residents = t3.residents, e4.node.terminals = t3.terminals;
  }
  _shrink() {
    for (; ; ) {
      const e4 = this._findShrinkIndex();
      if (-1 === e4)
        break;
      this._root.advance(e4), this._root.depth = 0;
    }
  }
  _findShrinkIndex() {
    if (0 !== this._root.node.terminals.length || this._root.isLeaf())
      return -1;
    let e4 = null;
    const t3 = this._root.node.children;
    let o2 = 0, n2 = 0;
    for (; n2 < t3.length && null == e4; )
      o2 = n2++, e4 = t3[o2];
    for (; n2 < t3.length; )
      if (t3[n2++])
        return -1;
    return o2;
  }
  _isDegenerate(e4) {
    return !E2(this.objectToBoundingSphere(e4)[3]);
  }
  _fitsInsideTree(e4) {
    const t3 = this._root.bounds, o2 = this._root.halfSize;
    return e4[3] <= o2 && e4[0] >= t3[0] - o2 && e4[0] <= t3[0] + o2 && e4[1] >= t3[1] - o2 && e4[1] <= t3[1] + o2 && e4[2] >= t3[2] - o2 && e4[2] <= t3[2] + o2;
  }
  toJSON() {
    const { maximumDepth: e4, maximumObjectsPerNode: t3, _objectCount: o2 } = this, n2 = this._nodeToJSON(this._root.node);
    return { maximumDepth: e4, maximumObjectsPerNode: t3, objectCount: o2, root: { bounds: this._root.bounds, halfSize: this._root.halfSize, depth: this._root.depth, node: n2 } };
  }
  _nodeToJSON(e4) {
    var _a, _b2;
    const t3 = e4.children.map((e5) => e5 ? this._nodeToJSON(e5) : null), o2 = (_a = e4.residents) == null ? void 0 : _a.map((e5) => this.objectToBoundingSphere(e5)), n2 = (_b2 = e4.terminals) == null ? void 0 : _b2.map((e5) => this.objectToBoundingSphere(e5));
    return { children: t3, residents: o2, terminals: n2 };
  }
  static fromJSON(e4) {
    const t3 = new _b((e5) => e5, { maximumDepth: e4.maximumDepth, maximumObjectsPerNode: e4.maximumObjectsPerNode });
    return t3._objectCount = e4.objectCount, t3._root.initFrom(e4.root.node, e4.root.bounds, e4.root.halfSize, e4.root.depth), t3;
  }
};
var g2 = class _g {
  constructor() {
    this.bounds = E(), this.halfSize = 0, this.initFrom(null, null, 0, 0);
  }
  init(e4) {
    return this.initFrom(e4.node, e4.bounds, e4.halfSize, e4.depth);
  }
  initFrom(e4, t3, o2, n2 = this.depth) {
    return this.node = null != e4 ? e4 : _g.createEmptyNode(), null != t3 && T(t3, this.bounds), this.halfSize = o2, this.depth = n2, this;
  }
  increaseHalfSize(e4) {
    this.halfSize *= e4, this.updateBoundsRadiusFromHalfSize();
  }
  updateBoundsRadiusFromHalfSize() {
    this.bounds[3] = this.halfSize * A3;
  }
  advance(e4) {
    let t3 = this.node.children[e4];
    t3 || (t3 = _g.createEmptyNode(), this.node.children[e4] = t3), this.node = t3, this.halfSize /= 2, this.depth++;
    const o2 = M[e4];
    return this.bounds[0] += o2[0] * this.halfSize, this.bounds[1] += o2[1] * this.halfSize, this.bounds[2] += o2[2] * this.halfSize, this.updateBoundsRadiusFromHalfSize(), this;
  }
  advanceTo(e4, t3, o2 = false) {
    for (; ; ) {
      if (this.isTerminalFor(e4))
        return t3 && t3(this, -1), true;
      if (this.isLeaf()) {
        if (!o2)
          return t3 && t3(this, -1), false;
        this.node.residents = null;
      }
      const n2 = this._childIndex(e4);
      t3 && t3(this, n2), this.advance(n2);
    }
  }
  isLeaf() {
    return null != this.node.residents;
  }
  isTerminalFor(e4) {
    return e4[3] > this.halfSize / 2;
  }
  _childIndex(e4) {
    const t3 = this.bounds;
    return (t3[0] < e4[0] ? 1 : 0) + (t3[1] < e4[1] ? 2 : 0) + (t3[2] < e4[2] ? 4 : 0);
  }
  static createEmptyNode() {
    return { children: [null, null, null, null, null, null, null, null], terminals: new l({ shrink: true }), residents: new l({ shrink: true }) };
  }
  static acquire() {
    return _g._pool.acquire();
  }
  static release(e4) {
    _g._pool.release(e4);
  }
  static clearPool() {
    _g._pool.prune();
  }
};
function S2(e4, t3) {
  e4[0] = Math.min(e4[0], t3[0] - t3[3]), e4[1] = Math.min(e4[1], t3[1] - t3[3]), e4[2] = Math.min(e4[2], t3[2] - t3[3]);
}
function O(e4, t3) {
  e4[0] = Math.max(e4[0], t3[0] + t3[3]), e4[1] = Math.max(e4[1], t3[1] + t3[3]), e4[2] = Math.max(e4[2], t3[2] + t3[3]);
}
function j(e4, t3, o2) {
  o2[0] = e4[0] + t3, o2[1] = e4[1] + t3, o2[2] = e4[2] + t3;
}
function x2(e4, t3, o2, n2) {
  if (1 === t3) {
    const t4 = o2(e4[0]);
    T(t4, n2);
  } else {
    C[0] = 1 / 0, C[1] = 1 / 0, C[2] = 1 / 0, y3[0] = -1 / 0, y3[1] = -1 / 0, y3[2] = -1 / 0;
    for (let n3 = 0; n3 < t3; n3++) {
      const t4 = o2(e4[n3]);
      E2(t4[3]) && (S2(C, t4), O(y3, t4));
    }
    A(n2, C, y3, 0.5), n2[3] = Math.max(y3[0] - C[0], y3[1] - C[1], y3[2] - C[2]) / 2;
  }
}
function N2(e4, t3, o2) {
  if (!H.length)
    for (let n2 = 0; n2 < 8; ++n2)
      H.push({ index: 0, distance: 0 });
  for (let n2 = 0; n2 < 8; ++n2) {
    const o3 = M[n2];
    H.data[n2].index = n2, H.data[n2].distance = z(e4, t3, o3);
  }
  H.sort((e5, t4) => e5.distance - t4.distance);
  for (let n2 = 0; n2 < 8; ++n2)
    o2[n2] = H.data[n2].index;
}
function T2(e4, t3) {
  let o2, n2 = 1 / 0;
  for (let i2 = 0; i2 < 8; ++i2) {
    const s4 = z(e4, t3, D[i2]);
    s4 < n2 && (n2 = s4, o2 = D[i2]);
  }
  return o2;
}
function z(e4, t3, o2) {
  return t3 * (e4[0] * o2[0] + e4[1] * o2[1] + e4[2] * o2[2]);
}
function E2(e4) {
  return !isNaN(e4) && e4 !== -1 / 0 && e4 !== 1 / 0 && e4 > 0;
}
g2._pool = new e2(g2), function(e4) {
  var t3;
  (t3 = e4.DepthOrder || (e4.DepthOrder = {}))[t3.FRONT_TO_BACK = 1] = "FRONT_TO_BACK", t3[t3.BACK_TO_FRONT = -1] = "BACK_TO_FRONT";
}(b4 || (b4 = {}));
var M = [r(-1, -1, -1), r(1, -1, -1), r(-1, 1, -1), r(1, 1, -1), r(-1, -1, 1), r(1, -1, 1), r(-1, 1, 1), r(1, 1, 1)];
var D = [r(-1, -1, -1), r(-1, -1, 1), r(-1, 1, -1), r(-1, 1, 1), r(1, -1, -1), r(1, -1, 1), r(1, 1, -1), r(1, 1, 1)];
var A3 = Math.sqrt(3);
var B2 = [null];
function R(e4) {
  return B2[0] = e4, B2;
}
var F2 = E();
var v4 = n();
var C = n();
var y3 = n();
var P2 = new l();
var w2 = E();
var k3 = E();
var q2 = E();
var I = E();
var L = [{ min: 0, max: 0 }, { min: 0, max: 0 }, { min: 0, max: 0 }];
var H = new l();
var K = [0, 0, 0, 0, 0, 0, 0, 0];
var W2 = b4;

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/sceneLayerSource/sceneLayerSnappingUtils.js
var t2 = 1e3;
function e3(t3, e4, a2) {
  const m3 = E(), p3 = U(m3);
  return q(p3, p3, t3, 0.5), q(p3, p3, e4, 0.5), m3[3] = x(p3, t3), u(p3, p3, a2), m3;
}

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/sceneLayerSource/SceneLayerSnappingSourceWorker.js
var _ = class {
  constructor() {
    this._idToComponent = /* @__PURE__ */ new Map(), this._components = new W2((e4) => e4.bounds), this._edges = new W2((e4) => e4.bounds), this._tmpLineSegment = v(), this._tmpP1 = n(), this._tmpP2 = n(), this._tmpP3 = n(), this.remoteClient = null;
  }
  async fetchCandidates(e4, s4) {
    await Promise.resolve(), s(s4), await this._ensureEdgeLocations(e4, s4);
    const o2 = [];
    return this._edges.forEachNeighbor((t3) => (this._addCandidates(e4, t3, o2), o2.length < t2), e4.bounds), { result: { candidates: o2 } };
  }
  async _ensureEdgeLocations(e4, t3) {
    const s4 = [];
    if (this._components.forEachNeighbor((e5) => {
      if (null == e5.info) {
        const { id: t4, uid: o3 } = e5;
        s4.push({ id: t4, uid: o3 });
      }
      return true;
    }, e4.bounds), !s4.length)
      return;
    const o2 = { components: s4 }, n2 = await this.remoteClient.invoke("fetchAllEdgeLocations", o2, t3 ?? {});
    for (const i2 of n2.components)
      this._setFetchEdgeLocations(i2);
  }
  async add(e4) {
    const t3 = new b5(e4.id, e4.bounds);
    return this._idToComponent.set(t3.id, t3), this._components.add([t3]), { result: {} };
  }
  async remove(e4) {
    const t3 = this._idToComponent.get(e4.id);
    if (t3) {
      const e5 = [];
      this._edges.forEachNeighbor((s4) => (s4.component === t3 && e5.push(s4), true), t3.bounds), this._edges.remove(e5), this._components.remove([t3]), this._idToComponent.delete(t3.id);
    }
    return { result: {} };
  }
  _setFetchEdgeLocations(e4) {
    const t3 = this._idToComponent.get(e4.id);
    if (null == t3 || e4.uid !== t3.uid)
      return;
    const s4 = m.createView(e4.locations), o2 = new Array(s4.count), n2 = n(), r5 = n();
    for (let i2 = 0; i2 < s4.count; i2++) {
      s4.position0.getVec(i2, n2), s4.position1.getVec(i2, r5);
      const d4 = e3(n2, r5, e4.origin), c4 = new j2(t3, i2, d4);
      o2[i2] = c4;
    }
    this._edges.add(o2);
    const { objectIds: d3, origin: c3 } = e4;
    t3.info = { locations: s4, objectIds: d3, origin: c3 };
  }
  _addCandidates(e4, t3, s4) {
    const { info: n2 } = t3.component, { origin: i2, objectIds: r5 } = n2, d3 = n2.locations, c3 = d3.position0.getVec(t3.index, this._tmpP1), a2 = d3.position1.getVec(t3.index, this._tmpP2);
    u(c3, c3, i2), u(a2, a2, i2);
    const p3 = r5[d3.componentIndex.get(t3.index)];
    this._addEdgeCandidate(e4, p3, c3, a2, s4), this._addVertexCandidate(e4, p3, c3, s4), this._addVertexCandidate(e4, p3, a2, s4);
  }
  _addEdgeCandidate(e4, t3, s4, o2, i2) {
    if (!e4.returnEdge)
      return;
    const d3 = U(e4.bounds), h3 = b(s4, o2, this._tmpLineSegment), m3 = l2(h3, d3, this._tmpP3);
    it(e4.bounds, m3) && i2.push({ type: "edge", objectId: t3, target: t(m3), distance: x(d3, m3), start: t(s4), end: t(o2) });
  }
  _addVertexCandidate(e4, t3, s4, o2) {
    if (!e4.returnVertex)
      return;
    const i2 = U(e4.bounds);
    it(e4.bounds, s4) && o2.push({ type: "vertex", objectId: t3, target: t(s4), distance: x(i2, s4) });
  }
};
_ = e([c("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")], _);
var f2 = _;
var b5 = class _b {
  constructor(e4, t3) {
    this.id = e4, this.bounds = t3, this.info = null, this.uid = ++_b.uid;
  }
};
b5.uid = 0;
var j2 = class {
  constructor(e4, t3, s4) {
    this.component = e4, this.index = t3, this.bounds = s4;
  }
};
export {
  f2 as default
};
//# sourceMappingURL=SceneLayerSnappingSourceWorker-JOHMJEO2.js.map
