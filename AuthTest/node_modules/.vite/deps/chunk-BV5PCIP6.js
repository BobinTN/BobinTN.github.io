import {
  c,
  i,
  o as o2
} from "./chunk-T56C4ORZ.js";
import {
  H,
  V
} from "./chunk-RCLKRKWR.js";
import {
  n
} from "./chunk-MVXU4PVF.js";
import {
  r
} from "./chunk-WGO3VFQP.js";
import {
  s2 as s
} from "./chunk-WJ3HJKNC.js";
import {
  a,
  p2 as p
} from "./chunk-4V6374PV.js";
import {
  o
} from "./chunk-A34O4XB5.js";

// node_modules/@arcgis/core/chunks/builtins.js
var r2;
var t = { exports: {} };
t.exports, void 0 !== (r2 = ["precision", "highp", "mediump", "lowp", "attribute", "const", "uniform", "varying", "break", "continue", "do", "for", "while", "if", "else", "in", "out", "inout", "float", "int", "void", "bool", "true", "false", "discard", "return", "mat2", "mat3", "mat4", "vec2", "vec3", "vec4", "ivec2", "ivec3", "ivec4", "bvec2", "bvec3", "bvec4", "sampler1D", "sampler2D", "sampler3D", "samplerCube", "sampler1DShadow", "sampler2DShadow", "struct", "asm", "class", "union", "enum", "typedef", "template", "this", "packed", "goto", "switch", "default", "inline", "noinline", "volatile", "public", "static", "extern", "external", "interface", "long", "short", "double", "half", "fixed", "unsigned", "input", "output", "hvec2", "hvec3", "hvec4", "dvec2", "dvec3", "dvec4", "fvec2", "fvec3", "fvec4", "sampler2DRect", "sampler3DRect", "sampler2DRectShadow", "sizeof", "cast", "namespace", "using"]) && (t.exports = r2);
var o3 = o(t.exports);
var l;
var a2 = { exports: {} };
a2.exports, l = a2, function(e5) {
  var r3 = ["<<=", ">>=", "++", "--", "<<", ">>", "<=", ">=", "==", "!=", "&&", "||", "+=", "-=", "*=", "/=", "%=", "&=", "^^", "^=", "|=", "(", ")", "[", "]", ".", "!", "~", "*", "/", "%", "+", "-", "<", ">", "&", "^", "|", "?", ":", "=", ",", ";", "{", "}"];
  void 0 !== r3 && (l.exports = r3);
}();
var g = o(a2.exports);
var i2 = { exports: {} };
i2.exports, function(e5) {
  !function(r3) {
    var t2 = function() {
      return ["abs", "acos", "all", "any", "asin", "atan", "ceil", "clamp", "cos", "cross", "dFdx", "dFdy", "degrees", "distance", "dot", "equal", "exp", "exp2", "faceforward", "floor", "fract", "gl_BackColor", "gl_BackLightModelProduct", "gl_BackLightProduct", "gl_BackMaterial", "gl_BackSecondaryColor", "gl_ClipPlane", "gl_ClipVertex", "gl_Color", "gl_DepthRange", "gl_DepthRangeParameters", "gl_EyePlaneQ", "gl_EyePlaneR", "gl_EyePlaneS", "gl_EyePlaneT", "gl_Fog", "gl_FogCoord", "gl_FogFragCoord", "gl_FogParameters", "gl_FragColor", "gl_FragCoord", "gl_FragData", "gl_FragDepth", "gl_FragDepthEXT", "gl_FrontColor", "gl_FrontFacing", "gl_FrontLightModelProduct", "gl_FrontLightProduct", "gl_FrontMaterial", "gl_FrontSecondaryColor", "gl_LightModel", "gl_LightModelParameters", "gl_LightModelProducts", "gl_LightProducts", "gl_LightSource", "gl_LightSourceParameters", "gl_MaterialParameters", "gl_MaxClipPlanes", "gl_MaxCombinedTextureImageUnits", "gl_MaxDrawBuffers", "gl_MaxFragmentUniformComponents", "gl_MaxLights", "gl_MaxTextureCoords", "gl_MaxTextureImageUnits", "gl_MaxTextureUnits", "gl_MaxVaryingFloats", "gl_MaxVertexAttribs", "gl_MaxVertexTextureImageUnits", "gl_MaxVertexUniformComponents", "gl_ModelViewMatrix", "gl_ModelViewMatrixInverse", "gl_ModelViewMatrixInverseTranspose", "gl_ModelViewMatrixTranspose", "gl_ModelViewProjectionMatrix", "gl_ModelViewProjectionMatrixInverse", "gl_ModelViewProjectionMatrixInverseTranspose", "gl_ModelViewProjectionMatrixTranspose", "gl_MultiTexCoord0", "gl_MultiTexCoord1", "gl_MultiTexCoord2", "gl_MultiTexCoord3", "gl_MultiTexCoord4", "gl_MultiTexCoord5", "gl_MultiTexCoord6", "gl_MultiTexCoord7", "gl_Normal", "gl_NormalMatrix", "gl_NormalScale", "gl_ObjectPlaneQ", "gl_ObjectPlaneR", "gl_ObjectPlaneS", "gl_ObjectPlaneT", "gl_Point", "gl_PointCoord", "gl_PointParameters", "gl_PointSize", "gl_Position", "gl_ProjectionMatrix", "gl_ProjectionMatrixInverse", "gl_ProjectionMatrixInverseTranspose", "gl_ProjectionMatrixTranspose", "gl_SecondaryColor", "gl_TexCoord", "gl_TextureEnvColor", "gl_TextureMatrix", "gl_TextureMatrixInverse", "gl_TextureMatrixInverseTranspose", "gl_TextureMatrixTranspose", "gl_Vertex", "greaterThan", "greaterThanEqual", "inversesqrt", "length", "lessThan", "lessThanEqual", "log", "log2", "matrixCompMult", "max", "min", "mix", "mod", "normalize", "not", "notEqual", "pow", "radians", "reflect", "refract", "sign", "sin", "smoothstep", "sqrt", "step", "tan", "texture2D", "texture2DLod", "texture2DProj", "texture2DProjLod", "textureCube", "textureCubeLod", "texture2DLodEXT", "texture2DProjLodEXT", "textureCubeLodEXT", "texture2DGradEXT", "texture2DProjGradEXT", "textureCubeGradEXT", "textureSize", "texelFetch"];
    }();
    void 0 !== t2 && (e5.exports = t2);
  }();
}(i2);
var n2 = o(i2.exports);

// node_modules/@arcgis/core/views/webgl/reservedWordsGLSL3.js
var e = ["layout", "centroid", "smooth", "case", "mat2x2", "mat2x3", "mat2x4", "mat3x2", "mat3x3", "mat3x4", "mat4x2", "mat4x3", "mat4x4", "uint", "uvec2", "uvec3", "uvec4", "samplerCubeShadow", "sampler2DArray", "sampler2DArrayShadow", "isampler2D", "isampler3D", "isamplerCube", "isampler2DArray", "usampler2D", "usampler3D", "usamplerCube", "usampler2DArray", "coherent", "restrict", "readonly", "writeonly", "resource", "atomic_uint", "noperspective", "patch", "sample", "subroutine", "common", "partition", "active", "filter", "image1D", "image2D", "image3D", "imageCube", "iimage1D", "iimage2D", "iimage3D", "iimageCube", "uimage1D", "uimage2D", "uimage3D", "uimageCube", "image1DArray", "image2DArray", "iimage1DArray", "iimage2DArray", "uimage1DArray", "uimage2DArray", "image1DShadow", "image2DShadow", "image1DArrayShadow", "image2DArrayShadow", "imageBuffer", "iimageBuffer", "uimageBuffer", "sampler1DArray", "sampler1DArrayShadow", "isampler1D", "isampler1DArray", "usampler1D", "usampler1DArray", "isampler2DRect", "usampler2DRect", "samplerBuffer", "isamplerBuffer", "usamplerBuffer", "sampler2DMS", "isampler2DMS", "usampler2DMS", "sampler2DMSArray", "isampler2DMSArray", "usampler2DMSArray", "trunc", "round", "roundEven", "isnan", "isinf", "floatBitsToInt", "floatBitsToUint", "intBitsToFloat", "uintBitsToFloat", "packSnorm2x16", "unpackSnorm2x16", "packUnorm2x16", "unpackUnorm2x16", "packHalf2x16", "unpackHalf2x16", "outerProduct", "transpose", "determinant", "inverse", "texture", "textureSize", "textureProj", "textureLod", "textureOffset", "texelFetch", "texelFetchOffset", "textureProjOffset", "textureLodOffset", "textureProjLod", "textureProjLodOffset", "textureGrad", "textureGradOffset", "textureProjGrad", "textureProjGradOffset"];

// node_modules/@arcgis/core/views/webgl/testUtils.js
var e2 = { enableCache: false };

// node_modules/@arcgis/core/views/webgl/ShaderTranspiler.js
var i3 = 999;
var s2 = 9999;
var c2 = 0;
var p2 = 1;
var u = 2;
var f = 3;
var d = 4;
var l2 = 5;
var h = 6;
var y = 7;
var w = 8;
var g2 = 9;
var m = 10;
var k = 11;
var b = ["block-comment", "line-comment", "preprocessor", "operator", "integer", "float", "ident", "builtin", "keyword", "whitespace", "eof", "integer"];
function E() {
  var t2, e5, a4, E2 = 0, _3 = 0, v2 = i3, j2 = [], A2 = [], x2 = 1, D2 = 0, R2 = 0, T2 = false, S2 = false, G2 = "";
  return function(t3) {
    return A2 = [], null !== t3 ? F2(t3.replace ? t3.replace(/\r\n/g, "\n") : t3) : L2();
  };
  function X2(t3) {
    t3.length && A2.push({ type: b[v2], data: t3, position: R2, line: x2, column: D2 });
  }
  function F2(e6) {
    var r3;
    for (E2 = 0, a4 = (G2 += e6).length; t2 = G2[E2], E2 < a4; ) {
      switch (r3 = E2, v2) {
        case c2:
          E2 = V2();
          break;
        case p2:
          E2 = P();
          break;
        case u:
          E2 = M();
          break;
        case f:
          E2 = O();
          break;
        case d:
          E2 = $();
          break;
        case k:
          E2 = W();
          break;
        case l2:
          E2 = z();
          break;
        case s2:
          E2 = I();
          break;
        case g2:
          E2 = H3();
          break;
        case i3:
          E2 = C2();
      }
      if (r3 !== E2)
        if ("\n" === G2[r3])
          D2 = 0, ++x2;
        else
          ++D2;
    }
    return _3 += E2, G2 = G2.slice(E2), A2;
  }
  function L2(t3) {
    return j2.length && X2(j2.join("")), v2 = m, X2("(eof)"), A2;
  }
  function C2() {
    return j2 = j2.length ? [] : j2, "/" === e5 && "*" === t2 ? (R2 = _3 + E2 - 1, v2 = c2, e5 = t2, E2 + 1) : "/" === e5 && "/" === t2 ? (R2 = _3 + E2 - 1, v2 = p2, e5 = t2, E2 + 1) : "#" === t2 ? (v2 = u, R2 = _3 + E2, E2) : /\s/.test(t2) ? (v2 = g2, R2 = _3 + E2, E2) : (T2 = /\d/.test(t2), S2 = /[^\w_]/.test(t2), R2 = _3 + E2, v2 = T2 ? d : S2 ? f : s2, E2);
  }
  function H3() {
    return /[^\s]/g.test(t2) ? (X2(j2.join("")), v2 = i3, E2) : (j2.push(t2), e5 = t2, E2 + 1);
  }
  function M() {
    return "\r" !== t2 && "\n" !== t2 || "\\" === e5 ? (j2.push(t2), e5 = t2, E2 + 1) : (X2(j2.join("")), v2 = i3, E2);
  }
  function P() {
    return M();
  }
  function V2() {
    return "/" === t2 && "*" === e5 ? (j2.push(t2), X2(j2.join("")), v2 = i3, E2 + 1) : (j2.push(t2), e5 = t2, E2 + 1);
  }
  function O() {
    if ("." === e5 && /\d/.test(t2))
      return v2 = l2, E2;
    if ("/" === e5 && "*" === t2)
      return v2 = c2, E2;
    if ("/" === e5 && "/" === t2)
      return v2 = p2, E2;
    if ("." === t2 && j2.length) {
      for (; N(j2); )
        ;
      return v2 = l2, E2;
    }
    if (";" === t2 || ")" === t2 || "(" === t2) {
      if (j2.length)
        for (; N(j2); )
          ;
      return X2(t2), v2 = i3, E2 + 1;
    }
    var a5 = 2 === j2.length && "=" !== t2;
    if (/[\w_\d\s]/.test(t2) || a5) {
      for (; N(j2); )
        ;
      return v2 = i3, E2;
    }
    return j2.push(t2), e5 = t2, E2 + 1;
  }
  function N(t3) {
    for (var e6, a5, n3 = 0; ; ) {
      if (e6 = g.indexOf(t3.slice(0, t3.length + n3).join("")), a5 = g[e6], -1 === e6) {
        if (n3-- + t3.length > 0)
          continue;
        a5 = t3.slice(0, 1).join("");
      }
      return X2(a5), R2 += a5.length, (j2 = j2.slice(a5.length)).length;
    }
  }
  function W() {
    return /[^a-fA-F0-9]/.test(t2) ? (X2(j2.join("")), v2 = i3, E2) : (j2.push(t2), e5 = t2, E2 + 1);
  }
  function $() {
    return "." === t2 || /[eE]/.test(t2) ? (j2.push(t2), v2 = l2, e5 = t2, E2 + 1) : "x" === t2 && 1 === j2.length && "0" === j2[0] ? (v2 = k, j2.push(t2), e5 = t2, E2 + 1) : /[^\d]/.test(t2) ? (X2(j2.join("")), v2 = i3, E2) : (j2.push(t2), e5 = t2, E2 + 1);
  }
  function z() {
    return "f" === t2 && (j2.push(t2), e5 = t2, E2 += 1), /[eE]/.test(t2) || "-" === t2 && /[eE]/.test(e5) ? (j2.push(t2), e5 = t2, E2 + 1) : /[^\d]/.test(t2) ? (X2(j2.join("")), v2 = i3, E2) : (j2.push(t2), e5 = t2, E2 + 1);
  }
  function I() {
    if (/[^\d\w_]/.test(t2)) {
      var a5 = j2.join("");
      return v2 = o3.indexOf(a5) > -1 ? w : n2.indexOf(a5) > -1 ? y : h, X2(j2.join("")), v2 = i3, E2;
    }
    return j2.push(t2), e5 = t2, E2 + 1;
  }
}
function _(t2) {
  var e5 = E(), a4 = [];
  return a4 = (a4 = a4.concat(e5(t2))).concat(e5(null));
}
function v(t2) {
  return _(t2);
}
function j(t2) {
  return t2.map((t3) => "eof" !== t3.type ? t3.data : "").join("");
}
var A = /* @__PURE__ */ new Set(["GL_OES_standard_derivatives", "GL_EXT_frag_depth", "GL_EXT_draw_buffers", "GL_EXT_shader_texture_lod"]);
function x(t2, e5 = "100", a4 = "300 es") {
  const r3 = /^\s*\#version\s+([0-9]+(\s+[a-zA-Z]+)?)\s*/;
  for (const n3 of t2)
    if ("preprocessor" === n3.type) {
      const t3 = r3.exec(n3.data);
      if (t3) {
        const r4 = t3[1].replaceAll(/\s\s+/g, " ");
        if (r4 === a4)
          return r4;
        if (r4 === e5)
          return n3.data = "#version " + a4, e5;
        throw new Error("unknown glsl version: " + r4);
      }
    }
  return t2.splice(0, 0, { type: "preprocessor", data: "#version " + a4 }, { type: "whitespace", data: "\n" }), null;
}
function D(t2, e5) {
  for (let a4 = e5 - 1; a4 >= 0; a4--) {
    const e6 = t2[a4];
    if ("whitespace" !== e6.type && "block-comment" !== e6.type) {
      if ("keyword" !== e6.type)
        break;
      if ("attribute" === e6.data || "in" === e6.data)
        return true;
    }
  }
  return false;
}
function R(t2, e5, a4, r3) {
  r3 = r3 || a4;
  for (const n3 of t2)
    if ("ident" === n3.type && n3.data === a4) {
      r3 in e5 ? e5[r3]++ : e5[r3] = 0;
      return R(t2, e5, r3 + "_" + e5[r3], r3);
    }
  return a4;
}
function T(t2, e5, a4 = "afterVersion") {
  function r3(t3, e6) {
    for (let a5 = e6; a5 < t3.length; a5++) {
      const e7 = t3[a5];
      if ("operator" === e7.type && ";" === e7.data)
        return a5;
    }
    return null;
  }
  function n3(t3) {
    let e6 = -1, n4 = 0, o6 = -1;
    for (let i5 = 0; i5 < t3.length; i5++) {
      const s5 = t3[i5];
      if ("preprocessor" === s5.type && (/\#(if|ifdef|ifndef)\s+.+/.test(s5.data) ? ++n4 : /\#endif\s*.*/.test(s5.data) && --n4), "afterVersion" !== a4 && "afterPrecision" !== a4 || "preprocessor" === s5.type && s5.data.startsWith("#version") && (o6 = Math.max(o6, i5)), "afterPrecision" === a4 && "keyword" === s5.type && "precision" === s5.data) {
        const e7 = r3(t3, i5);
        if (null === e7)
          throw new Error("precision statement not followed by any semicolons!");
        o6 = Math.max(o6, e7);
      }
      e6 < o6 && 0 === n4 && (e6 = i5);
    }
    return e6 + 1;
  }
  const o5 = { data: "\n", type: "whitespace" }, i4 = (e6) => e6 < t2.length && /[^\r\n]$/.test(t2[e6].data);
  let s4 = n3(t2);
  i4(s4 - 1) && t2.splice(s4++, 0, o5);
  for (const c4 of e5)
    t2.splice(s4++, 0, c4);
  i4(s4 - 1) && i4(s4) && t2.splice(s4, 0, o5);
}
function S(t2, e5, a4, r3 = "lowp") {
  T(t2, [{ type: "keyword", data: "out" }, { type: "whitespace", data: " " }, { type: "keyword", data: r3 }, { type: "whitespace", data: " " }, { type: "keyword", data: a4 }, { type: "whitespace", data: " " }, { type: "ident", data: e5 }, { type: "operator", data: ";" }], "afterPrecision");
}
function G(t2, e5, a4, r3, n3 = "lowp") {
  T(t2, [{ type: "keyword", data: "layout" }, { type: "operator", data: "(" }, { type: "keyword", data: "location" }, { type: "whitespace", data: " " }, { type: "operator", data: "=" }, { type: "whitespace", data: " " }, { type: "integer", data: r3.toString() }, { type: "operator", data: ")" }, { type: "whitespace", data: " " }, { type: "keyword", data: "out" }, { type: "whitespace", data: " " }, { type: "keyword", data: n3 }, { type: "whitespace", data: " " }, { type: "keyword", data: a4 }, { type: "whitespace", data: " " }, { type: "ident", data: e5 }, { type: "operator", data: ";" }], "afterPrecision");
}
function X(t2, e5) {
  let a4, r3, n3 = -1;
  for (let o5 = e5; o5 < t2.length; o5++) {
    const e6 = t2[o5];
    if ("operator" === e6.type && ("[" === e6.data && (a4 = o5), "]" === e6.data)) {
      r3 = o5;
      break;
    }
    "integer" === e6.type && (n3 = parseInt(e6.data, 10));
  }
  return a4 && r3 && t2.splice(a4, r3 - a4 + 1), n3;
}
function F(a4, r3) {
  if (a4.startsWith("#version 300"))
    return a4;
  const n3 = C(a4);
  if (null != n3)
    return n3;
  const o5 = v(a4);
  if ("300 es" === x(o5, "100", "300 es"))
    return a4;
  let i4 = null, s4 = null;
  const c4 = {}, p3 = {};
  for (let u2 = 0; u2 < o5.length; ++u2) {
    const a5 = o5[u2];
    switch (a5.type) {
      case "keyword":
        r3 === H.VERTEX_SHADER && "attribute" === a5.data ? a5.data = "in" : "varying" === a5.data && (a5.data = r3 === H.VERTEX_SHADER ? "out" : "in");
        break;
      case "builtin":
        if (/^texture(2D|Cube)(Proj)?(Lod|Grad)?(EXT)?$/.test(a5.data.trim()) && (a5.data = a5.data.replaceAll(/(2D|Cube|EXT)/g, "")), r3 === H.FRAGMENT_SHADER && "gl_FragColor" === a5.data && (i4 || (i4 = R(o5, c4, "fragColor"), S(o5, i4, "vec4")), a5.data = i4), r3 === H.FRAGMENT_SHADER && "gl_FragData" === a5.data) {
          const t2 = X(o5, u2 + 1), e5 = R(o5, c4, "fragData");
          G(o5, e5, "vec4", t2, "mediump"), a5.data = e5;
        } else
          r3 === H.FRAGMENT_SHADER && "gl_FragDepthEXT" === a5.data && (s4 || (s4 = R(o5, c4, "gl_FragDepth")), a5.data = s4);
        break;
      case "ident":
        if (e.includes(a5.data)) {
          if (r3 === H.VERTEX_SHADER && D(o5, u2))
            throw new Error("attribute in vertex shader uses a name that is a reserved word in glsl 300 es");
          a5.data in p3 || (p3[a5.data] = R(o5, c4, a5.data)), a5.data = p3[a5.data];
        }
    }
  }
  for (let t2 = o5.length - 1; t2 >= 0; --t2) {
    const e5 = o5[t2];
    if ("preprocessor" === e5.type) {
      const a5 = e5.data.match(/\#extension\s+(.*)\:/);
      if (a5 && a5[1] && A.has(a5[1].trim())) {
        const e6 = o5[t2 + 1];
        o5.splice(t2, e6 && "whitespace" === e6.type ? 2 : 1);
      }
      const r4 = e5.data.match(/\#ifdef\s+(.*)/);
      r4 && r4[1] && A.has(r4[1].trim()) && (e5.data = "#if 1");
      const n4 = e5.data.match(/\#ifndef\s+(.*)/);
      n4 && n4[1] && A.has(n4[1].trim()) && (e5.data = "#if 0");
    }
  }
  return H2(a4, j(o5));
}
var L = /* @__PURE__ */ new Map();
function C(t2) {
  return e2.enableCache ? L.get(t2) : null;
}
function H2(t2, e5) {
  return e2.enableCache && L.set(t2, e5), e5;
}

// node_modules/@arcgis/core/views/webgl/Program.js
var s3 = 4294967295;
var m2 = class {
  constructor(t2, m3, h3, f4, c4 = /* @__PURE__ */ new Map()) {
    this._context = t2, this._locations = f4, this._uniformBlockBindings = c4, this._refCount = 1, this._compiled = false, this._linesOfCode = 0, this._nameToUniformLocation = /* @__PURE__ */ new Map(), this._nameToUniform1 = /* @__PURE__ */ new Map(), this._nameToUniform1v = /* @__PURE__ */ new Map(), this._nameToUniform2 = /* @__PURE__ */ new Map(), this._nameToUniform3 = /* @__PURE__ */ new Map(), this._nameToUniform4 = /* @__PURE__ */ new Map(), this._nameToUniformMatrix3 = /* @__PURE__ */ new Map(), this._nameToUniformMatrix4 = /* @__PURE__ */ new Map(), t2 || console.error("RenderingContext isn't initialized!"), 0 === m3.length && console.error("Shaders source should not be empty!"), this._context.type === n.WEBGL2 && (m3 = F(m3, H.VERTEX_SHADER), h3 = F(h3, H.FRAGMENT_SHADER)), this._vShader = a3(this._context, H.VERTEX_SHADER, m3), this._fShader = a3(this._context, H.FRAGMENT_SHADER, h3), _2.enabled && (this._linesOfCode = m3.match(/\n/g).length + h3.match(/\n/g).length + 2, this._context.instanceCounter.increment(V.LinesOfCode, this._vShader, this._linesOfCode)), this._vShader && this._fShader || console.error("Error loading shaders!"), this._context.instanceCounter.increment(V.Shader, this), c() && (this.vertexShader = m3, this.fragmentShader = h3);
    const l3 = this._context.gl, g3 = l3.createProgram();
    if (l3.attachShader(g3, this._vShader), l3.attachShader(g3, this._fShader), this._locations.forEach((t3, e5) => l3.bindAttribLocation(g3, t3, e5)), l3.linkProgram(g3), c() && !l3.getProgramParameter(g3, l3.LINK_STATUS) && console.error(`Could not link shader
validated: ${l3.getProgramParameter(g3, l3.VALIDATE_STATUS)}, gl error ${l3.getError()}, vertex: ${l3.getShaderParameter(this._vShader, l3.COMPILE_STATUS)}, fragment: ${l3.getShaderParameter(this._fShader, l3.COMPILE_STATUS)}, info log: ${l3.getProgramInfoLog(g3)}, vertex source: ${this.vertexShader}, fragment source: ${this.fragmentShader}`), this._context.type === n.WEBGL2) {
      const t3 = l3;
      for (const [e5, i4] of this._uniformBlockBindings) {
        const o5 = t3.getUniformBlockIndex(g3, e5);
        o5 < s3 && t3.uniformBlockBinding(g3, o5, i4);
      }
    }
    this._glName = g3, this._context.instanceCounter.increment(V.Program, this);
  }
  get glName() {
    return this._glName;
  }
  get hasGLName() {
    return null != this._glName;
  }
  get compiled() {
    if (this._compiled)
      return true;
    const t2 = this._context.gl.getExtension("KHR_parallel_shader_compile");
    return null == t2 || null == this.glName ? (this._compiled = true, true) : (this._compiled = !!this._context.gl.getProgramParameter(this.glName, t2.COMPLETION_STATUS_KHR), this._compiled);
  }
  dispose() {
    if (--this._refCount > 0)
      return;
    const t2 = this._context.gl, e5 = this._context.instanceCounter;
    this._nameToUniformLocation.forEach((t3) => t3 && e5.decrement(V.Uniform, t3)), this._nameToUniformLocation.clear(), this._vShader && (this._linesOfCode > 0 && (e5.decrement(V.LinesOfCode, this._vShader, this._linesOfCode), this._linesOfCode = 0), t2.deleteShader(this._vShader), this._vShader = null, e5.decrement(V.Shader, this)), this._fShader && (t2.deleteShader(this._fShader), this._fShader = null), this._glName && (t2.deleteProgram(this._glName), this._glName = null, e5.decrement(V.Program, this));
  }
  ref() {
    ++this._refCount;
  }
  _getUniformLocation(t2) {
    const e5 = this._nameToUniformLocation.get(t2);
    if (void 0 !== e5)
      return e5;
    if (this.glName) {
      const e6 = this._context.gl.getUniformLocation(this.glName, t2);
      return this._nameToUniformLocation.set(t2, e6), e6 && this._context.instanceCounter.increment(V.Uniform, e6), e6;
    }
    return null;
  }
  hasUniform(t2) {
    return null != this._getUniformLocation(t2);
  }
  setUniform1i(t2, e5) {
    const i4 = this._nameToUniform1.get(t2);
    void 0 !== i4 && e5 === i4 || (this._context.gl.uniform1i(this._getUniformLocation(t2), e5), this._nameToUniform1.set(t2, e5));
  }
  setUniform1iv(t2, e5) {
    c3(this._nameToUniform1v, t2, e5) && this._context.gl.uniform1iv(this._getUniformLocation(t2), e5);
  }
  setUniform2iv(t2, e5) {
    c3(this._nameToUniform2, t2, e5) && this._context.gl.uniform2iv(this._getUniformLocation(t2), e5);
  }
  setUniform3iv(t2, e5) {
    c3(this._nameToUniform3, t2, e5) && this._context.gl.uniform3iv(this._getUniformLocation(t2), e5);
  }
  setUniform4iv(t2, e5) {
    c3(this._nameToUniform4, t2, e5) && this._context.gl.uniform4iv(this._getUniformLocation(t2), e5);
  }
  setUniform1f(t2, e5) {
    const i4 = this._nameToUniform1.get(t2);
    void 0 !== i4 && e5 === i4 || (this._context.gl.uniform1f(this._getUniformLocation(t2), e5), this._nameToUniform1.set(t2, e5));
  }
  setUniform1fv(t2, e5) {
    c3(this._nameToUniform1v, t2, e5) && this._context.gl.uniform1fv(this._getUniformLocation(t2), e5);
  }
  setUniform2f(t2, e5, i4) {
    const o5 = this._nameToUniform2.get(t2);
    void 0 === o5 ? (this._context.gl.uniform2f(this._getUniformLocation(t2), e5, i4), this._nameToUniform2.set(t2, [e5, i4])) : e5 === o5[0] && i4 === o5[1] || (this._context.gl.uniform2f(this._getUniformLocation(t2), e5, i4), o5[0] = e5, o5[1] = i4);
  }
  setUniform2fv(t2, e5) {
    c3(this._nameToUniform2, t2, e5) && this._context.gl.uniform2fv(this._getUniformLocation(t2), e5);
  }
  setUniform3f(t2, e5, i4, o5) {
    const n3 = this._nameToUniform3.get(t2);
    void 0 === n3 ? (this._context.gl.uniform3f(this._getUniformLocation(t2), e5, i4, o5), this._nameToUniform3.set(t2, [e5, i4, o5])) : e5 === n3[0] && i4 === n3[1] && o5 === n3[2] || (this._context.gl.uniform3f(this._getUniformLocation(t2), e5, i4, o5), n3[0] = e5, n3[1] = i4, n3[2] = o5);
  }
  setUniform3fv(t2, e5) {
    c3(this._nameToUniform3, t2, e5) && this._context.gl.uniform3fv(this._getUniformLocation(t2), e5);
  }
  setUniform4f(t2, e5, i4, o5, n3) {
    const r3 = this._nameToUniform4.get(t2);
    void 0 === r3 ? (this._context.gl.uniform4f(this._getUniformLocation(t2), e5, i4, o5, n3), this._nameToUniform4.set(t2, [e5, i4, o5, n3])) : void 0 !== r3 && e5 === r3[0] && i4 === r3[1] && o5 === r3[2] && n3 === r3[3] || (this._context.gl.uniform4f(this._getUniformLocation(t2), e5, i4, o5, n3), r3[0] = e5, r3[1] = i4, r3[2] = o5, r3[3] = n3);
  }
  setUniform4fv(t2, e5) {
    c3(this._nameToUniform4, t2, e5) && this._context.gl.uniform4fv(this._getUniformLocation(t2), e5);
  }
  setUniformMatrix3fv(t2, e5, i4 = false) {
    c3(this._nameToUniformMatrix3, t2, e5) && this._context.gl.uniformMatrix3fv(this._getUniformLocation(t2), i4, e5);
  }
  setUniformMatrix4fv(t2, e5, i4 = false) {
    c3(this._nameToUniformMatrix4, t2, e5) && this._context.gl.uniformMatrix4fv(this._getUniformLocation(t2), i4, e5);
  }
  stop() {
  }
};
function a3(t2, i4, n3) {
  const r3 = t2.gl, s4 = r3.createShader(i4);
  return r3.shaderSource(s4, n3), r3.compileShader(s4), c() && !r3.getShaderParameter(s4, r3.COMPILE_STATUS) && (console.error("Compile error in ".concat(i4 === H.VERTEX_SHADER ? "vertex" : "fragment", " shader")), console.error(r3.getShaderInfoLog(s4)), console.error(h2(n3))), s4;
}
function h2(t2) {
  let e5 = 2;
  return t2.replaceAll("\n", () => "\n" + f2(e5++) + ":");
}
function f2(t2) {
  return t2 >= 1e3 ? t2.toString() : ("  " + t2).slice(-3);
}
function c3(e5, i4, o5) {
  const n3 = e5.get(i4);
  return n3 ? a(n3, o5) : (e5.set(i4, Array.from(o5)), true);
}
var _2 = { enabled: false };

// node_modules/@arcgis/core/views/webgl/ShaderCompiler.js
var e3 = class {
  constructor(e5) {
    this._readFile = e5;
  }
  resolveIncludes(e5) {
    return this._resolve(e5);
  }
  _resolve(e5, t2 = /* @__PURE__ */ new Map()) {
    if (t2.has(e5))
      return t2.get(e5);
    const r3 = this._read(e5);
    if (!r3)
      throw new Error(`cannot find shader file ${e5}`);
    const s4 = /^[^\S\n]*#include\s+<(\S+)>[^\S\n]?/gm;
    let n3 = s4.exec(r3);
    const l3 = [];
    for (; null != n3; )
      l3.push({ path: n3[1], start: n3.index, length: n3[0].length }), n3 = s4.exec(r3);
    let a4 = 0, h3 = "";
    return l3.forEach((e6) => {
      h3 += r3.slice(a4, e6.start), h3 += t2.has(e6.path) ? "" : this._resolve(e6.path, t2), a4 = e6.start + e6.length;
    }), h3 += r3.slice(a4), t2.set(e5, h3), h3;
  }
  _read(e5) {
    return this._readFile(e5);
  }
};

// node_modules/@arcgis/core/views/webgl/VertexArrayObject.js
var o4 = s.getLogger("esri.views.webgl.VertexArrayObject");
var f3 = class {
  constructor(t2, e5, i4, r3, s4 = null) {
    this._context = t2, this._locations = e5, this._layout = i4, this._buffers = r3, this._indexBuffer = s4, this._glName = null, this._initialized = false;
  }
  get glName() {
    return this._glName;
  }
  get context() {
    return this._context;
  }
  get vertexBuffers() {
    return this._buffers;
  }
  get indexBuffer() {
    return this._indexBuffer;
  }
  get byteSize() {
    return Object.keys(this._buffers).reduce((t2, e5) => t2 + this._buffers[e5].byteLength, null != this._indexBuffer ? this._indexBuffer.byteLength : 0);
  }
  get layout() {
    return this._layout;
  }
  get locations() {
    return this._locations;
  }
  get usedMemory() {
    return this.byteSize + (Object.keys(this._buffers).length + (this._indexBuffer ? 1 : 0)) * p;
  }
  dispose() {
    var _a;
    if (this._context) {
      this._context.getBoundVAO() === this && this._context.bindVAO(null);
      for (const t2 in this._buffers)
        (_a = this._buffers[t2]) == null ? void 0 : _a.dispose(), delete this._buffers[t2];
      this._indexBuffer = r(this._indexBuffer), this.disposeVAOOnly();
    } else
      (this._glName || Object.getOwnPropertyNames(this._buffers).length > 0) && o4.warn("Leaked WebGL VAO");
  }
  disposeVAOOnly() {
    var _a, _b;
    if (this._glName) {
      const t2 = (_b = (_a = this._context) == null ? void 0 : _a.capabilities) == null ? void 0 : _b.vao;
      t2.deleteVertexArray(this._glName), this._glName = null, this._context.instanceCounter.decrement(V.VertexArrayObject, this);
    }
    this._context = null;
  }
  initialize() {
    if (this._initialized)
      return;
    const t2 = this._context.capabilities.vao;
    if (t2) {
      const e5 = t2.createVertexArray();
      t2.bindVertexArray(e5), this._bindLayout(), t2.bindVertexArray(null), this._glName = e5, this._context.instanceCounter.increment(V.VertexArrayObject, this);
    }
    this._initialized = true;
  }
  bind() {
    this.initialize();
    const t2 = this._context.capabilities.vao;
    t2 ? t2.bindVertexArray(this.glName) : (this._context.bindVAO(null), this._bindLayout());
  }
  _bindLayout() {
    const { _buffers: t2, _layout: e5, _indexBuffer: i4 } = this;
    t2 || o4.error("Vertex buffer dictionary is empty!");
    const r3 = this._context.gl;
    for (const n3 in t2) {
      const i5 = t2[n3];
      i5 || o4.error("Vertex buffer is uninitialized!");
      const r4 = e5[n3];
      r4 || o4.error("Vertex element descriptor is empty!"), i(this._context, this._locations, i5, r4);
    }
    if (null != i4) {
      !!this._context.capabilities.vao ? r3.bindBuffer(r3.ELEMENT_ARRAY_BUFFER, i4.glName) : this._context.bindBuffer(i4);
    }
  }
  unbind() {
    this.initialize();
    const t2 = this._context.capabilities.vao;
    t2 ? t2.bindVertexArray(null) : this._unbindLayout();
  }
  _unbindLayout() {
    const { _buffers: t2, _layout: e5 } = this;
    t2 || o4.error("Vertex buffer dictionary is empty!");
    for (const i4 in t2) {
      const r3 = t2[i4];
      r3 || o4.error("Vertex buffer is uninitialized!");
      const s4 = e5[i4];
      o2(this._context, this._locations, r3, s4);
    }
    null != this._indexBuffer && this._context.unbindBuffer(this._indexBuffer.bufferType);
  }
};

// node_modules/@arcgis/core/views/webgl/ProgramTemplate.js
function e4(e5, t2, a4 = "") {
  return new m2(e5, a4 + t2.shaders.vertexShader, a4 + t2.shaders.fragmentShader, t2.attributes);
}

export {
  m2 as m,
  e3 as e,
  f3 as f,
  e4 as e2
};
//# sourceMappingURL=chunk-BV5PCIP6.js.map
