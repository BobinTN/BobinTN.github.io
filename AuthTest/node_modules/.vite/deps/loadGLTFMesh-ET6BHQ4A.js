import {
  e as e3,
  e2 as e4,
  f2,
  f3,
  l,
  l2,
  n,
  n3 as n2,
  o as o2,
  o2 as o3,
  o3 as o4,
  o4 as o5,
  r as r4
} from "./chunk-TUEI54TI.js";
import {
  r as r5
} from "./chunk-PRZWMTUS.js";
import {
  g as g2,
  p
} from "./chunk-ZN6Q7TWV.js";
import {
  c as c2,
  c2 as c3,
  m as m2
} from "./chunk-UTUG5XXJ.js";
import "./chunk-NB4VIBDC.js";
import {
  e
} from "./chunk-53TKZQ46.js";
import "./chunk-VHDTZ7JB.js";
import {
  D
} from "./chunk-RCLKRKWR.js";
import {
  B
} from "./chunk-5VOKVSCM.js";
import "./chunk-SD4PEUIA.js";
import "./chunk-TOWKJZW4.js";
import "./chunk-SLEGPWAA.js";
import {
  f,
  i as i2,
  o,
  t
} from "./chunk-GLOKOXWD.js";
import "./chunk-4OLZTDWK.js";
import "./chunk-JYYKU27J.js";
import "./chunk-SKLWU2B3.js";
import {
  e as e2
} from "./chunk-2RN2AAP7.js";
import {
  E,
  L,
  O,
  T,
  c,
  i,
  u,
  x
} from "./chunk-YHB3DQSV.js";
import "./chunk-VKTTTBW2.js";
import {
  r as r3
} from "./chunk-AMSVADDY.js";
import "./chunk-SBUFDP7O.js";
import {
  g
} from "./chunk-YVNEJWNQ.js";
import "./chunk-NDKHIQMD.js";
import "./chunk-TWNBDJHC.js";
import {
  u as u2
} from "./chunk-G557TGXY.js";
import "./chunk-PJQIAD5D.js";
import "./chunk-WJ4LS3YG.js";
import "./chunk-F6MD5VOH.js";
import "./chunk-V2RPSCV3.js";
import "./chunk-LMT5JII2.js";
import "./chunk-4HKQSEUR.js";
import "./chunk-V3U4F2NL.js";
import "./chunk-ZB6PGKG5.js";
import "./chunk-OIIDE5GZ.js";
import "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import {
  _,
  m
} from "./chunk-MKW4ORPJ.js";
import {
  r as r2
} from "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import "./chunk-6TJWLWLO.js";
import "./chunk-FN47E7YK.js";
import "./chunk-Y5D433JZ.js";
import "./chunk-QNOCEWCR.js";
import "./chunk-WURET5CW.js";
import "./chunk-QWPLZ3QH.js";
import "./chunk-HLGIRLYQ.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import {
  j
} from "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import "./chunk-LXXF7K7W.js";
import {
  r2 as r
} from "./chunk-SBW6NNVI.js";
import "./chunk-62CXLI6S.js";
import "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import "./chunk-WJ3HJKNC.js";
import "./chunk-4V6374PV.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/chunks/mat32.js
function e5(e7, t5, o8) {
  const r7 = e7.typedBuffer, f4 = e7.typedBufferStride, d = t5.typedBuffer, n3 = t5.typedBufferStride, c4 = o8 ? o8.count : t5.count;
  let u4 = ((o8 == null ? void 0 : o8.dstIndex) ?? 0) * f4, l3 = ((o8 == null ? void 0 : o8.srcIndex) ?? 0) * n3;
  for (let p2 = 0; p2 < c4; ++p2) {
    for (let e8 = 0; e8 < 9; ++e8)
      r7[u4 + e8] = d[l3 + e8];
    u4 += f4, l3 += n3;
  }
}
var t2 = Object.freeze(Object.defineProperty({ __proto__: null, copy: e5 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/mat42.js
function e6(e7, t5, o8) {
  const r7 = e7.typedBuffer, f4 = e7.typedBufferStride, d = t5.typedBuffer, n3 = t5.typedBufferStride, c4 = o8 ? o8.count : t5.count;
  let u4 = ((o8 == null ? void 0 : o8.dstIndex) ?? 0) * f4, l3 = ((o8 == null ? void 0 : o8.srcIndex) ?? 0) * n3;
  for (let p2 = 0; p2 < c4; ++p2) {
    for (let e8 = 0; e8 < 16; ++e8)
      r7[u4 + e8] = d[l3 + e8];
    u4 += f4, l3 += n3;
  }
}
var t3 = Object.freeze(Object.defineProperty({ __proto__: null, copy: e6 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/geometry/support/buffer/utils.js
function r6(s, r7) {
  return new s(new ArrayBuffer(r7 * s.ElementCount * e(s.ElementType)));
}

// node_modules/@arcgis/core/geometry/support/meshUtils/loadGLTFMesh.js
async function N(e7, t5, r7) {
  const o8 = { ...r7, useTransform: (r7 == null ? void 0 : r7.useTransform) ?? true }, n3 = new n2(z(o8)), s = (await l2(n3, t5, o8, true)).model, a = s.lods.shift(), l3 = /* @__PURE__ */ new Map(), i3 = /* @__PURE__ */ new Map();
  s.textures.forEach((e8, t6) => l3.set(t6, H(e8))), s.materials.forEach((e8, t6) => i3.set(t6, J(e8, l3)));
  const u4 = Q(a);
  for (const p2 of u4.parts)
    W(u4, p2, i3);
  const { position: c4, normal: f4, tangent: m3, color: d, texCoord0: g3 } = u4.vertexAttributes, x2 = { position: c4.typedBuffer, normal: null != f4 ? f4.typedBuffer : null, tangent: null != m3 ? m3.typedBuffer : null, uv: null != g3 ? g3.typedBuffer : null, color: null != d ? d.typedBuffer : null }, T2 = B(x2, e7, o8);
  return { transform: T2.transform, vertexSpace: T2.vertexSpace, components: u4.components, spatialReference: e7.spatialReference, vertexAttributes: new p({ position: T2.vertexAttributes.position, normal: T2.vertexAttributes.normal, tangent: T2.vertexAttributes.tangent, color: x2.color, uv: x2.uv }) };
}
function z(e7) {
  const r7 = e7 == null ? void 0 : e7.resolveFile, o8 = e7 == null ? void 0 : e7.requestFile;
  return r7 || o8 ? { busy: false, request: async (e8, n3, s) => {
    const a = (r7 == null ? void 0 : r7(e8)) ?? e8;
    if (o8) {
      const e9 = await o8(a, n3, s == null ? void 0 : s.signal);
      if (void 0 !== e9)
        return e9;
    }
    const l3 = "image" === n3 ? "image" : "binary" === n3 ? "array-buffer" : "json";
    return (await j(a, { responseType: l3, signal: null != s ? s.signal : null })).data;
  } } : null;
}
function G(e7, t5) {
  if (null == e7)
    return "-";
  const o8 = e7.typedBuffer;
  return `${r(t5, o8.buffer, () => t5.size)}/${o8.byteOffset}/${o8.byteLength}`;
}
function K(e7) {
  return null != e7 ? e7.toString() : "-";
}
function Q(e7) {
  let t5 = 0;
  const has = { color: false, tangent: false, normal: false, texCoord0: false }, o8 = /* @__PURE__ */ new Map(), n3 = /* @__PURE__ */ new Map(), s = [];
  for (const a of e7.parts) {
    const { attributes: { position: e8, normal: l3, color: i3, tangent: u4, texCoord0: c4 } } = a, f4 = `
      ${G(e8, o8)}/
      ${G(l3, o8)}/
      ${G(i3, o8)}/
      ${G(u4, o8)}/
      ${G(c4, o8)}/
      ${K(a.transform)}
    `;
    let m3 = false;
    const p2 = r(n3, f4, () => (m3 = true, { start: t5, length: e8.count }));
    m3 && (t5 += e8.count), l3 && (has.normal = true), i3 && (has.color = true), u4 && (has.tangent = true), c4 && (has.texCoord0 = true), s.push({ gltf: a, writeVertices: m3, region: p2 });
  }
  return { vertexAttributes: { position: r6(T, t5), normal: has.normal ? r6(i, t5) : null, tangent: has.tangent ? r6(c, t5) : null, color: has.color ? r6(x, t5) : null, texCoord0: has.texCoord0 ? r6(u, t5) : null }, parts: s, components: [] };
}
function H(e7) {
  return new m2({ data: (r5(e7.data), e7.data), wrap: Z(e7.parameters.wrap) });
}
function J(t5, r7) {
  const o8 = new u2(re(t5.color, t5.opacity)), s = t5.emissiveFactor ? new u2(oe(t5.emissiveFactor)) : null, a = (e7) => e7 ? new c2({ scale: e7.scale ? [e7.scale[0], e7.scale[1]] : [1, 1], rotation: m(e7.rotation ?? 0), offset: e7.offset ? [e7.offset[0], e7.offset[1]] : [0, 0] }) : null;
  return new c3({ color: o8, colorTexture: r7.get(t5.textureColor), normalTexture: r7.get(t5.textureNormal), emissiveColor: s, emissiveTexture: r7.get(t5.textureEmissive), occlusionTexture: r7.get(t5.textureOcclusion), alphaMode: Y(t5.alphaMode), alphaCutoff: t5.alphaCutoff, doubleSided: t5.doubleSided, metallic: t5.metallicFactor, roughness: t5.roughnessFactor, metallicRoughnessTexture: r7.get(t5.textureMetallicRoughness), colorTextureTransform: a(t5.colorTextureTransform), normalTextureTransform: a(t5.normalTextureTransform), occlusionTextureTransform: a(t5.occlusionTextureTransform), emissiveTextureTransform: a(t5.emissiveTextureTransform), metallicRoughnessTextureTransform: a(t5.metallicRoughnessTextureTransform) });
}
function W(e7, t5, r7) {
  t5.writeVertices && X(e7, t5);
  const { indices: o8, attributes: n3, primitiveType: s, material: a } = t5.gltf;
  let l3 = o4(o8 || n3.position.count, s);
  const i3 = t5.region.start;
  if (i3) {
    const e8 = new Uint32Array(l3);
    for (let t6 = 0; t6 < l3.length; t6++)
      e8[t6] += i3;
    l3 = e8;
  }
  e7.components.push(new g2({ name: t5.gltf.name, faces: l3, material: r7.get(a), shading: n3.normal ? "source" : "flat", trustSourceNormals: true }));
}
function X(e7, t5) {
  const { position: r7, normal: n3, tangent: l3, color: i3, texCoord0: u4 } = e7.vertexAttributes, c4 = t5.region.start, { attributes: f4, transform: m3 } = t5.gltf, p2 = f4.position.count;
  if (t(r7.slice(c4, p2), f4.position, m3), null != f4.normal && null != n3) {
    const e8 = g(e2(), m3), t6 = n3.slice(c4, p2);
    f(t6, f4.normal, e8), _(e8) && i2(t6, t6);
  } else
    null != n3 && f2(n3, 0, 0, 1, { dstIndex: c4, count: p2 });
  if (null != f4.tangent && null != l3) {
    const e8 = g(e2(), m3), t6 = l3.slice(c4, p2);
    r4(t6, f4.tangent, e8), _(e8) && n(t6, t6);
  } else
    null != l3 && f3(l3, 0, 0, 1, 1, { dstIndex: c4, count: p2 });
  if (null != f4.texCoord0 && null != u4 ? o3(u4.slice(c4, p2), f4.texCoord0) : null != u4 && l(u4, 0, 0, { dstIndex: c4, count: p2 }), null != f4.color && null != i3) {
    const e8 = f4.color, t6 = i3.slice(c4, p2);
    if (4 === e8.elementCount)
      e8 instanceof c ? o2(t6, e8, 255) : e8 instanceof x ? e4(t6, e8) : e8 instanceof L && o2(t6, e8, 1 / 256);
    else {
      f3(t6, 255, 255, 255, 255);
      const r8 = O.fromTypedArray(t6.typedBuffer, t6.typedBufferStride);
      e8 instanceof i ? o(r8, e8, 255) : e8 instanceof O ? e3(r8, e8) : e8 instanceof E && o(r8, e8, 1 / 256);
    }
  } else
    null != i3 && f3(i3.slice(c4, p2), 255, 255, 255, 255);
}
function Y(e7) {
  switch (e7) {
    case "OPAQUE":
      return "opaque";
    case "MASK":
      return "mask";
    case "BLEND":
      return "blend";
  }
}
function Z(e7) {
  return { horizontal: ee(e7.s), vertical: ee(e7.t) };
}
function ee(e7) {
  switch (e7) {
    case D.CLAMP_TO_EDGE:
      return "clamp";
    case D.MIRRORED_REPEAT:
      return "mirror";
    case D.REPEAT:
      return "repeat";
  }
}
function te(e7) {
  return e7 ** (1 / o5) * 255;
}
function re(e7, t5) {
  return r3(te(e7[0]), te(e7[1]), te(e7[2]), t5);
}
function oe(e7) {
  return r2(te(e7[0]), te(e7[1]), te(e7[2]));
}
export {
  N as loadGLTFMesh
};
//# sourceMappingURL=loadGLTFMesh-ET6BHQ4A.js.map
