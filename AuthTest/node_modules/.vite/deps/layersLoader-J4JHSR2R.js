import {
  w
} from "./chunk-ZUDDGRGT.js";
import {
  e as e2,
  l as l2
} from "./chunk-IUQHF7KZ.js";
import {
  t as t3
} from "./chunk-ID2FHQ3Y.js";
import {
  a,
  e,
  i,
  l,
  n,
  r,
  s as s2,
  t as t2
} from "./chunk-JSBCPI3K.js";
import "./chunk-4LVXP3AZ.js";
import {
  t
} from "./chunk-3U7MSH5S.js";
import {
  a as a2
} from "./chunk-6DA3YN7V.js";
import {
  t as t4
} from "./chunk-T2S5L26W.js";
import {
  s as s3
} from "./chunk-6B7VJB6C.js";
import {
  p
} from "./chunk-AOJ6OCPK.js";
import "./chunk-LMT5JII2.js";
import "./chunk-A43TI6AT.js";
import "./chunk-2D3PORS4.js";
import "./chunk-4HKQSEUR.js";
import "./chunk-V3U4F2NL.js";
import "./chunk-ZB6PGKG5.js";
import "./chunk-OIIDE5GZ.js";
import "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import "./chunk-6TJWLWLO.js";
import "./chunk-JUZJCTW2.js";
import "./chunk-423VNHLR.js";
import "./chunk-FN47E7YK.js";
import {
  j
} from "./chunk-WZPOQGKL.js";
import "./chunk-CCXEAKIM.js";
import "./chunk-Y5D433JZ.js";
import "./chunk-QNOCEWCR.js";
import "./chunk-WURET5CW.js";
import "./chunk-QWPLZ3QH.js";
import "./chunk-HLGIRLYQ.js";
import "./chunk-N2K4VRZH.js";
import "./chunk-WL4VPODY.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import "./chunk-LXXF7K7W.js";
import "./chunk-SBW6NNVI.js";
import "./chunk-62CXLI6S.js";
import "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  s3 as s
} from "./chunk-WJ3HJKNC.js";
import "./chunk-4V6374PV.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/portal/support/layersLoader.js
async function g(e3, t5) {
  const r2 = e3.instance.portalItem;
  if (r2 == null ? void 0 : r2.id)
    return await r2.load(t5), I(e3), L(e3, t5);
}
function I(t5) {
  const r2 = t5.instance.portalItem;
  if (!(r2 == null ? void 0 : r2.type) || !t5.supportedTypes.includes(r2.type))
    throw new s("portal:invalid-layer-item-type", "Invalid layer item type '${type}', expected '${expectedType}'", { type: r2 == null ? void 0 : r2.type, expectedType: t5.supportedTypes.join(", ") });
}
async function L(e3, t5) {
  const r2 = e3.instance, n2 = r2.portalItem;
  if (!n2)
    return;
  const { url: o, title: s4 } = n2, i2 = e2(n2);
  if ("group" === r2.type)
    return S(r2, i2, e3);
  o && r2.read({ url: o }, i2);
  const p2 = new e(), u = await F(e3, p2, t5);
  return u && r2.read(u, i2), r2.resourceReferences = { portalItem: n2, paths: i2.readResourcePaths ?? [] }, "subtype-group" !== r2.type && r2.read({ title: s4 }, i2), t4(r2, i2);
}
async function S(t5, r2, a3) {
  const n2 = t5.portalItem;
  if (!t5.sourceIsPortalItem)
    return;
  const { title: o, type: s4 } = n2;
  if ("Group Layer" === s4) {
    if (!s3(n2, "Map"))
      throw new s("portal:invalid-layer-item-typekeyword", "'Group Layer' item without 'Map' type keyword is not supported");
    return T(t5);
  }
  return t5.read({ title: o }, r2), j2(t5, a3);
}
async function T(e3) {
  const t5 = e3.portalItem, r2 = await t5.fetchData("json");
  if (!r2)
    return;
  const a3 = l2(t5);
  e3.read(r2, a3), await w(e3, r2, { context: a3 }), e3.resourceReferences = { portalItem: t5, paths: a3.readResourcePaths ?? [] };
}
async function j2(t5, r2) {
  let n2;
  const { portalItem: o } = t5;
  if (!o)
    return;
  const s4 = o.type, l3 = r2.layerModuleTypeMap;
  switch (s4) {
    case "Feature Service":
    case "Feature Collection":
      n2 = l3.FeatureLayer;
      break;
    case "Stream Service":
      n2 = l3.StreamLayer;
      break;
    case "Scene Service":
      n2 = l3.SceneLayer;
      break;
    default:
      throw new s("portal:unsupported-item-type-as-group", `The item type '${s4}' is not supported as a 'IGroupLayer'`);
  }
  const i2 = new e();
  let [d, m] = await Promise.all([n2(), F(r2, i2)]), h = () => d;
  if ("Feature Service" === s4) {
    m = o.url ? await a(m, o.url, i2) : {};
    const e3 = n(m), r3 = s2(m), a3 = [];
    if (e3.length || (r3 == null ? void 0 : r3.length)) {
      e3.length && a3.push("SubtypeGroupLayer"), (r3 == null ? void 0 : r3.length) && a3.push("OrientedImageryLayer");
      const t6 = [];
      for (const e4 of a3) {
        const r4 = l3[e4];
        t6.push(r4());
      }
      const n4 = await Promise.all(t6), o2 = /* @__PURE__ */ new Map();
      a3.forEach((e4, t7) => {
        o2.set(e4, n4[t7]);
      }), h = (e4) => e4.layerType ? o2.get(e4.layerType) ?? d : d;
    }
    const n3 = await E(o.url);
    return await M(t5, h, m, n3);
  }
  return "Scene Service" === s4 && o.url && (m = await i(o, m, i2)), l(m) > 0 ? await M(t5, h, m) : await v(t5, h);
}
async function v(e3, t5) {
  var _a, _b;
  const { portalItem: r2 } = e3;
  if (!(r2 == null ? void 0 : r2.url))
    return;
  const a3 = await t(r2.url);
  a3 && M(e3, t5, { layers: (_a = a3.layers) == null ? void 0 : _a.map(t2), tables: (_b = a3.tables) == null ? void 0 : _b.map(t2) });
}
async function M(e3, t5, r2, a3) {
  var _a;
  let n2 = r2.layers || [];
  const s4 = r2.tables || [];
  if ("Feature Collection" === ((_a = e3.portalItem) == null ? void 0 : _a.type) ? (n2.forEach((e4, t6) => {
    var _a2;
    e4.id = t6, "Table" === ((_a2 = e4 == null ? void 0 : e4.layerDefinition) == null ? void 0 : _a2.type) && s4.push(e4);
  }), n2 = n2.filter((e4) => {
    var _a2;
    return "Table" !== ((_a2 = e4 == null ? void 0 : e4.layerDefinition) == null ? void 0 : _a2.type);
  })) : (n2.reverse(), s4.reverse()), n2.forEach((n3) => {
    const o = a3 == null ? void 0 : a3(n3);
    if (o || !a3) {
      const a4 = x(e3, t5(n3), r2, n3, o);
      e3.add(a4);
    }
  }), s4.length) {
    const t6 = await a2.FeatureLayer();
    s4.forEach((n3) => {
      const o = a3 == null ? void 0 : a3(n3);
      if (o || !a3) {
        const a4 = x(e3, t6, r2, n3, o);
        e3.tables.add(a4);
      }
    });
  }
}
function x(e3, t5, r2, a3, n2) {
  const o = e3.portalItem, l3 = { portalItem: o.clone(), layerId: a3.id };
  null != a3.url && (l3.url = a3.url);
  const i2 = new t5(l3);
  if ("sourceJSON" in i2 && (i2.sourceJSON = n2), "subtype-group" !== i2.type && (i2.sublayerTitleMode = "service-name"), "Feature Collection" === o.type) {
    const e4 = { origin: "portal-item", portal: o.portal || j.getDefault() };
    i2.read(a3, e4);
    const t6 = r2.showLegend;
    null != t6 && i2.read({ showLegend: t6 }, e4);
  }
  return i2;
}
async function F(e3, t5, r2) {
  if (false === e3.supportsData)
    return;
  const a3 = e3.instance, n2 = a3.portalItem;
  if (!n2)
    return;
  let o = null;
  try {
    o = await n2.fetchData("json", r2);
  } catch (s4) {
  }
  if (D(a3)) {
    let e4 = null;
    const r3 = await P(n2, o, t5);
    if (((o == null ? void 0 : o.layers) || (o == null ? void 0 : o.tables)) && r3 > 0) {
      if (null == a3.layerId) {
        const e5 = n(o);
        a3.layerId = "subtype-group" === a3.type ? e5 == null ? void 0 : e5[0] : r(o);
      }
      e4 = C(o, a3), e4 && null != o.showLegend && (e4.showLegend = o.showLegend);
    }
    return r3 > 1 && "sublayerTitleMode" in a3 && "service-name" !== a3.sublayerTitleMode && (a3.sublayerTitleMode = "item-title-and-service-name"), e4;
  }
  return o;
}
async function P(e3, r2, a3) {
  var _a, _b, _c, _d;
  if ((r2 == null ? void 0 : r2.layers) && (r2 == null ? void 0 : r2.tables))
    return l(r2);
  const n2 = p(e3.url);
  if (!n2)
    return 1;
  const o = await a3.fetchServiceMetadata(n2.url.path).catch(() => null);
  return (((_a = r2 == null ? void 0 : r2.layers) == null ? void 0 : _a.length) ?? ((_b = o == null ? void 0 : o.layers) == null ? void 0 : _b.length) ?? 0) + (((_c = r2 == null ? void 0 : r2.tables) == null ? void 0 : _c.length) ?? ((_d = o == null ? void 0 : o.tables) == null ? void 0 : _d.length) ?? 0);
}
function C(e3, t5) {
  var _a, _b;
  const { layerId: r2 } = t5, a3 = ((_a = e3.layers) == null ? void 0 : _a.find((e4) => e4.id === r2)) || ((_b = e3.tables) == null ? void 0 : _b.find((e4) => e4.id === r2));
  return a3 && k(a3, t5) ? a3 : null;
}
function D(e3) {
  return "stream" !== e3.type && "layerId" in e3;
}
function k(e3, t5) {
  return !("feature" === t5.type && "layerType" in e3 && "SubtypeGroupLayer" === e3.layerType || "subtype-group" === t5.type && !("layerType" in e3));
}
async function E(e3) {
  const { layersJSON: t5 } = await t3(e3);
  if (!t5)
    return null;
  const a3 = [...t5.layers, ...t5.tables];
  return (e4) => a3.find((t6) => t6.id === e4.id);
}
export {
  g as load
};
//# sourceMappingURL=layersLoader-J4JHSR2R.js.map
