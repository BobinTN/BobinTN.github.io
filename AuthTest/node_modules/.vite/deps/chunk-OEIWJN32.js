import {
  a as a4,
  f as f3,
  h,
  o as o3,
  s as s4,
  u as u3,
  u2 as u4,
  u3 as u5
} from "./chunk-ABKJC2RS.js";
import {
  A,
  j,
  y as y2,
  z
} from "./chunk-XZLDDXLF.js";
import {
  u as u2
} from "./chunk-G557TGXY.js";
import {
  M
} from "./chunk-Y5D433JZ.js";
import {
  x2 as x
} from "./chunk-QNOCEWCR.js";
import {
  o
} from "./chunk-WURET5CW.js";
import {
  f as f2,
  r
} from "./chunk-QWPLZ3QH.js";
import {
  s as s3
} from "./chunk-EUTNDAIV.js";
import {
  a as a3
} from "./chunk-SJZIFARA.js";
import {
  a as a2,
  f
} from "./chunk-NSRXJNTS.js";
import {
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c as c2
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  c2 as c,
  u
} from "./chunk-RFPH3ZTZ.js";
import {
  n
} from "./chunk-WGO3VFQP.js";
import {
  a,
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import {
  o as o2
} from "./chunk-A34O4XB5.js";

// node_modules/@arcgis/core/chunks/Zlib.js
var e2;
var r2;
var i;
var s5 = { exports: {} };
s5.exports, r2 = s5, void 0 !== (e2 = function() {
  function t8() {
    this.pos = 0, this.bufferLength = 0, this.eof = false, this.buffer = null;
  }
  return t8.prototype = { ensureBuffer: function(t9) {
    var e7 = this.buffer, r13 = e7 ? e7.byteLength : 0;
    if (t9 < r13)
      return e7;
    for (var i9 = 512; i9 < t9; )
      i9 <<= 1;
    for (var s10 = new Uint8Array(i9), f10 = 0; f10 < r13; ++f10)
      s10[f10] = e7[f10];
    return this.buffer = s10;
  }, getByte: function() {
    for (var t9 = this.pos; this.bufferLength <= t9; ) {
      if (this.eof)
        return null;
      this.readBlock();
    }
    return this.buffer[this.pos++];
  }, getBytes: function(t9) {
    var e7 = this.pos;
    if (t9) {
      this.ensureBuffer(e7 + t9);
      for (var r13 = e7 + t9; !this.eof && this.bufferLength < r13; )
        this.readBlock();
      var i9 = this.bufferLength;
      r13 > i9 && (r13 = i9);
    } else {
      for (; !this.eof; )
        this.readBlock();
      r13 = this.bufferLength;
    }
    return this.pos = r13, this.buffer.subarray(e7, r13);
  }, lookChar: function() {
    for (var t9 = this.pos; this.bufferLength <= t9; ) {
      if (this.eof)
        return null;
      this.readBlock();
    }
    return String.fromCharCode(this.buffer[this.pos]);
  }, getChar: function() {
    for (var t9 = this.pos; this.bufferLength <= t9; ) {
      if (this.eof)
        return null;
      this.readBlock();
    }
    return String.fromCharCode(this.buffer[this.pos++]);
  }, makeSubStream: function(t9, e7, r13) {
    for (var i9 = t9 + e7; this.bufferLength <= i9 && !this.eof; )
      this.readBlock();
    return new Stream(this.buffer, t9, e7, r13);
  }, skip: function(t9) {
    t9 || (t9 = 1), this.pos += t9;
  }, reset: function() {
    this.pos = 0;
  } }, t8;
}(), i = function() {
  if (!self || !self.Uint32Array)
    return null;
  var t8 = new Uint32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), r13 = new Uint32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]), i9 = new Uint32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]), s10 = [new Uint32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9], f10 = [new Uint32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
  function o10(t9) {
    throw new Error(t9);
  }
  function n12(t9) {
    var r14 = 0, i10 = t9[r14++], s11 = t9[r14++];
    -1 != i10 && -1 != s11 || o10("Invalid header in flate stream"), 8 != (15 & i10) && o10("Unknown compression method in flate stream"), ((i10 << 8) + s11) % 31 != 0 && o10("Bad FCHECK in flate stream"), 32 & s11 && o10("FDICT bit set in flate stream"), this.bytes = t9, this.bytesPos = r14, this.codeSize = 0, this.codeBuf = 0, e2.call(this);
  }
  return n12.prototype = Object.create(e2.prototype), n12.prototype.getBits = function(t9) {
    for (var e7, r14 = this.codeSize, i10 = this.codeBuf, s11 = this.bytes, f11 = this.bytesPos; r14 < t9; )
      void 0 === (e7 = s11[f11++]) && o10("Bad encoding in flate stream"), i10 |= e7 << r14, r14 += 8;
    return e7 = i10 & (1 << t9) - 1, this.codeBuf = i10 >> t9, this.codeSize = r14 -= t9, this.bytesPos = f11, e7;
  }, n12.prototype.getCode = function(t9) {
    for (var e7 = t9[0], r14 = t9[1], i10 = this.codeSize, s11 = this.codeBuf, f11 = this.bytes, n13 = this.bytesPos; i10 < r14; ) {
      var a13;
      void 0 === (a13 = f11[n13++]) && o10("Bad encoding in flate stream"), s11 |= a13 << i10, i10 += 8;
    }
    var h7 = e7[s11 & (1 << r14) - 1], u14 = h7 >> 16, l5 = 65535 & h7;
    return (0 == i10 || i10 < u14 || 0 == u14) && o10("Bad encoding in flate stream"), this.codeBuf = s11 >> u14, this.codeSize = i10 - u14, this.bytesPos = n13, l5;
  }, n12.prototype.generateHuffmanTable = function(t9) {
    for (var e7 = t9.length, r14 = 0, i10 = 0; i10 < e7; ++i10)
      t9[i10] > r14 && (r14 = t9[i10]);
    for (var s11 = 1 << r14, f11 = new Uint32Array(s11), o11 = 1, n13 = 0, a13 = 2; o11 <= r14; ++o11, n13 <<= 1, a13 <<= 1)
      for (var h7 = 0; h7 < e7; ++h7)
        if (t9[h7] == o11) {
          var u14 = 0, l5 = n13;
          for (i10 = 0; i10 < o11; ++i10)
            u14 = u14 << 1 | 1 & l5, l5 >>= 1;
          for (i10 = u14; i10 < s11; i10 += a13)
            f11[i10] = o11 << 16 | h7;
          ++n13;
        }
    return [f11, r14];
  }, n12.prototype.readBlock = function() {
    function e7(t9, e8, r14, i10, s11) {
      for (var f11 = t9.getBits(r14) + i10; f11-- > 0; )
        e8[b4++] = s11;
    }
    var n13 = this.getBits(3);
    if (1 & n13 && (this.eof = true), 0 != (n13 >>= 1)) {
      var a13, h7;
      if (1 == n13)
        a13 = s10, h7 = f10;
      else if (2 == n13) {
        for (var u14 = this.getBits(5) + 257, l5 = this.getBits(5) + 1, c8 = this.getBits(4) + 4, d4 = Array(t8.length), b4 = 0; b4 < c8; )
          d4[t8[b4++]] = this.getBits(3);
        for (var v4 = this.generateHuffmanTable(d4), g5 = 0, B3 = (b4 = 0, u14 + l5), p6 = new Array(B3); b4 < B3; ) {
          var y6 = this.getCode(v4);
          16 == y6 ? e7(this, p6, 2, 3, g5) : 17 == y6 ? e7(this, p6, 3, 3, g5 = 0) : 18 == y6 ? e7(this, p6, 7, 11, g5 = 0) : p6[b4++] = g5 = y6;
        }
        a13 = this.generateHuffmanTable(p6.slice(0, u14)), h7 = this.generateHuffmanTable(p6.slice(u14, B3));
      } else
        o10("Unknown block type in flate stream");
      for (var m6 = (T3 = this.buffer) ? T3.length : 0, k4 = this.bufferLength; ; ) {
        var w4 = this.getCode(a13);
        if (w4 < 256)
          k4 + 1 >= m6 && (m6 = (T3 = this.ensureBuffer(k4 + 1)).length), T3[k4++] = w4;
        else {
          if (256 == w4)
            return void (this.bufferLength = k4);
          var C5 = (w4 = r13[w4 -= 257]) >> 16;
          C5 > 0 && (C5 = this.getBits(C5)), g5 = (65535 & w4) + C5, w4 = this.getCode(h7), (C5 = (w4 = i9[w4]) >> 16) > 0 && (C5 = this.getBits(C5));
          var L3 = (65535 & w4) + C5;
          k4 + g5 >= m6 && (m6 = (T3 = this.ensureBuffer(k4 + g5)).length);
          for (var S3 = 0; S3 < g5; ++S3, ++k4)
            T3[k4] = T3[k4 - L3];
        }
      }
    } else {
      var A5, U3 = this.bytes, P3 = this.bytesPos;
      void 0 === (A5 = U3[P3++]) && o10("Bad block header in flate stream");
      var z2 = A5;
      void 0 === (A5 = U3[P3++]) && o10("Bad block header in flate stream"), z2 |= A5 << 8, void 0 === (A5 = U3[P3++]) && o10("Bad block header in flate stream");
      var H2 = A5;
      void 0 === (A5 = U3[P3++]) && o10("Bad block header in flate stream"), (H2 |= A5 << 8) != (65535 & ~z2) && o10("Bad uncompressed block length in flate stream"), this.codeBuf = 0, this.codeSize = 0;
      var x5 = this.bufferLength, T3 = this.ensureBuffer(x5 + z2), j3 = x5 + z2;
      this.bufferLength = j3;
      for (var E3 = x5; E3 < j3; ++E3) {
        if (void 0 === (A5 = U3[P3++])) {
          this.eof = true;
          break;
        }
        T3[E3] = A5;
      }
      this.bytesPos = P3;
    }
  }, n12;
}()) && (r2.exports = i);
var f4 = o2(s5.exports);

// node_modules/@arcgis/core/layers/support/rasterFormats/ImageCanvasDecoder.js
var i2 = class _i {
  constructor(t8) {
    this._canvas = null, this._ctx = null, t8 && (this._canvas = t8.canvas, this._ctx = t8.ctx || t8.canvas && t8.canvas.getContext("2d"));
  }
  decode(n12, s10, r13) {
    if (!n12 || n12.byteLength < 10)
      throw new s2("imagecanvasdecoder: decode", "required a valid encoded data as input.");
    let { width: c8 = 0, height: h7 = 0, format: o10 } = s10;
    const { applyJpegMask: l5 } = s10;
    if (l5 && (!c8 || !h7))
      throw new s2("imagecanvasdecoder: decode", "image width and height are needed to apply jpeg mask directly to canvas");
    return new Promise((t8, d4) => {
      let g5 = null;
      "jpg" === o10 && l5 && (g5 = _i._getMask(n12, { width: c8, height: h7 }));
      const w4 = new Blob([new Uint8Array(n12)], { type: "image/" + o10 == "jpg" ? "jpeg" : o10 }), v4 = URL.createObjectURL(w4), m6 = new Image();
      let _2;
      m6.src = v4, m6.onload = () => {
        if (URL.revokeObjectURL(v4), c(r13))
          return void d4(u());
        c8 = m6.width, h7 = m6.height, this._canvas && this._ctx ? (this._canvas.width === c8 && this._canvas.height === h7 || (this._canvas.width = c8, this._canvas.height = h7), this._ctx.clearRect(0, 0, c8, h7)) : (this._canvas = document.createElement("canvas"), this._canvas.width = c8, this._canvas.height = h7, this._ctx = this._canvas.getContext("2d")), this._ctx.drawImage(m6, 0, 0);
        const n13 = this._ctx.getImageData(0, 0, c8, h7);
        let i9;
        if (_2 = n13.data, s10.renderOnCanvas) {
          if (g5)
            for (i9 = 0; i9 < g5.length; i9++)
              g5[i9] ? _2[4 * i9 + 3] = 255 : _2[4 * i9 + 3] = 0;
          return this._ctx.putImageData(n13, 0, 0), void t8(null);
        }
        const o11 = c8 * h7, l6 = new Uint8Array(o11), w5 = new Uint8Array(o11), p6 = new Uint8Array(o11);
        if (g5)
          for (i9 = 0; i9 < o11; i9++)
            l6[i9] = _2[4 * i9], w5[i9] = _2[4 * i9 + 1], p6[i9] = _2[4 * i9 + 2];
        else
          for (g5 = new Uint8Array(o11), i9 = 0; i9 < o11; i9++)
            l6[i9] = _2[4 * i9], w5[i9] = _2[4 * i9 + 1], p6[i9] = _2[4 * i9 + 2], g5[i9] = _2[4 * i9 + 3];
        t8({ width: c8, height: h7, pixels: [l6, w5, p6], mask: g5, pixelType: "u8" });
      }, m6.onerror = () => {
        URL.revokeObjectURL(v4), d4("cannot load image");
      };
    });
  }
  static _getMask(t8, e7) {
    let a13 = null;
    try {
      const i9 = new Uint8Array(t8), s10 = Math.ceil(i9.length / 2);
      let r13 = 0;
      const c8 = i9.length - 2;
      for (r13 = s10; r13 < c8 && (255 !== i9[r13] || 217 !== i9[r13 + 1]); r13++)
        ;
      if (r13 += 2, r13 < i9.length - 1) {
        const t9 = new f4(i9.subarray(r13)).getBytes();
        a13 = new Uint8Array(e7.width * e7.height);
        let s11 = 0;
        for (let e8 = 0; e8 < t9.length; e8++)
          for (let n12 = 7; n12 >= 0; n12--)
            a13[s11++] = t9[e8] >> n12 & 1;
      }
    } catch (i9) {
    }
    return a13;
  }
};

// node_modules/@arcgis/core/chunks/Jpg.js
var r3;
var n2;
var o4;
var a5 = { exports: {} };
a5.exports, r3 = a5, n2 = function() {
  var e7 = function() {
    function e8(e9) {
      this.message = "JPEG error: " + e9;
    }
    return e8.prototype = new Error(), e8.prototype.name = "JpegError", e8.constructor = e8, e8;
  }();
  return function() {
    if (!self || !self.Uint8ClampedArray)
      return null;
    var r13 = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), n12 = 4017, o10 = 799, a13 = 3406, t8 = 2276, i9 = 1567, s10 = 3784, c8 = 5793, f10 = 2896;
    function l5() {
      this.decodeTransform = null, this.colorTransform = -1;
    }
    function u14(e8, r14) {
      for (var n13, o11, a14 = 0, t9 = [], i10 = 16; i10 > 0 && !e8[i10 - 1]; )
        i10--;
      t9.push({ children: [], index: 0 });
      var s11, c9 = t9[0];
      for (n13 = 0; n13 < i10; n13++) {
        for (o11 = 0; o11 < e8[n13]; o11++) {
          for ((c9 = t9.pop()).children[c9.index] = r14[a14]; c9.index > 0; )
            c9 = t9.pop();
          for (c9.index++, t9.push(c9); t9.length <= n13; )
            t9.push(s11 = { children: [], index: 0 }), c9.children[c9.index] = s11.children, c9 = s11;
          a14++;
        }
        n13 + 1 < i10 && (t9.push(s11 = { children: [], index: 0 }), c9.children[c9.index] = s11.children, c9 = s11);
      }
      return t9[0].children;
    }
    function h7(e8, r14, n13) {
      return 64 * ((e8.blocksPerLine + 1) * r14 + n13);
    }
    function v4(n13, o11, a14, t9, i10, s11, c9, f11, l6) {
      var u15 = a14.mcusPerLine, v5 = a14.progressive, m7 = o11, d5 = 0, b4 = 0;
      function k4() {
        if (b4 > 0)
          return b4--, d5 >> b4 & 1;
        if (255 === (d5 = n13[o11++])) {
          var r14 = n13[o11++];
          if (r14)
            throw new e7("unexpected marker " + (d5 << 8 | r14).toString(16));
        }
        return b4 = 7, d5 >>> 7;
      }
      function g5(r14) {
        for (var n14 = r14; ; ) {
          if ("number" == typeof (n14 = n14[k4()]))
            return n14;
          if ("object" != typeof n14)
            throw new e7("invalid huffman sequence");
        }
      }
      function C5(e8) {
        for (var r14 = 0; e8 > 0; )
          r14 = r14 << 1 | k4(), e8--;
        return r14;
      }
      function w4(e8) {
        if (1 === e8)
          return 1 === k4() ? 1 : -1;
        var r14 = C5(e8);
        return r14 >= 1 << e8 - 1 ? r14 : r14 + (-1 << e8) + 1;
      }
      function x5(e8, n14) {
        var o12 = g5(e8.huffmanTableDC), a15 = 0 === o12 ? 0 : w4(o12);
        e8.blockData[n14] = e8.pred += a15;
        for (var t10 = 1; t10 < 64; ) {
          var i11 = g5(e8.huffmanTableAC), s12 = 15 & i11, c10 = i11 >> 4;
          if (0 !== s12) {
            var f12 = r13[t10 += c10];
            e8.blockData[n14 + f12] = w4(s12), t10++;
          } else {
            if (c10 < 15)
              break;
            t10 += 16;
          }
        }
      }
      function y6(e8, r14) {
        var n14 = g5(e8.huffmanTableDC), o12 = 0 === n14 ? 0 : w4(n14) << l6;
        e8.blockData[r14] = e8.pred += o12;
      }
      function D4(e8, r14) {
        e8.blockData[r14] |= k4() << l6;
      }
      var T3 = 0;
      function P3(e8, n14) {
        if (T3 > 0)
          T3--;
        else
          for (var o12 = s11, a15 = c9; o12 <= a15; ) {
            var t10 = g5(e8.huffmanTableAC), i11 = 15 & t10, f12 = t10 >> 4;
            if (0 !== i11) {
              var u16 = r13[o12 += f12];
              e8.blockData[n14 + u16] = w4(i11) * (1 << l6), o12++;
            } else {
              if (f12 < 15) {
                T3 = C5(f12) + (1 << f12) - 1;
                break;
              }
              o12 += 16;
            }
          }
      }
      var L3, A5 = 0;
      function _2(n14, o12) {
        for (var a15, t10, i11 = s11, f12 = c9, u16 = 0; i11 <= f12; ) {
          var h8 = r13[i11];
          switch (A5) {
            case 0:
              if (u16 = (t10 = g5(n14.huffmanTableAC)) >> 4, 0 == (a15 = 15 & t10))
                u16 < 15 ? (T3 = C5(u16) + (1 << u16), A5 = 4) : (u16 = 16, A5 = 1);
              else {
                if (1 !== a15)
                  throw new e7("invalid ACn encoding");
                L3 = w4(a15), A5 = u16 ? 2 : 3;
              }
              continue;
            case 1:
            case 2:
              n14.blockData[o12 + h8] ? n14.blockData[o12 + h8] += k4() << l6 : 0 == --u16 && (A5 = 2 === A5 ? 3 : 0);
              break;
            case 3:
              n14.blockData[o12 + h8] ? n14.blockData[o12 + h8] += k4() << l6 : (n14.blockData[o12 + h8] = L3 << l6, A5 = 0);
              break;
            case 4:
              n14.blockData[o12 + h8] && (n14.blockData[o12 + h8] += k4() << l6);
          }
          i11++;
        }
        4 === A5 && 0 == --T3 && (A5 = 0);
      }
      function U3(e8, r14, n14, o12, a15) {
        var t10 = n14 % u15;
        r14(e8, h7(e8, (n14 / u15 | 0) * e8.v + o12, t10 * e8.h + a15));
      }
      function z2(e8, r14, n14) {
        r14(e8, h7(e8, n14 / e8.blocksPerLine | 0, n14 % e8.blocksPerLine));
      }
      var I4, M4, Y2, q, S3, H2, R3 = t9.length;
      H2 = v5 ? 0 === s11 ? 0 === f11 ? y6 : D4 : 0 === f11 ? P3 : _2 : x5;
      var j3, E3, J, V2, B3 = 0;
      for (E3 = 1 === R3 ? t9[0].blocksPerLine * t9[0].blocksPerColumn : u15 * a14.mcusPerColumn; B3 < E3; ) {
        var N2 = i10 ? Math.min(E3 - B3, i10) : E3;
        for (M4 = 0; M4 < R3; M4++)
          t9[M4].pred = 0;
        if (T3 = 0, 1 === R3)
          for (I4 = t9[0], S3 = 0; S3 < N2; S3++)
            z2(I4, H2, B3), B3++;
        else
          for (S3 = 0; S3 < N2; S3++) {
            for (M4 = 0; M4 < R3; M4++)
              for (J = (I4 = t9[M4]).h, V2 = I4.v, Y2 = 0; Y2 < V2; Y2++)
                for (q = 0; q < J; q++)
                  U3(I4, H2, B3, Y2, q);
            B3++;
          }
        b4 = 0, (j3 = p6(n13, o11)) && j3.invalid && (console.log("decodeScan - unexpected MCU data, next marker is: " + j3.invalid), o11 = j3.offset);
        var G3 = j3 && j3.marker;
        if (!G3 || G3 <= 65280)
          throw new e7("marker was not found");
        if (!(G3 >= 65488 && G3 <= 65495))
          break;
        o11 += 2;
      }
      return (j3 = p6(n13, o11)) && j3.invalid && (console.log("decodeScan - unexpected Scan data, next marker is: " + j3.invalid), o11 = j3.offset), o11 - m7;
    }
    function m6(r14, l6, u15) {
      var h8, v5, m7, d5, p7, b4, k4, g5, C5, w4, x5, y6, D4, T3, P3, L3, A5, _2 = r14.quantizationTable, U3 = r14.blockData;
      if (!_2)
        throw new e7("missing required Quantization Table.");
      for (var z2 = 0; z2 < 64; z2 += 8)
        C5 = U3[l6 + z2], w4 = U3[l6 + z2 + 1], x5 = U3[l6 + z2 + 2], y6 = U3[l6 + z2 + 3], D4 = U3[l6 + z2 + 4], T3 = U3[l6 + z2 + 5], P3 = U3[l6 + z2 + 6], L3 = U3[l6 + z2 + 7], C5 *= _2[z2], 0 != (w4 | x5 | y6 | D4 | T3 | P3 | L3) ? (w4 *= _2[z2 + 1], x5 *= _2[z2 + 2], y6 *= _2[z2 + 3], D4 *= _2[z2 + 4], T3 *= _2[z2 + 5], P3 *= _2[z2 + 6], L3 *= _2[z2 + 7], v5 = (h8 = (h8 = c8 * C5 + 128 >> 8) + (v5 = c8 * D4 + 128 >> 8) + 1 >> 1) - v5, A5 = (m7 = x5) * s10 + (d5 = P3) * i9 + 128 >> 8, m7 = m7 * i9 - d5 * s10 + 128 >> 8, k4 = (p7 = (p7 = f10 * (w4 - L3) + 128 >> 8) + (k4 = T3 << 4) + 1 >> 1) - k4, b4 = (g5 = (g5 = f10 * (w4 + L3) + 128 >> 8) + (b4 = y6 << 4) + 1 >> 1) - b4, d5 = (h8 = h8 + (d5 = A5) + 1 >> 1) - d5, m7 = (v5 = v5 + m7 + 1 >> 1) - m7, A5 = p7 * t8 + g5 * a13 + 2048 >> 12, p7 = p7 * a13 - g5 * t8 + 2048 >> 12, g5 = A5, A5 = b4 * o10 + k4 * n12 + 2048 >> 12, b4 = b4 * n12 - k4 * o10 + 2048 >> 12, k4 = A5, u15[z2] = h8 + g5, u15[z2 + 7] = h8 - g5, u15[z2 + 1] = v5 + k4, u15[z2 + 6] = v5 - k4, u15[z2 + 2] = m7 + b4, u15[z2 + 5] = m7 - b4, u15[z2 + 3] = d5 + p7, u15[z2 + 4] = d5 - p7) : (A5 = c8 * C5 + 512 >> 10, u15[z2] = A5, u15[z2 + 1] = A5, u15[z2 + 2] = A5, u15[z2 + 3] = A5, u15[z2 + 4] = A5, u15[z2 + 5] = A5, u15[z2 + 6] = A5, u15[z2 + 7] = A5);
      for (var I4 = 0; I4 < 8; ++I4)
        C5 = u15[I4], 0 != ((w4 = u15[I4 + 8]) | (x5 = u15[I4 + 16]) | (y6 = u15[I4 + 24]) | (D4 = u15[I4 + 32]) | (T3 = u15[I4 + 40]) | (P3 = u15[I4 + 48]) | (L3 = u15[I4 + 56])) ? (v5 = (h8 = 4112 + ((h8 = c8 * C5 + 2048 >> 12) + (v5 = c8 * D4 + 2048 >> 12) + 1 >> 1)) - v5, A5 = (m7 = x5) * s10 + (d5 = P3) * i9 + 2048 >> 12, m7 = m7 * i9 - d5 * s10 + 2048 >> 12, d5 = A5, k4 = (p7 = (p7 = f10 * (w4 - L3) + 2048 >> 12) + (k4 = T3) + 1 >> 1) - k4, b4 = (g5 = (g5 = f10 * (w4 + L3) + 2048 >> 12) + (b4 = y6) + 1 >> 1) - b4, A5 = p7 * t8 + g5 * a13 + 2048 >> 12, p7 = p7 * a13 - g5 * t8 + 2048 >> 12, g5 = A5, A5 = b4 * o10 + k4 * n12 + 2048 >> 12, b4 = b4 * n12 - k4 * o10 + 2048 >> 12, C5 = (C5 = (h8 = h8 + d5 + 1 >> 1) + g5) < 16 ? 0 : C5 >= 4080 ? 255 : C5 >> 4, w4 = (w4 = (v5 = v5 + m7 + 1 >> 1) + (k4 = A5)) < 16 ? 0 : w4 >= 4080 ? 255 : w4 >> 4, x5 = (x5 = (m7 = v5 - m7) + b4) < 16 ? 0 : x5 >= 4080 ? 255 : x5 >> 4, y6 = (y6 = (d5 = h8 - d5) + p7) < 16 ? 0 : y6 >= 4080 ? 255 : y6 >> 4, D4 = (D4 = d5 - p7) < 16 ? 0 : D4 >= 4080 ? 255 : D4 >> 4, T3 = (T3 = m7 - b4) < 16 ? 0 : T3 >= 4080 ? 255 : T3 >> 4, P3 = (P3 = v5 - k4) < 16 ? 0 : P3 >= 4080 ? 255 : P3 >> 4, L3 = (L3 = h8 - g5) < 16 ? 0 : L3 >= 4080 ? 255 : L3 >> 4, U3[l6 + I4] = C5, U3[l6 + I4 + 8] = w4, U3[l6 + I4 + 16] = x5, U3[l6 + I4 + 24] = y6, U3[l6 + I4 + 32] = D4, U3[l6 + I4 + 40] = T3, U3[l6 + I4 + 48] = P3, U3[l6 + I4 + 56] = L3) : (A5 = (A5 = c8 * C5 + 8192 >> 14) < -2040 ? 0 : A5 >= 2024 ? 255 : A5 + 2056 >> 4, U3[l6 + I4] = A5, U3[l6 + I4 + 8] = A5, U3[l6 + I4 + 16] = A5, U3[l6 + I4 + 24] = A5, U3[l6 + I4 + 32] = A5, U3[l6 + I4 + 40] = A5, U3[l6 + I4 + 48] = A5, U3[l6 + I4 + 56] = A5);
    }
    function d4(e8, r14) {
      for (var n13 = r14.blocksPerLine, o11 = r14.blocksPerColumn, a14 = new Int16Array(64), t9 = 0; t9 < o11; t9++)
        for (var i10 = 0; i10 < n13; i10++)
          m6(r14, h7(r14, t9, i10), a14);
      return r14.blockData;
    }
    function p6(e8, r14, n13) {
      function o11(r15) {
        return e8[r15] << 8 | e8[r15 + 1];
      }
      var a14 = e8.length - 1, t9 = n13 < r14 ? n13 : r14;
      if (r14 >= a14)
        return null;
      var i10 = o11(r14);
      if (i10 >= 65472 && i10 <= 65534)
        return { invalid: null, marker: i10, offset: r14 };
      for (var s11 = o11(t9); !(s11 >= 65472 && s11 <= 65534); ) {
        if (++t9 >= a14)
          return null;
        s11 = o11(t9);
      }
      return { invalid: i10.toString(16), marker: s11, offset: t9 };
    }
    return l5.prototype = { parse: function(n13) {
      function o11() {
        var e8 = n13[c9] << 8 | n13[c9 + 1];
        return c9 += 2, e8;
      }
      function a14() {
        var e8 = o11(), r14 = c9 + e8 - 2, a15 = p6(n13, r14, c9);
        a15 && a15.invalid && (console.log("readDataBlock - incorrect length, next marker is: " + a15.invalid), r14 = a15.offset);
        var t10 = n13.subarray(c9, r14);
        return c9 += t10.length, t10;
      }
      function t9(e8) {
        for (var r14 = Math.ceil(e8.samplesPerLine / 8 / e8.maxH), n14 = Math.ceil(e8.scanLines / 8 / e8.maxV), o12 = 0; o12 < e8.components.length; o12++) {
          R3 = e8.components[o12];
          var a15 = Math.ceil(Math.ceil(e8.samplesPerLine / 8) * R3.h / e8.maxH), t10 = Math.ceil(Math.ceil(e8.scanLines / 8) * R3.v / e8.maxV), i11 = r14 * R3.h, s12 = n14 * R3.v * 64 * (i11 + 1);
          R3.blockData = new Int16Array(s12), R3.blocksPerLine = a15, R3.blocksPerColumn = t10;
        }
        e8.mcusPerLine = r14, e8.mcusPerColumn = n14;
      }
      var i10, s11, c9 = 0, f11 = null, l6 = null, h8 = [], m7 = [], b4 = [], k4 = o11();
      if (65496 !== k4)
        throw new e7("SOI not found");
      for (k4 = o11(); 65497 !== k4; ) {
        var g5, C5, w4;
        switch (k4) {
          case 65504:
          case 65505:
          case 65506:
          case 65507:
          case 65508:
          case 65509:
          case 65510:
          case 65511:
          case 65512:
          case 65513:
          case 65514:
          case 65515:
          case 65516:
          case 65517:
          case 65518:
          case 65519:
          case 65534:
            var x5 = a14();
            65504 === k4 && 74 === x5[0] && 70 === x5[1] && 73 === x5[2] && 70 === x5[3] && 0 === x5[4] && (f11 = { version: { major: x5[5], minor: x5[6] }, densityUnits: x5[7], xDensity: x5[8] << 8 | x5[9], yDensity: x5[10] << 8 | x5[11], thumbWidth: x5[12], thumbHeight: x5[13], thumbData: x5.subarray(14, 14 + 3 * x5[12] * x5[13]) }), 65518 === k4 && 65 === x5[0] && 100 === x5[1] && 111 === x5[2] && 98 === x5[3] && 101 === x5[4] && (l6 = { version: x5[5] << 8 | x5[6], flags0: x5[7] << 8 | x5[8], flags1: x5[9] << 8 | x5[10], transformCode: x5[11] });
            break;
          case 65499:
            for (var y6 = o11() + c9 - 2; c9 < y6; ) {
              var D4 = n13[c9++], T3 = new Uint16Array(64);
              if (D4 >> 4 == 0)
                for (C5 = 0; C5 < 64; C5++)
                  T3[r13[C5]] = n13[c9++];
              else {
                if (D4 >> 4 != 1)
                  throw new e7("DQT - invalid table spec");
                for (C5 = 0; C5 < 64; C5++)
                  T3[r13[C5]] = o11();
              }
              h8[15 & D4] = T3;
            }
            break;
          case 65472:
          case 65473:
          case 65474:
            if (i10)
              throw new e7("Only single frame JPEGs supported");
            o11(), (i10 = {}).extended = 65473 === k4, i10.progressive = 65474 === k4, i10.precision = n13[c9++], i10.scanLines = o11(), i10.samplesPerLine = o11(), i10.components = [], i10.componentIds = {};
            var P3, L3 = n13[c9++], A5 = 0, _2 = 0;
            for (g5 = 0; g5 < L3; g5++) {
              P3 = n13[c9];
              var U3 = n13[c9 + 1] >> 4, z2 = 15 & n13[c9 + 1];
              A5 < U3 && (A5 = U3), _2 < z2 && (_2 = z2);
              var I4 = n13[c9 + 2];
              w4 = i10.components.push({ h: U3, v: z2, quantizationId: I4, quantizationTable: null }), i10.componentIds[P3] = w4 - 1, c9 += 3;
            }
            i10.maxH = A5, i10.maxV = _2, t9(i10);
            break;
          case 65476:
            var M4 = o11();
            for (g5 = 2; g5 < M4; ) {
              var Y2 = n13[c9++], q = new Uint8Array(16), S3 = 0;
              for (C5 = 0; C5 < 16; C5++, c9++)
                S3 += q[C5] = n13[c9];
              var H2 = new Uint8Array(S3);
              for (C5 = 0; C5 < S3; C5++, c9++)
                H2[C5] = n13[c9];
              g5 += 17 + S3, (Y2 >> 4 == 0 ? b4 : m7)[15 & Y2] = u14(q, H2);
            }
            break;
          case 65501:
            o11(), s11 = o11();
            break;
          case 65498:
            o11();
            var R3, j3 = n13[c9++], E3 = [];
            for (g5 = 0; g5 < j3; g5++) {
              var J = i10.componentIds[n13[c9++]];
              R3 = i10.components[J];
              var V2 = n13[c9++];
              R3.huffmanTableDC = b4[V2 >> 4], R3.huffmanTableAC = m7[15 & V2], E3.push(R3);
            }
            var B3 = n13[c9++], N2 = n13[c9++], G3 = n13[c9++], O3 = v4(n13, c9, i10, E3, s11, B3, N2, G3 >> 4, 15 & G3);
            c9 += O3;
            break;
          case 65535:
            255 !== n13[c9] && c9--;
            break;
          default:
            if (255 === n13[c9 - 3] && n13[c9 - 2] >= 192 && n13[c9 - 2] <= 254) {
              c9 -= 3;
              break;
            }
            throw new e7("unknown marker " + k4.toString(16));
        }
        k4 = o11();
      }
      for (this.width = i10.samplesPerLine, this.height = i10.scanLines, this.jfif = f11, this.eof = c9, this.adobe = l6, this.components = [], g5 = 0; g5 < i10.components.length; g5++) {
        var Q = h8[(R3 = i10.components[g5]).quantizationId];
        Q && (R3.quantizationTable = Q), this.components.push({ output: d4(i10, R3), scaleX: R3.h / i10.maxH, scaleY: R3.v / i10.maxV, blocksPerLine: R3.blocksPerLine, blocksPerColumn: R3.blocksPerColumn });
      }
      this.numComponents = this.components.length;
    }, _getLinearizedBlockData: function(e8, r14) {
      var n13, o11, a14, t9, i10, s11, c9, f11, l6, u15, h8, v5 = this.width / e8, m7 = this.height / r14, d5 = 0, p7 = this.components.length, b4 = e8 * r14 * p7, k4 = new Uint8ClampedArray(b4), g5 = new Uint32Array(e8), C5 = 4294967288;
      for (c9 = 0; c9 < p7; c9++) {
        for (o11 = (n13 = this.components[c9]).scaleX * v5, a14 = n13.scaleY * m7, d5 = c9, h8 = n13.output, t9 = n13.blocksPerLine + 1 << 3, i10 = 0; i10 < e8; i10++)
          f11 = 0 | i10 * o11, g5[i10] = (f11 & C5) << 3 | 7 & f11;
        for (s11 = 0; s11 < r14; s11++)
          for (u15 = t9 * ((f11 = 0 | s11 * a14) & C5) | (7 & f11) << 3, i10 = 0; i10 < e8; i10++)
            k4[d5] = h8[u15 + g5[i10]], d5 += p7;
      }
      var w4 = this.decodeTransform;
      if (w4)
        for (c9 = 0; c9 < b4; )
          for (f11 = 0, l6 = 0; f11 < p7; f11++, c9++, l6 += 2)
            k4[c9] = (k4[c9] * w4[l6] >> 8) + w4[l6 + 1];
      return k4;
    }, _isColorConversionNeeded: function() {
      return this.adobe ? !!this.adobe.transformCode : 3 === this.numComponents ? 0 !== this.colorTransform : 1 === this.colorTransform;
    }, _convertYccToRgb: function(e8) {
      for (var r14, n13, o11, a14 = 0, t9 = e8.length; a14 < t9; a14 += 3)
        r14 = e8[a14], n13 = e8[a14 + 1], o11 = e8[a14 + 2], e8[a14] = r14 - 179.456 + 1.402 * o11, e8[a14 + 1] = r14 + 135.459 - 0.344 * n13 - 0.714 * o11, e8[a14 + 2] = r14 - 226.816 + 1.772 * n13;
      return e8;
    }, _convertYcckToRgb: function(e8) {
      for (var r14, n13, o11, a14, t9 = 0, i10 = 0, s11 = e8.length; i10 < s11; i10 += 4)
        r14 = e8[i10], n13 = e8[i10 + 1], o11 = e8[i10 + 2], a14 = e8[i10 + 3], e8[t9++] = n13 * (-660635669420364e-19 * n13 + 437130475926232e-18 * o11 - 54080610064599e-18 * r14 + 48449797120281e-17 * a14 - 0.154362151871126) - 122.67195406894 + o11 * (-957964378445773e-18 * o11 + 817076911346625e-18 * r14 - 0.00477271405408747 * a14 + 1.53380253221734) + r14 * (961250184130688e-18 * r14 - 0.00266257332283933 * a14 + 0.48357088451265) + a14 * (-336197177618394e-18 * a14 + 0.484791561490776), e8[t9++] = 107.268039397724 + n13 * (219927104525741e-19 * n13 - 640992018297945e-18 * o11 + 659397001245577e-18 * r14 + 426105652938837e-18 * a14 - 0.176491792462875) + o11 * (-778269941513683e-18 * o11 + 0.00130872261408275 * r14 + 770482631801132e-18 * a14 - 0.151051492775562) + r14 * (0.00126935368114843 * r14 - 0.00265090189010898 * a14 + 0.25802910206845) + a14 * (-318913117588328e-18 * a14 - 0.213742400323665), e8[t9++] = n13 * (-570115196973677e-18 * n13 - 263409051004589e-19 * o11 + 0.0020741088115012 * r14 - 0.00288260236853442 * a14 + 0.814272968359295) - 20.810012546947 + o11 * (-153496057440975e-19 * o11 - 132689043961446e-18 * r14 + 560833691242812e-18 * a14 - 0.195152027534049) + r14 * (0.00174418132927582 * r14 - 0.00255243321439347 * a14 + 0.116935020465145) + a14 * (-343531996510555e-18 * a14 + 0.24165260232407);
      return e8;
    }, _convertYcckToCmyk: function(e8) {
      for (var r14, n13, o11, a14 = 0, t9 = e8.length; a14 < t9; a14 += 4)
        r14 = e8[a14], n13 = e8[a14 + 1], o11 = e8[a14 + 2], e8[a14] = 434.456 - r14 - 1.402 * o11, e8[a14 + 1] = 119.541 - r14 + 0.344 * n13 + 0.714 * o11, e8[a14 + 2] = 481.816 - r14 - 1.772 * n13;
      return e8;
    }, _convertCmykToRgb: function(e8) {
      for (var r14, n13, o11, a14, t9 = 0, i10 = 1 / 255, s11 = 0, c9 = e8.length; s11 < c9; s11 += 4)
        r14 = e8[s11] * i10, n13 = e8[s11 + 1] * i10, o11 = e8[s11 + 2] * i10, a14 = e8[s11 + 3] * i10, e8[t9++] = 255 + r14 * (-4.387332384609988 * r14 + 54.48615194189176 * n13 + 18.82290502165302 * o11 + 212.25662451639585 * a14 - 285.2331026137004) + n13 * (1.7149763477362134 * n13 - 5.6096736904047315 * o11 - 17.873870861415444 * a14 - 5.497006427196366) + o11 * (-2.5217340131683033 * o11 - 21.248923337353073 * a14 + 17.5119270841813) - a14 * (21.86122147463605 * a14 + 189.48180835922747), e8[t9++] = 255 + r14 * (8.841041422036149 * r14 + 60.118027045597366 * n13 + 6.871425592049007 * o11 + 31.159100130055922 * a14 - 79.2970844816548) + n13 * (-15.310361306967817 * n13 + 17.575251261109482 * o11 + 131.35250912493976 * a14 - 190.9453302588951) + o11 * (4.444339102852739 * o11 + 9.8632861493405 * a14 - 24.86741582555878) - a14 * (20.737325471181034 * a14 + 187.80453709719578), e8[t9++] = 255 + r14 * (0.8842522430003296 * r14 + 8.078677503112928 * n13 + 30.89978309703729 * o11 - 0.23883238689178934 * a14 - 14.183576799673286) + n13 * (10.49593273432072 * n13 + 63.02378494754052 * o11 + 50.606957656360734 * a14 - 112.23884253719248) + o11 * (0.03296041114873217 * o11 + 115.60384449646641 * a14 - 193.58209356861505) - a14 * (22.33816807309886 * a14 + 180.12613974708367);
      return e8;
    }, getData: function(r14, n13, o11) {
      if (this.numComponents > 4)
        throw new e7("Unsupported color mode");
      var a14 = this._getLinearizedBlockData(r14, n13);
      if (1 === this.numComponents && o11) {
        for (var t9 = a14.length, i10 = new Uint8ClampedArray(3 * t9), s11 = 0, c9 = 0; c9 < t9; c9++) {
          var f11 = a14[c9];
          i10[s11++] = f11, i10[s11++] = f11, i10[s11++] = f11;
        }
        return i10;
      }
      if (3 === this.numComponents && this._isColorConversionNeeded())
        return this._convertYccToRgb(a14);
      if (4 === this.numComponents) {
        if (this._isColorConversionNeeded())
          return o11 ? this._convertYcckToRgb(a14) : this._convertYcckToCmyk(a14);
        if (o11)
          return this._convertCmykToRgb(a14);
      }
      return a14;
    } }, l5;
  }();
}, void 0 !== (o4 = n2()) && (r3.exports = o4);
var t = o2(a5.exports);

// node_modules/@arcgis/core/layers/support/rasterFormats/JpgPlus.js
var r4 = class {
  static decode(r13, n12 = false) {
    const s10 = new Uint8Array(r13), o10 = new t();
    o10.parse(s10);
    const { width: a13, height: i9, numComponents: f10, eof: h7 } = o10, l5 = o10.getData(a13, i9, true), c8 = a13 * i9;
    let u14, g5 = null, p6 = 0, w4 = 0, m6 = 0;
    if (!n12 && h7 < s10.length - 1)
      try {
        const t8 = new f4(s10.subarray(h7)).getBytes();
        g5 = new Uint8Array(c8);
        let r14 = 0;
        for (p6 = 0; p6 < t8.length; p6++)
          for (m6 = 7; m6 >= 0; m6--)
            g5[r14++] = t8[p6] >> m6 & 1;
      } catch {
      }
    if (1 === f10 && l5.length === a13 * i9) {
      const t8 = new Uint8Array(l5.buffer);
      u14 = [t8, t8, t8];
    } else {
      for (u14 = [], p6 = 0; p6 < 3; p6++)
        u14.push(new Uint8Array(c8));
      for (m6 = 0, w4 = 0; w4 < c8; w4++)
        for (p6 = 0; p6 < 3; p6++)
          u14[p6][w4] = l5[m6++];
    }
    return { width: a13, height: i9, pixels: u14, mask: g5 };
  }
};

// node_modules/@arcgis/core/layers/support/rasterFormats/Lerc.js
var t2 = [{ pixelType: "S8", size: 1, ctor: Int8Array, range: [-128, 127] }, { pixelType: "U8", size: 1, ctor: Uint8Array, range: [0, 255] }, { pixelType: "S16", size: 2, ctor: Int16Array, range: [-32768, 32767] }, { pixelType: "U16", size: 2, ctor: Uint16Array, range: [0, 65536] }, { pixelType: "S32", size: 4, ctor: Int32Array, range: [-2147483648, 2147483647] }, { pixelType: "U32", size: 4, ctor: Uint32Array, range: [0, 4294967296] }, { pixelType: "F32", size: 4, ctor: Float32Array, range: [-34027999387901484e22, 34027999387901484e22] }, { pixelType: "F64", size: 8, ctor: Float64Array, range: [-17976931348623157e292, 17976931348623157e292] }];
var n3 = null;
var r5 = false;
function a6() {
  return n3 || (n3 = import("./lerc-wasm-JHODVQEO.js").then((e7) => e7.l).then(({ default: t8 }) => t8({ locateFile: (t9) => a3(`esri/layers/support/rasterFormats/${t9}`) })).then((e7) => {
    u6(e7), r5 = true;
  }), n3);
}
var l = { getBlobInfo: null, decode: null };
function s6(e7) {
  return 16 + (e7 >> 3 << 3);
}
function i3(e7, t8, n12) {
  n12.set(e7.slice(t8, t8 + n12.length));
}
function u6(e7) {
  const { _malloc: n12, _free: r13, _lerc_getBlobInfo: a13, _lerc_getDataRanges: o10, _lerc_decode_4D: u14, asm: f10 } = e7;
  let c8;
  const h7 = Object.values(f10).find((t8) => t8 && "buffer" in t8 && t8.buffer === e7.HEAPU8.buffer), y6 = (e8) => {
    const t8 = e8.map((e9) => s6(e9)), r14 = t8.reduce((e9, t9) => e9 + t9), a14 = n12(r14);
    c8 = new Uint8Array(h7.buffer);
    let o11 = t8[0];
    t8[0] = a14;
    for (let n13 = 1; n13 < t8.length; n13++) {
      const e9 = t8[n13];
      t8[n13] = t8[n13 - 1] + o11, o11 = e9;
    }
    return t8;
  };
  l.getBlobInfo = (e8) => {
    const t8 = 12, n13 = 3, l5 = new Uint8Array(4 * t8), s10 = new Uint8Array(8 * n13), [u15, f11, p6] = y6([e8.length, l5.length, s10.length]);
    c8.set(e8, u15), c8.set(l5, f11), c8.set(s10, p6);
    let g5 = a13(u15, e8.length, f11, p6, t8, n13);
    if (g5)
      throw r13(u15), new Error(`lerc-getBlobInfo: error code is ${g5}`);
    c8 = new Uint8Array(h7.buffer), i3(c8, f11, l5), i3(c8, p6, s10);
    const d4 = new Uint32Array(l5.buffer), b4 = new Float64Array(s10.buffer), [w4, A5, , m6, U3, x5, C5, V2, T3, D4, z2] = d4, F2 = { version: w4, depthCount: D4, width: m6, height: U3, validPixelCount: C5, bandCount: x5, blobSize: V2, maskCount: T3, dataType: A5, minValue: b4[0], maxValue: b4[1], maxZerror: b4[2], statistics: [], bandCountWithNoData: z2 };
    if (z2 && D4 > 1)
      return r13(u15), F2;
    if (1 === D4 && 1 === x5)
      return r13(u15), F2.statistics.push({ minValue: b4[0], maxValue: b4[1] }), F2;
    const I4 = D4 * x5 * 8, _2 = new Uint8Array(I4), k4 = new Uint8Array(I4);
    let B3 = u15, S3 = 0, v4 = 0, E3 = false;
    if (c8.byteLength < u15 + 2 * I4 ? (r13(u15), E3 = true, [B3, S3, v4] = y6([e8.length, I4, I4]), c8.set(e8, B3)) : [S3, v4] = y6([I4, I4]), c8.set(_2, S3), c8.set(k4, v4), g5 = o10(B3, e8.length, D4, x5, S3, v4), g5)
      throw r13(B3), E3 || r13(S3), new Error(`lerc-getDataRanges: error code is ${g5}`);
    c8 = new Uint8Array(h7.buffer), i3(c8, S3, _2), i3(c8, v4, k4);
    const O3 = new Float64Array(_2.buffer), $ = new Float64Array(k4.buffer), j3 = F2.statistics;
    for (let r14 = 0; r14 < x5; r14++)
      if (D4 > 1) {
        const e9 = O3.slice(r14 * D4, (r14 + 1) * D4), t9 = $.slice(r14 * D4, (r14 + 1) * D4), n14 = Math.min.apply(null, e9), a14 = Math.max.apply(null, t9);
        j3.push({ minValue: n14, maxValue: a14, depthStats: { minValues: e9, maxValues: t9 } });
      } else
        j3.push({ minValue: O3[r14], maxValue: $[r14] });
    return r13(B3), E3 || r13(S3), F2;
  }, l.decode = (e8, n13) => {
    const { maskCount: a14, depthCount: o11, bandCount: l5, width: s10, height: f11, dataType: p6, bandCountWithNoData: g5 } = n13, d4 = t2[p6], b4 = s10 * f11, w4 = new Uint8Array(b4 * l5), A5 = b4 * o11 * l5 * d4.size, m6 = new Uint8Array(A5), U3 = new Uint8Array(l5), x5 = new Uint8Array(8 * l5), [C5, V2, T3, D4, z2] = y6([e8.length, w4.length, m6.length, U3.length, x5.length]);
    c8.set(e8, C5), c8.set(w4, V2), c8.set(m6, T3), c8.set(U3, D4), c8.set(x5, z2);
    const F2 = u14(C5, e8.length, a14, V2, o11, s10, f11, l5, p6, T3, D4, z2);
    if (F2)
      throw r13(C5), new Error(`lerc-decode: error code is ${F2}`);
    c8 = new Uint8Array(h7.buffer), i3(c8, T3, m6), i3(c8, V2, w4);
    let I4 = null;
    if (g5) {
      i3(c8, D4, U3), i3(c8, z2, x5), I4 = [];
      const e9 = new Float64Array(x5.buffer);
      for (let t8 = 0; t8 < U3.length; t8++)
        I4.push(U3[t8] ? e9[t8] : null);
    }
    return r13(C5), { data: m6, maskData: w4, noDataValues: I4 };
  };
}
function f5(e7, t8, n12, r13, a13) {
  if (n12 < 2)
    return e7;
  const o10 = new r13(t8 * n12);
  if (a13)
    for (let l5 = 0, s10 = 0; l5 < t8; l5++)
      for (let r14 = 0, a14 = l5; r14 < n12; r14++, a14 += t8)
        o10[a14] = e7[s10++];
  else
    for (let l5 = 0, s10 = 0; l5 < t8; l5++)
      for (let r14 = 0, a14 = l5; r14 < n12; r14++, a14 += t8)
        o10[s10++] = e7[a14];
  return o10;
}
function c3(e7, n12 = {}) {
  const r13 = n12.inputOffset ?? 0, a13 = e7 instanceof Uint8Array ? e7.subarray(r13) : new Uint8Array(e7, r13), o10 = l.getBlobInfo(a13), { data: s10, maskData: i9, noDataValues: u14 } = l.decode(a13, o10), { width: c8, height: h7, bandCount: y6, depthCount: p6, dataType: g5, maskCount: d4, statistics: b4 } = o10, w4 = t2[g5], A5 = new w4.ctor(s10.buffer), m6 = [], U3 = [], x5 = c8 * h7, C5 = x5 * p6;
  for (let t8 = 0; t8 < y6; t8++) {
    const e8 = A5.subarray(t8 * C5, (t8 + 1) * C5);
    if (n12.returnInterleaved)
      m6.push(e8);
    else {
      const t9 = f5(e8, x5, p6, w4.ctor, true);
      m6.push(t9);
    }
    U3.push(i9.subarray(t8 * C5, (t8 + 1) * C5));
  }
  const V2 = 0 === d4 ? null : 1 === d4 ? U3[0] : new Uint8Array(x5);
  if (d4 > 1) {
    V2.set(U3[0]);
    for (let e8 = 1; e8 < U3.length; e8++) {
      const t8 = U3[e8];
      for (let e9 = 0; e9 < x5; e9++)
        V2[e9] = V2[e9] & t8[e9];
    }
  }
  const { noDataValue: T3 } = n12, D4 = null != T3 && w4.range[0] <= T3 && w4.range[1] >= T3;
  if (d4 > 0 && D4)
    for (let t8 = 0; t8 < y6; t8++) {
      const e8 = m6[t8], n13 = U3[t8] || V2;
      for (let t9 = 0; t9 < x5; t9++)
        0 === n13[t9] && (e8[t9] = T3);
    }
  const z2 = d4 === y6 && y6 > 1 ? U3 : null, { pixelType: F2 } = w4;
  return { width: c8, height: h7, bandCount: y6, pixelType: F2, depthCount: p6, statistics: b4, pixels: m6, mask: V2, bandMasks: z2, noDataValues: u14 };
}

// node_modules/@arcgis/core/layers/support/rasterFormats/Lzw.js
function e3(e7, n12, t8, r13 = true) {
  if (n12 % 4 != 0 || t8 % 4 != 0) {
    const i9 = new ArrayBuffer(4 * Math.ceil(t8 / 4)), o10 = new Uint8Array(i9), l5 = new Uint8Array(e7, n12, t8);
    if (r13)
      for (let e8 = 0; e8 < o10.length; e8 += 4)
        o10[e8] = l5[e8 + 3], o10[e8 + 1] = l5[e8 + 2], o10[e8 + 2] = l5[e8 + 1], o10[e8 + 3] = l5[e8];
    else
      o10.set(l5);
    return new Uint32Array(o10.buffer);
  }
  if (r13) {
    const r14 = new Uint8Array(e7, n12, t8), i9 = new Uint8Array(r14.length);
    for (let e8 = 0; e8 < i9.length; e8 += 4)
      i9[e8] = r14[e8 + 3], i9[e8 + 1] = r14[e8 + 2], i9[e8 + 2] = r14[e8 + 1], i9[e8 + 3] = r14[e8];
    return new Uint32Array(i9.buffer);
  }
  return new Uint32Array(e7, n12, t8 / 4);
}
function n4() {
  const e7 = [];
  for (let n12 = 0; n12 <= 257; n12++)
    e7[n12] = [n12];
  return e7;
}
function t3(e7, n12) {
  for (let t8 = 0; t8 < n12.length; t8++)
    e7.push(n12[t8]);
}
var r6 = /* @__PURE__ */ new Set();
function i4(i9, o10, l5, f10 = true) {
  const s10 = e3(i9, o10, l5, f10);
  let a13 = 9, c8 = n4(), u14 = 32, h7 = c8.length, d4 = [], w4 = 1, g5 = s10[0], y6 = 0;
  const A5 = s10.length, U3 = 8 * (4 * A5 - l5), p6 = [];
  for (; null != g5; ) {
    if (u14 >= a13)
      u14 -= a13, y6 = g5 >>> 32 - a13, g5 <<= a13;
    else {
      y6 = g5 >>> 32 - u14, g5 = s10[w4++];
      const e8 = a13 - u14;
      u14 = 32 - e8, y6 = (y6 << e8) + (g5 >>> u14), g5 <<= e8;
    }
    if (257 === y6)
      break;
    if (256 === y6) {
      a13 = 9, c8 = n4(), h7 = c8.length, d4 = [];
      continue;
    }
    const e7 = c8[y6];
    if (null == e7) {
      if (y6 > c8.length)
        throw new Error("data integrity issue: code does not exist on code page");
      d4.push(d4[0]), c8[h7++] = d4.slice(), t3(p6, d4);
    } else
      t3(p6, e7), d4.push(e7[0]), d4.length > 1 && (c8[h7++] = d4.slice()), d4 = e7.slice();
    if (r6.has(h7) && a13++, 0 === u14 && (g5 = s10[w4++], u14 = 32), w4 > A5 || w4 === A5 && u14 <= U3)
      break;
  }
  return new Uint8Array(p6);
}
r6.add(511), r6.add(1023), r6.add(2047), r6.add(4095), r6.add(8191);

// node_modules/@arcgis/core/layers/support/rasterFormats/Raw.js
var e4 = (e7, r13) => {
  const a13 = r13.width * r13.height, n12 = r13.pixelType;
  return Math.floor(e7.byteLength / (a13 * t4(n12)));
};
var t4 = (e7) => {
  let t8 = 1;
  switch (e7) {
    case Uint8Array:
    case Int8Array:
      t8 = 1;
      break;
    case Uint16Array:
    case Int16Array:
      t8 = 2;
      break;
    case Uint32Array:
    case Int32Array:
    case Float32Array:
      t8 = 4;
      break;
    case Float64Array:
      t8 = 8;
  }
  return t8;
};
var r7 = (e7, t8) => {
  if (8 * e7.byteLength < t8)
    return null;
  const r13 = new Uint8Array(e7, 0, Math.ceil(t8 / 8)), a13 = new Uint8Array(t8);
  let n12 = 0, s10 = 0, l5 = 0, i9 = 0;
  for (l5 = 0; l5 < r13.length - 1; l5++)
    for (s10 = r13[l5], i9 = 7; i9 >= 0; i9--)
      a13[n12++] = s10 >> i9 & 1;
  for (i9 = 7; n12 < t8 - 1; )
    s10 = r13[r13.length - 1], a13[n12++] = s10 >> i9 & 1, i9--;
  return a13;
};
var a7 = class {
  static decode(a13, n12) {
    const s10 = n12.pixelType, l5 = [], i9 = n12.width * n12.height, h7 = e4(a13, n12), { bandIds: c8, format: y6 } = n12, o10 = (c8 == null ? void 0 : c8.length) || e4(a13, n12), b4 = a13.byteLength - a13.byteLength % (i9 * t4(s10)), f10 = new s10(a13, 0, i9 * h7);
    let u14, g5, A5, p6, d4 = null;
    if ("bip" === y6)
      for (u14 = 0; u14 < o10; u14++) {
        for (A5 = new s10(i9), p6 = c8 ? c8[u14] : u14, g5 = 0; g5 < i9; g5++)
          A5[g5] = f10[g5 * h7 + p6];
        l5.push(A5);
      }
    else if ("bsq" === y6)
      for (u14 = 0; u14 < o10; u14++)
        p6 = c8 ? c8[u14] : u14, l5.push(f10.subarray(p6 * i9, (p6 + 1) * i9));
    return b4 < a13.byteLength - 1 && (d4 = r7(a13.slice(b4), i9)), { pixels: l5, mask: d4 };
  }
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/byteStreamUtils.js
function r8(r13, t8) {
  let n12 = 0, o10 = "", e7 = 0, f10 = 0;
  const c8 = r13.length;
  for (; n12 < c8; )
    f10 = r13[n12++], e7 = f10 >> 4, e7 < 8 ? e7 = 1 : 15 === e7 ? (e7 = 4, f10 = (7 & f10) << 18 | (63 & r13[n12++]) << 12 | (63 & r13[n12++]) << 6 | 63 & r13[n12++]) : 14 === e7 ? (e7 = 3, f10 = (15 & f10) << 12 | (63 & r13[n12++]) << 6 | 63 & r13[n12++]) : (e7 = 2, f10 = (31 & f10) << 6 | 63 & r13[n12++]), (0 !== f10 || t8) && (o10 += String.fromCharCode(f10));
  return o10;
}

// node_modules/@arcgis/core/layers/support/rasterFormats/TiffTags.js
var e5 = (() => {
  const e7 = [];
  return e7[254] = "NEWSUBFILETYPE", e7[255] = "SUBFILETYPE", e7[256] = "IMAGEWIDTH", e7[257] = "IMAGELENGTH", e7[258] = "BITSPERSAMPLE", e7[259] = "COMPRESSION", e7[262] = "PHOTOMETRICINTERPRETATION", e7[263] = "THRESHHOLDING", e7[264] = "CELLWIDTH", e7[265] = "CELLLENGTH", e7[266] = "FILLORDER", e7[269] = "DOCUMENTNAME", e7[270] = "IMAGEDESCRIPTION", e7[271] = "MAKE", e7[272] = "MODEL", e7[273] = "STRIPOFFSETS", e7[274] = "ORIENTATION", e7[277] = "SAMPLESPERPIXEL", e7[278] = "ROWSPERSTRIP", e7[279] = "STRIPBYTECOUNTS", e7[280] = "MINSAMPLEVALUE", e7[281] = "MAXSAMPLEVALUE", e7[282] = "XRESOLUTION", e7[283] = "YRESOLUTION", e7[284] = "PLANARCONFIGURATION", e7[285] = "PAGENAME", e7[286] = "XPOSITION", e7[287] = "YPOSITION", e7[288] = "FREEOFFSETS", e7[289] = "FREEBYTECOUNTS", e7[290] = "GRAYRESPONSEUNIT", e7[291] = "GRAYRESPONSECURVE", e7[292] = "T4OPTIONS", e7[293] = "T6OPTIONS", e7[296] = "RESOLUTIONUNIT", e7[297] = "PAGENUMBER", e7[300] = "COLORRESPONSEUNIT", e7[301] = "TRANSFERFUNCTION", e7[305] = "SOFTWARE", e7[306] = "DATETIME", e7[315] = "ARTIST", e7[316] = "HOSTCOMPUTER", e7[317] = "PREDICTOR", e7[318] = "WHITEPOINT", e7[319] = "PRIMARYCHROMATICITIES", e7[320] = "COLORMAP", e7[321] = "HALFTONEHINTS", e7[322] = "TILEWIDTH", e7[323] = "TILELENGTH", e7[324] = "TILEOFFSETS", e7[325] = "TILEBYTECOUNTS", e7[326] = "BADFAXLINES", e7[327] = "CLEANFAXDATA", e7[328] = "CONSECUTIVEBADFAXLINES", e7[330] = "SUBIFD", e7[332] = "INKSET", e7[333] = "INKNAMES", e7[334] = "NUMBEROFINKS", e7[336] = "DOTRANGE", e7[337] = "TARGETPRINTER", e7[338] = "EXTRASAMPLES", e7[339] = "SAMPLEFORMAT", e7[340] = "SMINSAMPLEVALUE", e7[341] = "SMAXSAMPLEVALUE", e7[342] = "TRANSFERRANGE", e7[347] = "JPEGTABLES", e7[512] = "JPEGPROC", e7[513] = "JPEGIFOFFSET", e7[514] = "JPEGIFBYTECOUNT", e7[515] = "JPEGRESTARTINTERVAL", e7[517] = "JPEGLOSSLESSPREDICTORS", e7[518] = "JPEGPOINTTRANSFORM", e7[519] = "JPEGQTABLES", e7[520] = "JPEGDCTABLES", e7[521] = "JPEGACTABLES", e7[529] = "YCBCRCOEFFICIENTS", e7[530] = "YCBCRSUBSAMPLING", e7[531] = "YCBCRPOSITIONING", e7[532] = "REFERENCEBLACKWHITE", e7[700] = "XMP", e7[33550] = "GEOPIXELSCALE", e7[33922] = "GEOTIEPOINTS", e7[33432] = "COPYRIGHT", e7[42112] = "GDAL_METADATA", e7[42113] = "GDAL_NODATA", e7[50844] = "RPCCOEFFICIENT", e7[34264] = "GEOTRANSMATRIX", e7[34735] = "GEOKEYDIRECTORY", e7[34736] = "GEODOUBLEPARAMS", e7[34737] = "GEOASCIIPARAMS", e7[34665] = "EXIFIFD", e7[34853] = "GPSIFD", e7[40965] = "INTEROPERABILITYIFD", e7;
})();
var i5 = (() => {
  const i9 = e5.slice();
  return i9[36864] = "ExifVersion", i9[40960] = "FlashpixVersion", i9[40961] = "ColorSpace", i9[42240] = "Gamma", i9[37121] = "ComponentsConfiguration", i9[37122] = "CompressedBitsPerPixel", i9[40962] = "PixelXDimension", i9[40963] = "PixelYDimension", i9[37500] = "MakerNote", i9[37510] = "UserComment", i9[40964] = "RelatedSoundFile", i9[36867] = "DateTimeOriginal", i9[36868] = "DateTimeDigitized", i9[36880] = "OffsetTime", i9[36881] = "OffsetTimeOriginal", i9[36882] = "OffsetTimeDigitized", i9[37520] = "SubSecTime", i9[37521] = "SubSecTimeOriginal", i9[37522] = "SubSecTimeDigitized", i9[37888] = "Temperature", i9[37889] = "Humidity", i9[37890] = "Pressure", i9[37891] = "WaterDepth", i9[37892] = "Acceleration", i9[37893] = "CameraElevationAngle", i9[42016] = "ImageUniqueID", i9[42032] = "CameraOwnerName", i9[42033] = "BodySerialNumber", i9[42034] = "LensSpecification", i9[42035] = "LensMake", i9[42036] = "LensModel", i9[42037] = "LensSerialNumber", i9[33434] = "ExposureTime", i9[33437] = "FNumber", i9[34850] = "ExposureProgram", i9[34852] = "SpectralSensitivity", i9[34855] = "PhotographicSensitivity", i9[34856] = "OECF", i9[34864] = "SensitivityType", i9[34865] = "StandardOutputSensitivity", i9[34866] = "RecommendedExposureIndex", i9[34867] = "ISOSpeed", i9[34868] = "ISOSpeedLatitudeyyy", i9[34869] = "ISOSpeedLatitudezzz", i9[37377] = "ShutterSpeedValue", i9[37378] = "ApertureValue", i9[37379] = "BrightnessValue", i9[37380] = "ExposureBiasValue", i9[37381] = "MaxApertureValue", i9[37382] = "SubjectDistance", i9[37383] = "MeteringMode", i9[37384] = "LightSource", i9[37385] = "Flash", i9[37386] = "FocalLength", i9[37396] = "SubjectArea", i9[41483] = "FlashEnergy", i9[41484] = "SpatialFrequencyResponse", i9[41486] = "FocalPlaneXResolution", i9[41487] = "FocalPlaneYResolution", i9[41488] = "FocalPlaneResolutionUnit", i9[41492] = "SubjectLocation", i9[41493] = "ExposureIndex", i9[41495] = "SensingMethod", i9[41728] = "FileSource", i9[41729] = "SceneType", i9[41730] = "CFAPattern", i9[41985] = "CustomRendered", i9[41986] = "ExposureMode", i9[41987] = "WhiteBalance", i9[41988] = "DigitalZoomRatio", i9[41989] = "FocalLengthIn35mmFilm", i9[41990] = "SceneCaptureType", i9[41991] = "GainControl", i9[41992] = "Contrast", i9[41993] = "Saturation", i9[41994] = "Sharpness", i9[41995] = "DeviceSettingDescription", i9[41996] = "SubjectDistanceRange", i9;
})();
var t5 = ["GPSVersionID", "GPSLatitudeRef", "GPSLatitude", "GPSLongitudeRef", "GPSLongitude", "GPSAltitudeRef", "GPSAltitude", "GPSTimeStamp", "GPSSatellites", "GPSStatus", "GPSMeasureMode", "GPSDOP", "GPSSpeedRef", "GPSSpeed", "GPSTrackRef", "GPSTrack", "GPSImgDirectionRef", "GPSImgDirection", "GPSMapDatum", "GPSDestLatitudeRef", "GPSDestLatitude", "GPSDestLongitudeRef", "GPSDestLongitude", "GPSDestBearingRef", "GPSDestBearing", "GPSDestDistanceRef", "GPSDestDistance", "GPSProcessingMethod", "GPSAreaInformation", "GPSDateStamp", "GPSDifferential", "GPSHPositioningError"];
var o5 = (() => {
  const e7 = [];
  return e7[1024] = "GTModelTypeGeoKey", e7[1025] = "GTRasterTypeGeoKey", e7[1026] = "GTCitationGeoKey", e7[2048] = "GeographicTypeGeoKey", e7[2049] = "GeogCitationGeoKey", e7[2050] = "GeogGeodeticDatumGeoKey", e7[2051] = "GeogPrimeMeridianGeoKey", e7[2052] = "GeogLinearUnitsGeoKey", e7[2053] = "GeogLinearUnitSizeGeoKey", e7[2054] = "GeogAngularUnitsGeoKey", e7[2055] = "GeogAngularUnitSizeGeoKey", e7[2056] = "GeogEllipsoidGeoKey", e7[2057] = "GeogSemiMajorAxisGeoKey", e7[2058] = "GeogSemiMinorAxisGeoKey", e7[2059] = "GeogInvFlatteningGeoKey", e7[2061] = "GeogPrimeMeridianLongGeoKey", e7[2060] = "GeogAzimuthUnitsGeoKey", e7[3072] = "ProjectedCSTypeGeoKey", e7[3073] = "PCSCitationGeoKey", e7[3074] = "ProjectionGeoKey", e7[3075] = "ProjCoordTransGeoKey", e7[3076] = "ProjLinearUnitsGeoKey", e7[3077] = "ProjLinearUnitSizeGeoKey", e7[3078] = "ProjStdParallel1GeoKey", e7[3079] = "ProjStdParallel2GeoKey", e7[3080] = "ProjNatOriginLongGeoKey", e7[3081] = "ProjNatOriginLatGeoKey", e7[3082] = "ProjFalseEastingGeoKey", e7[3083] = "ProjFalseNorthingGeoKey", e7[3084] = "ProjFalseOriginLongGeoKey", e7[3085] = "ProjFalseOriginLatGeoKey", e7[3086] = "ProjFalseOriginEastingGeoKey", e7[3087] = "ProjFalseOriginNorthingGeoKey", e7[3088] = "ProjCenterLongGeoKey", e7[3090] = "ProjCenterEastingGeoKey", e7[3091] = "ProjCenterNorthingGeoKey", e7[3092] = "ProjScaleAtNatOriginGeoKey", e7[3093] = "ProjScaleAtCenterGeoKey", e7[3094] = "ProjAzimuthAngleGeoKey", e7[3095] = "ProjStraightVertPoleLongGeoKey", e7[4096] = "VerticalCSTypeGeoKey", e7[4097] = "VerticalCitationGeoKey", e7[4098] = "VerticalDatumGeoKey", e7[4099] = "VerticalUnitsGeoKey", e7;
})();
var S = (i9, t8) => {
  let o10 = (t8 || e5)[i9];
  return void 0 === o10 && (o10 = "unknown" + String(i9)), o10;
};
var E = /* @__PURE__ */ new Map();
E.set("EXIFIFD", i5), E.set("GPSIFD", t5);
var n5 = { tiffTags: e5, ifdTags: E, geoKeys: o5, getTagName: S };

// node_modules/@arcgis/core/layers/support/rasterFormats/utils.js
var r9 = (() => {
  const r13 = new ArrayBuffer(4), n12 = new Uint8Array(r13);
  return new Uint32Array(r13)[0] = 1, 1 === n12[0];
})();

// node_modules/@arcgis/core/layers/support/rasterFormats/TiffDecoder.js
var f6 = [0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8, -1, -1, -1, 8, 8, 8];
var u7 = 4294967296;
var c4 = /* @__PURE__ */ new Set([1, 5, 6, 7, 8, 34712, 34887]);
function h2(e7, t8) {
  let n12 = "unknown";
  return 3 === e7 ? n12 = 64 === t8 ? "f64" : "f32" : 1 === e7 ? 1 === t8 ? n12 = "u1" : 2 === t8 ? n12 = "u2" : 4 === t8 ? n12 = "u4" : t8 <= 8 ? n12 = "u8" : t8 <= 16 ? n12 = "u16" : t8 <= 32 && (n12 = "u32") : 2 === e7 && (t8 <= 8 ? n12 = "s8" : t8 <= 16 ? n12 = "s16" : t8 <= 32 && (n12 = "s32")), n12;
}
function g(e7) {
  let t8 = null;
  switch (e7 ? e7.toLowerCase() : "f32") {
    case "u1":
    case "u2":
    case "u4":
    case "u8":
      t8 = Uint8Array;
      break;
    case "u16":
      t8 = Uint16Array;
      break;
    case "u32":
      t8 = Uint32Array;
      break;
    case "s8":
      t8 = Int8Array;
      break;
    case "s16":
      t8 = Int16Array;
      break;
    case "s32":
      t8 = Int32Array;
      break;
    case "f64":
      t8 = Float64Array;
      break;
    default:
      t8 = Float32Array;
  }
  return t8;
}
function E2(e7, t8) {
  return { x: t8[0] * e7.x + t8[1] * e7.y + t8[2], y: t8[3] * e7.x + t8[4] * e7.y + t8[5] };
}
function T(e7, t8) {
  var _a;
  return (_a = e7.get(t8)) == null ? void 0 : _a.values;
}
function I(e7, t8) {
  var _a;
  return (_a = e7.get(t8)) == null ? void 0 : _a.values;
}
function w(e7, t8) {
  var _a, _b;
  return (_b = (_a = e7.get(t8)) == null ? void 0 : _a.values) == null ? void 0 : _b[0];
}
function d(e7, t8) {
  var _a, _b;
  return (_b = (_a = e7.get(t8)) == null ? void 0 : _a.values) == null ? void 0 : _b[0];
}
function p(e7, t8, n12, a13 = 0, i9 = n5.tiffTags, s10 = 4) {
  const l5 = 8 === s10, o10 = l5 ? C(new DataView(e7, n12, 8), 0, t8) : new DataView(e7, n12, 2).getUint16(0, t8), f10 = 4 + 2 * s10, u14 = l5 ? 8 : 2, c8 = u14 + o10 * f10;
  if (n12 + c8 > e7.byteLength)
    return { success: false, ifd: null, nextIFD: null, requiredBufferSize: c8 };
  const h7 = n12 + c8 + 4 <= e7.byteLength ? v(new DataView(e7, n12 + c8, 8 === s10 ? 8 : 4), 0, t8, 8 === s10) : null, g5 = n12 + u14, E3 = /* @__PURE__ */ new Map();
  let T3, I4, w4, d4, p6, y6 = 0, m6 = 0;
  for (let S3 = 0; S3 < o10; S3++) {
    I4 = new DataView(e7, g5 + f10 * S3, f10), w4 = I4.getUint16(0, t8), p6 = I4.getUint16(2, t8), d4 = n5.getTagName(w4, i9);
    const n13 = [];
    2 === s10 ? (y6 = I4.getUint16(4, t8), m6 = I4.getUint16(6, t8)) : 4 === s10 ? (y6 = I4.getUint32(4, t8), m6 = I4.getUint32(8, t8)) : 8 === s10 && (y6 = v(I4, 4, t8, true), m6 = v(I4, 12, t8, true), n13.push(I4.getUint32(12, t8)), n13.push(I4.getUint32(16, t8))), T3 = { id: w4, type: p6, valueCount: y6, valueOffset: m6, valueOffsets: n13, values: null }, L(e7, t8, T3, a13, false, s10), E3.set(d4, T3);
  }
  return { success: true, ifd: E3, nextIFD: h7, requiredBufferSize: c8 };
}
var y3 = (e7, t8) => c3(e7, { inputOffset: t8 }).pixels[0];
function m(e7, t8) {
  if (1 !== t8 && 2 !== t8 && 4 !== t8)
    return e7;
  const n12 = new Uint8Array(e7), a13 = 8 / t8, i9 = new Uint8Array(e7.byteLength * a13);
  let s10 = 0;
  const r13 = 2 ** t8 - 1;
  for (let l5 = 0; l5 < n12.length; l5++) {
    const e8 = n12[l5];
    for (let n13 = 0; n13 < a13; n13++)
      i9[s10++] = e8 << t8 * n13 >>> 8 - t8 & r13;
  }
  return i9.buffer;
}
function S2(e7, n12, a13) {
  const i9 = new t();
  i9.parse(e7), i9.colorTransform = 6 === a13 ? -1 : 0;
  const s10 = i9.getData(i9.width, i9.height, 1 !== n12 && 4 !== n12);
  return new Uint8Array(s10.buffer);
}
function A2(e7) {
  const t8 = new f4(e7).getBytes(), n12 = new ArrayBuffer(t8.length), a13 = new Uint8Array(n12);
  return a13.set(t8), a13;
}
async function M2(e7, t8, a13, s10, r13) {
  const o10 = r9 === t8, f10 = d(a13, "BITSPERSAMPLE"), u14 = d(a13, "SAMPLESPERPIXEL") ?? 1, c8 = d(a13, "PHOTOMETRICINTERPRETATION"), E3 = d(a13, "SAMPLEFORMAT") ?? 1, T3 = h2(E3, f10), I4 = d(a13, "COMPRESSION") ?? 1, w4 = g(T3);
  let p6, M4, P3;
  if (34887 === I4)
    return await a6(), y3(e7, s10);
  if (1 === I4)
    p6 = e7.slice(s10, s10 + r13), M4 = new Uint8Array(p6);
  else if (8 === I4 || 32946 === I4)
    M4 = new Uint8Array(e7, s10, r13), M4 = A2(M4), p6 = M4.buffer;
  else if (6 === I4)
    M4 = new Uint8Array(e7, s10, r13), M4 = S2(M4, u14, c8), p6 = M4.buffer;
  else if (7 === I4) {
    const t9 = a13.get("JPEGTABLES").values, n12 = t9.length - 2;
    M4 = new Uint8Array(n12 + r13 - 2);
    for (let e8 = 0; e8 < n12; e8++)
      M4[e8] = t9[e8];
    const i9 = new Uint8Array(e7, s10 + 2, r13 - 2);
    for (let e8 = 0; e8 < i9.length; e8++)
      M4[n12 + e8] = i9[e8];
    M4 = S2(M4, u14, c8), p6 = M4.buffer;
  } else {
    if (5 !== I4)
      throw new Error("tiff-decode: unsupport compression " + I4);
    M4 = i4(e7, s10, r13, t8), p6 = M4.buffer;
  }
  if (p6 = m(p6, f10), "u8" === T3 || "s8" === T3 || o10)
    P3 = new w4(p6);
  else {
    p6 = new ArrayBuffer(M4.length);
    const e8 = new Uint8Array(p6);
    switch (T3) {
      case "u16":
      case "s16":
        for (let t9 = 0; t9 < M4.length; t9 += 2)
          e8[t9] = M4[t9 + 1], e8[t9 + 1] = M4[t9];
        break;
      case "u32":
      case "s32":
      case "f32":
        for (let t9 = 0; t9 < M4.length; t9 += 4)
          e8[t9] = M4[t9 + 3], e8[t9 + 1] = M4[t9 + 2], e8[t9 + 2] = M4[t9 + 1], e8[t9 + 3] = M4[t9];
    }
    P3 = new w4(p6);
  }
  const b4 = d(a13, "PREDICTOR") ?? 1, O3 = d(a13, "TILEWIDTH"), x5 = d(a13, "TILELENGTH");
  if (b4 > 1 && (5 === I4 || 8 === I4 || 32946 === I4) && O3 && x5) {
    const e8 = D(a13), t9 = new w4(P3.length);
    t9.set(P3), P3 = W(t9, x5, O3, 3 === E3 && 3 === b4, e8 ? 1 : u14);
  }
  return P3;
}
async function P(e7, t8, n12) {
  const a13 = I(n12, "TILEOFFSETS");
  if (void 0 === a13)
    return null;
  const i9 = I(n12, "TILEBYTECOUNTS"), { width: s10, height: r13, pixelType: l5, tileWidth: o10, tileHeight: f10 } = R([n12]), u14 = D(n12, t8), c8 = d(n12, "SAMPLESPERPIXEL") || t8.planes, h7 = s10 * r13, E3 = d(n12, "BITSPERSAMPLE"), T3 = 34887 === (d(n12, "COMPRESSION") ?? 1), w4 = g(l5), p6 = [];
  for (let g5 = 0; g5 < c8; g5++)
    p6.push(new w4(h7));
  let y6, m6, S3, A5, P3, b4, O3, x5, L3, U3, N2, k4, C5;
  const G3 = Math.ceil(s10 / o10), v4 = new Uint8Array(h7).fill(255);
  let F2 = false;
  if (E3 % 8 == 0)
    if (T3 && u14 && c8 > 1) {
      const l6 = Math.round(a13.length / c8);
      for (y6 = 0; y6 < l6; y6++) {
        b4 = Math.floor(y6 / G3) * f10, O3 = y6 % G3 * o10, x5 = b4 * s10 + O3;
        for (let l7 = 0; l7 < c8; l7++) {
          const u15 = y6 * c8 + l7;
          for (0 === i9[u15] ? (S3 = null, F2 = true) : S3 = await M2(e7, t8.littleEndian, n12, a13[u15], i9[u15]), U3 = 0, L3 = x5, k4 = Math.min(o10, s10 - O3), N2 = Math.min(f10, r13 - b4), C5 = p6[l7], A5 = 0; A5 < N2; A5++)
            for (L3 = x5 + A5 * s10, U3 = A5 * o10, P3 = 0; P3 < k4; P3++, L3++, U3++)
              S3 ? C5[L3] = S3[U3] : v4[L3] = 0;
        }
      }
    } else
      for (y6 = 0; y6 < a13.length; y6++)
        for (b4 = Math.floor(y6 / G3) * f10, O3 = y6 % G3 * o10, x5 = b4 * s10 + O3, 0 === i9[y6] ? (S3 = null, F2 = true) : S3 = await M2(e7, t8.littleEndian, n12, a13[y6], i9[y6]), U3 = 0, L3 = x5, k4 = Math.min(o10, s10 - O3), N2 = Math.min(f10, r13 - b4), m6 = 0; m6 < c8; m6++)
          if (C5 = p6[m6], u14 || T3)
            for (A5 = 0; A5 < N2; A5++)
              for (L3 = x5 + A5 * s10, U3 = o10 * f10 * m6 + A5 * o10, P3 = 0; P3 < k4; P3++, L3++, U3++)
                S3 ? C5[L3] = S3[U3] : v4[L3] = 0;
          else
            for (A5 = 0; A5 < N2; A5++)
              for (L3 = x5 + A5 * s10, U3 = A5 * o10 * c8 + m6, P3 = 0; P3 < k4; P3++, L3++, U3 += c8)
                S3 ? C5[L3] = S3[U3] : v4[L3] = 0;
  return { width: s10, height: r13, pixelType: l5, pixels: p6, mask: F2 ? v4 : void 0 };
}
var b = (e7, t8, n12) => {
  const a13 = r9 === t8.littleEndian, s10 = I(n12, "STRIPOFFSETS");
  if (void 0 === s10)
    return null;
  const { width: r13, height: o10, pixelType: f10 } = R([n12]), u14 = d(n12, "SAMPLESPERPIXEL") || t8.planes, c8 = d(n12, "PHOTOMETRICINTERPRETATION"), h7 = r13 * o10, E3 = d(n12, "BITSPERSAMPLE"), T3 = g(f10), w4 = new T3(h7 * u14), p6 = I(n12, "STRIPBYTECOUNTS"), y6 = d(n12, "ROWSPERSTRIP"), M4 = d(n12, "COMPRESSION") ?? 1;
  let P3, b4, O3, x5, L3, D4, U3, N2, k4, C5 = y6;
  if (E3 % 8 == 0)
    for (P3 = 0; P3 < s10.length; P3++) {
      if (L3 = P3 * (y6 * r13) * u14, C5 = (P3 + 1) * y6 > o10 ? o10 - P3 * y6 : y6, "u8" === f10 || "s8" === f10 || a13)
        8 === M4 || 32946 === M4 ? (U3 = new Uint8Array(e7, s10[P3], p6[P3]), U3 = A2(U3), D4 = U3.buffer) : 6 === M4 ? (U3 = new Uint8Array(e7, s10[P3], p6[P3]), U3 = S2(U3, u14, c8), D4 = U3.buffer) : 5 === M4 ? (U3 = i4(e7, s10[P3], p6[P3], t8.littleEndian), D4 = U3.buffer) : (p6[P3] !== C5 * r13 * u14 * E3 / 8 && console.log("strip byte counts is different than expected"), D4 = e7.slice(s10[P3], s10[P3] + p6[P3])), D4 = m(D4, E3), x5 = new T3(D4);
      else {
        switch (6 === M4 || 8 === M4 || 32946 === M4 ? (U3 = new Uint8Array(e7, s10[P3], p6[P3]), N2 = A2(U3), D4 = N2.buffer) : (p6[P3] !== C5 * r13 * u14 * E3 / 8 && console.log("strip byte counts is different than expected"), D4 = new ArrayBuffer(p6[P3]), U3 = new Uint8Array(e7, s10[P3], p6[P3]), N2 = new Uint8Array(D4)), f10) {
          case "u16":
          case "s16":
            for (O3 = 0; O3 < U3.length; O3 += 2)
              N2[O3] = U3[O3 + 1], N2[O3 + 1] = U3[O3];
            break;
          case "u32":
          case "s32":
          case "f32":
            for (O3 = 0; O3 < U3.length; O3 += 4)
              N2[O3] = U3[O3 + 3], N2[O3 + 1] = U3[O3 + 2], N2[O3 + 2] = U3[O3 + 1], N2[O3 + 3] = U3[O3];
        }
        D4 = m(D4, E3), x5 = new T3(D4);
      }
      w4.set(x5, L3);
    }
  const G3 = [];
  if (1 === u14)
    G3.push(w4);
  else
    for (P3 = 0; P3 < u14; P3++) {
      for (k4 = new T3(h7), b4 = 0; b4 < h7; b4++)
        k4[b4] = w4[b4 * u14 + P3];
      G3.push(k4);
    }
  return { width: r13, height: o10, pixelType: f10, pixels: G3 };
};
var O = (e7, t8, n12) => {
  if (!(e7 && e7.length > 0 && t8 && n12))
    return null;
  let a13, i9, s10;
  const r13 = e7[0].length, l5 = e7.length, o10 = new Uint8Array(r13);
  for (let f10 = 0; f10 < l5; f10++)
    if (a13 = e7[f10], i9 = t8[f10], s10 = n12[f10], 0 === f10)
      for (let e8 = 0; e8 < r13; e8++)
        o10[e8] = a13[e8] < i9 || a13[e8] > s10 ? 0 : 1;
    else
      for (let e8 = 0; e8 < r13; e8++)
        o10[e8] && (o10[e8] = a13[e8] < i9 || a13[e8] > s10 ? 0 : 1);
  return o10;
};
var x2 = (e7) => {
  if (!e7)
    return null;
  const t8 = e7.match(/<Item(.*?)Item>/gi);
  if (!t8 || 0 === t8.length)
    return null;
  const n12 = /* @__PURE__ */ new Map();
  let a13, i9, s10, r13, l5;
  for (let w4 = 0; w4 < t8.length; w4++)
    a13 = t8[w4], i9 = a13.slice(6, a13.indexOf(">")), r13 = a13.indexOf("sample="), r13 > -1 && (l5 = a13.slice(r13 + 8, a13.indexOf('"', r13 + 8))), r13 = a13.indexOf("name="), r13 > -1 && (i9 = a13.slice(r13 + 6, a13.indexOf('"', r13 + 6))), i9 && (s10 = a13.slice(a13.indexOf(">") + 1, a13.indexOf("</Item>")).trim(), null != l5 ? n12.has(i9) ? n12.get(i9)[l5] = s10 : n12.set(i9, [s10]) : n12.set(i9, s10)), l5 = null;
  const o10 = n12.get("STATISTICS_MINIMUM"), f10 = n12.get("STATISTICS_MAXIMUM"), u14 = n12.get("STATISTICS_MEAN"), c8 = n12.get("STATISTICS_STDDEV");
  let h7 = null;
  if (o10 && f10) {
    h7 = [];
    for (let e8 = 0; e8 < o10.length; e8++)
      h7.push({ min: parseFloat(o10[e8]), max: parseFloat(f10[e8]), avg: u14 && parseFloat(u14[e8]), stddev: c8 && parseFloat(c8[e8]) });
  }
  const g5 = n12.get("BandName"), E3 = n12.get("WavelengthMin"), T3 = n12.get("WavelengthMax");
  let I4 = null;
  if (g5) {
    I4 = [];
    for (let e8 = 0; e8 < g5.length; e8++)
      I4.push({ BandName: g5[e8], WavelengthMin: E3 && parseFloat(E3[e8]), WavelengthMax: T3 && parseFloat(T3[e8]) });
  }
  return { statistics: h7, bandProperties: I4, dataType: n12.get("DataType"), rawMetadata: n12 };
};
function L(e7, t8, n12, a13 = 0, i9 = false, s10 = 4) {
  if (n12.values)
    return true;
  const r13 = n12.type, l5 = n12.valueCount;
  let o10 = n12.valueOffset, c8 = [];
  const h7 = f6[r13], g5 = 8 * h7, E3 = l5 * h7, T3 = l5 * f6[r13] * 8;
  let I4, w4;
  const d4 = 8 === s10 ? 64 : 32, p6 = n12.valueOffsets;
  if (T3 > d4) {
    if (E3 > (i9 ? e7.byteLength : e7 ? e7.byteLength - o10 + a13 : 0))
      return n12.offlineOffsetSize = [o10, E3], n12.values = null, false;
  }
  if (T3 <= d4) {
    if (!t8)
      if (d4 <= 32)
        o10 >>>= 32 - T3;
      else {
        const e8 = (p6 == null ? void 0 : p6.length) ? p6[0] : o10 >>> 0, t9 = (p6 == null ? void 0 : p6.length) ? p6[1] : Math.round((o10 - e8) / u7);
        T3 <= 32 ? (o10 = e8 >>> 32 - T3, p6[0] = o10) : (o10 = e8 * 2 ** (32 - T3) + (t9 >>> 32 - T3), p6[0] = e8, p6[1] = t9 >>> 32 - T3);
      }
    if (1 === l5 && g5 === d4)
      c8 = [o10];
    else if (64 === d4) {
      const e8 = (p6 == null ? void 0 : p6.length) ? p6[0] : o10 >>> 0, t9 = (p6 == null ? void 0 : p6.length) ? p6[1] : Math.round((o10 - e8) / u7);
      let n13 = e8, a14 = 32;
      for (w4 = 1; w4 <= l5; w4++) {
        const e9 = 32 - g5 * w4 % 32;
        if (a14 < g5) {
          const i10 = n13 << e9 >>> 32 - a14, s11 = t9 << 32 - a14 >>> 32 - a14;
          n13 = t9, c8.push(i10 + s11 * 2 ** (g5 - a14)), a14 -= 32 - (g5 - a14);
        } else
          c8.push(n13 << e9 >>> 32 - g5), a14 -= g5;
        0 === a14 && (a14 = 32, n13 = t9);
      }
    } else
      for (w4 = 1; w4 <= l5; w4++) {
        const e8 = 32 - g5 * w4;
        c8.push(o10 << e8 >>> 32 - g5);
      }
  } else {
    o10 -= a13, i9 && (o10 = 0);
    for (let n13 = o10; n13 < o10 + E3; n13 += h7) {
      switch (r13) {
        case 1:
        case 2:
        case 7:
          I4 = new DataView(e7, n13, 1).getUint8(0);
          break;
        case 3:
          I4 = new DataView(e7, n13, 2).getUint16(0, t8);
          break;
        case 4:
        case 13:
          I4 = new DataView(e7, n13, 4).getUint32(0, t8);
          break;
        case 5:
          I4 = new DataView(e7, n13, 4).getUint32(0, t8) / new DataView(e7, n13 + 4, 4).getUint32(0, t8);
          break;
        case 6:
          I4 = new DataView(e7, n13, 1).getInt8(0);
          break;
        case 8:
          I4 = new DataView(e7, n13, 2).getInt16(0, t8);
          break;
        case 9:
          I4 = new DataView(e7, n13, 4).getInt32(0, t8);
          break;
        case 10:
          I4 = new DataView(e7, n13, 4).getInt32(0, t8) / new DataView(e7, n13 + 4, 4).getInt32(0, t8);
          break;
        case 11:
          I4 = new DataView(e7, n13, 4).getFloat32(0, t8);
          break;
        case 12:
          I4 = new DataView(e7, n13, 8).getFloat64(0, t8);
          break;
        case 16:
        case 18:
          I4 = C(new DataView(e7, n13, 8), 0, t8);
          break;
        case 17:
          I4 = G(new DataView(e7, n13, 8), 0, t8);
          break;
        default:
          I4 = null;
      }
      c8.push(I4);
    }
  }
  if (2 === r13) {
    let e8 = "";
    const t9 = c8;
    for (c8 = [], w4 = 0; w4 < t9.length; w4++)
      0 === t9[w4] && "" !== e8 ? (c8.push(e8), e8 = "") : e8 += String.fromCharCode(t9[w4]);
    "" === e8 && 0 !== c8.length || c8.push(e8);
  }
  return n12.values = c8, true;
}
function R(e7) {
  const t8 = e7[0], n12 = d(t8, "TILEWIDTH"), a13 = d(t8, "TILELENGTH"), i9 = d(t8, "IMAGEWIDTH"), s10 = d(t8, "IMAGELENGTH"), r13 = d(t8, "BITSPERSAMPLE"), l5 = d(t8, "SAMPLESPERPIXEL"), o10 = d(t8, "SAMPLEFORMAT") ?? 1, f10 = h2(o10, r13), u14 = D(t8), g5 = T(t8, "GDAL_NODATA");
  let p6 = null;
  (g5 == null ? void 0 : g5.length) && (p6 = g5.map((e8) => parseFloat(e8)), p6.some((e8) => isNaN(e8)) && (p6 = null));
  const y6 = d(t8, "COMPRESSION") ?? 1;
  let m6;
  switch (y6) {
    case 1:
      m6 = "NONE";
      break;
    case 2:
    case 3:
    case 4:
    case 32771:
      m6 = "CCITT";
      break;
    case 5:
      m6 = "LZW";
      break;
    case 6:
    case 7:
      m6 = "JPEG";
      break;
    case 32773:
      m6 = "PACKBITS";
      break;
    case 8:
    case 32946:
      m6 = "DEFLATE";
      break;
    case 34712:
      m6 = "JPEG2000";
      break;
    case 34887:
      m6 = "LERC";
      break;
    default:
      m6 = String(y6);
  }
  let S3 = true, A5 = "";
  c4.has(y6) || (S3 = false, A5 += "unsupported tag compression " + y6), o10 > 3 && (S3 = false, A5 += "unsupported tag sampleFormat " + o10), 1 !== r13 && 2 !== r13 && 4 !== r13 && r13 % 8 != 0 && (S3 = false, A5 += "unsupported tag bitsPerSample " + r13);
  const M4 = w(t8, "GEOASCIIPARAMS");
  let P3;
  if (M4) {
    const e8 = M4.split("|").find((e9) => e9.includes("ESRI PE String = ")), t9 = e8 ? e8.replace("ESRI PE String = ", "") : "";
    P3 = t9.startsWith("COMPD_CS") || t9.startsWith("PROJCS") || t9.startsWith("GEOGCS") ? { wkid: null, wkt: t9 } : null;
  }
  const b4 = I(t8, "GEOTIEPOINTS"), O3 = I(t8, "GEOPIXELSCALE"), L3 = I(t8, "GEOTRANSMATRIX"), R3 = t8.has("GEOKEYDIRECTORY") ? t8.get("GEOKEYDIRECTORY").data : null;
  let k4, C5, G3 = false, v4 = false;
  if (R3) {
    G3 = 2 === d(R3, "GTRasterTypeGeoKey");
    const e8 = d(R3, "GTModelTypeGeoKey");
    if (2 === e8) {
      const e9 = d(R3, "GeographicTypeGeoKey");
      e9 >= 1024 && e9 <= 32766 && (P3 = { wkid: e9 }), P3 || 32767 !== e9 || (v4 = true, P3 = { wkid: 4326 });
    } else if (1 === e8) {
      const e9 = d(R3, "ProjectedCSTypeGeoKey");
      e9 >= 1024 && e9 <= 32766 && (P3 = { wkid: e9 });
    }
  }
  if (O3 && b4 && b4.length >= 6 ? (k4 = [O3[0], 0, b4[3] - b4[0] * O3[0], 0, -Math.abs(O3[1]), b4[4] - b4[1] * O3[1]], G3 && (k4[2] -= 0.5 * k4[0] + 0.5 * k4[1], k4[5] -= 0.5 * k4[3] + 0.5 * k4[4])) : L3 && 16 === L3.length && (k4 = G3 ? [L3[0], L3[1], L3[3] - 0.5 * L3[0], L3[4], L3[5], L3[7] - 0.5 * L3[5]] : [L3[0], L3[1], L3[3], L3[4], L3[5], L3[7]]), k4) {
    const e8 = [{ x: 0, y: s10 }, { x: 0, y: 0 }, { x: i9, y: s10 }, { x: i9, y: 0 }];
    let t9, n13 = Number.POSITIVE_INFINITY, a14 = Number.POSITIVE_INFINITY, r14 = Number.NEGATIVE_INFINITY, l6 = Number.NEGATIVE_INFINITY;
    for (let i10 = 0; i10 < e8.length; i10++)
      t9 = E2(e8[i10], k4), n13 = t9.x > n13 ? n13 : t9.x, r14 = t9.x < r14 ? r14 : t9.x, a14 = t9.y > a14 ? a14 : t9.y, l6 = t9.y < l6 ? l6 : t9.y;
    C5 = { xmin: n13, xmax: r14, ymin: a14, ymax: l6, spatialReference: P3 };
  } else
    C5 = { xmin: -0.5, ymin: 0.5 - s10, xmax: i9 - 0.5, ymax: 0.5, spatialReference: P3 };
  v4 && (C5.xmax - C5.xmin > 400 || Math.max(Math.abs(C5.xmin), Math.abs(C5.xmax)) > 361) && (P3 = null, C5.spatialReference = null);
  const F2 = U(e7);
  let B3, W2, H2, Y2, _2;
  if (F2.length > 0) {
    H2 = Math.round(Math.log(i9 / d(F2[0], "IMAGEWIDTH")) / Math.LN2);
    const e8 = F2[F2.length - 1];
    Y2 = Math.round(Math.log(i9 / d(e8, "IMAGEWIDTH")) / Math.LN2), B3 = d(e8, "TILEWIDTH"), W2 = d(e8, "TILELENGTH");
  }
  B3 = null != Y2 && Y2 > 0 ? B3 || n12 : null, W2 = null != Y2 && Y2 > 0 ? W2 || a13 : null, n12 && (_2 = [{ maxCol: Math.ceil(i9 / n12) - 1, maxRow: Math.ceil(s10 / a13) - 1, minRow: 0, minCol: 0 }], F2.forEach((e8) => {
    _2.push({ maxCol: Math.ceil(d(e8, "IMAGEWIDTH") / d(e8, "TILEWIDTH")) - 1, maxRow: Math.ceil(d(e8, "IMAGELENGTH") / d(e8, "TILELENGTH")) - 1, minRow: 0, minCol: 0 });
  }));
  const K = w(e7[0], "GDAL_METADATA"), X = x2(K);
  A5 += " " + V({ width: i9, height: s10, tileWidth: n12, tileHeight: a13, planes: l5, ifds: e7 });
  return { width: i9, height: s10, tileWidth: n12, tileHeight: a13, planes: l5, isBSQ: u14, pixelType: f10, compression: m6, noData: p6, hasMaskBand: N(e7).length === F2.length + 1, isSupported: S3, message: A5, extent: C5, isPseudoGeographic: v4, affine: O3 ? null : k4, firstPyramidLevel: H2, maximumPyramidLevel: Y2, pyramidBlockWidth: B3, pyramidBlockHeight: W2, tileBoundary: _2, metadata: X };
}
function D(e7, t8) {
  const n12 = T(e7, "PLANARCONFIGURATION");
  return n12 ? 2 === n12[0] : !!t8 && t8.isBSQ;
}
function U(e7) {
  return e7.filter((e8) => 1 === d(e8, "NEWSUBFILETYPE"));
}
function N(e7) {
  return e7.filter((e8) => {
    const t8 = 4 == (4 & (d(e8, "NEWSUBFILETYPE") ?? 0)), n12 = 4 === d(e8, "PHOTOMETRICINTERPRETATION");
    return t8 && n12;
  });
}
function k(e7) {
  const { littleEndian: t8, isBigTiff: n12, firstIFDPos: a13 } = F(e7);
  let i9 = a13;
  const s10 = [];
  do {
    const a14 = B(e7, t8, i9, 0, n5.tiffTags, n12 ? 8 : 4);
    if (!a14.success)
      break;
    s10.push(a14.ifd), i9 = a14.nextIFD;
  } while (i9 > 0);
  return { ...R(s10), littleEndian: t8, isBigTiff: n12, ifds: s10, pyramidIFDs: U(s10), maskIFDs: N(s10) };
}
function C(e7, t8, n12) {
  const a13 = e7.getUint32(t8, n12), i9 = e7.getUint32(t8 + 4, n12);
  return n12 ? i9 * u7 + a13 : a13 * u7 + i9;
}
function G(e7, t8, n12) {
  let a13 = n12 ? e7.getInt32(t8, n12) : e7.getUint32(t8, n12), i9 = n12 ? e7.getUint32(t8 + 4, n12) : e7.getInt32(t8 + 4, n12);
  const s10 = (n12 ? a13 : i9) >= 0 ? 1 : -1;
  n12 ? a13 *= s10 : i9 *= s10;
  return s10 * (n12 ? i9 * u7 + a13 : a13 * u7 + i9);
}
function v(e7, t8, n12, a13) {
  return a13 ? C(e7, t8, n12) : e7.getUint32(t8, n12);
}
function F(e7) {
  const t8 = new DataView(e7, 0, 16), n12 = t8.getUint16(0, false);
  let a13 = null;
  if (18761 === n12)
    a13 = true;
  else {
    if (19789 !== n12)
      throw new Error("unexpected endianess byte");
    a13 = false;
  }
  const i9 = t8.getUint16(2, a13);
  if (42 !== i9 && 43 !== i9)
    throw new Error("unexpected tiff identifier");
  let s10 = 4;
  const r13 = 43 === i9;
  if (r13) {
    const e8 = t8.getUint16(s10, a13);
    if (s10 += 2, 8 !== e8)
      throw new Error("unsupported bigtiff version");
    if (0 !== t8.getUint16(s10, a13))
      throw new Error("unsupported bigtiff version");
    s10 += 2;
  }
  return { littleEndian: a13, isBigTiff: r13, firstIFDPos: v(t8, s10, a13, r13) };
}
function B(t8, n12, a13, i9 = 0, s10 = n5.tiffTags, l5 = 4) {
  const o10 = p(t8, n12, a13, i9, s10, l5);
  let f10;
  const u14 = o10.ifd;
  if (u14) {
    if (n5.ifdTags.forEach((e7, a14) => {
      u14.has(a14) && (f10 = u14.get(a14), f10.data = p(t8, n12, f10.valueOffset - i9, i9, e7).ifd);
    }), u14.has("GEOKEYDIRECTORY")) {
      f10 = u14.get("GEOKEYDIRECTORY");
      const e7 = f10.values;
      if (e7 && e7.length > 4) {
        const a14 = e7[0] + "." + e7[1] + "." + e7[2];
        f10.data = p(t8, n12, f10.valueOffset + 6 - i9, i9, n5.geoKeys, 2).ifd, f10.data && f10.data.set("GEOTIFFVersion", { id: 0, type: 2, valueCount: 1, valueOffset: null, values: [a14] });
      }
    }
    if (u14.has("XMP")) {
      f10 = u14.get("XMP");
      const t9 = f10.values;
      "number" == typeof t9[0] && 7 === f10.type && (f10.values = [r8(new Uint8Array(t9))]);
    }
  }
  return o10;
}
function V(e7) {
  const { width: t8, height: n12, tileHeight: a13, tileWidth: i9 } = e7, s10 = e7.planes, r13 = i9 ? i9 * a13 : t8 * n12, l5 = d(e7.ifds[0], "BITSPERSAMPLE");
  let o10 = "";
  return r13 * s10 > 2 ** 30 / (l5 > 8 ? l5 / 8 : 1) && (o10 = i9 ? "tiled tiff exceeding 1 gigabits per tile is not supported" : "scanline tiff exceeding 1 gigabits is not supported"), o10;
}
function W(e7, t8, n12, a13, i9) {
  const s10 = a13 ? 4 : 1, r13 = n12 * s10 * i9;
  a13 && (e7 = new Uint8Array(e7.buffer));
  for (let f10 = 0; f10 < t8; f10++) {
    const t9 = f10 * r13;
    for (let n13 = i9; n13 < r13; n13++)
      e7[t9 + n13] += e7[t9 + n13 - i9];
  }
  if (!a13)
    return e7;
  const l5 = new Uint8Array(e7.length), o10 = n12 * i9;
  for (let f10 = 0; f10 < t8; f10++) {
    const t9 = f10 * r13;
    for (let n13 = 0; n13 < o10; n13++)
      for (let a14 = 0; a14 < s10; a14++)
        l5[t9 + n13 * s10 + a14] = e7[t9 + n13 + (s10 - a14 - 1) * o10];
  }
  return new Float32Array(l5.buffer);
}
async function H(e7, t8) {
  const { headerInfo: n12, ifd: a13, offsets: i9, sizes: r13 } = t8, l5 = [];
  for (let s10 = 0; s10 < i9.length; s10++) {
    r13[s10];
    const t9 = await M2(e7, n12.littleEndian, a13, i9[s10], r13[s10] || e7.byteLength);
    l5.push(t9);
  }
  const o10 = D(a13, n12), f10 = d(a13, "BITSPERSAMPLE"), u14 = h2(d(a13, "SAMPLEFORMAT") ?? 1, f10), c8 = d(a13, "SAMPLESPERPIXEL") || n12.planes, E3 = g(u14), T3 = d(a13, "TILEWIDTH"), I4 = d(a13, "TILELENGTH"), w4 = d(a13, "COMPRESSION") ?? 1, p6 = T3 * I4;
  let y6;
  const m6 = [];
  let S3 = l5[0];
  const A5 = 34887 === w4;
  for (let s10 = 0; s10 < c8; s10++) {
    if (y6 = new E3(p6), l5.length === c8)
      S3 = l5[s10], S3.length === p6 && (y6 = S3);
    else if (S3.length)
      if (o10 || A5)
        y6 = S3.length === p6 ? S3 : S3.slice(p6 * s10, p6 * (s10 + 1));
      else
        for (let e8 = 0; e8 < p6; e8++)
          y6[e8] = S3[e8 * c8 + s10];
    m6.push(y6);
  }
  const P3 = n12.noData ? n12.noData[0] : t8.noDataValue, b4 = n12.metadata ? n12.metadata.statistics : null, x5 = b4 ? b4.map((e8) => e8.min) : null, L3 = b4 ? b4.map((e8) => e8.max) : null, R3 = { pixelType: u14, width: T3, height: I4, pixels: m6, noDataValue: P3 };
  return null != P3 ? u3(R3, P3) : x5 && L3 && t8.applyMinMaxConstraint && (R3.mask = O(m6, x5, L3)), R3;
}
async function Y(e7, t8 = {}) {
  const n12 = t8.pyramidLevel || 0, a13 = t8.headerInfo || k(e7), { ifds: i9, noData: r13 } = a13;
  if (0 === i9.length)
    throw new Error("no valid image file directory");
  const l5 = V(a13);
  if (l5)
    throw l5;
  let o10 = null;
  const f10 = -1 === n12 ? i9[i9.length - 1] : i9[n12], u14 = r13 ?? t8.noDataValue;
  return o10 = a13.tileWidth ? await P(e7, a13, f10) : b(e7, a13, f10), o10 ? (null != u14 && u3(o10, u14), o10) : o10;
}

// node_modules/@arcgis/core/layers/support/rasterFormats/RasterCodec.js
var f7 = function(t8) {
  var e7, a13, i9, s10, r13, n12;
  function o10(t9) {
    var e8, a14, i10, s11, r14, n13, o11, h7, c8, l5, p6, d4, u14;
    for (this.data = t9, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, r14 = null; ; ) {
      switch (e8 = this.readUInt32(), h7 = (function() {
        var t10, e9;
        for (e9 = [], t10 = 0; t10 < 4; ++t10)
          e9.push(String.fromCharCode(this.data[this.pos++]));
        return e9;
      }).call(this).join(""), h7) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(e8);
          break;
        case "fcTL":
          r14 && this.animation.frames.push(r14), this.pos += 4, r14 = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, s11 = this.readUInt16(), i10 = this.readUInt16() || 100, r14.delay = 1e3 * s11 / i10, r14.disposeOp = this.data[this.pos++], r14.blendOp = this.data[this.pos++], r14.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for ("fdAT" === h7 && (this.pos += 4, e8 -= 4), t9 = (null != r14 ? r14.data : void 0) || this.imgData, p6 = 0; 0 <= e8 ? p6 < e8 : p6 > e8; 0 <= e8 ? ++p6 : --p6)
            t9.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (this.transparency.indexed = this.read(e8), (c8 = 255 - this.transparency.indexed.length) > 0)
                for (d4 = 0; 0 <= c8 ? d4 < c8 : d4 > c8; 0 <= c8 ? ++d4 : --d4)
                  this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(e8)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(e8);
          }
          break;
        case "tEXt":
          n13 = (l5 = this.read(e8)).indexOf(0), o11 = String.fromCharCode.apply(String, l5.slice(0, n13)), this.text[o11] = String.fromCharCode.apply(String, l5.slice(n13 + 1));
          break;
        case "IEND":
          return r14 && this.animation.frames.push(r14), this.colors = (function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }).call(this), this.hasAlphaChannel = 4 === (u14 = this.colorType) || 6 === u14, a14 = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * a14, this.colorSpace = (function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }).call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += e8;
      }
      if (this.pos += 4, this.pos > this.data.length)
        throw new Error("Incomplete or corrupt PNG file");
    }
  }
  return o10.load = function(t9, e8, a14) {
    var i10;
    return "function" == typeof e8 && (a14 = e8), (i10 = new XMLHttpRequest()).open("GET", t9, true), i10.responseType = "arraybuffer", i10.onload = function() {
      var t10;
      return t10 = new o10(new Uint8Array(i10.response || i10.mozResponseArrayBuffer)), "function" == typeof (null != e8 ? e8.getContext : void 0) && t10.render(e8), "function" == typeof a14 ? a14(t10) : void 0;
    }, i10.send(null);
  }, a13 = 1, i9 = 2, e7 = 0, o10.prototype.read = function(t9) {
    var e8, a14;
    for (a14 = [], e8 = 0; 0 <= t9 ? e8 < t9 : e8 > t9; 0 <= t9 ? ++e8 : --e8)
      a14.push(this.data[this.pos++]);
    return a14;
  }, o10.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, o10.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, o10.prototype.decodePixels = function(t9) {
    var e8, a14, i10, s11, r14, n13, o11, h7, l5, p6, d4, u14, f10, m6, g5, w4, y6, b4, x5, k4, T3, I4, C5;
    if (null == t9 && (t9 = this.imgData), 0 === t9.length)
      return new Uint8Array(0);
    for (t9 = (t9 = new f4(t9)).getBytes(), w4 = (u14 = this.pixelBitlength / 8) * this.width, f10 = new Uint8Array(w4 * this.height), n13 = t9.length, g5 = 0, m6 = 0, a14 = 0; m6 < n13; ) {
      switch (t9[m6++]) {
        case 0:
          for (s11 = x5 = 0; x5 < w4; s11 = x5 += 1)
            f10[a14++] = t9[m6++];
          break;
        case 1:
          for (s11 = k4 = 0; k4 < w4; s11 = k4 += 1)
            e8 = t9[m6++], r14 = s11 < u14 ? 0 : f10[a14 - u14], f10[a14++] = (e8 + r14) % 256;
          break;
        case 2:
          for (s11 = T3 = 0; T3 < w4; s11 = T3 += 1)
            e8 = t9[m6++], i10 = (s11 - s11 % u14) / u14, y6 = g5 && f10[(g5 - 1) * w4 + i10 * u14 + s11 % u14], f10[a14++] = (y6 + e8) % 256;
          break;
        case 3:
          for (s11 = I4 = 0; I4 < w4; s11 = I4 += 1)
            e8 = t9[m6++], i10 = (s11 - s11 % u14) / u14, r14 = s11 < u14 ? 0 : f10[a14 - u14], y6 = g5 && f10[(g5 - 1) * w4 + i10 * u14 + s11 % u14], f10[a14++] = (e8 + Math.floor((r14 + y6) / 2)) % 256;
          break;
        case 4:
          for (s11 = C5 = 0; C5 < w4; s11 = C5 += 1)
            e8 = t9[m6++], i10 = (s11 - s11 % u14) / u14, r14 = s11 < u14 ? 0 : f10[a14 - u14], 0 === g5 ? y6 = b4 = 0 : (y6 = f10[(g5 - 1) * w4 + i10 * u14 + s11 % u14], b4 = i10 && f10[(g5 - 1) * w4 + (i10 - 1) * u14 + s11 % u14]), o11 = r14 + y6 - b4, h7 = Math.abs(o11 - r14), p6 = Math.abs(o11 - y6), d4 = Math.abs(o11 - b4), l5 = h7 <= p6 && h7 <= d4 ? r14 : p6 <= d4 ? y6 : b4, f10[a14++] = (e8 + l5) % 256;
          break;
        default:
          throw new Error("Invalid filter algorithm: " + t9[m6 - 1]);
      }
      g5++;
    }
    return f10;
  }, o10.prototype.decodePalette = function() {
    var t9, e8, a14, i10, s11, r14, n13, o11, h7;
    for (a14 = this.palette, r14 = this.transparency.indexed || [], s11 = new Uint8Array((r14.length || 0) + a14.length), i10 = 0, a14.length, t9 = 0, e8 = n13 = 0, o11 = a14.length; n13 < o11; e8 = n13 += 3)
      s11[i10++] = a14[e8], s11[i10++] = a14[e8 + 1], s11[i10++] = a14[e8 + 2], s11[i10++] = null != (h7 = r14[t9++]) ? h7 : 255;
    return s11;
  }, o10.prototype.copyToImageData = function(t9, e8) {
    var a14, i10, s11, r14, n13, o11, h7, c8, l5, p6, d4;
    if (i10 = this.colors, l5 = null, a14 = this.hasAlphaChannel, this.palette.length && (l5 = null != (d4 = this._decodedPalette) ? d4 : this._decodedPalette = this.decodePalette(), i10 = 4, a14 = true), c8 = (s11 = t9.data || t9).length, n13 = l5 || e8, r14 = o11 = 0, 1 === i10)
      for (; r14 < c8; )
        h7 = l5 ? 4 * e8[r14 / 4] : o11, p6 = n13[h7++], s11[r14++] = p6, s11[r14++] = p6, s11[r14++] = p6, s11[r14++] = a14 ? n13[h7++] : this.transparency.grayscale && this.transparency.grayscale === p6 ? 0 : 255, o11 = h7;
    else
      for (; r14 < c8; )
        h7 = l5 ? 4 * e8[r14 / 4] : o11, s11[r14++] = n13[h7++], s11[r14++] = n13[h7++], s11[r14++] = n13[h7++], s11[r14++] = a14 ? n13[h7++] : this.transparency.rgb && this.transparency.rgb[1] === n13[h7 - 3] && this.transparency.rgb[3] === n13[h7 - 2] && this.transparency.rgb[5] === n13[h7 - 1] ? 0 : 255, o11 = h7;
  }, o10.prototype.decode = function() {
    var t9;
    return t9 = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t9, this.decodePixels()), t9;
  }, r13 = t8.document && t8.document.createElement("canvas"), n12 = r13 && r13.getContext("2d"), s10 = function(t9) {
    var e8;
    return n12.width = t9.width, n12.height = t9.height, n12.clearRect(0, 0, t9.width, t9.height), n12.putImageData(t9, 0, 0), (e8 = new Image()).src = r13.toDataURL(), e8;
  }, o10.prototype.decodeFrames = function(t9) {
    var e8, a14, i10, r14, n13, o11, h7, c8;
    if (this.animation) {
      for (c8 = [], a14 = n13 = 0, o11 = (h7 = this.animation.frames).length; n13 < o11; a14 = ++n13)
        e8 = h7[a14], i10 = t9.createImageData(e8.width, e8.height), r14 = this.decodePixels(new Uint8Array(e8.data)), this.copyToImageData(i10, r14), e8.imageData = i10, c8.push(e8.image = s10(i10));
      return c8;
    }
  }, o10.prototype.renderFrame = function(t9, s11) {
    var r14, n13, o11;
    return r14 = (n13 = this.animation.frames)[s11], o11 = n13[s11 - 1], 0 === s11 && t9.clearRect(0, 0, this.width, this.height), (null != o11 ? o11.disposeOp : void 0) === a13 ? t9.clearRect(o11.xOffset, o11.yOffset, o11.width, o11.height) : (null != o11 ? o11.disposeOp : void 0) === i9 && t9.putImageData(o11.imageData, o11.xOffset, o11.yOffset), r14.blendOp === e7 && t9.clearRect(r14.xOffset, r14.yOffset, r14.width, r14.height), t9.drawImage(r14.image, r14.xOffset, r14.yOffset);
  }, o10.prototype.animate = function(t9) {
    var e8, a14, i10, s11, r14, n13, o11 = this;
    return a14 = 0, n13 = this.animation, s11 = n13.numFrames, i10 = n13.frames, r14 = n13.numPlays, (e8 = function() {
      var n14, h7;
      if (n14 = a14++ % s11, h7 = i10[n14], o11.renderFrame(t9, n14), s11 > 1 && a14 / s11 < r14)
        return o11.animation._timeout = setTimeout(e8, h7.delay);
    })();
  }, o10.prototype.stopAnimation = function() {
    var t9;
    return clearTimeout(null != (t9 = this.animation) ? t9._timeout : void 0);
  }, o10.prototype.render = function(t9) {
    var e8, a14;
    return t9._png && t9._png.stopAnimation(), t9._png = this, t9.width = this.width, t9.height = this.height, e8 = t9.getContext("2d"), this.animation ? (this.decodeFrames(e8), this.animate(e8)) : (a14 = e8.createImageData(this.width, this.height), this.copyToImageData(a14, this.decodePixels()), e8.putImageData(a14, 0, 0));
  }, o10;
}(self);
var m2 = /* @__PURE__ */ new Set(["jpg", "png", "bmp", "gif"]);
async function g2(e7, i9) {
  if (!r9)
    throw new s2("rasterCoded:decode", "lerc decoder is not supported on big endian platform");
  await a6();
  const { offset: s10 } = i9, { width: o10, height: h7, pixelType: c8, statistics: l5, depthCount: p6, noDataValues: d4, bandMasks: f10, pixels: m6, mask: g5 } = c3(e7, { inputOffset: s10, returnInterleaved: i9.returnInterleaved }), w4 = new u4({ width: o10, height: h7, pixelType: c8.toLowerCase(), pixels: m6, mask: g5, statistics: l5, bandMasks: f10, depthCount: p6, noDataValues: d4 });
  return (l5 == null ? void 0 : l5.length) || w4.updateStatistics(), w4;
}
async function w2(t8, i9) {
  const s10 = await Y(t8, { ...i9, noDataValue: null });
  n(s10);
  const r13 = new u4({ width: s10.width, height: s10.height, pixels: s10.pixels, pixelType: s10.pixelType.toLowerCase(), mask: s10.mask, bandMasks: s10.bandMasks, statistics: null });
  return r13.updateStatistics(), r13;
}
async function y4(t8, e7) {
  const i9 = await H(t8, e7.customOptions), s10 = new u4({ width: i9.width, height: i9.height, pixels: i9.pixels, pixelType: i9.pixelType.toLowerCase(), mask: i9.mask, statistics: null });
  return s10.updateStatistics(), s10;
}
function b2(t8, e7) {
  const i9 = e7.pixelType || "u8", s10 = u4.getPixelArrayConstructor(i9), r13 = "u8" === i9 ? t8 : new s10(t8.buffer), n12 = [], o10 = e7.planes || 1;
  if (1 === o10)
    n12.push(r13);
  else
    for (let a13 = 0; a13 < o10; a13++) {
      const i10 = (e7.width || 1) * (e7.height || t8.length), h8 = new s10(i10);
      for (let t9 = 0; t9 < i10; t9++)
        h8[t9] = r13[t9 * o10 + a13];
      n12.push(h8);
    }
  const h7 = new u4({ width: e7.width || 1, height: e7.height || t8.length, pixels: n12, pixelType: i9, statistics: null });
  return h7.updateStatistics(), h7;
}
function x3(t8, e7) {
  return b2(new f4(new Uint8Array(t8)).getBytes(), e7);
}
function k2(t8, e7) {
  return b2(i4(t8, e7.offset, e7.eof, !e7.isInputBigEndian), e7);
}
function T2(t8, e7, i9) {
  const { pixelTypeCtor: s10 } = D2(e7.pixelType), r13 = (0, a7.decode)(t8, { width: e7.width, height: e7.height, pixelType: s10, format: i9 }), n12 = new u4({ width: e7.width, height: e7.height, pixels: r13.pixels, pixelType: e7.pixelType, mask: r13.mask, statistics: null });
  return n12.updateStatistics(), n12;
}
function I2(t8, e7) {
  const i9 = r4.decode(t8, e7.hasNoZlibMask ?? void 0), r13 = new u4({ width: i9.width, height: i9.height, pixels: i9.pixels, pixelType: "U8", mask: i9.mask, statistics: null });
  return r13.updateStatistics(), r13;
}
function C2(t8, e7) {
  const i9 = new Uint8Array(t8), s10 = new f7(i9), { width: r13, height: n12 } = e7, o10 = r13 * n12, h7 = s10.decode();
  let c8, l5 = 0, p6 = 0;
  const d4 = new Uint8Array(o10);
  for (l5 = 0; l5 < o10; l5++)
    d4[l5] = h7[4 * l5 + 3];
  const u14 = new u4({ width: r13, height: n12, pixels: [], pixelType: "U8", mask: d4, statistics: [] });
  for (l5 = 0; l5 < 3; l5++) {
    for (c8 = new Uint8Array(o10), p6 = 0; p6 < o10; p6++)
      c8[p6] = h7[4 * p6 + l5];
    u14.addData({ pixels: c8 });
  }
  return u14.updateStatistics(), u14;
}
async function v2(t8, e7, s10, r13) {
  const n12 = new i2(), o10 = { applyJpegMask: false, format: e7, ...s10 }, h7 = await n12.decode(t8, o10, r13), c8 = new u4(h7);
  return c8.updateStatistics(), c8;
}
function U2(e7) {
  if (null == e7)
    throw new s2("rasterCodec:decode", "parameter encodeddata is required.");
  const a13 = new Uint8Array(e7, 0, 10);
  let i9 = "";
  return 255 === a13[0] && 216 === a13[1] ? i9 = "jpg" : 137 === a13[0] && 80 === a13[1] && 78 === a13[2] && 71 === a13[3] ? i9 = "png" : 67 === a13[0] && 110 === a13[1] && 116 === a13[2] && 90 === a13[3] && 73 === a13[4] && 109 === a13[5] && 97 === a13[6] && 103 === a13[7] && 101 === a13[8] && 32 === a13[9] ? i9 = "lerc" : 76 === a13[0] && 101 === a13[1] && 114 === a13[2] && 99 === a13[3] && 50 === a13[4] && 32 === a13[5] ? i9 = "lerc2" : 73 === a13[0] && 73 === a13[1] && 42 === a13[2] && 0 === a13[3] || 77 === a13[0] && 77 === a13[1] && 0 === a13[2] && 42 === a13[3] || 73 === a13[0] && 73 === a13[1] && 43 === a13[2] && 0 === a13[3] || 77 === a13[0] && 77 === a13[1] && 0 === a13[2] && 43 === a13[3] ? i9 = "tiff" : 71 === a13[0] && 73 === a13[1] && 70 === a13[2] ? i9 = "gif" : 66 === a13[0] && 77 === a13[1] ? i9 = "bmp" : String.fromCharCode.apply(null, a13).toLowerCase().includes("error") && (i9 = "error"), i9;
}
function A3(e7) {
  let a13 = null;
  switch (e7) {
    case "lerc":
    case "lerc2":
      a13 = g2;
      break;
    case "jpg":
      a13 = I2;
      break;
    case "png":
      a13 = C2;
      break;
    case "bsq":
    case "bip":
      a13 = (t8, a14) => T2(t8, a14, e7);
      break;
    case "tiff":
      a13 = w2;
      break;
    case "deflate":
      a13 = x3;
      break;
    case "lzw":
      a13 = k2;
      break;
    case "error":
      a13 = () => {
        throw new s2("rasterCodec:decode", "input data contains error");
      };
      break;
    default:
      a13 = () => {
        throw new s2("rasterCodec:decode", "unsupported raster format");
      };
  }
  return a13;
}
function D2(t8) {
  let e7 = null, a13 = null;
  switch (t8 ? t8.toLowerCase() : "f32") {
    case "u1":
    case "u2":
    case "u4":
    case "u8":
      a13 = 255, e7 = Uint8Array;
      break;
    case "u16":
      a13 = a13 || 65535, e7 = Uint16Array;
      break;
    case "u32":
      a13 = a13 || 2 ** 32 - 1, e7 = Uint32Array;
      break;
    case "s8":
      a13 = a13 || -128, e7 = Int8Array;
      break;
    case "s16":
      a13 = a13 || -32768, e7 = Int16Array;
      break;
    case "s32":
      a13 = a13 || 0 - 2 ** 31, e7 = Int32Array;
      break;
    default:
      e7 = Float32Array;
  }
  return { pixelTypeCtor: e7, noDataValue: a13 };
}
function O2(t8, e7 = 1) {
  if (!t8)
    return;
  const { pixels: i9, width: s10, height: r13, mask: n12 } = t8;
  if (!i9 || 0 === i9.length)
    return;
  const o10 = i9.length, h7 = s10 - 1, c8 = r13 - 1, l5 = [];
  let p6, d4, u14, f10, m6, g5, w4 = null;
  const y6 = u4.getPixelArrayConstructor(t8.pixelType);
  if (0 === e7) {
    for (p6 = 0; p6 < o10; p6++) {
      for (m6 = i9[p6], g5 = new y6(h7 * c8), d4 = 0; d4 < c8; d4++)
        for (f10 = d4 * s10, u14 = 0; u14 < h7; u14++)
          g5[d4 * h7 + u14] = m6[f10 + u14];
      l5.push(g5);
    }
    if (null != n12)
      for (w4 = new Uint8Array(h7 * c8), d4 = 0; d4 < c8; d4++)
        for (f10 = d4 * s10, u14 = 0; u14 < h7; u14++)
          w4[d4 * h7 + u14] = n12[f10 + u14];
  } else {
    for (p6 = 0; p6 < o10; p6++) {
      for (m6 = i9[p6], g5 = new y6(h7 * c8), d4 = 0; d4 < c8; d4++)
        for (f10 = d4 * s10, u14 = 0; u14 < h7; u14++)
          g5[d4 * h7 + u14] = (m6[f10 + u14] + m6[f10 + u14 + 1] + m6[f10 + s10 + u14] + m6[f10 + s10 + u14 + 1]) / 4;
      l5.push(g5);
    }
    if (n12)
      for (w4 = new Uint8Array(h7 * c8), d4 = 0; d4 < c8; d4++)
        for (f10 = d4 * s10, u14 = 0; u14 < h7; u14++)
          w4[d4 * h7 + u14] = Math.min.apply(null, [n12[f10 + u14], n12[f10 + u14 + 1], n12[f10 + s10 + u14], n12[f10 + s10 + u14 + 1]]);
  }
  t8.width = h7, t8.height = c8, t8.mask = w4, t8.pixels = l5;
}
function P2(t8) {
  let e7 = U2(t8);
  return "lerc2" === e7 ? e7 = "lerc" : "error" === e7 && (e7 = ""), e7;
}
async function j2(e7, a13 = {}, i9) {
  var _a;
  if (null == e7)
    throw new s2("rasterCodec:decode", "missing encodeddata parameter.");
  let s10 = (_a = a13.format) == null ? void 0 : _a.toLowerCase();
  if (!("bsq" !== s10 && "bip" !== s10 || null != a13.width && null != a13.height))
    throw new s2("rasterCodec:decode", "requires width and height in options parameter.");
  if ("tiff" === s10 && a13.customOptions)
    return y4(e7, a13);
  if ((!s10 || "bsq" !== s10 && "bip" !== s10 && "deflate" !== s10 && "lzw" !== s10) && (s10 = U2(e7)), a13.useCanvas && m2.has(s10))
    return v2(e7, s10, a13, i9);
  const r13 = A3(s10);
  a13.isPoint && (null != (a13 = { ...a13 }).width && a13.width++, null != a13.height && a13.height++);
  const n12 = await r13(e7, a13);
  return n12 ? ("jpg" !== s10 && null != a13.noDataValue && 1 === n12.depthCount && u3(n12, a13.noDataValue, { customFloatTolerance: a13.tolerance }), a13.isPoint && O2(n12), n12) : n12;
}

// node_modules/@arcgis/core/renderers/support/stretchRendererUtils.js
var n6 = new s3({ none: "none", standardDeviation: "standard-deviation", histogramEqualization: "histogram-equalization", minMax: "min-max", percentClip: "percent-clip", sigmoid: "sigmoid" });
var a8 = { 0: "none", 3: "standardDeviation", 4: "histogramEqualization", 5: "minMax", 6: "percentClip", 9: "sigmoid" };

// node_modules/@arcgis/core/layers/support/rasterFunctions/stretchUtils.js
var i6 = 1;
var o6 = [0.299, 0.587, 0.114];
function r10(t8, n12 = 256) {
  n12 = Math.min(n12, 256);
  const { size: s10, counts: e7 } = t8, i9 = new Uint8Array(s10), o10 = e7.reduce((t9, s11) => t9 + s11 / n12, 0);
  let r13 = 0, a13 = 0, l5 = 0, f10 = o10;
  for (let u14 = 0; u14 < s10; u14++)
    if (l5 += e7[u14], !(u14 < s10 - 1 && l5 + e7[u14 + 1] < f10)) {
      for (; r13 < n12 - 1 && f10 < l5; )
        r13++, f10 += o10;
      for (let t9 = a13; t9 <= u14; t9++)
        i9[t9] = r13;
      a13 = u14 + 1;
    }
  for (let u14 = a13; u14 < s10; u14++)
    i9[u14] = n12 - 1;
  return i9;
}
function a9(t8) {
  const { minCutOff: n12, maxCutOff: s10, gamma: e7, pixelType: i9, rounding: o10 } = t8, r13 = t8.outMin || 0, a13 = t8.outMax || 255;
  if (!["u8", "u16", "s8", "s16"].includes(i9))
    return null;
  const f10 = n12.length;
  let u14, c8, m6 = 0;
  "s8" === i9 ? m6 = -127 : "s16" === i9 && (m6 = -32767);
  let h7 = 256;
  ["u16", "s16"].includes(i9) && (h7 = 65536);
  const g5 = [], p6 = [], d4 = a13 - r13;
  for (u14 = 0; u14 < f10; u14++)
    p6[u14] = s10[u14] - n12[u14], g5[u14] = 0 === p6[u14] ? 0 : d4 / p6[u14];
  let M4;
  const y6 = [];
  let b4, k4, v4;
  if (e7 && e7.length >= f10) {
    const t9 = x4(f10, e7);
    for (u14 = 0; u14 < f10; u14++) {
      for (v4 = [], c8 = 0; c8 < h7; c8++)
        if (0 !== p6[u14])
          if (b4 = c8 + m6, M4 = (b4 - n12[u14]) / p6[u14], k4 = 1, e7[u14] > 1 && (k4 -= (1 / d4) ** (M4 * t9[u14])), b4 < s10[u14] && b4 > n12[u14]) {
            const t10 = k4 * d4 * M4 ** (1 / e7[u14]) + r13;
            v4[c8] = "floor" === o10 ? Math.floor(t10) : "round" === o10 ? Math.round(t10) : t10;
          } else
            b4 >= s10[u14] ? v4[c8] = a13 : v4[c8] = r13;
        else
          v4[c8] = r13;
      y6[u14] = v4;
    }
  } else
    for (u14 = 0; u14 < f10; u14++) {
      for (v4 = [], c8 = 0; c8 < h7; c8++)
        if (b4 = c8 + m6, b4 <= n12[u14])
          v4[c8] = r13;
        else if (b4 >= s10[u14])
          v4[c8] = a13;
        else {
          const t9 = (b4 - n12[u14]) * g5[u14] + r13;
          v4[c8] = "floor" === o10 ? Math.floor(t9) : "round" === o10 ? Math.round(t9) : t9;
        }
      y6[u14] = v4;
    }
  if (null != t8.contrastOffset) {
    const n13 = l2(t8.contrastOffset, t8.brightnessOffset);
    for (u14 = 0; u14 < f10; u14++)
      for (v4 = y6[u14], c8 = 0; c8 < h7; c8++)
        v4[c8] = n13[v4[c8]];
  }
  return { lut: y6, offset: m6 };
}
function l2(t8, n12) {
  const s10 = Math.min(Math.max(t8, -100), 100), e7 = Math.min(Math.max(n12 ?? 0, -100), 100), i9 = 255, o10 = 128;
  let r13 = 0, a13 = 0;
  const l5 = new Uint8Array(256);
  for (r13 = 0; r13 < 256; r13++)
    s10 > 0 && s10 < 100 ? a13 = (200 * r13 - 100 * i9 + 2 * i9 * e7) / (2 * (100 - s10)) + o10 : s10 <= 0 && s10 > -100 ? a13 = (200 * r13 - 100 * i9 + 2 * i9 * e7) * (100 + s10) / 2e4 + o10 : 100 === s10 ? (a13 = 200 * r13 - 100 * i9 + (i9 + 1) * (100 - s10) + 2 * i9 * e7, a13 = a13 > 0 ? i9 : 0) : -100 === s10 && (a13 = o10), l5[r13] = a13 > i9 ? i9 : a13 < 0 ? 0 : a13;
  return l5;
}
function f8(t8, n12, s10) {
  const e7 = [];
  for (let i9 = 0; i9 < n12.length; i9++) {
    let r13 = 0, a13 = 0, l5 = 0;
    "min" in n12[i9] ? { min: r13, max: a13, avg: l5 } = n12[i9] : [r13, a13, l5] = n12[i9];
    let f10 = l5 ?? 0;
    "u8" !== t8 && (f10 = 255 * (f10 - r13) / (a13 - r13)), s10 && (f10 *= o6[i9]), e7.push(u8(f10));
  }
  return e7;
}
function u8(t8) {
  if (t8 <= 0 || t8 >= 255)
    return i6;
  let n12 = 0;
  150 !== t8 && (n12 = t8 <= 150 ? 45 * Math.cos(0.01047 * t8) : 17 * Math.sin(0.021 * t8));
  const s10 = 255, e7 = t8 + n12, o10 = Math.log(t8 / s10), r13 = Math.log(e7 / s10);
  if (0 === r13)
    return i6;
  const a13 = o10 / r13;
  return isNaN(a13) ? i6 : Math.min(9.9, Math.max(0.01, a13));
}
function c5(t8, n12, s10, e7) {
  let i9 = 1 / 0, o10 = -1 / 0, r13 = 0, a13 = 0, l5 = 0, f10 = 0;
  const u14 = t8.length, c8 = /* @__PURE__ */ new Map(), m6 = [];
  for (let w4 = 0; w4 < u14; w4++) {
    const s11 = t8[w4];
    if (!n12 || n12[w4]) {
      m6.push(s11);
      const t9 = (c8.get(s11) ?? 0) + 1;
      c8.set(s11, t9), t9 > f10 && (f10 = t9, l5 = s11), i9 = s11 < i9 ? s11 : i9, o10 = s11 > o10 ? s11 : o10, r13 += s11, a13++;
    }
  }
  if (0 === a13)
    return { statistics: { min: 0, max: 0, avg: 0, stddev: 0, mode: 0, median: 0 }, histogram: null };
  const h7 = r13 / a13;
  let g5 = 0;
  for (let w4 = 0; w4 < u14; w4++)
    n12 && !n12[w4] || (g5 += (t8[w4] - h7) ** 2);
  const p6 = n12 ? n12.filter((t9) => t9).length : u14, d4 = p6 <= 1 ? 0 : Math.sqrt(g5 / (p6 - 1));
  m6.sort((t9, n13) => t9 - n13);
  const x5 = a13 >>> 1, M4 = { min: i9, max: o10, avg: h7, stddev: d4, mode: l5, median: a13 % 2 ? m6[Math.floor(x5)] : (m6[x5 - 1] + m6[x5]) / 2 };
  if (!e7)
    return { statistics: M4, histogram: null };
  if (["u8", "s8", "u4", "u2", "u1"].includes(s10)) {
    const s11 = o10 - i9 + 1, e8 = new Uint32Array(s11);
    for (let o11 = 0; o11 < u14; o11++)
      n12 && !n12[o11] || e8[t8[o11] - i9]++;
    return { statistics: M4, histogram: { min: i9 - 0.5, max: o10 + 0.5, size: s11, counts: e8 } };
  }
  const y6 = 256, b4 = new Uint32Array(y6), k4 = (o10 - i9) / y6;
  if (0 === k4)
    return { statistics: M4, histogram: { min: i9, max: o10, size: 1, counts: new Uint32Array(1).fill(a13) } };
  const v4 = new Uint32Array(y6 + 1);
  for (let w4 = 0; w4 < u14; w4++)
    n12 && !n12[w4] || v4[Math.floor((t8[w4] - i9) / k4)]++;
  for (let w4 = 0; w4 < y6 - 1; w4++)
    b4[w4] = v4[w4];
  return b4[y6 - 1] = v4[y6 - 1] + v4[y6], { statistics: M4, histogram: { min: i9, max: o10, size: y6, counts: b4 } };
}
function m3(t8) {
  const { pixels: n12, mask: s10, pixelType: e7, bandMasks: i9 } = t8, o10 = n12.map((t9, n13) => c5(t9, (i9 == null ? void 0 : i9[n13]) ?? s10, e7, true));
  return { statistics: o10.map(({ statistics: t9 }) => t9), histograms: o10.map(({ histogram: t9 }) => t9) };
}
function h3(t8) {
  var _a;
  if (!((_a = t8 == null ? void 0 : t8.pixels) == null ? void 0 : _a.length))
    return null;
  const { pixels: n12, mask: s10, bandMasks: e7, pixelType: i9 } = t8, o10 = t8.width * t8.height, r13 = n12.length;
  let a13, l5, f10, u14, c8;
  const m6 = [], h7 = [];
  let g5, p6, d4, x5, M4, y6, b4, k4, v4, w4;
  const z2 = 256;
  for (u14 = 0; u14 < r13; u14++) {
    g5 = new Uint32Array(z2), d4 = n12[u14];
    const r14 = (e7 == null ? void 0 : e7[u14]) ?? s10;
    if ("u8" === i9)
      if (a13 = -0.5, l5 = 255.5, r14)
        for (c8 = 0; c8 < o10; c8++)
          r14[c8] && g5[d4[c8]]++;
      else
        for (c8 = 0; c8 < o10; c8++)
          g5[d4[c8]]++;
    else {
      let n13 = false;
      t8.statistics || (t8.updateStatistics(), n13 = true);
      const s11 = t8.statistics;
      if (a13 = s11[u14].minValue, l5 = s11[u14].maxValue, f10 = (l5 - a13) / z2, 0 === f10) {
        !s11 || t8.validPixelCount || n13 || t8.updateStatistics();
        const e8 = (t8.validPixelCount || t8.width * t8.height) / z2;
        for (let t9 = 0; t9 < z2; t9++)
          g5[t9] = Math.round(e8 * (t9 + 1)) - Math.round(e8 * t9);
      } else {
        for (p6 = new Uint32Array(z2 + 1), c8 = 0; c8 < o10; c8++)
          r14 && !r14[c8] || p6[Math.floor((d4[c8] - a13) / f10)]++;
        for (c8 = 0; c8 < z2 - 1; c8++)
          g5[c8] = p6[c8];
        g5[z2 - 1] = p6[z2 - 1] + p6[z2];
      }
    }
    for (m6.push({ min: a13, max: l5, size: z2, counts: g5 }), x5 = 0, M4 = 0, k4 = 0, c8 = 0; c8 < z2; c8++)
      x5 += g5[c8], M4 += c8 * g5[c8];
    for (v4 = M4 / x5, c8 = 0; c8 < z2; c8++)
      k4 += g5[c8] * (c8 - v4) ** 2;
    w4 = Math.sqrt(k4 / (x5 - 1)), f10 = (l5 - a13) / z2, y6 = (v4 + 0.5) * f10 + a13, b4 = w4 * f10, h7.push({ min: a13, max: l5, avg: y6, stddev: b4 });
  }
  return { statistics: h7, histograms: m6 };
}
function g3(t8) {
  const n12 = [];
  for (let s10 = 0; s10 < t8.length; s10++) {
    const { min: e7, max: i9, size: o10, counts: r13 } = t8[s10];
    let a13 = 0, l5 = 0;
    for (let t9 = 0; t9 < o10; t9++)
      a13 += r13[t9], l5 += t9 * r13[t9];
    const f10 = l5 / a13;
    let u14 = 0;
    for (let t9 = 0; t9 < o10; t9++)
      u14 += r13[t9] * (t9 - f10) ** 2;
    const c8 = (i9 - e7) / o10, m6 = (f10 + 0.5) * c8 + e7, h7 = Math.sqrt(u14 / (a13 - 1)) * c8;
    n12.push({ min: e7, max: i9, avg: m6, stddev: h7 });
  }
  return n12;
}
function p2(n12, i9) {
  var _a;
  const { pixelBlock: o10, bandIds: a13, returnHistogramLut: l5, rasterInfo: f10 } = i9;
  let u14 = null, c8 = null, m6 = n12.stretchType;
  if ("number" == typeof m6 && (m6 = a8[m6]), n12.dra)
    if ("minMax" === m6 && (o10 == null ? void 0 : o10.statistics))
      u14 = o10.statistics.map((t8) => [t8.minValue, t8.maxValue, 0, 0]);
    else {
      const t8 = h3(o10);
      u14 = null != t8 ? t8.statistics : null, c8 = null != t8 ? t8.histograms : null;
    }
  else
    u14 = ((_a = n12.statistics) == null ? void 0 : _a.length) ? n12.statistics : f10.statistics, c8 = "histograms" in n12 ? n12.histograms : void 0, c8 || (c8 = f10.histograms);
  "percentClip" !== m6 && "histogramEqualization" !== m6 || (c8 == null ? void 0 : c8.length) || (m6 = "minMax");
  const g5 = (u14 == null ? void 0 : u14.length) || (c8 == null ? void 0 : c8.length) || f10.bandCount, p6 = [], x5 = [];
  let M4, y6, b4, k4, v4, w4, z2, C5, O3;
  u14 && !Array.isArray(u14[0]) && (u14 = u14.map((t8) => [t8.min, t8.max, t8.avg, t8.stddev]));
  const [A5, U3] = s4(f10.pixelType);
  if (!(u14 == null ? void 0 : u14.length)) {
    for (u14 = [], C5 = 0; C5 < g5; C5++)
      u14.push([A5, U3, 1, 1]);
    "standardDeviation" === m6 && (m6 = "minMax");
  }
  switch (m6) {
    case "none":
      for (C5 = 0; C5 < g5; C5++)
        p6[C5] = A5, x5[C5] = U3;
      break;
    case "minMax":
      for (C5 = 0; C5 < g5; C5++) {
        const t8 = u14[C5];
        p6[C5] = t8[0], x5[C5] = t8[1];
      }
      break;
    case "standardDeviation":
      {
        const { numberOfStandardDeviations: t8 = 2 } = n12;
        for (C5 = 0; C5 < g5; C5++) {
          const n13 = u14[C5];
          p6[C5] = n13[2] - t8 * n13[3], x5[C5] = n13[2] + t8 * n13[3], p6[C5] < n13[0] && (p6[C5] = n13[0]), x5[C5] > n13[1] && (x5[C5] = n13[1]);
        }
      }
      break;
    case "histogramEqualization":
      for (n(c8), C5 = 0; C5 < g5; C5++)
        p6[C5] = c8[C5].min, x5[C5] = c8[C5].max;
      break;
    case "percentClip":
      for (n(c8), C5 = 0; C5 < c8.length; C5++) {
        for (M4 = c8[C5], v4 = new Uint32Array(M4.size), k4 = [...M4.counts], k4.length >= 20 && (k4[0] = k4[1] = k4[2] = k4[k4.length - 1] = k4[k4.length - 2] = 0), b4 = 0, y6 = (M4.max - M4.min) / M4.size, z2 = -0.5 === M4.min && 1 === y6 ? 0.5 : 0, O3 = 0; O3 < M4.size; O3++)
          b4 += k4[O3], v4[O3] = b4;
        for (w4 = (n12.minPercent || 0) * b4 / 100, p6[C5] = M4.min + z2, O3 = 0; O3 < M4.size; O3++)
          if (v4[O3] > w4) {
            p6[C5] = M4.min + y6 * (O3 + z2);
            break;
          }
        for (w4 = (1 - (n12.maxPercent || 0) / 100) * b4, x5[C5] = M4.max + z2, O3 = M4.size - 2; O3 >= 0; O3--)
          if (v4[O3] < w4) {
            x5[C5] = M4.min + y6 * (O3 + 2 - z2);
            break;
          }
        if (x5[C5] < p6[C5]) {
          const t8 = p6[C5];
          p6[C5] = x5[C5], x5[C5] = t8;
        }
      }
      break;
    default:
      for (C5 = 0; C5 < g5; C5++) {
        const t8 = u14[C5];
        p6[C5] = t8[0], x5[C5] = t8[1];
      }
  }
  let T3, q, P3;
  "histogramEqualization" === m6 ? (n(c8), q = c8[0].size || 256, T3 = 0, l5 && (P3 = c8.map((t8) => r10(t8)))) : (q = n12.max || 255, T3 = n12.min || 0);
  return d2({ minCutOff: p6, maxCutOff: x5, outMax: q, outMin: T3, histogramLut: P3 }, a13);
}
function d2(t8, n12) {
  if (null == n12 || 0 === n12.length)
    return t8;
  const s10 = Math.max.apply(null, n12), { minCutOff: e7, maxCutOff: i9, outMin: o10, outMax: r13, histogramLut: a13 } = t8;
  return e7.length === n12.length || e7.length <= s10 ? t8 : { minCutOff: n12.map((t9) => e7[t9]), maxCutOff: n12.map((t9) => i9[t9]), histogramLut: a13 ? n12.map((t9) => a13[t9]) : null, outMin: o10, outMax: r13 };
}
function x4(t8, n12) {
  const s10 = new Float32Array(t8);
  for (let e7 = 0; e7 < t8; e7++)
    n12[e7] > 1 ? n12[e7] > 2 ? s10[e7] = 6.5 + (n12[e7] - 2) ** 2.5 : s10[e7] = 6.5 + 100 * (2 - n12[e7]) ** 4 : s10[e7] = 1;
  return s10;
}
function M3(t8, s10) {
  var _a;
  if (!((_a = t8 == null ? void 0 : t8.pixels) == null ? void 0 : _a.length))
    return t8;
  const { mask: e7, bandMasks: i9, width: o10, height: r13, pixels: a13 } = t8, { minCutOff: l5, maxCutOff: f10, gamma: u14 } = s10, c8 = s10.outMin || 0, m6 = s10.outMax || 255, h7 = o10 * r13, g5 = s10.outputPixelType || "u8", p6 = t8.pixels.map(() => u4.createEmptyBand(g5, h7)), d4 = p6.length, M4 = m6 - c8, y6 = [], b4 = [];
  for (let n12 = 0; n12 < d4; n12++)
    b4[n12] = f10[n12] - l5[n12], y6[n12] = 0 === b4[n12] ? 0 : M4 / b4[n12];
  const k4 = g5.startsWith("u") || g5.startsWith("s"), v4 = u14 && u14.length >= d4, w4 = !!s10.isRenderer;
  if (v4) {
    const t9 = x4(d4, u14);
    for (let n12 = 0; n12 < d4; n12++) {
      const s11 = (i9 == null ? void 0 : i9[n12]) ?? e7;
      for (let e8 = 0; e8 < h7; e8++)
        if (null == s11 || s11[e8]) {
          if (0 === b4[n12]) {
            p6[n12][e8] = c8;
            continue;
          }
          const s12 = a13[n12][e8], i10 = (s12 - l5[n12]) / b4[n12];
          let o11 = 1;
          if (u14[n12] > 1 && (o11 -= (1 / M4) ** (i10 * t9[n12])), s12 < f10[n12] && s12 > l5[n12]) {
            const t10 = o11 * M4 * i10 ** (1 / u14[n12]) + c8;
            p6[n12][e8] = w4 ? Math.floor(t10) : k4 ? Math.round(t10) : t10;
          } else
            s12 >= f10[n12] ? p6[n12][e8] = m6 : p6[n12][e8] = c8;
        }
    }
  } else
    for (let n12 = 0; n12 < d4; n12++) {
      const t9 = (i9 == null ? void 0 : i9[n12]) ?? e7;
      for (let s11 = 0; s11 < h7; s11++)
        if (null == t9 || t9[s11]) {
          const t10 = a13[n12][s11];
          if (t10 < f10[n12] && t10 > l5[n12]) {
            const e8 = (t10 - l5[n12]) * y6[n12] + c8;
            p6[n12][s11] = w4 ? Math.floor(e8) : k4 ? Math.round(e8) : e8;
          } else
            t10 >= f10[n12] ? p6[n12][s11] = m6 : p6[n12][s11] = c8;
        }
    }
  const z2 = new u4({ width: o10, height: r13, mask: e7, bandMasks: i9, pixels: p6, pixelType: g5 });
  return z2.updateStatistics(), z2;
}

// node_modules/@arcgis/core/layers/support/RasterBandInfo.js
var t6;
function n7(e7) {
  return e7 = Number(e7), isNaN(e7) ? void 0 : e7;
}
var o7 = t6 = class extends f {
  constructor() {
    super(...arguments), this.name = null, this.minWavelength = void 0, this.maxWavelength = void 0, this.radianceBias = void 0, this.radianceGain = void 0, this.reflectanceBias = void 0, this.reflectanceGain = void 0, this.solarIrradiance = void 0;
  }
  clone() {
    return new t6({ name: this.name, minWavelength: this.minWavelength, maxWavelength: this.maxWavelength, radianceBias: this.radianceBias, radianceGain: this.radianceGain, reflectanceBias: this.reflectanceBias, reflectanceGain: this.reflectanceGain, solarIrradiance: this.solarIrradiance });
  }
};
e([y({ json: { name: "BandName", write: true } })], o7.prototype, "name", void 0), e([y({ json: { name: "WavelengthMin", read: { reader: n7 }, write: true } })], o7.prototype, "minWavelength", void 0), e([y({ json: { name: "WavelengthMax", read: { reader: n7 }, write: true } })], o7.prototype, "maxWavelength", void 0), e([y({ json: { name: "RadianceBias", read: { reader: n7 }, write: true } })], o7.prototype, "radianceBias", void 0), e([y({ json: { name: "RadianceGain", read: { reader: n7 }, write: true } })], o7.prototype, "radianceGain", void 0), e([y({ json: { name: "ReflectanceBias", read: { reader: n7 }, write: true } })], o7.prototype, "reflectanceBias", void 0), e([y({ json: { name: "ReflectanceGain", read: { reader: n7 }, write: true } })], o7.prototype, "reflectanceGain", void 0), e([y({ json: { name: "SolarIrradiance", read: { reader: n7 }, write: true } })], o7.prototype, "solarIrradiance", void 0), o7 = t6 = e([c2("esri.layers.support.RasterBandInfo")], o7);
var s7 = o7;

// node_modules/@arcgis/core/layers/support/RasterSensorInfo.js
var a10;
function n8(o10) {
  return o10 = Number(o10), isNaN(o10) ? void 0 : o10;
}
var u9 = a10 = class extends f {
  constructor() {
    super(...arguments), this.acquisitionDate = void 0, this.cloudCover = void 0, this.productName = void 0, this.sensorName = null, this.sensorAzimuth = void 0, this.sensorElevation = void 0, this.sunAzimuth = void 0, this.sunElevation = void 0;
  }
  readAcquisitionDate(o10) {
    return new Date(o10);
  }
  writeAcquisitionDate(o10, e7) {
    e7.AcquisitionDate = o10.getTime();
  }
  clone() {
    return new a10({ acquisitionDate: this.acquisitionDate, cloudCover: this.cloudCover, productName: this.productName, sensorName: this.sensorName, sensorAzimuth: this.sensorAzimuth, sensorElevation: this.sensorElevation, sunAzimuth: this.sunAzimuth, sunElevation: this.sunElevation });
  }
};
e([y({ json: { name: "AcquisitionDate", write: true } })], u9.prototype, "acquisitionDate", void 0), e([o("acquisitionDate")], u9.prototype, "readAcquisitionDate", null), e([r("acquisitionDate")], u9.prototype, "writeAcquisitionDate", null), e([y({ json: { name: "CloudCover", read: { reader: n8 }, write: true } })], u9.prototype, "cloudCover", void 0), e([y({ json: { name: "ProductName", write: true } })], u9.prototype, "productName", void 0), e([y({ json: { name: "SensorName", write: true } })], u9.prototype, "sensorName", void 0), e([y({ json: { name: "SensorAzimuth", read: { reader: n8 }, write: true } })], u9.prototype, "sensorAzimuth", void 0), e([y({ json: { name: "SensorElevation", read: { reader: n8 }, write: true } })], u9.prototype, "sensorElevation", void 0), e([y({ json: { name: "SunAzimuth", read: { reader: n8 }, write: true } })], u9.prototype, "sunAzimuth", void 0), e([y({ json: { name: "SunElevation", read: { reader: n8 }, write: true } })], u9.prototype, "sunElevation", void 0), u9 = a10 = e([c2("esri.layers.support.RasterSensorInfo")], u9);
var p3 = u9;

// node_modules/@arcgis/core/layers/support/RasterStorageInfo.js
var p4;
var l3 = p4 = class extends f {
  constructor() {
    super(...arguments), this.blockWidth = void 0, this.blockHeight = void 0, this.compression = null, this.origin = null, this.firstPyramidLevel = null, this.maximumPyramidLevel = null, this.pyramidScalingFactor = 2, this.pyramidBlockWidth = null, this.pyramidBlockHeight = null, this.isVirtualTileInfo = false, this.tileInfo = null, this.transposeInfo = null, this.blockBoundary = null;
  }
  clone() {
    return new p4({ blockWidth: this.blockWidth, blockHeight: this.blockHeight, compression: this.compression, origin: a(this.origin), firstPyramidLevel: this.firstPyramidLevel, maximumPyramidLevel: this.maximumPyramidLevel, pyramidResolutions: a(this.pyramidResolutions), pyramidScalingFactor: this.pyramidScalingFactor, pyramidBlockWidth: this.pyramidBlockWidth, pyramidBlockHeight: this.pyramidBlockHeight, isVirtualTileInfo: this.isVirtualTileInfo, tileInfo: a(this.tileInfo), transposeInfo: a(this.transposeInfo), blockBoundary: a(this.blockBoundary) });
  }
};
e([y({ type: Number, json: { write: true } })], l3.prototype, "blockWidth", void 0), e([y({ type: Number, json: { write: true } })], l3.prototype, "blockHeight", void 0), e([y({ type: String, json: { write: true } })], l3.prototype, "compression", void 0), e([y({ type: x, json: { write: true } })], l3.prototype, "origin", void 0), e([y({ type: Number, json: { write: true } })], l3.prototype, "firstPyramidLevel", void 0), e([y({ type: Number, json: { write: true } })], l3.prototype, "maximumPyramidLevel", void 0), e([y({ json: { write: true } })], l3.prototype, "pyramidResolutions", void 0), e([y({ type: Number, json: { write: true } })], l3.prototype, "pyramidScalingFactor", void 0), e([y({ type: Number, json: { write: true } })], l3.prototype, "pyramidBlockWidth", void 0), e([y({ type: Number, json: { write: true } })], l3.prototype, "pyramidBlockHeight", void 0), e([y({ type: Boolean, json: { write: true } })], l3.prototype, "isVirtualTileInfo", void 0), e([y({ json: { write: true } })], l3.prototype, "tileInfo", void 0), e([y()], l3.prototype, "transposeInfo", void 0), e([y()], l3.prototype, "blockBoundary", void 0), l3 = p4 = e([c2("esri.layers.support.RasterStorageInfo")], l3);
var n9 = l3;

// node_modules/@arcgis/core/layers/support/RasterInfo.js
var h4;
var u10 = h4 = class extends f {
  constructor(t8) {
    super(t8), this.attributeTable = null, this.bandCount = null, this.colormap = null, this.extent = null, this.format = void 0, this.height = null, this.width = null, this.histograms = null, this.keyProperties = {}, this.multidimensionalInfo = null, this.noDataValue = null, this.pixelSize = null, this.pixelType = null, this.isPseudoSpatialReference = false, this.spatialReference = null, this.statistics = null, this.storageInfo = null, this.transform = null;
  }
  get bandInfos() {
    const t8 = this.keyProperties.BandProperties, { bandCount: e7 } = this;
    if (!(t8 == null ? void 0 : t8.length) || t8.length < e7) {
      const t9 = [];
      for (let o11 = 1; o11 <= e7; o11++)
        t9.push(new s7({ name: "band_" + o11 }));
      return t9;
    }
    const o10 = t8.map((t9) => s7.fromJSON(t9));
    for (let i9 = 0; i9 < o10.length; i9++)
      o10[i9].name = o10[i9].name || "band_" + (i9 + 1);
    return o10;
  }
  get dataType() {
    var _a, _b;
    const t8 = ((_b = (_a = this.keyProperties) == null ? void 0 : _a.DataType) == null ? void 0 : _b.toLowerCase()) ?? "generic";
    return "stdtime" === t8 ? "standard-time" : t8;
  }
  get nativeExtent() {
    return this._get("nativeExtent") || this.extent;
  }
  set nativeExtent(t8) {
    t8 && this._set("nativeExtent", t8);
  }
  get nativePixelSize() {
    if (null == this.transform || !this.transform.affectsPixelSize)
      return this.pixelSize;
    const t8 = this.nativeExtent;
    return { x: t8.width / this.width, y: t8.height / this.height };
  }
  get hasMultidimensionalTranspose() {
    var _a;
    return !!((_a = this.storageInfo) == null ? void 0 : _a.transposeInfo);
  }
  get sensorInfo() {
    var _a;
    if ((_a = this.keyProperties) == null ? void 0 : _a.SensorName)
      return p3.fromJSON(this.keyProperties);
  }
  clone() {
    return new h4({ attributeTable: a(this.attributeTable), bandCount: this.bandCount, colormap: a(this.colormap), extent: a(this.extent), nativePixelSize: a(this.nativePixelSize), format: this.format, height: this.height, width: this.width, histograms: a(this.histograms), keyProperties: a(this.keyProperties), multidimensionalInfo: a(this.multidimensionalInfo), noDataValue: this.noDataValue, pixelSize: a(this.pixelSize), pixelType: this.pixelType, isPseudoSpatialReference: this.isPseudoSpatialReference, spatialReference: a(this.spatialReference), statistics: a(this.statistics), storageInfo: a(this.storageInfo), transform: a(this.transform) });
  }
};
e([y({ json: { write: true } })], u10.prototype, "attributeTable", void 0), e([y({ json: { write: true } })], u10.prototype, "bandCount", void 0), e([y({ readOnly: true })], u10.prototype, "bandInfos", null), e([y({ json: { write: true } })], u10.prototype, "colormap", void 0), e([y({ type: String, readOnly: true })], u10.prototype, "dataType", null), e([y({ type: M, json: { write: true } })], u10.prototype, "extent", void 0), e([y({ type: M, json: { write: true } })], u10.prototype, "nativeExtent", null), e([y({ json: { write: true } })], u10.prototype, "nativePixelSize", null), e([y({ json: { write: true } })], u10.prototype, "format", void 0), e([y({ json: { write: true } })], u10.prototype, "height", void 0), e([y({ json: { write: true } })], u10.prototype, "width", void 0), e([y({ json: { write: true } })], u10.prototype, "hasMultidimensionalTranspose", null), e([y({ json: { write: true } })], u10.prototype, "histograms", void 0), e([y({ json: { write: true } })], u10.prototype, "keyProperties", void 0), e([y({ json: { write: true } })], u10.prototype, "multidimensionalInfo", void 0), e([y({ json: { write: true } })], u10.prototype, "noDataValue", void 0), e([y({ json: { write: true } })], u10.prototype, "pixelSize", void 0), e([y({ json: { write: true } })], u10.prototype, "pixelType", void 0), e([y()], u10.prototype, "isPseudoSpatialReference", void 0), e([y({ readOnly: true })], u10.prototype, "sensorInfo", null), e([y({ type: f2, json: { write: true } })], u10.prototype, "spatialReference", void 0), e([y({ json: { write: true } })], u10.prototype, "statistics", void 0), e([y({ type: n9, json: { write: true } })], u10.prototype, "storageInfo", void 0), e([y({ json: { write: true } })], u10.prototype, "transform", void 0), u10 = h4 = e([c2("esri.layers.support.RasterInfo")], u10);
var m4 = u10;

// node_modules/@arcgis/core/layers/support/rasterFunctions/surfaceUtils.js
var i7 = 1;
var s8 = 1 / 111e3;
function n10(t8) {
  let { altitude: e7, azimuth: i9 } = t8;
  const { hillshadeType: n12, pixelSizePower: a13 = 1, pixelSizeFactor: l5 = 1, scalingType: o10, isGCS: r13, resolution: c8 } = t8, h7 = "multi-directional" === n12 ? 2 * t8.zFactor : t8.zFactor, { x: u14, y: f10 } = c8;
  let d4 = h7 / (8 * u14), p6 = h7 / (8 * f10);
  if (r13 && h7 > 1e-3 && (d4 /= s8, p6 /= s8), "adjusted" === o10)
    if (r13) {
      const t9 = u14 * s8, e8 = f10 * s8;
      d4 = (h7 + t9 ** a13 * l5) / (8 * t9), p6 = (h7 + e8 ** a13 * l5) / (8 * e8);
    } else
      d4 = (h7 + u14 ** a13 * l5) / (8 * u14), p6 = (h7 + f10 ** a13 * l5) / (8 * f10);
  let x5 = (90 - e7) * Math.PI / 180, w4 = Math.cos(x5), y6 = (360 - i9 + 90) * Math.PI / 180, M4 = Math.sin(x5) * Math.cos(y6), m6 = Math.sin(x5) * Math.sin(y6);
  const A5 = [315, 270, 225, 360, 180, 0], g5 = [60, 60, 60, 60, 60, 90], k4 = new Float32Array([3, 5, 3, 2, 1, 4]), z2 = k4.reduce((t9, e8) => t9 + e8), F2 = k4.map((t9) => t9 / z2), P3 = "multi-directional" === n12 ? A5.length : 1, C5 = new Float32Array(6), Z = new Float32Array(6), v4 = new Float32Array(6);
  if ("multi-directional" === n12)
    for (let s10 = 0; s10 < P3; s10++)
      e7 = g5[s10], i9 = A5[s10], x5 = (90 - e7) * Math.PI / 180, w4 = Math.cos(x5), y6 = (360 - i9 + 90) * Math.PI / 180, M4 = Math.sin(x5) * Math.cos(y6), m6 = Math.sin(x5) * Math.sin(y6), C5[s10] = w4, Z[s10] = M4, v4[s10] = m6;
  else
    C5.fill(w4), Z.fill(M4), v4.fill(m6);
  return { resolution: c8, factor: [d4, p6], sinZcosA: M4, sinZsinA: m6, cosZ: w4, sinZcosAs: Z, sinZsinAs: v4, cosZs: C5, weights: F2, hillshadeType: ["traditional", "multi-directional"].indexOf(n12) };
}
function a11(t8, e7) {
  const { width: s10, height: n12 } = t8, a13 = s10 * n12, l5 = new Uint8Array(a13), o10 = null != t8.mask;
  let r13;
  if (o10) {
    r13 = new Uint8Array(t8.mask);
    for (let t9 = 0; t9 < r13.length; t9++)
      r13[t9] && (l5[t9] = 1, r13[t9] = 1);
  }
  const c8 = t8.pixels[0], h7 = new Float32Array(a13), u14 = new Float32Array(a13);
  let f10, d4 = 0;
  if (e7) {
    const { resolution: t9 } = e7, i9 = t9 ? (t9.x + t9.y) / 2 : 1;
    d4 = 200 * e7.zFactor / (i9 * i9), f10 = new Float32Array(a13);
  }
  const p6 = e7 == null ? void 0 : e7.curvatureType;
  let x5, w4, y6, M4, m6, A5, g5, k4;
  for (let z2 = i7; z2 < n12 - i7; z2++) {
    const t9 = z2 * s10;
    for (let e8 = i7; e8 < s10 - i7; e8++) {
      const i9 = t9 + e8;
      if (!r13 || 0 !== r13[i9]) {
        if (r13) {
          if (r13[i9 - s10 - 1] + r13[i9 - s10] + r13[i9 - s10 + 1] + r13[i9 - 1] + r13[i9 + 1] + r13[i9 + s10 - 1] + r13[i9 + s10] + r13[i9 + s10 + 1] < 7) {
            l5[i9] = 0;
            continue;
          }
          x5 = r13[i9 - s10 - 1] ? c8[i9 - s10 - 1] : c8[i9], w4 = r13[i9 - s10] ? c8[i9 - s10] : c8[i9], y6 = r13[i9 - s10 + 1] ? c8[i9 - s10 + 1] : c8[i9], M4 = r13[i9 - 1] ? c8[i9 - 1] : c8[i9], m6 = r13[i9 + 1] ? c8[i9 + 1] : c8[i9], A5 = r13[i9 + s10 - 1] ? c8[i9 + s10 - 1] : c8[i9], g5 = r13[i9 + s10] ? c8[i9 + s10] : c8[i9], k4 = r13[i9 + s10 + 1] ? c8[i9 + s10 + 1] : c8[i9];
        } else
          x5 = c8[i9 - s10 - 1], w4 = c8[i9 - s10], y6 = c8[i9 - s10 + 1], M4 = c8[i9 - 1], m6 = c8[i9 + 1], A5 = c8[i9 + s10 - 1], g5 = c8[i9 + s10], k4 = c8[i9 + s10 + 1];
        if (h7[i9] = y6 + m6 + m6 + k4 - (x5 + M4 + M4 + A5), u14[i9] = A5 + g5 + g5 + k4 - (x5 + w4 + w4 + y6), null != f10) {
          const t10 = c8[i9], e9 = 0.5 * (M4 + m6) - t10, s11 = 0.5 * (w4 + g5) - t10;
          if ("standard" === p6)
            f10[i9] = -d4 * (e9 + s11);
          else {
            const t11 = (-x5 + y6 + A5 - k4) / 4, n13 = (-M4 + m6) / 2, a14 = (w4 - g5) / 2, l6 = n13 * n13, o11 = a14 * a14, r14 = l6 + o11;
            r14 && (f10[i9] = "profile" === p6 ? d4 * (e9 * l6 + s11 * o11 + t11 * n13 * a14) / r14 : -d4 * (e9 * o11 + s11 * l6 - t11 * n13 * a14) / r14);
          }
        }
      }
    }
  }
  return { outMask: o10 ? l5 : null, dzxs: h7, dzys: u14, curvatures: f10 };
}
function l4(t8, e7, i9) {
  for (let s10 = 0; s10 < i9; s10++)
    t8[s10 * e7] = t8[s10 * e7 + 1], t8[(s10 + 1) * e7 - 1] = t8[(s10 + 1) * e7 - 2];
  for (let s10 = 1; s10 < e7 - 1; s10++)
    t8[s10] = t8[s10 + e7], t8[s10 + (i9 - 1) * e7] = t8[s10 + (i9 - 2) * e7];
}
function o8(s10, o10) {
  if (!o3(s10))
    return s10;
  const { factor: r13, sinZcosA: c8, sinZsinA: h7, cosZ: u14, sinZcosAs: f10, sinZsinAs: d4, cosZs: p6, weights: x5 } = n10(o10), [w4, y6] = r13, M4 = "traditional" === o10.hillshadeType, { width: m6, height: A5 } = s10, g5 = new Uint8Array(m6 * A5), { dzxs: k4, dzys: z2, outMask: F2 } = a11(s10);
  for (let t8 = i7; t8 < A5 - i7; t8++) {
    const e7 = t8 * m6;
    for (let t9 = i7; t9 < m6 - i7; t9++) {
      const i9 = e7 + t9;
      if (!F2 || F2[i9]) {
        const t10 = k4[i9] * w4, e8 = z2[i9] * y6, s11 = Math.sqrt(1 + t10 * t10 + e8 * e8);
        let n12 = 0;
        if (M4) {
          let i10 = 255 * (u14 + h7 * e8 - c8 * t10) / s11;
          i10 < 0 && (i10 = 0), n12 = i10;
        } else {
          const i10 = d4.length;
          for (let a13 = 0; a13 < i10; a13++) {
            let i11 = 255 * (p6[a13] + d4[a13] * e8 - f10[a13] * t10) / s11;
            i11 < 0 && (i11 = 0), n12 += i11 * x5[a13];
          }
        }
        g5[i9] = 255 & n12;
      }
    }
  }
  l4(g5, m6, A5);
  return new u4({ width: m6, height: A5, pixels: [g5], mask: F2, pixelType: "u8", validPixelCount: s10.validPixelCount, statistics: [{ minValue: 0, maxValue: 255 }] });
}
function r11(t8, i9, s10, n12) {
  if (!o3(t8) || !o3(i9))
    return;
  const { min: a13, max: l5 } = n12, o10 = t8.pixels[0], { pixels: r13, mask: c8 } = i9, h7 = r13[0], u14 = 255.00001 / (l5 - a13), f10 = new Uint8ClampedArray(h7.length), d4 = new Uint8ClampedArray(h7.length), p6 = new Uint8ClampedArray(h7.length), x5 = s10.length - 1;
  for (let e7 = 0; e7 < h7.length; e7++) {
    if (c8 && 0 === c8[e7])
      continue;
    const t9 = Math.floor((h7[e7] - a13) * u14), [i10, n13] = s10[t9 < 0 ? 0 : t9 > x5 ? x5 : t9], l6 = o10[e7], r14 = l6 * n13, w4 = r14 * (1 - Math.abs(i10 % 2 - 1)), y6 = l6 - r14;
    switch (Math.floor(i10)) {
      case 0:
        f10[e7] = r14 + y6, d4[e7] = w4 + y6, p6[e7] = y6;
        break;
      case 1:
        f10[e7] = w4 + y6, d4[e7] = r14 + y6, p6[e7] = y6;
        break;
      case 2:
        f10[e7] = y6, d4[e7] = r14 + y6, p6[e7] = w4 + y6;
        break;
      case 3:
        f10[e7] = y6, d4[e7] = w4 + y6, p6[e7] = r14 + y6;
        break;
      case 4:
        f10[e7] = w4 + y6, d4[e7] = y6, p6[e7] = r14 + y6;
        break;
      case 5:
      case 6:
        f10[e7] = r14 + y6, d4[e7] = y6, p6[e7] = w4 + y6;
    }
  }
  t8.pixels = [f10, d4, p6], t8.updateStatistics();
}
function c6(n12, o10) {
  if (!o3(n12))
    return n12;
  const r13 = o10.zFactor, c8 = o10.pixelSizePower ?? 1, h7 = o10.pixelSizeFactor ?? 1, u14 = o10.slopeType, f10 = o10.isGCS, { x: d4, y: p6 } = o10.resolution;
  let x5 = r13 / (8 * d4), w4 = r13 / (8 * p6);
  f10 && Math.abs(r13 - 1) < 1e-4 && (x5 /= s8, w4 /= s8), "adjusted" === u14 && (x5 = (r13 + d4 ** c8 * h7) / (8 * d4), w4 = (r13 + p6 ** c8 * h7) / (8 * p6));
  const { dzxs: y6, dzys: M4, outMask: m6 } = a11(n12), { width: A5, height: g5 } = n12, k4 = new Float32Array(A5 * g5);
  for (let t8 = i7; t8 < g5 - i7; t8++) {
    const e7 = t8 * A5;
    for (let t9 = i7; t9 < A5 - i7; t9++) {
      const i9 = e7 + t9;
      if (!m6 || m6[i9]) {
        const s10 = y6[i9] * x5, n13 = M4[i9] * w4, a13 = Math.sqrt(s10 * s10 + n13 * n13);
        k4[e7 + t9] = "percent-rise" === u14 ? 100 * a13 : 57.2957795 * Math.atan(a13);
      }
    }
  }
  l4(k4, A5, g5);
  const z2 = new u4({ width: A5, height: g5, pixels: [k4], mask: m6, pixelType: "f32", validPixelCount: n12.validPixelCount });
  return z2.updateStatistics(), z2;
}
function h5(s10, n12 = {}) {
  if (!o3(s10))
    return s10;
  const { resolution: o10 } = n12, r13 = o10 ? 1 / o10.x : 1, c8 = o10 ? 1 / o10.y : 1, { dzxs: h7, dzys: u14, outMask: f10 } = a11(s10), { width: d4, height: p6 } = s10, x5 = new Float32Array(d4 * p6);
  for (let t8 = i7; t8 < p6 - i7; t8++) {
    const e7 = t8 * d4;
    for (let t9 = i7; t9 < d4 - i7; t9++) {
      const i9 = e7 + t9;
      if (!f10 || f10[i9]) {
        const s11 = h7[i9] * r13, n13 = u14[i9] * c8;
        let a13 = -1;
        0 === s11 && 0 === n13 || (a13 = 90 - 57.29578 * Math.atan2(n13, -s11), a13 < 0 && (a13 += 360), 360 === a13 ? a13 = 0 : a13 > 360 && (a13 %= 360)), x5[e7 + t9] = a13;
      }
    }
  }
  l4(x5, d4, p6);
  return new u4({ width: d4, height: p6, pixels: [x5], mask: f10, pixelType: "f32", validPixelCount: s10.validPixelCount, statistics: [{ minValue: -1, maxValue: 360 }] });
}
function u11(i9, s10) {
  if (!o3(i9))
    return i9;
  const { curvatures: n12, outMask: o10 } = a11(i9, s10), { width: r13, height: c8 } = i9;
  l4(n12, r13, c8);
  const h7 = new u4({ width: r13, height: c8, pixels: [n12], mask: o10, pixelType: "f32", validPixelCount: i9.validPixelCount });
  return h7.updateStatistics(), h7;
}

// node_modules/@arcgis/core/renderers/support/colorRampUtils.js
var C3 = ["random", "ndvi", "ndvi2", "ndvi3", "elevation", "gray", "hillshade"];
var m5 = [{ id: "aspect", type: "multipart", colorRamps: [{ fromColor: [190, 190, 190], toColor: [255, 45, 8] }, { fromColor: [255, 45, 8], toColor: [255, 181, 61] }, { fromColor: [255, 181, 61], toColor: [255, 254, 52] }, { fromColor: [255, 254, 52], toColor: [0, 251, 50] }, { fromColor: [0, 251, 50], toColor: [255, 254, 52] }, { fromColor: [0, 253, 255], toColor: [0, 181, 255] }, { fromColor: [0, 181, 255], toColor: [26, 35, 253] }, { fromColor: [26, 35, 253], toColor: [255, 57, 251] }, { fromColor: [255, 57, 251], toColor: [255, 45, 8] }] }, { id: "black-to-white", fromColor: [0, 0, 0], toColor: [255, 255, 255] }, { id: "blue-bright", fromColor: [204, 204, 255], toColor: [0, 0, 224] }, { id: "blue-light-to-dark", fromColor: [211, 229, 232], toColor: [46, 100, 140] }, { id: "blue-green-bright", fromColor: [203, 245, 234], toColor: [48, 207, 146] }, { id: "blue-green-light-to-dark", fromColor: [216, 242, 237], toColor: [21, 79, 74] }, { id: "brown-light-to-dark", fromColor: [240, 236, 170], toColor: [102, 72, 48] }, { id: "brown-to-blue-green-diverging-right", type: "multipart", colorRamps: [{ fromColor: [156, 85, 31], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [33, 130, 145] }] }, { id: "brown-to-blue-green-diverging-dark", type: "multipart", colorRamps: [{ fromColor: [110, 70, 45], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [48, 100, 102] }] }, { id: "coefficient-bias", fromColor: [214, 214, 255], toColor: [0, 57, 148] }, { id: "cold-to-hot-diverging", type: "multipart", colorRamps: [{ fromColor: [69, 117, 181], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [214, 47, 39] }] }, { id: "condition-number", type: "multipart", colorRamps: [{ fromColor: [0, 97, 0], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [255, 34, 0] }] }, { id: "cyan-to-purple", type: "multipart", colorRamps: [{ fromColor: [0, 245, 245], toColor: [0, 0, 245] }, { fromColor: [0, 0, 245], toColor: [245, 0, 245] }] }, { id: "cyan-light-to-blue-dark", type: "multipart", colorRamps: [{ fromColor: [182, 237, 240], toColor: [31, 131, 224] }, { fromColor: [31, 131, 224], toColor: [9, 9, 145] }] }, { id: "distance", fromColor: [255, 200, 0], toColor: [0, 0, 255] }, { id: "elevation1", type: "multipart", colorRamps: [{ fromColor: [175, 240, 233], toColor: [255, 255, 179] }, { fromColor: [255, 255, 179], toColor: [0, 128, 64] }, { fromColor: [0, 128, 64], toColor: [252, 186, 3] }, { fromColor: [252, 186, 3], toColor: [128, 0, 0] }, { fromColor: [120, 0, 0], toColor: [105, 48, 13] }, { fromColor: [105, 48, 13], toColor: [171, 171, 171] }, { fromColor: [171, 171, 171], toColor: [255, 252, 255] }] }, { id: "elevation2", type: "multipart", colorRamps: [{ fromColor: [118, 219, 211], toColor: [255, 255, 199] }, { fromColor: [255, 255, 199], toColor: [255, 255, 128] }, { fromColor: [255, 255, 128], toColor: [217, 194, 121] }, { fromColor: [217, 194, 121], toColor: [135, 96, 38] }, { fromColor: [135, 96, 38], toColor: [150, 150, 181] }, { fromColor: [150, 150, 181], toColor: [181, 150, 181] }, { fromColor: [181, 150, 181], toColor: [255, 252, 255] }] }, { id: "errors", fromColor: [255, 235, 214], toColor: [196, 10, 10] }, { id: "gray-light-to-dark", fromColor: [219, 219, 219], toColor: [69, 69, 69] }, { id: "green-bright", fromColor: [204, 255, 204], toColor: [14, 204, 14] }, { id: "green-light-to-dark", fromColor: [220, 245, 233], toColor: [34, 102, 51] }, { id: "green-to-blue", type: "multipart", colorRamps: [{ fromColor: [32, 204, 16], toColor: [0, 242, 242] }, { fromColor: [0, 242, 242], toColor: [2, 33, 227] }] }, { id: "orange-bright", fromColor: [255, 235, 204], toColor: [240, 118, 5] }, { id: "orange-light-to-dark", fromColor: [250, 233, 212], toColor: [171, 65, 36] }, { id: "partial-spectrum", type: "multipart", colorRamps: [{ fromColor: [242, 241, 162], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [255, 0, 0] }, { fromColor: [252, 3, 69], toColor: [176, 7, 237] }, { fromColor: [176, 7, 237], toColor: [2, 29, 173] }] }, { id: "partial-spectrum-1-diverging", type: "multipart", colorRamps: [{ fromColor: [135, 38, 38], toColor: [240, 149, 12] }, { fromColor: [240, 149, 12], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [74, 80, 181] }, { fromColor: [74, 80, 181], toColor: [39, 32, 122] }] }, { id: "partial-spectrum-2-diverging", type: "multipart", colorRamps: [{ fromColor: [115, 77, 42], toColor: [201, 137, 52] }, { fromColor: [201, 137, 52], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [91, 63, 176] }, { fromColor: [91, 63, 176], toColor: [81, 13, 97] }] }, { id: "pink-to-yellow-green-diverging-bright", type: "multipart", colorRamps: [{ fromColor: [158, 30, 113], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [99, 110, 45] }] }, { id: "pink-to-yellow-green-diverging-dark", type: "multipart", colorRamps: [{ fromColor: [97, 47, 73], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [22, 59, 15] }] }, { id: "precipitation", type: "multipart", colorRamps: [{ fromColor: [194, 82, 60], toColor: [237, 161, 19] }, { fromColor: [237, 161, 19], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [0, 219, 0] }, { fromColor: [0, 219, 0], toColor: [32, 153, 143] }, { fromColor: [32, 153, 143], toColor: [11, 44, 122] }] }, { id: "prediction", type: "multipart", colorRamps: [{ fromColor: [40, 146, 199], toColor: [250, 250, 100] }, { fromColor: [250, 250, 100], toColor: [232, 16, 20] }] }, { id: "purple-bright", fromColor: [255, 204, 255], toColor: [199, 0, 199] }, { id: "purple-to-green-diverging-bright", type: "multipart", colorRamps: [{ fromColor: [77, 32, 150], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [20, 122, 11] }] }, { id: "purple-to-green-diverging-dark", type: "multipart", colorRamps: [{ fromColor: [67, 14, 89], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [24, 79, 15] }] }, { id: "purple-blue-bright", fromColor: [223, 184, 230], toColor: [112, 12, 242] }, { id: "purple-blue-light-to-dark", fromColor: [229, 213, 242], toColor: [93, 44, 112] }, { id: "purple-red-bright", fromColor: [255, 204, 225], toColor: [199, 0, 99] }, { id: "purple-red-light-to-dark", fromColor: [250, 215, 246], toColor: [143, 17, 57] }, { id: "red-bright", fromColor: [255, 204, 204], toColor: [219, 0, 0] }, { id: "red-light-to-dark", fromColor: [255, 224, 224], toColor: [143, 10, 10] }, { id: "red-to-blue-diverging-bright", type: "multipart", colorRamps: [{ fromColor: [196, 69, 57], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [48, 95, 207] }] }, { id: "red-to-blue-diverging-dark", type: "multipart", colorRamps: [{ fromColor: [107, 13, 13], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [13, 53, 97] }] }, { id: "red-to-green", type: "multipart", colorRamps: [{ fromColor: [245, 0, 0], toColor: [245, 245, 0] }, { fromColor: [245, 245, 0], toColor: [0, 245, 0] }] }, { id: "red-to-green-diverging-bright", type: "multipart", colorRamps: [{ fromColor: [186, 20, 20], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [54, 145, 33] }] }, { id: "red-to-green-diverging-dark", type: "multipart", colorRamps: [{ fromColor: [97, 21, 13], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [16, 69, 16] }] }, { id: "slope", type: "multipart", colorRamps: [{ fromColor: [56, 168, 0], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [255, 0, 0] }] }, { id: "spectrum-full-bright", type: "multipart", colorRamps: [{ fromColor: [255, 0, 0], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [0, 255, 255] }, { fromColor: [0, 255, 255], toColor: [0, 0, 255] }] }, { id: "spectrum-full-dark", type: "multipart", colorRamps: [{ fromColor: [153, 0, 0], toColor: [153, 153, 0] }, { fromColor: [153, 153, 0], toColor: [0, 153, 153] }, { fromColor: [0, 153, 153], toColor: [0, 0, 153] }] }, { id: "spectrum-full-light", type: "multipart", colorRamps: [{ fromColor: [255, 153, 153], toColor: [255, 255, 153] }, { fromColor: [255, 255, 153], toColor: [153, 255, 255] }, { fromColor: [153, 255, 255], toColor: [153, 153, 255] }] }, { id: "surface", type: "multipart", colorRamps: [{ fromColor: [112, 153, 89], toColor: [242, 238, 162] }, { fromColor: [242, 238, 162], toColor: [242, 206, 133] }, { fromColor: [242, 206, 133], toColor: [194, 140, 124] }, { fromColor: [194, 140, 124], toColor: [255, 242, 255] }] }, { id: "temperature", type: "multipart", colorRamps: [{ fromColor: [255, 252, 255], toColor: [255, 0, 255] }, { fromColor: [255, 0, 255], toColor: [0, 0, 255] }, { fromColor: [0, 0, 255], toColor: [0, 255, 255] }, { fromColor: [0, 255, 255], toColor: [0, 255, 0] }, { fromColor: [0, 255, 0], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [255, 128, 0] }, { fromColor: [255, 128, 0], toColor: [128, 0, 0] }] }, { id: "white-to-black", fromColor: [255, 255, 255], toColor: [0, 0, 0] }, { id: "yellow-to-dark-red", type: "multipart", colorRamps: [{ fromColor: [255, 255, 128], toColor: [242, 167, 46] }, { fromColor: [242, 167, 46], toColor: [107, 0, 0] }] }, { id: "yellow-to-green-to-dark-blue", type: "multipart", colorRamps: [{ fromColor: [255, 255, 128], toColor: [56, 224, 9] }, { fromColor: [56, 224, 9], toColor: [26, 147, 171] }, { fromColor: [26, 147, 171], toColor: [12, 16, 120] }] }, { id: "yellow-to-red", fromColor: [245, 245, 0], toColor: [255, 0, 0] }, { id: "yellow-green-bright", fromColor: [236, 252, 204], toColor: [157, 204, 16] }, { id: "yellow-green-light-to-dark", fromColor: [215, 240, 175], toColor: [96, 107, 45] }];
var a12 = new s3({ Aspect: "aspect", "Black to White": "black-to-white", "Blue Bright": "blue-bright", "Blue Light to Dark": "blue-light-to-dark", "Blue-Green Bright": "blue-green-bright", "Blue-Green Light to Dark": "blue-green-light-to-dark", "Brown Light to Dark": "brown-light-to-dark", "Brown to Blue Green Diverging, Bright": "brown-to-blue-green-diverging-right", "Brown to Blue Green Diverging, Dark": "brown-to-blue-green-diverging-dark", "Coefficient Bias": "coefficient-bias", "Cold to Hot Diverging": "cold-to-hot-diverging", "Condition Number": "condition-number", "Cyan to Purple": "cyan-to-purple", "Cyan-Light to Blue-Dark": "cyan-light-to-blue-dark", Distance: "distance", "Elevation #1": "elevation1", "Elevation #2": "elevation2", Errors: "errors", "Gray Light to Dark": "gray-light-to-dark", "Green Bright": "green-bright", "Green Light to Dark": "green-light-to-dark", "Green to Blue": "green-to-blue", "Orange Bright": "orange-bright", "Orange Light to Dark": "orange-light-to-dark", "Partial Spectrum": "partial-spectrum", "Partial Spectrum 1 Diverging": "partial-spectrum-1-diverging", "Partial Spectrum 2 Diverging": "partial-spectrum-2-diverging", "Pink to YellowGreen Diverging, Bright": "pink-to-yellow-green-diverging-bright", "Pink to YellowGreen Diverging, Dark": "pink-to-yellow-green-diverging-dark", Precipitation: "precipitation", Prediction: "prediction", "Purple Bright": "purple-bright", "Purple to Green Diverging, Bright": "purple-to-green-diverging-bright", "Purple to Green Diverging, Dark": "purple-to-green-diverging-dark", "Purple-Blue Bright": "purple-blue-bright", "Purple-Blue Light to Dark": "purple-blue-light-to-dark", "Purple-Red Bright": "purple-red-bright", "Purple-Red Light to Dark": "purple-red-light-to-dark", "Red Bright": "red-bright", "Red Light to Dark": "red-light-to-dark", "Red to Blue Diverging, Bright": "red-to-blue-diverging-bright", "Red to Blue Diverging, Dark": "red-to-blue-diverging-dark", "Red to Green": "red-to-green", "Red to Green Diverging, Bright": "red-to-green-diverging-bright", "Red to Green Diverging, Dark": "red-to-green-diverging-dark", Slope: "slope", "Spectrum-Full Bright": "spectrum-full-bright", "Spectrum-Full Dark": "spectrum-full-dark", "Spectrum-Full Light": "spectrum-full-light", Surface: "surface", Temperature: "temperature", "White to Black": "white-to-black", "Yellow to Dark Red": "yellow-to-dark-red", "Yellow to Green to Dark Blue": "yellow-to-green-to-dark-blue", "Yellow to Red": "yellow-to-red", "Yellow-Green Bright": "yellow-green-bright", "Yellow-Green Light to Dark": "yellow-green-light-to-dark" });
function g4(o10, r13) {
  if (!o10 || !r13 || o10.length !== r13.length)
    return false;
  for (let t8 = 0; t8 < o10.length; t8++)
    if (o10[t8] > r13[t8] + 2 || o10[t8] < r13[t8] - 2)
      return false;
  return true;
}
function p5(o10) {
  const r13 = o10.clone();
  return r13.fromColor = o10.toColor, r13.toColor = o10.fromColor, r13.algorithm = o10.algorithm, r13;
}
function u12(o10) {
  var _a;
  if ("multipart" === o10.type) {
    const r13 = o10.clone();
    return ((_a = r13.colorRamps) == null ? void 0 : _a.length) ? (r13.colorRamps = r13.colorRamps.reverse().map((o11) => p5(o11)), r13) : r13;
  }
  return p5(o10);
}
function f9(r13, t8) {
  if (!r13)
    return;
  const l5 = t8 ?? m5;
  let e7 = null;
  return "algorithmic" === r13.type ? l5.some((o10) => {
    if (g4(r13.fromColor.toRgb(), o10.fromColor) && g4(r13.toColor.toRgb(), o10.toColor))
      return e7 = o10.id, true;
  }) : "multipart" === r13.type && l5.some((t9) => {
    const l6 = r13.colorRamps, i9 = t9.colorRamps;
    if (l6 && i9 && l6.length === i9.length && !i9.some((r14, t10) => {
      if (!g4(l6[t10].fromColor.toRgb(), new u2(r14.fromColor).toRgb()) || !g4(l6[t10].toColor.toRgb(), new u2(r14.toColor).toRgb()))
        return true;
    })) {
      if (e7)
        return true;
      e7 = t9.id;
    }
  }), e7;
}
function s9(o10, r13, t8 = false) {
  if (!o10)
    return;
  let l5 = f9(o10, r13);
  return null != l5 || t8 || (l5 = f9(o10 = u12(o10), r13)), l5;
}
function c7(o10, r13 = false) {
  const t8 = "string" == typeof o10 ? o10 : s9(o10, void 0, r13);
  return t8 ? a12.toJSON(t8) : null;
}
function d3(o10, r13 = "esriCIELabAlgorithm") {
  const t8 = m5.find(({ id: r14 }) => r14 === o10);
  return t8 ? t8.colorRamps ? { type: "multipart", colorRamps: t8.colorRamps.map((o11) => ({ type: "algorithmic", algorithm: r13, fromColor: [...o11.fromColor], toColor: [...o11.toColor] })) } : { type: "algorithmic", algorithm: r13, fromColor: [...t8.fromColor], toColor: [...t8.toColor] } : null;
}
function h6(o10) {
  const r13 = (o10 = o10 || {}).numColors || 256, t8 = o10.distanceOffset || 0, l5 = null != o10.isCustomInterval ? o10.isCustomInterval : null !== o10.distanceInterval && o10.distanceInterval !== 1 / (r13 - 1), e7 = o10.distanceInterval || 1 / (r13 - 1);
  return { ...o10, numColors: r13, distanceOffset: t8, interpolateAlpha: !!o10.interpolateAlpha, distanceInterval: e7, isCustomInterval: l5, weights: o10.weights };
}
function b3(o10, r13, t8) {
  const { numColors: l5, distanceOffset: e7, distanceInterval: i9, isCustomInterval: n12 } = t8, C5 = 0 === o10.s, m6 = 0 === r13.s;
  let a13 = o10.h, g5 = r13.h;
  C5 && !m6 ? a13 = g5 : m6 && !C5 && (r13 = { ...r13, h: a13 }, g5 = a13);
  let p6, u14 = Math.abs(g5 - a13);
  const f10 = 360;
  u14 < f10 / 2 ? p6 = (g5 - a13) * i9 : (u14 = f10 - u14, p6 = a13 > g5 ? u14 * i9 : -u14 * i9);
  const s10 = (r13.s - o10.s) * i9, c8 = (r13.v - o10.v) * i9;
  let { s: d4, v: h7 } = o10, b4 = a13;
  if (e7) {
    const o11 = e7 / i9;
    b4 = (b4 + o11 * p6 + f10) % f10, d4 += o11 * s10, h7 += o11 * c8;
  }
  const v4 = [];
  for (let k4 = 0; k4 < l5 - 1; k4++)
    v4.push({ h: b4, s: d4, v: h7 }), b4 = (b4 + p6 + f10) % f10, d4 += s10, h7 += c8;
  return v4.push(n12 ? { h: b4, s: d4, v: h7 } : r13), v4;
}
function v3(o10, r13, t8) {
  const { numColors: l5, distanceOffset: e7, distanceInterval: i9, isCustomInterval: n12 } = t8;
  let { l: C5, a: m6, b: a13 } = o10;
  const g5 = (r13.l - C5) * i9, p6 = (r13.a - m6) * i9, u14 = (r13.b - a13) * i9, f10 = [];
  if (e7) {
    const o11 = e7 / i9;
    C5 += o11 * g5, m6 += o11 * p6, a13 += o11 * u14;
  }
  for (let s10 = 0; s10 < l5 - 1; s10++)
    f10.push({ l: C5, a: m6, b: a13 }), C5 += g5, m6 += p6, a13 += u14;
  return f10.push(n12 ? { l: C5, a: m6, b: a13 } : r13), f10;
}
function k3(o10, r13, t8) {
  const { numColors: l5, distanceOffset: e7, distanceInterval: i9, isCustomInterval: n12 } = t8, C5 = o10.h, m6 = r13.h, a13 = 2 * Math.PI;
  let g5;
  if (C5 <= m6) {
    const o11 = m6 - C5, r14 = m6 - C5 - a13;
    g5 = Math.abs(r14) < Math.abs(o11) ? r14 : o11;
  } else {
    const o11 = m6 + a13 - C5, r14 = m6 - C5;
    g5 = Math.abs(r14) < Math.abs(o11) ? r14 : o11;
  }
  const p6 = g5 * i9, u14 = (r13.l - o10.l) * i9, f10 = (r13.c - o10.c) * i9;
  let { l: s10, c: c8, h: d4 } = o10;
  if (e7) {
    const o11 = e7 / i9;
    s10 += o11 * u14, c8 += o11 * f10, d4 = (d4 + o11 * p6 + a13) % a13;
  }
  const h7 = [];
  for (let b4 = 0; b4 < l5 - 1; b4++)
    h7.push({ l: s10, c: c8, h: d4 }), s10 += u14, c8 += f10, d4 = (d4 + p6 + a13) % a13;
  return h7.push(n12 ? { l: s10, c: c8, h: d4 } : r13), h7;
}
function y5(o10, i9) {
  let { fromColor: n12, toColor: C5 } = o10;
  n12 = [...n12], C5 = [...C5], 3 === n12.length && (n12 = n12.concat([255])), 3 === C5.length && (C5 = C5.concat([255]));
  const m6 = o10.algorithm || "esriCIELabAlgorithm", a13 = h6(i9), { numColors: g5, distanceOffset: p6, isCustomInterval: u14, interpolateAlpha: f10 } = a13;
  if (1 === g5 && 0 === p6)
    return [n12];
  if (2 === g5 && 0 === p6 && !u14)
    return [n12, C5];
  const s10 = { r: n12[0], g: n12[1], b: n12[2] }, c8 = { r: C5[0], g: C5[1], b: C5[2] }, d4 = "esriCIELabAlgorithm" === m6 ? v3(A(s10), A(c8), a13) : "esriHSVAlgorithm" === m6 ? b3(z(s10), z(c8), a13) : k3(j(s10), j(c8), a13), y6 = [], R3 = n12[3] ?? 255, w4 = ((C5[3] ?? 255) - R3) / (g5 - 1);
  for (let r13 = 0; r13 < g5; r13++) {
    const { r: o11, g: t8, b: l5 } = y2(d4[r13]), i10 = f10 ? Math.round(R3 + w4 * r13) : 255;
    y6.push([o11, t8, l5, i10]);
  }
  return y6;
}
function R2(o10, r13) {
  const { numColors: t8, interpolateAlpha: l5 } = h6(r13);
  let e7 = r13 == null ? void 0 : r13.weights;
  const { colorRamps: i9 } = o10;
  if (e7) {
    const o11 = e7.reduce((o12, r14) => o12 + r14);
    e7 = e7.map((r14) => r14 / o11);
  } else {
    e7 = [];
    for (let o11 = 0; o11 < i9.length; o11++)
      e7[o11] = 1 / i9.length;
  }
  const n12 = [];
  let C5 = 0, m6 = 0;
  const a13 = 1 / (t8 - 1);
  let g5 = false;
  for (let u14 = 0; u14 < i9.length; u14++) {
    let o11 = g5 ? 0 : C5 * a13 - m6, r14 = u14 === i9.length - 1 ? t8 - 1 - C5 : (e7[u14] - o11) / a13;
    if (g5 = Math.ceil(r14) === r14, r14 = Math.ceil(r14), 0 === r14)
      continue;
    o11 /= e7[u14];
    const p7 = y5(i9[u14], { numColors: r14, interpolateAlpha: l5, distanceOffset: o11, distanceInterval: a13 / e7[u14] });
    C5 += p7.length, n12.push(...p7), m6 += e7[u14];
  }
  const p6 = [...i9[i9.length - 1].toColor];
  return 3 === p6.length && p6.push(255), n12.push(p6), n12;
}
function w3(o10, r13) {
  const t8 = a2(o10) ? o10.toJSON() : o10;
  return "multipart" === t8.type ? R2(t8, r13) : y5(t8, r13);
}
function B2(o10, r13) {
  const t8 = w3(o10, r13), l5 = r13 == null ? void 0 : r13.interpolateAlpha;
  return t8.forEach((o11, r14) => {
    o11.unshift(r14), l5 || o11.pop();
  }), t8;
}
function D3(o10) {
  const r13 = z(o10);
  return { type: "HsvColor", Hue: r13.h, Saturation: r13.s, Value: r13.v, AlphaValue: 255 };
}
function I3(o10) {
  const r13 = o10.toJSON();
  return { Algorithm: (r13 == null ? void 0 : r13.Algorithm) || "esriHSVAlgorithm", type: "AlgorithmicColorRamp", FromColor: D3(o10.fromColor), ToColor: D3(o10.toColor) };
}
function G2(o10) {
  const r13 = c7(o10);
  if (!r13)
    return null;
  if ("algorithmic" === o10.type)
    return { ...I3(o10), Name: r13 };
  if (o10.colorRamps) {
    const t8 = o10.colorRamps.map(I3);
    return { type: "MultiPartColorRamp", NumColorRamps: t8.length, ArrayOfColorRamp: t8, Name: r13 };
  }
  return null;
}
function A4(o10) {
  const r13 = o10.reverse().map((o11) => {
    const r14 = o11.toString(16);
    return r14.length < 2 ? "0" + r14 : r14;
  });
  return 4294967295 & Number.parseInt(r13.join(""), 16);
}

// node_modules/@arcgis/core/renderers/support/rasterRendererChecks.js
function n11(n12) {
  var _a, _b, _c;
  return ["u8", "s8"].includes(n12.pixelType) && null != ((_b = (_a = n12.statistics) == null ? void 0 : _a[0]) == null ? void 0 : _b.min) && null != ((_c = n12.statistics[0]) == null ? void 0 : _c.max) && 1 === n12.bandCount;
}
function t7(t8, e7) {
  const { attributeTable: u14, bandCount: r13 } = t8;
  if (null == u14 && n11(t8))
    return true;
  if (null == u14 || r13 > 1)
    return false;
  if (e7) {
    if (null == u14.fields.find((n12) => n12.name.toLowerCase() === e7.toLowerCase()))
      return false;
  }
  return true;
}
function e6(n12) {
  const { bandCount: t8, dataType: e7, pixelType: u14 } = n12;
  return "elevation" === e7 || "generic" === e7 && 1 === t8 && ("s16" === u14 || "s32" === u14 || "f32" === u14 || "f64" === u14);
}
function u13(n12, t8 = false) {
  const { bandCount: e7, colormap: u14, pixelType: r13 } = n12;
  return 1 === e7 && (!!(u14 == null ? void 0 : u14.length) || !t8 && "u8" === r13);
}
function r12(n12, t8 = false) {
  const { attributeTable: e7, bandCount: u14 } = n12;
  return 1 === u14 && (!t8 || null != e7 || null != n12.histograms);
}
function o9(n12) {
  const { dataType: t8 } = n12;
  return "vector-uv" === t8 || "vector-magdir" === t8;
}
function i8(n12) {
  const { dataType: t8 } = n12;
  return "vector-uv" === t8 || "vector-magdir" === t8;
}

// node_modules/@arcgis/core/renderers/support/RasterSymbolizer.js
var C4 = class extends f {
  constructor(e7) {
    super(e7);
  }
  bind() {
    const { rendererJSON: e7 } = this;
    if (!e7)
      return { success: false };
    let t8;
    switch (this.lookup = { rendererJSON: {} }, e7.type) {
      case "uniqueValue":
        t8 = this._updateUVRenderer(e7);
        break;
      case "rasterColormap":
        t8 = this._updateColormapRenderer(e7);
        break;
      case "rasterStretch":
        t8 = this._updateStretchRenderer(e7);
        break;
      case "classBreaks":
        t8 = this._updateClassBreaksRenderer(e7);
        break;
      case "rasterShadedRelief":
        t8 = this._updateShadedReliefRenderer(e7);
        break;
      case "vectorField":
        t8 = this._updateVectorFieldRenderer();
        break;
      case "flowRenderer":
        t8 = this._updateFlowRenderer();
    }
    return t8;
  }
  symbolize(e7) {
    let t8 = e7 == null ? void 0 : e7.pixelBlock;
    if (!_(t8))
      return t8;
    if (e7.simpleStretchParams && "rasterStretch" === this.rendererJSON.type)
      return this.simpleStretch(t8, e7.simpleStretchParams);
    try {
      let r13;
      switch (t8.pixels.length > 3 && (t8 = t8.extractBands([0, 1, 2])), this.rendererJSON.type) {
        case "uniqueValue":
        case "rasterColormap":
          r13 = this._symbolizeColormap(t8);
          break;
        case "classBreaks":
          r13 = this._symbolizeClassBreaks(t8);
          break;
        case "rasterStretch":
          r13 = this._symbolizeStretch(t8, e7.bandIds);
          break;
        case "rasterShadedRelief": {
          const s10 = e7.extent, o10 = s10.spatialReference.isGeographic, a13 = { x: (s10.xmax - s10.xmin) / t8.width, y: (s10.ymax - s10.ymin) / t8.height };
          r13 = this._symbolizeShadedRelief(t8, { isGCS: o10, resolution: a13 });
          break;
        }
      }
      return r13;
    } catch (r13) {
      return s.getLogger(this).error("symbolize", r13.message), t8;
    }
  }
  simpleStretch(e7, t8) {
    if (!_(e7))
      return e7;
    try {
      return e7.pixels.length > 3 && (e7 = e7.extractBands([0, 1, 2])), M3(e7, { ...t8, isRenderer: true });
    } catch (r13) {
      return s.getLogger(this).error("symbolize", r13.message), e7;
    }
  }
  generateWebGLParameters(e7) {
    if (["uniqueValue", "rasterColormap", "classBreaks"].includes(this.rendererJSON.type)) {
      const { indexedColormap: e8, offset: t9 } = this.lookup.colormapLut || {};
      return { colormap: e8, colormapOffset: t9, type: "lut" };
    }
    const { pixelBlock: t8, isGCS: r13, resolution: s10, bandIds: o10 } = e7, { rendererJSON: a13 } = this;
    return "rasterStretch" === a13.type ? this._generateStretchWebGLParams(t8, a13, o10) : "rasterShadedRelief" === a13.type ? this._generateShadedReliefWebGLParams(a13, r13, s10 ?? void 0) : "vectorField" === a13.type ? this._generateVectorFieldWebGLParams(a13) : null;
  }
  _isLUTChanged(e7) {
    if (!this.lookup || !this.lookup.rendererJSON)
      return true;
    if ("colorRamp" in this.rendererJSON) {
      const t8 = this.rendererJSON.colorRamp;
      return e7 ? JSON.stringify(t8) !== JSON.stringify(this.lookup.rendererJSON.colorRamp) : (this.rendererJSON, this.lookup.rendererJSON, JSON.stringify(this.rendererJSON) !== JSON.stringify(this.lookup.rendererJSON));
    }
    return JSON.stringify(this.rendererJSON) !== JSON.stringify(this.lookup.rendererJSON);
  }
  _symbolizeColormap(e7) {
    if (this._isLUTChanged()) {
      if (!this.bind().success)
        return e7;
    }
    return h(e7, this.lookup.colormapLut);
  }
  _symbolizeClassBreaks(e7) {
    const { canUseIndexedLUT: t8 } = this._analyzeClassBreaks(this.rendererJSON);
    if (this._isLUTChanged()) {
      if (!this.bind().success)
        return e7;
    }
    return t8 ? h(e7, this.lookup.colormapLut) : u5(e7, this.lookup.remapLut ?? []);
  }
  _symbolizeStretch(e7, t8) {
    var _a, _b;
    const { rasterInfo: r13 } = this, { pixelType: s10, bandCount: o10 } = r13, a13 = this.rendererJSON, n12 = ["u8", "u16", "s8", "s16"].includes(s10);
    let l5, c8;
    const { dra: p6 } = a13, { gamma: f10 } = this.lookup;
    if ("histogramEqualization" === a13.stretchType) {
      const s11 = p6 ? null : (_a = this.lookup) == null ? void 0 : _a.histogramLut, o11 = p2(a13, { rasterInfo: r13, pixelBlock: e7, bandIds: t8, returnHistogramLut: !s11 }), n13 = M3(e7, { ...o11, gamma: f10, isRenderer: true });
      c8 = f3(n13, { lut: p6 ? o11.histogramLut : s11, offset: 0 });
    } else if (n12) {
      if (p6) {
        const o11 = p2(a13, { rasterInfo: r13, pixelBlock: e7, bandIds: t8 });
        l5 = a9({ pixelType: s10, ...o11, gamma: f10, rounding: "floor" });
      } else if (this._isLUTChanged()) {
        if (!this.bind().success)
          return e7;
        l5 = this.lookup ? this.lookup.stretchLut : null;
      } else
        l5 = this.lookup ? this.lookup.stretchLut : null;
      if (!l5)
        return e7;
      o10 > 1 && null != t8 && t8.length === (e7 == null ? void 0 : e7.pixels.length) && (l5 == null ? void 0 : l5.lut.length) === o10 && (l5 = { lut: t8.map((e8) => l5.lut[e8]), offset: l5.offset }), c8 = f3(e7, l5);
    } else {
      const s11 = p2(a13, { rasterInfo: r13, pixelBlock: e7, bandIds: t8 });
      c8 = M3(e7, { ...s11, gamma: f10, isRenderer: true });
    }
    if (a13.colorRamp) {
      if (this._isLUTChanged(true)) {
        if (!this.bind().success)
          return e7;
      }
      c8 = h(c8, (_b = this.lookup) == null ? void 0 : _b.colormapLut);
    }
    return c8;
  }
  _symbolizeShadedRelief(e7, t8) {
    var _a;
    const r13 = this.rendererJSON, s10 = { ...r13, ...t8 }, o10 = o8(e7, s10);
    if (!r13.colorRamp)
      return o10;
    let a13;
    if (this._isLUTChanged(true)) {
      if (!this.bind().success)
        return o10;
      a13 = this.lookup ? this.lookup.hsvMap : null;
    } else
      a13 = this.lookup ? this.lookup.hsvMap : null;
    if (!a13)
      return o10;
    const n12 = ((_a = this.rasterInfo.statistics) == null ? void 0 : _a[0]) ?? { min: 0, max: 8e3 };
    return r11(o10, e7, a13, n12), o10;
  }
  _isVectorFieldData() {
    const { bandCount: e7, dataType: t8 } = this.rasterInfo;
    return 2 === e7 && ("vector-magdir" === t8 || "vector-uv" === t8);
  }
  _updateVectorFieldRenderer() {
    return this._isVectorFieldData() ? { success: true } : { success: false, error: `Unsupported data type "${this.rasterInfo.dataType}"; VectorFieldRenderer only supports "vector-magdir" and "vector-uv".` };
  }
  _updateFlowRenderer() {
    return this._isVectorFieldData() ? { success: true } : { success: false, error: `Unsupported data type "${this.rasterInfo.dataType}"; FlowRenderer only supports "vector-magdir" and "vector-uv".` };
  }
  _updateUVRenderer(e7) {
    var _a;
    const { bandCount: t8, attributeTable: r13, pixelType: s10 } = this.rasterInfo, o10 = e7.field1;
    if (!o10)
      return { success: false, error: "Unsupported renderer; missing UniqueValueRenderer.field." };
    const a13 = e7.defaultSymbol, n12 = 1 === t8 && ["u8", "s8"].includes(s10);
    if (!t7(this.rasterInfo, o10) && !n12)
      return { success: false, error: "Unsupported data; UniqueValueRenderer is only supported on single band data with a valid raster attribute table." };
    const i9 = [];
    if (null != r13) {
      const t9 = r13.fields.find((e8) => "value" === e8.name.toLowerCase());
      if (!t9)
        return { success: false, error: "Unsupported data; the data's raster attribute table does not have a value field." };
      r13.features.forEach((r14) => {
        var _a2, _b;
        const s11 = (_a2 = e7.uniqueValueInfos) == null ? void 0 : _a2.find((e8) => String(e8.value) === String(r14.attributes[o10])), n13 = (_b = s11 == null ? void 0 : s11.symbol) == null ? void 0 : _b.color;
        n13 ? i9.push([r14.attributes[t9.name]].concat(n13)) : a13 && i9.push([r14.attributes[t9.name]].concat(a13.color));
      });
    } else {
      if ("value" !== o10.toLowerCase())
        return { success: false, error: 'Unsupported renderer; UniqueValueRenderer.field must be "Value" when raster attribute table is not availalbe.' };
      (_a = e7.uniqueValueInfos) == null ? void 0 : _a.forEach((e8) => {
        var _a2;
        const t9 = (_a2 = e8 == null ? void 0 : e8.symbol) == null ? void 0 : _a2.color;
        t9 ? i9.push([parseInt("" + e8.value, 10)].concat(t9)) : a13 && i9.push([parseInt("" + e8.value, 10)].concat(a13 == null ? void 0 : a13.color));
      });
    }
    if (0 === i9.length)
      return { success: false, error: "Invalid UniqueValueRenderer. Cannot find matching records in the raster attribute table." };
    const l5 = a4({ colormap: i9 });
    return this.lookup = { rendererJSON: e7, colormapLut: l5 }, this.canRenderInWebGL = this._isColormapSupportedByWebGL(l5 == null ? void 0 : l5.indexedColormap), { success: true };
  }
  _updateColormapRenderer(e7) {
    if (!u13(this.rasterInfo))
      return { success: false, error: "Unsupported data; the data source does not have a colormap." };
    const t8 = e7.colormapInfos.map((e8) => [e8.value].concat(e8.color)).sort((e8, t9) => e8[0] - t9[0]);
    if (!t8 || 0 === t8.length)
      return { success: false, error: "Unsupported renderer; ColormapRenderer must have meaningful colormapInfos." };
    const r13 = a4({ colormap: t8 });
    return this.lookup = { rendererJSON: e7, colormapLut: r13 }, this.canRenderInWebGL = this._isColormapSupportedByWebGL(r13 == null ? void 0 : r13.indexedColormap), { success: true };
  }
  _updateShadedReliefRenderer(e7) {
    if (!e6(this.rasterInfo))
      return { success: false, error: `Unsupported data type "${this.rasterInfo.dataType}"; ShadedReliefRenderer only supports "elevation", or single band float/s16 data.` };
    if (e7.colorRamp) {
      const r13 = B2(e7.colorRamp, { interpolateAlpha: true }), s10 = a4({ colormap: r13 }), o10 = [], a13 = s10.indexedColormap;
      for (let e8 = 0; e8 < a13.length; e8 += 4) {
        const r14 = z({ r: a13[e8], g: a13[e8 + 1], b: a13[e8 + 2] });
        o10.push([r14.h / 60, r14.s / 100, 255 * r14.v / 100]);
      }
      this.lookup = { rendererJSON: e7, colormapLut: s10, hsvMap: o10 };
    } else
      this.lookup = null;
    return this.canRenderInWebGL = true, { success: true };
  }
  _analyzeClassBreaks(e7) {
    const { attributeTable: t8, pixelType: r13 } = this.rasterInfo, s10 = null != t8 ? t8.fields.find((e8) => "value" === e8.name.toLowerCase()) : null, o10 = null != t8 ? t8.fields.find((t9) => t9.name.toLowerCase() === e7.field.toLowerCase()) : null, a13 = null != s10 && null !== o10;
    return { canUseIndexedLUT: ["u8", "u16", "s8", "s16"].includes(r13) || a13, tableValueField: s10, tableBreakField: o10 };
  }
  _updateClassBreaksRenderer(e7) {
    const { attributeTable: t8 } = this.rasterInfo, { canUseIndexedLUT: r13, tableValueField: s10, tableBreakField: o10 } = this._analyzeClassBreaks(e7), a13 = e7.classBreakInfos;
    if (!(a13 == null ? void 0 : a13.length))
      return { success: false, error: "Unsupported renderer; missing or invalid ClassBreaksRenderer.classBreakInfos." };
    const n12 = a13.sort((e8, t9) => e8.classMaxValue - t9.classMaxValue), i9 = n12[n12.length - 1];
    let l5 = e7.minValue;
    if (!r13) {
      const t9 = [];
      for (let e8 = 0; e8 < n12.length; e8++)
        t9.push({ value: n12[e8].classMinValue ?? l5, mappedColor: n12[e8].symbol.color }), l5 = n12[e8].classMaxValue;
      return t9.push({ value: i9.classMaxValue, mappedColor: i9.symbol.color }), this.lookup = { rendererJSON: e7, remapLut: t9 }, this.canRenderInWebGL = false, { success: true };
    }
    const u14 = [];
    if (null != t8 && null != s10 && null !== o10 && s10 !== o10) {
      const r14 = s10.name, a14 = o10.name, i10 = n12[n12.length - 1], { classMaxValue: c8 } = i10;
      l5 = e7.minValue;
      for (const e8 of t8.features) {
        const t9 = e8.attributes[r14], s11 = e8.attributes[a14], o11 = s11 === c8 ? i10 : s11 < l5 ? null : n12.find(({ classMaxValue: e9 }) => e9 > s11);
        o11 && u14.push([t9].concat(o11.symbol.color));
      }
    } else {
      l5 = Math.floor(e7.minValue);
      for (let e8 = 0; e8 < n12.length; e8++) {
        const t9 = n12[e8];
        for (let e9 = l5; e9 < t9.classMaxValue; e9++)
          u14.push([e9].concat(t9.symbol.color));
        l5 = Math.ceil(t9.classMaxValue);
      }
      i9.classMaxValue === l5 && u14.push([i9.classMaxValue].concat(i9.symbol.color));
    }
    const p6 = a4({ colormap: u14, fillUnspecified: false });
    return this.lookup = { rendererJSON: e7, colormapLut: p6 }, this.canRenderInWebGL = this._isColormapSupportedByWebGL(p6 == null ? void 0 : p6.indexedColormap), { success: true };
  }
  _isColormapSupportedByWebGL(e7) {
    return !!(e7 == null ? void 0 : e7.length) && e7.length <= 16384;
  }
  _isHistogramRequired(e7) {
    return "percentClip" === e7 || "histogramEqualization" === e7;
  }
  _isValidRasterStatistics(e7) {
    return null != e7 && e7.length > 0 && null != e7[0].min && null != e7[0].max;
  }
  _updateStretchRenderer(e7) {
    var _a, _b;
    let { stretchType: t8, dra: r13 } = e7;
    if (!("none" === t8 || ((_a = e7.statistics) == null ? void 0 : _a.length) || this._isValidRasterStatistics(this.rasterInfo.statistics) || r13))
      return { success: false, error: "Unsupported renderer; StretchRenderer.statistics is required when dynamic range adjustment is not used." };
    const s10 = e7.histograms || this.rasterInfo.histograms;
    !this._isHistogramRequired(e7.stretchType) || (s10 == null ? void 0 : s10.length) || r13 || (t8 = "minMax");
    const { computeGamma: o10, useGamma: a13, colorRamp: n12 } = e7;
    let { gamma: i9 } = e7;
    if (a13 && o10 && !(i9 == null ? void 0 : i9.length)) {
      const t9 = ((_b = e7.statistics) == null ? void 0 : _b.length) ? e7.statistics : this.rasterInfo.statistics;
      i9 = f8(this.rasterInfo.pixelType, t9);
    }
    const l5 = this.rasterInfo.pixelType, u14 = !r13 && ["u8", "u16", "s8", "s16"].includes(l5);
    if ("histogramEqualization" === t8) {
      const t9 = s10.map((e8) => r10(e8));
      this.lookup = { rendererJSON: e7, histogramLut: t9 };
    } else if (u14) {
      const t9 = p2(e7, { rasterInfo: this.rasterInfo }), r14 = a9({ pixelType: l5, ...t9, gamma: a13 ? i9 : null, rounding: "floor" });
      this.lookup = { rendererJSON: e7, stretchLut: r14 };
    }
    if (n12 && !this._isStretchColorRampNoop(n12)) {
      const t9 = B2(n12, { interpolateAlpha: true });
      this.lookup || (this.lookup = { rendererJSON: e7 }), this.lookup.colormapLut = a4({ colormap: t9 }), this.lookup.rendererJSON = e7;
    }
    return this.lookup.gamma = a13 && (i9 == null ? void 0 : i9.length) ? i9 : null, this.canRenderInWebGL = true, { success: true };
  }
  _isStretchColorRampNoop(e7) {
    return "algorithmic" === e7.type && ["0,0,0,255", "0,0,0"].includes(e7.fromColor.join(",")) && ["255,255,255,255", "255,255,255"].includes(e7.toColor.join(","));
  }
  _generateStretchWebGLParams(e7, t8, r13) {
    var _a;
    let s10 = null, o10 = null;
    const a13 = (_a = this.lookup) == null ? void 0 : _a.colormapLut;
    t8.colorRamp && a13 && (s10 = a13.indexedColormap, o10 = a13.offset), "histogramEqualization" === t8.stretchType && (t8 = { ...t8, stretchType: "minMax" });
    const { gamma: n12 } = this.lookup, i9 = !!(t8.useGamma && n12 && n12.some((e8) => 1 !== e8)), { minCutOff: l5, maxCutOff: u14, outMin: c8, outMax: p6 } = p2(t8, { rasterInfo: this.rasterInfo, pixelBlock: e7, bandIds: r13 });
    let d4 = 0;
    null != e7 && (d4 = e7.getPlaneCount(), 2 === d4 && ((e7 = e7.clone()).statistics = [e7.statistics[0]], e7.pixels = [e7.pixels[0]]));
    const { bandCount: m6 } = this.rasterInfo, f10 = Math.min(3, (r13 == null ? void 0 : r13.length) || d4 || m6, m6), y6 = new Float32Array(f10), b4 = s10 || i9 ? 1 : 255;
    let g5;
    for (g5 = 0; g5 < l5.length; g5++)
      y6[g5] = u14[g5] === l5[g5] ? 0 : (p6 - c8) / (u14[g5] - l5[g5]) / b4;
    const S3 = new Float32Array(f10);
    if (i9 && n12)
      for (g5 = 0; g5 < f10; g5++)
        n12[g5] > 1 ? n12[g5] > 2 ? S3[g5] = 6.5 + (n12[g5] - 2) ** 2.5 : S3[g5] = 6.5 + 100 * (2 - n12[g5]) ** 4 : S3[g5] = 1;
    return { bandCount: f10, outMin: c8 / b4, outMax: p6 / b4, minCutOff: l5, maxCutOff: u14, factor: y6, useGamma: i9, gamma: i9 ? n12 : [1, 1, 1], gammaCorrection: i9 ? S3 : [1, 1, 1], colormap: s10, colormapOffset: o10, stretchType: t8.stretchType, type: "stretch" };
  }
  _generateShadedReliefWebGLParams(e7, t8 = false, r13 = { x: 0, y: 0 }) {
    var _a, _b;
    let s10 = null, o10 = null;
    const a13 = (_a = this.lookup) == null ? void 0 : _a.colormapLut;
    e7.colorRamp && a13 && (s10 = a13.indexedColormap, o10 = a13.offset);
    const n12 = { ...e7, isGCS: t8, resolution: r13 }, i9 = n10(n12), l5 = (_b = this.rasterInfo.statistics) == null ? void 0 : _b[0];
    return { ...i9, minValue: (l5 == null ? void 0 : l5.min) ?? 0, maxValue: (l5 == null ? void 0 : l5.max) ?? 8e3, hillshadeType: "traditional" === e7.hillshadeType ? 0 : 1, type: "hillshade", colormap: s10, colormapOffset: o10 };
  }
  _generateVectorFieldWebGLParams(e7) {
    var _a, _b, _c;
    const { style: t8, inputUnit: r13, outputUnit: s10, visualVariables: o10, symbolTileSize: a13, flowRepresentation: n12 } = e7;
    let i9;
    const l5 = ((_a = this.rasterInfo.statistics) == null ? void 0 : _a[0].min) ?? 0, u14 = ((_b = this.rasterInfo.statistics) == null ? void 0 : _b[0].max) ?? 50, c8 = (o10 == null ? void 0 : o10.find((e8) => "sizeInfo" === e8.type)) ?? { type: "sizeInfo", field: "Magnitude", maxDataValue: u14, maxSize: 0.8 * a13, minDataValue: l5, minSize: 0.2 * a13 }, p6 = c8.minDataValue ?? l5, d4 = c8.maxDataValue ?? u14, h7 = null != c8.maxSize && null != c8.minSize ? [c8.minSize / a13, c8.maxSize / a13] : [0.2, 0.8];
    if ("wind_speed" === t8) {
      const e8 = (h7[0] + h7[1]) / 2;
      h7[0] = h7[1] = e8;
    }
    const m6 = null != p6 && null != d4 ? [p6, d4] : null;
    if ("classified_arrow" === t8)
      if (null != p6 && null != d4 && null != c8) {
        i9 = [];
        const e8 = (c8.maxDataValue - c8.minDataValue) / 5;
        for (let t9 = 0; t9 < 6; t9++)
          i9.push(c8.minDataValue + e8 * t9);
      } else
        i9 = [0, 1e-6, 3.5, 7, 10.5, 14];
    const f10 = "flow_to" === n12 === ("ocean_current_kn" === t8 || "ocean_current_m" === t8) ? 0 : Math.PI, y6 = o10 == null ? void 0 : o10.find((e8) => "rotationInfo" === e8.type);
    return { breakValues: i9, dataRange: m6, inputUnit: r13, outputUnit: s10, symbolTileSize: a13, symbolPercentRange: h7, style: t8 || "single_arrow", rotation: f10, rotationType: ((_c = this.rasterInfo.storageInfo) == null ? void 0 : _c.tileInfo) && "vector-uv" === this.rasterInfo.dataType ? "geographic" : (y6 == null ? void 0 : y6.rotationType) || e7.rotationType, type: "vectorField" };
  }
};
function _(e7) {
  return o3(e7) && 0 !== e7.validPixelCount;
}
e([y({ json: { write: true } })], C4.prototype, "rendererJSON", void 0), e([y({ type: m4, json: { write: true } })], C4.prototype, "rasterInfo", void 0), e([y({ json: { write: true } })], C4.prototype, "lookup", void 0), e([y()], C4.prototype, "canRenderInWebGL", void 0), C4 = e([c2("esri.renderers.support.RasterSymbolizer")], C4);
var L2 = C4;

export {
  r8 as r,
  n5 as n,
  r9 as r2,
  L,
  R,
  D,
  U,
  N,
  F,
  B,
  P2 as P,
  j2 as j,
  n9 as n2,
  m4 as m,
  s8 as s,
  c6 as c,
  h5 as h,
  u11 as u,
  C3 as C,
  m5 as m2,
  a12 as a,
  c7 as c2,
  d3 as d,
  w3 as w,
  B2,
  G2 as G,
  A4 as A,
  n6 as n3,
  a8 as a2,
  a9 as a3,
  l2 as l,
  m3,
  h3 as h2,
  g3 as g,
  p2 as p,
  x4 as x,
  M3 as M,
  t7 as t,
  e6 as e,
  u13 as u2,
  r12 as r3,
  o9 as o,
  i8 as i,
  L2
};
//# sourceMappingURL=chunk-OEIWJN32.js.map
