import {
  i
} from "./chunk-ZBT4RUU7.js";
import {
  l
} from "./chunk-X2Y3P2BF.js";
import {
  e
} from "./chunk-GJ4KNHRS.js";
import {
  a
} from "./chunk-2AXFVQBN.js";
import {
  u
} from "./chunk-3XSRVKBX.js";
import {
  o
} from "./chunk-423VNHLR.js";
import {
  M
} from "./chunk-Y5D433JZ.js";
import {
  t4 as t
} from "./chunk-LXXF7K7W.js";
import {
  has
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/views/2d/layers/features/support/Tile.js
var n = class _n {
  constructor(t2, e2) {
    this.key = new e(0, 0, 0, 0), this.bounds = u(), this.objectIds = /* @__PURE__ */ new Set(), this.key.set(e2);
    const s = t2.getLODInfoAt(this.key);
    this.tileInfoView = t2, this.tileInfoView.getTileBounds(this.bounds, this.key, true), this.resolution = s.resolution, this.scale = s.scale, this.level = s.level;
  }
  get id() {
    return this.key.id;
  }
  get extent() {
    return M.fromBounds(this.bounds, this.tileInfoView.tileInfo.spatialReference);
  }
  get transform() {
    return { originPosition: "upperLeft", scale: [this.resolution, this.resolution], translate: [this.bounds[0], this.bounds[3]] };
  }
  createChildTiles() {
    const e2 = this.key.getChildKeys(), i2 = t.acquire();
    for (let t2 = 0; t2 < e2.length; t2++)
      i2[t2] = new _n(this.tileInfoView, e2[t2]);
    return i2;
  }
  getQuantizationParameters() {
    return a.fromJSON({ mode: "view", originPosition: "upperLeft", tolerance: this.resolution, extent: { xmin: this.bounds[0], ymin: this.bounds[1], xmax: this.bounds[2], ymax: this.bounds[3], spatialReference: this.tileInfoView.tileInfo.spatialReference } });
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/TileStore.js
var h = { added: [], removed: [] };
var n2 = /* @__PURE__ */ new Set();
var r = new e(0, 0, 0, 0);
var d = class extends o {
  constructor(e2) {
    super(), this._tiles = /* @__PURE__ */ new Map(), this._index = i(9, has("esri-csp-restrictions") ? (e3) => ({ minX: e3.bounds[0], minY: e3.bounds[1], maxX: e3.bounds[2], maxY: e3.bounds[3] }) : [".bounds[0]", ".bounds[1]", ".bounds[2]", ".bounds[3]"]), this.tiles = [], this.tileScheme = e2;
  }
  destroy() {
    this.clear();
  }
  clear() {
    this.tiles.length = 0, this._tiles.clear(), this._index.clear();
  }
  has(e2) {
    return this._tiles.has(e2);
  }
  get(e2) {
    return this._tiles.get(e2);
  }
  boundsIntersections(e2) {
    return this._index.search({ minX: e2[0], minY: e2[1], maxX: e2[2], maxY: e2[3] });
  }
  updateTiles(e2) {
    const t2 = { added: [], removed: [] };
    for (const i2 of e2.added)
      if (!this.has(i2)) {
        const e3 = new n(this.tileScheme, i2);
        this._tiles.set(i2, e3), this._index.insert(e3), t2.added.push(e3);
      }
    for (const s of e2.removed)
      if (this.has(s)) {
        const e3 = this.get(s);
        this._tiles.delete(s), this._index.remove(e3), t2.removed.push(e3);
      }
    this.tiles.length = 0, this._tiles.forEach((e3) => this.tiles.push(e3)), (t2.added.length || t2.removed.length) && this.emit("update", t2);
  }
  setViewState(e2) {
    const t2 = this.tileScheme.getTileCoverage(e2, 0);
    if (!t2)
      return;
    const { spans: o2, lodInfo: d2 } = t2, { level: l2 } = d2;
    if (o2.length > 0)
      for (const { row: i2, colFrom: a2, colTo: m } of o2)
        for (let e3 = a2; e3 <= m; e3++) {
          const t3 = r.set(l2, i2, d2.normalizeCol(e3), d2.getWorldForColumn(e3)).id;
          if (n2.add(t3), !this.has(t3)) {
            const e4 = new n(this.tileScheme, t3);
            this._tiles.set(t3, e4), this._index.insert(e4), this.tiles.push(e4), h.added.push(e4);
          }
        }
    for (let s = this.tiles.length - 1; s >= 0; s--) {
      const e3 = this.tiles[s];
      n2.has(e3.id) || (this._tiles.delete(e3.id), this.tiles.splice(s, 1), this._index.remove(e3), h.removed.push(e3));
    }
    (h.added.length || h.removed.length) && this.emit("update", h), l.pool.release(t2), n2.clear(), h.added.length = 0, h.removed.length = 0;
  }
};

export {
  d
};
//# sourceMappingURL=chunk-ZEQ5M7ZZ.js.map
