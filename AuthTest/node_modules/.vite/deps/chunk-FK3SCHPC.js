import {
  T,
  _,
  c as c2,
  f as f4,
  g as g2,
  h as h3,
  m as m3,
  p,
  r as r2,
  u as u4,
  x as x4
} from "./chunk-3Y5JS6MU.js";
import {
  f as f3
} from "./chunk-BV5PCIP6.js";
import {
  a as a4
} from "./chunk-L7TO2DFS.js";
import {
  h as h2
} from "./chunk-A6KO3R3G.js";
import {
  h,
  k as k2,
  r
} from "./chunk-ST3TBFQ6.js";
import {
  S as S2
} from "./chunk-NI23WAWZ.js";
import {
  i as i4
} from "./chunk-7PBKZJWC.js";
import {
  E as E2,
  a as a3,
  e as e2,
  o,
  x as x3
} from "./chunk-JNWIDZDW.js";
import {
  i as i3
} from "./chunk-3XN3CFM5.js";
import {
  F as F2,
  H,
  P,
  R,
  Y,
  j as j2,
  te,
  x as x2
} from "./chunk-UMP4LYVN.js";
import {
  U
} from "./chunk-LJAHTUH5.js";
import {
  i as i2,
  ie,
  te as te2,
  tt
} from "./chunk-HR42LBYN.js";
import {
  S
} from "./chunk-TREPTI6V.js";
import {
  X
} from "./chunk-XFC7DZXI.js";
import {
  F
} from "./chunk-RCLKRKWR.js";
import {
  j,
  x
} from "./chunk-57KRYRCY.js";
import {
  $,
  C,
  dt,
  ht,
  ot
} from "./chunk-747B2TEO.js";
import {
  t as t2
} from "./chunk-5WG7GACT.js";
import {
  L,
  d as d2
} from "./chunk-7Y57Y6IH.js";
import {
  N,
  O,
  y as y2
} from "./chunk-2XWWTLSJ.js";
import {
  n as n2
} from "./chunk-JLSYG6MV.js";
import {
  i as i5
} from "./chunk-ZBT4RUU7.js";
import {
  L as L2
} from "./chunk-LOGPPZUD.js";
import {
  s as s4
} from "./chunk-JHJVOI7Q.js";
import {
  f as f2,
  l as l2,
  m as m2,
  s as s3,
  u as u2,
  v
} from "./chunk-IPCIO3PX.js";
import {
  u as u3
} from "./chunk-EIY2DYTV.js";
import {
  a2,
  l,
  m
} from "./chunk-OIIDE5GZ.js";
import {
  E,
  M,
  i,
  q,
  s as s2,
  u
} from "./chunk-3XSRVKBX.js";
import {
  d
} from "./chunk-TBSVVR6M.js";
import {
  f
} from "./chunk-QWPLZ3QH.js";
import {
  G
} from "./chunk-HLGIRLYQ.js";
import {
  g,
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  a,
  b,
  s
} from "./chunk-RFPH3ZTZ.js";
import {
  n
} from "./chunk-WGO3VFQP.js";
import {
  has,
  k,
  t2 as t
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/DirtyMap.js
var t3 = -1;
var e3 = class {
  constructor() {
    this._dirties = [{ vertexFrom: t3, vertexCount: t3, indexFrom: t3, indexCount: t3, allDirty: false }, { vertexFrom: t3, vertexCount: t3, indexFrom: t3, indexCount: t3, allDirty: false }, { vertexFrom: t3, vertexCount: t3, indexFrom: t3, indexCount: t3, allDirty: false }, { vertexFrom: t3, vertexCount: t3, indexFrom: t3, indexCount: t3, allDirty: false }, { vertexFrom: t3, vertexCount: t3, indexFrom: t3, indexCount: t3, allDirty: false }];
  }
  hasDirty() {
    return this._dirties.some((e9) => e9.indexCount !== t3 || e9.allDirty);
  }
  markAllClean() {
    for (const e9 of this._dirties)
      e9.indexFrom = t3, e9.indexCount = t3, e9.vertexFrom = t3, e9.vertexCount = t3, e9.allDirty = false;
  }
  markAllDirty() {
    for (const t8 of this._dirties)
      t8.allDirty = true;
  }
  forEach(e9) {
    for (let r6 = 0; r6 < this._dirties.length; ++r6) {
      const { indexCount: i7, indexFrom: o7, vertexCount: n6, vertexFrom: x6, allDirty: l4 } = this._dirties[r6], s8 = {};
      let d6, m5 = false;
      (l4 || x6 !== t3 && n6 > 0) && (s8.geometry = { count: n6, from: x6, allDirty: l4 }, m5 = true), (l4 || o7 !== t3 && i7 > 0) && (d6 = { count: i7, from: o7, allDirty: l4 }, m5 = true), m5 && e9({ indices: d6, vertices: s8 }, r6);
    }
  }
  markDirtyIndices(e9, r6, i7) {
    const o7 = this._dirties[e9], n6 = r6, x6 = i7;
    if (!o7.allDirty)
      if (o7.indexCount !== t3) {
        const t8 = Math.min(o7.indexFrom, n6), e10 = Math.max(o7.indexFrom + o7.indexCount, n6 + x6) - t8;
        o7.indexFrom = t8, o7.indexCount = e10;
      } else
        o7.indexFrom = n6, o7.indexCount = x6;
  }
  markDirtyVertices(e9, r6, i7, o7) {
    const n6 = this._dirties[e9], x6 = i7, l4 = o7;
    if (!n6.allDirty)
      if (n6.vertexCount !== t3) {
        const t8 = Math.min(n6.vertexFrom, x6), e10 = Math.max(n6.vertexFrom + n6.vertexCount, x6 + l4) - t8;
        n6.vertexFrom = t8, n6.vertexCount = e10;
      } else
        n6.vertexFrom = x6, n6.vertexCount = l4;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/FreeList.js
var e4 = class {
  get largestRange() {
    return this._largestRange;
  }
  constructor(e9) {
    this._largestRange = null, this._parent = e9, this._updateLargestRange();
  }
  rangeCreated(e9) {
    (!this._largestRange || e9.count > this._largestRange.count) && (this._largestRange = e9);
  }
  rangeResized(e9, t8) {
    e9 === this._largestRange ? e9.count < t8 && this._updateLargestRange() : (!this._largestRange || e9.count > this._largestRange.count) && (this._largestRange = e9);
  }
  findBestRange(e9) {
    let t8 = this._parent._freeHead, n6 = null;
    for (; null !== t8; )
      t8.count >= e9 && (!n6 || t8.count - e9 < n6.count - e9) && (n6 = t8), t8 = t8.next;
    return n6;
  }
  findAdjacentRanges(e9, t8) {
    let n6 = true, r6 = false, s8 = null, o7 = this._parent._freeHead;
    for (; n6 && !r6; ) {
      const a6 = null !== s8 ? s8.from + s8.count : 0, l4 = null !== o7 ? o7.from : this._parent._size;
      e9 >= a6 && e9 + t8 <= l4 ? (n6 = false, r6 = true) : null !== o7 ? (s8 = o7, o7 = o7.next) : n6 = false;
    }
    return [s8, o7];
  }
  _updateLargestRange() {
    let e9 = null, t8 = this._parent._freeHead;
    for (; null !== t8; )
      (!e9 || t8.count > e9.count) && (e9 = t8), t8 = t8.next;
    this._largestRange = e9;
  }
};
var t4 = class _t {
  constructor(t8, n6) {
    this._allocated = 0, this._size = t8, this._freeHead = t8 > 0 ? { from: 0, count: t8, prev: null, next: null } : null, this._bookKeeper = n6 || new e4(this), this._freeHead && this._bookKeeper.rangeCreated(this._freeHead);
  }
  allocate(e9) {
    const n6 = this._bookKeeper.findBestRange(e9);
    if (null == n6)
      return -1;
    const r6 = n6.from, s8 = n6.count;
    if (n6.from += e9, n6.count -= e9, this._bookKeeper.rangeResized(n6, r6, s8), this._allocated += e9, 0 === n6.count) {
      const e10 = null !== n6.prev ? this._freeHead : n6.next;
      _t._removeRange(n6), this._freeHead = e10;
    }
    return r6;
  }
  free(e9, n6) {
    const [r6, s8] = this._bookKeeper.findAdjacentRanges(e9, n6), o7 = { from: e9, count: n6, prev: r6 ?? null, next: s8 ?? null };
    if (null != r6 && (r6.next = o7), null != s8 && (s8.prev = o7), this._bookKeeper.rangeCreated(o7), this._allocated -= n6, null != s8 && o7.from + o7.count === s8.from) {
      const e10 = o7.from, n7 = o7.count;
      _t._fuse(o7, s8), _t._removeRange(s8), this._bookKeeper.rangeResized(o7, e10, n7), this._bookKeeper.rangeResized(s8, void 0, 0);
    }
    if (null != r6 && r6.from + r6.count === o7.from) {
      const e10 = r6.from, n7 = r6.count;
      _t._fuse(r6, o7), _t._removeRange(o7), this._bookKeeper.rangeResized(r6, e10, n7), this._bookKeeper.rangeResized(o7, void 0, 0);
    }
    this._freeHead = null !== o7.prev ? this._freeHead : o7;
  }
  get fragmentation() {
    const e9 = this._size - this._allocated;
    if (0 === e9)
      return 0;
    return 1 - this._bookKeeper.largestRange.count / e9;
  }
  static _removeRange(e9) {
    null !== e9.prev ? null !== e9.next ? (e9.prev.next = e9.next, e9.next.prev = e9.prev) : e9.prev.next = null : null !== e9.next && (e9.next.prev = null);
  }
  static _fuse(e9, t8) {
    e9.count += t8.count, e9.next = t8.next, t8.from += t8.count, t8.count = 0, null !== t8.next && (t8.next.prev = e9);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/DisplayRecordStore.js
var s5 = ["FILL", "LINE", "MARKER", "TEXT", "LABEL"];
function o2(e9) {
  const t8 = e9.getStrides(), r6 = {};
  for (let i7 = 0; i7 < t8.length; i7++)
    r6[s5[i7]] = t8[i7];
  return r6;
}
var n3 = 0.5;
var d3 = class _d {
  constructor(r6, i7, s8, o7) {
    this._strides = r6, this._displayList = i7, this._freeListsAndStorage = {}, this._dirtyMap = null, this._dirtyMap = s8;
    for (const n6 in r6) {
      this._freeListsAndStorage[n6] = { vtxFreeList: o7 ? new t4(o7) : null, idxFreeList: o7 ? new t4(o7) : null, vertexBuffers: {}, indexBuffer: o7 ? new Uint32Array(o7) : null };
      for (const e9 in r6[n6])
        this._freeListsAndStorage[n6].vertexBuffers[e9] = { data: o7 ? P(o7, r6[n6][e9]) : null, stride: r6[n6][e9] };
    }
  }
  static fromTileData(t8, i7) {
    var _a;
    const n6 = o2(t8), a6 = [0, 0, 0, 0, 0], x6 = [0, 0, 0, 0, 0];
    for (const e9 of t8.tileDisplayData.displayObjects)
      for (const t9 of e9.displayRecords)
        a6[t9.geometryType] = Math.max(a6[t9.geometryType], t9.vertexFrom + t9.vertexCount), x6[t9.geometryType] = Math.max(x6[t9.geometryType], t9.indexFrom + t9.indexCount);
    const u5 = new _d(n6, t8.tileDisplayData.displayList, i7, void 0), f8 = ((_a = t8.tileBufferData) == null ? void 0 : _a.geometries) ?? [];
    for (let o7 = 0; o7 < f8.length; ++o7) {
      const t9 = a6[o7], i8 = x6[o7], n7 = f8[o7], d6 = s5[o7], c3 = u5._storageFor(d6), l4 = f8[o7].indexBuffer;
      c3.indexBuffer = l4, c3.idxFreeList = new t4(l4.length), c3.idxFreeList.allocate(i8);
      let m5 = 0;
      for (const e9 in n7.vertexBuffer) {
        const t10 = f8[o7].vertexBuffer[e9];
        c3.vertexBuffers[e9].data = t10.data, c3.vertexBuffers[e9].stride = t10.stride;
        const i9 = F2(t10.stride), s8 = t10.data.length * i9 / t10.stride;
        m5 || (m5 = s8);
      }
      c3.vtxFreeList = new t4(m5), c3.vtxFreeList.allocate(t9);
    }
    return u5;
  }
  delete(e9) {
    const t8 = s5[e9.geometryType];
    this._freeVertices(t8, e9.vertexFrom, e9.vertexCount), this._freeIndices(t8, e9.indexFrom, e9.indexCount), this._displayList.removeFromList(e9), e9.vertexFrom = void 0, e9.indexFrom = void 0;
  }
  setMeshData(e9, t8, r6, o7, n6) {
    const d6 = s5[e9.geometryType];
    let a6, x6;
    e9.meshData = null, void 0 === e9.vertexFrom ? (x6 = t8.vertexCount, a6 = this._allocateVertices(d6, x6)) : t8.vertexCount > e9.vertexCount ? (this._freeVertices(d6, e9.vertexFrom, e9.vertexCount), x6 = t8.vertexCount, a6 = this._allocateVertices(d6, x6)) : t8.vertexCount === e9.vertexCount ? (a6 = e9.vertexFrom, x6 = e9.vertexCount) : (this._freeVertices(d6, e9.vertexFrom + t8.vertexCount, e9.vertexCount - t8.vertexCount), a6 = e9.vertexFrom, x6 = t8.vertexCount);
    let u5, f8, c3, l4 = true;
    if (void 0 === e9.indexFrom ? (u5 = n6, c3 = t8.indexCount, f8 = this._allocateIndices(d6, c3)) : t8.indexCount > e9.indexCount ? (u5 = this._displayList.removeFromList(e9), this._freeIndices(d6, e9.indexFrom, e9.indexCount), c3 = t8.indexCount, f8 = this._allocateIndices(d6, c3)) : t8.indexCount === e9.indexCount ? (l4 = false, f8 = e9.indexFrom, c3 = e9.indexCount) : (u5 = this._displayList.removeFromList(e9), this._freeIndices(d6, e9.indexFrom + t8.indexCount, e9.indexCount - t8.indexCount), f8 = e9.indexFrom, c3 = t8.indexCount), -1 !== a6 && -1 !== f8) {
      const s8 = this._storageFor(d6);
      if (j2(a6, f8, s8.vertexBuffers, s8.indexBuffer, t8, r6, o7), e9.vertexFrom = a6, e9.indexFrom = f8, e9.vertexCount = t8.vertexCount, e9.indexCount = t8.indexCount, this._dirtyMap) {
        this._dirtyMap.markDirtyIndices(e9.geometryType, e9.indexFrom, e9.indexCount);
        for (const t9 in r6)
          this._dirtyMap.markDirtyVertices(e9.geometryType, t9, e9.vertexFrom, e9.vertexCount);
      }
      return l4 && this._displayList.addToList(e9, u5), true;
    }
    return -1 !== a6 && this._freeVertices(d6, a6, x6), -1 !== f8 && this._freeIndices(d6, f8, c3), e9.setMeshDataFromBuffers(t8, r6, o7), e9.vertexFrom = void 0, e9.vertexCount = 0, e9.indexFrom = void 0, e9.indexCount = 0, false;
  }
  tryAddMeshData(e9, t8) {
    const r6 = t8.vertexBuffer, o7 = t8.indexBuffer, n6 = s5[e9.geometryType], d6 = this._allocateVertices(n6, e9.vertexCount);
    if (-1 === d6)
      return this._freeVertices(n6, d6, e9.vertexCount), false;
    const a6 = this._allocateIndices(n6, e9.indexCount);
    if (-1 === a6)
      return this._freeVertices(n6, d6, e9.vertexCount), this._freeIndices(n6, a6, e9.indexCount), false;
    const x6 = this._storageFor(n6);
    if (j2(d6, a6, x6.vertexBuffers, x6.indexBuffer, e9, r6, o7), e9.vertexFrom = d6, e9.indexFrom = a6, this._dirtyMap) {
      this._dirtyMap.markDirtyIndices(e9.geometryType, e9.indexFrom, e9.indexCount);
      for (const t9 in r6)
        this._dirtyMap.markDirtyVertices(e9.geometryType, t9, d6, e9.vertexCount);
    }
    return this._displayList.addToList(e9), true;
  }
  _allocateVertices(e9, t8) {
    var _a, _b;
    const r6 = this._storageFor(e9), i7 = (_a = r6.vtxFreeList) == null ? void 0 : _a.allocate(t8);
    if (null == i7 || -1 === i7)
      return -1;
    const s8 = (_b = r6.vtxFreeList) == null ? void 0 : _b.fragmentation;
    return null == s8 || s8 > n3 ? -1 : i7;
  }
  _freeVertices(e9, t8, r6) {
    var _a;
    const i7 = this._storageFor(e9);
    (_a = i7.vtxFreeList) == null ? void 0 : _a.free(t8, r6);
  }
  _freeIndices(e9, t8, r6) {
    var _a;
    const i7 = this._storageFor(e9);
    (_a = i7.idxFreeList) == null ? void 0 : _a.free(t8, r6);
  }
  _allocateIndices(e9, t8) {
    var _a, _b;
    const r6 = this._storageFor(e9), i7 = (_a = r6.idxFreeList) == null ? void 0 : _a.allocate(t8);
    if (null == i7 || -1 === i7)
      return -1;
    const s8 = (_b = r6.idxFreeList) == null ? void 0 : _b.fragmentation;
    return null == s8 || s8 > n3 ? -1 : i7;
  }
  _storageFor(e9) {
    return this._freeListsAndStorage[e9];
  }
  _stridesFor(e9, t8) {
    return this._strides[e9][t8];
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLBuffers.js
var o3 = class {
  constructor(a6) {
    this.geometryMap = H(() => ({ indexBuffer: h2.createIndex(a6, F.STATIC_DRAW), vao: null }), (e9, s8) => ({ vertexBuffer: h2.createVertex(a6, Y[s8]) }));
  }
  dispose() {
    var _a, _b, _c;
    for (let e9 = 0; e9 < 5; e9++) {
      const t8 = this.geometryMap[e9];
      if (t8) {
        (_a = t8.data.vao) == null ? void 0 : _a.disposeVAOOnly(), (_b = t8.data.indexBuffer) == null ? void 0 : _b.dispose();
        for (const e10 in t8.buffers)
          (_c = t8.buffers[e10]) == null ? void 0 : _c.data.vertexBuffer.dispose();
      }
    }
  }
  get(e9) {
    const t8 = this.geometryMap[e9];
    return { getVAO(e10, r6, s8) {
      if (!t8.data.vao) {
        const o7 = {};
        for (const e11 in t8.buffers)
          o7[e11] = t8.buffers[e11].data.vertexBuffer;
        t8.data.vao = new f3(e10, s8, r6, o7, t8.data.indexBuffer);
      }
      return t8.data.vao;
    } };
  }
  has(e9) {
    return null != this.geometryMap[e9];
  }
  upload(e9, t8) {
    t8.forEach((t9, r6) => {
      this._upload(t9, r6, e9);
    });
  }
  _upload(e9, t8, r6) {
    if (e9.indices && (e9.indices.allDirty ? this._uploadIndices(r6, t8) : null != e9.indices.from && null != e9.indices.count && this._uploadIndices(r6, t8, e9.indices.from, e9.indices.count)), e9.vertices) {
      const s8 = e9.vertices;
      for (const e10 in s8) {
        const a6 = s8[e10];
        a6.allDirty ? this._uploadVertices(r6, t8, e10) : null != a6.from && null != a6.count && this._uploadVertices(r6, t8, e10, a6.from, a6.count);
      }
    }
  }
  _uploadVertices(e9, t8, r6, s8, a6) {
    const o7 = this.geometryMap[t8];
    if (!o7)
      return;
    const f8 = e9.geometries[t8].vertexBuffer[r6];
    if (!f8)
      return;
    const { data: i7, stride: n6 } = f8;
    if (o7.buffers[r6] && i7.length > 0) {
      const e10 = n6 / i7.BYTES_PER_ELEMENT;
      null != s8 && null != a6 ? o7.buffers[r6].data.vertexBuffer.setSubData(i7, s8 * e10, s8 * e10, (s8 + a6) * e10) : o7.buffers[r6].data.vertexBuffer.setData(i7);
    }
  }
  _uploadIndices(e9, t8, r6, s8) {
    const a6 = this.geometryMap[t8];
    if (!a6)
      return;
    const o7 = e9.geometries[t8].indexBuffer;
    a6.data.indexBuffer && o7.length > 0 && (null != r6 && null != s8 ? a6.data.indexBuffer.setSubData(o7, r6, r6, r6 + s8) : a6.data.indexBuffer.setData(o7));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GraphicTile.js
var a5 = class extends m3 {
  constructor() {
    super(...arguments), this._data = null, this._displayList = null, this._lastCommitTime = 0, this._hasData = false, this._invalidated = false, this._wglBuffers = null, this._dirtyMap = new e3();
  }
  destroy() {
    super.destroy(), this.clear();
  }
  get hasData() {
    return !!this._hasData;
  }
  get displayObjects() {
    return this._displayObjects ?? [];
  }
  getGeometry(t8) {
    return this._wglBuffers && this._wglBuffers.has(t8) ? this._wglBuffers.get(t8) : null;
  }
  getDisplayList() {
    return this._displayList;
  }
  patch(e9) {
    var _a2, _b;
    if (true === e9.clear)
      return this.clear(), void (this._hasData = false);
    const i7 = e9.addOrUpdate, a6 = e9.remove;
    !this._data && ((_a2 = i7 == null ? void 0 : i7.tileDisplayData) == null ? void 0 : _a2.displayObjects.length) ? (i7.tileDisplayData.computeDisplayList(), this._dirtyMap = new e3(), this._dispRecStore = d3.fromTileData(i7, this._dirtyMap), this._data = i7, this._dirtyMap.markAllDirty(), this._hasData = true, e9.end && this.ready()) : this._data && (((_b = i7 == null ? void 0 : i7.tileDisplayData) == null ? void 0 : _b.displayObjects.length) || a6.length) ? this._doPatchData(e9) : e9.end && this.ready(), e9.end && !this._data && this.clear(), this.requestRender(), this.emit("change");
  }
  commit(t8) {
    t8.time && t8.time === this._lastCommitTime || (this._lastCommitTime = t8.time, this.visible && this._data && (this._wglBuffers || (this._wglBuffers = new o3(t8.context)), (this._dirtyMap.hasDirty() || this._invalidated) && (this._invalidated = false, this._wglBuffers.upload(this._data.tileBufferData, this._dirtyMap), this._displayList = this._data.tileDisplayData.displayList.clone(), this._displayObjects = this._data.tileDisplayData.displayObjects.slice(), this._dirtyMap.markAllClean())));
  }
  clear() {
    this._data = null, this._displayList = null, this._dispRecStore = null, this._wglBuffers && (this._wglBuffers.dispose(), this._wglBuffers = null);
  }
  _doPatchData(t8) {
    this._invalidated = true, this._patchData(t8) || (this._dirtyMap.markAllDirty(), this._data.reshuffle(), this._dispRecStore = d3.fromTileData(this._data, this._dirtyMap)), this.requestRender();
  }
  _patchData(t8) {
    var _a2, _b;
    let s8 = true;
    const e9 = ((_b = (_a2 = t8.addOrUpdate) == null ? void 0 : _a2.tileDisplayData) == null ? void 0 : _b.displayObjects) || [], i7 = (t8.remove || []).slice();
    for (const r6 of e9)
      null != r6.insertAfter && i7.push(r6.id);
    let a6;
    i7.length > 0 && (a6 = new Set(i7));
    const l4 = this._data.tileDisplayData;
    for (const r6 of i7) {
      const t9 = l4.displayObjectRegistry.get(r6);
      if (t9) {
        l4.displayList.removeFromList(t9.displayRecords);
        for (const s9 of t9.displayRecords)
          this._dispRecStore.delete(s9);
        l4.displayObjectRegistry.delete(r6);
      }
    }
    (a6 == null ? void 0 : a6.size) && (l4.displayObjects = l4.displayObjects.filter((t9) => !a6.has(t9.id)));
    for (const r6 of e9) {
      let e10, i8 = l4.displayObjectRegistry.get(r6.id);
      if (i8) {
        const t9 = i8.displayRecords;
        i8.set(r6), i8.displayRecords = t9;
        const s9 = i8.displayRecords.length;
        for (let e11 = 0; e11 < s9; ++e11) {
          const t10 = i8.displayRecords[e11], s10 = r6.displayRecords[e11];
          (e11 >= r6.displayRecords.length || t10.geometryType !== s10.geometryType || t10.symbolLevel !== s10.symbolLevel || t10.zOrder !== s10.zOrder || t10.materialKey !== s10.materialKey) && (this._dispRecStore.delete(i8.displayRecords[e11]), e11 < r6.displayRecords.length && (i8.displayRecords[e11] = void 0));
        }
        i8.displayRecords.length = r6.displayRecords.length;
      } else {
        let t9;
        i8 = r6.copy(), i8.displayRecords = [], l4.displayObjectRegistry.set(r6.id, i8);
        const s9 = l4.displayObjects;
        if (null != i8.insertAfter)
          if (e10 = {}, i8.insertAfter >= 0) {
            const e11 = l4.displayObjectRegistry.get(i8.insertAfter);
            e11 ? (t9 = s9.indexOf(e11) + 1, t9 < s9.length ? s9.splice(t9, 0, i8) : (s9.push(i8), t9 = s9.length)) : (s9.push(i8), t9 = s9.length);
          } else
            s9.unshift(i8), t9 = 0;
        else
          s9.push(i8), t9 = s9.length;
        if (e10) {
          const i9 = r6.displayRecords.length > 0 ? 1 : 0;
          let a8 = 0;
          for (let r7 = t9 - 1; r7 >= 0 && a8 < i9; --r7)
            for (let t10 = s9[r7].displayRecords.length - 1; t10 >= 0 && a8 < i9; --t10) {
              const i10 = s9[r7].displayRecords[t10], d6 = l4.displayList.getDPInfoType();
              e10[d6] || (e10[d6] = i10, ++a8);
            }
        }
      }
      const a7 = r6.displayRecords.length;
      for (let d6 = 0; d6 < a7; ++d6) {
        const a8 = r6.displayRecords[d6];
        let o7 = i8.displayRecords[d6];
        o7 ? (o7.meshData = a8.meshData, o7.materialKey = a8.materialKey) : (o7 = a8.copy(), o7.vertexFrom = void 0, o7.indexFrom = void 0, i8.displayRecords[d6] = o7);
        const h5 = a8.geometryType, p5 = l4.displayList.getDPInfoType(), y6 = t8.addOrUpdate.tileBufferData.geometries[h5], c3 = y6.vertexBuffer, n6 = y6.indexBuffer;
        let f8;
        e10 && (f8 = e10[p5] ? l4.displayList.splitAfter(e10[p5]) : -1), s8 = this._dispRecStore.setMeshData(o7, a8, c3, n6, f8) && s8, e10 && null != o7.indexFrom && null != o7.indexFrom && (e10[p5] = o7);
      }
    }
    return s8;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/MemoryRequirements.js
var e5 = class {
  constructor() {
    this._byGeometryType = null;
  }
  get satisfied() {
    return !this._byGeometryType;
  }
  reset() {
    this._byGeometryType = null;
  }
  verticesFor(e9) {
    return this._byGeometryType ? this._byGeometryType[e9].vertices : 0;
  }
  indicesFor(e9) {
    return this._byGeometryType ? this._byGeometryType[e9].indices : 0;
  }
  needMore(e9, t8, i7) {
    if (!t8 && !i7)
      return;
    this._byGeometryType || (this._byGeometryType = [{ vertices: 0, indices: 0 }, { vertices: 0, indices: 0 }, { vertices: 0, indices: 0 }, { vertices: 0, indices: 0 }, { vertices: 0, indices: 0 }]);
    const s8 = this._byGeometryType[e9];
    s8.vertices += t8, s8.indices += i7;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TileBufferData.js
var r3 = 5;
var f5 = class _f {
  constructor() {
    this.geometries = [{ indexBuffer: void 0, vertexBuffer: {} }, { indexBuffer: void 0, vertexBuffer: {} }, { indexBuffer: void 0, vertexBuffer: {} }, { indexBuffer: void 0, vertexBuffer: {} }, { indexBuffer: void 0, vertexBuffer: {} }];
  }
  clone() {
    const e9 = new _f();
    for (let r6 = 0; r6 < this.geometries.length; r6++) {
      const f8 = this.geometries[r6], t8 = e9.geometries[r6];
      t8.indexBuffer = f8.indexBuffer.slice(), t8.vertexBuffer = {};
      for (const e10 in f8.vertexBuffer) {
        const { data: r7, stride: i7 } = f8.vertexBuffer[e10];
        t8.vertexBuffer[e10] = { data: r7.slice(), stride: i7 };
      }
    }
    return e9;
  }
  static deserialize(t8) {
    const i7 = new _f();
    for (let f8 = 0; f8 < r3; ++f8) {
      i7.geometries[f8].indexBuffer = new Uint32Array(t8.geometries[f8].indexBuffer), i7.geometries[f8].vertexBuffer = {};
      for (const r6 in t8.geometries[f8].vertexBuffer)
        i7.geometries[f8].vertexBuffer[r6] = { data: x2(t8.geometries[f8].vertexBuffer[r6].data, t8.geometries[f8].vertexBuffer[r6].stride), stride: t8.geometries[f8].vertexBuffer[r6].stride };
    }
    return i7;
  }
  serialize() {
    const e9 = { geometries: [{ indexBuffer: this.geometries[0].indexBuffer.buffer, vertexBuffer: {} }, { indexBuffer: this.geometries[1].indexBuffer.buffer, vertexBuffer: {} }, { indexBuffer: this.geometries[2].indexBuffer.buffer, vertexBuffer: {} }, { indexBuffer: this.geometries[3].indexBuffer.buffer, vertexBuffer: {} }, { indexBuffer: this.geometries[4].indexBuffer.buffer, vertexBuffer: {} }] };
    for (let f8 = 0; f8 < r3; ++f8)
      for (const r6 in this.geometries[f8].vertexBuffer)
        e9.geometries[f8].vertexBuffer[r6] = { data: this.geometries[f8].vertexBuffer[r6].data.buffer, stride: this.geometries[f8].vertexBuffer[r6].stride };
    return e9;
  }
  getBuffers() {
    const e9 = [];
    for (let f8 = 0; f8 < r3; ++f8) {
      e9.push(this.geometries[f8].indexBuffer.buffer);
      for (const r6 in this.geometries[f8].vertexBuffer)
        e9.push(this.geometries[f8].vertexBuffer[r6].data.buffer);
    }
    return e9;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GraphicDisplayList.js
function t5(e9, t8, n6, ...o7) {
  t8 < e9.length ? e9.splice(t8, n6, ...o7) : e9.push(...o7);
}
var n4 = class _n {
  constructor() {
    this.symbolLevels = [];
  }
  replay(t8, n6, o7) {
    for (const i7 of this.symbolLevels)
      for (const r6 of i7.zLevels) {
        const i8 = r6.geometryDPInfo.unified;
        if (i8)
          for (const r7 of i8) {
            const { geometryType: i9, materialKey: l4, indexFrom: s8, indexCount: m5 } = r7, y6 = U.load(l4).symbologyType, d6 = t8.painter.getBrush(i9, y6), u5 = { geometryType: i9, materialKey: l4, indexFrom: s8, indexCount: m5, target: n6.getGeometry(i9) };
            d6.prepareState(t8), d6.drawGeometry(t8, n6, u5, o7);
          }
      }
  }
  get empty() {
    return !this.symbolLevels || 0 === this.symbolLevels.length;
  }
  clear() {
    this.symbolLevels.length = 0;
  }
  addToList(e9, t8) {
    if (Array.isArray(e9))
      for (const n6 of e9)
        this._addToList(n6, t8);
    else
      this._addToList(e9, t8);
  }
  removeFromList(e9) {
    Array.isArray(e9) || (e9 = [e9]);
    let t8 = null;
    for (const n6 of e9)
      t8 = this._removeFromList(n6);
    return t8;
  }
  clone() {
    const e9 = new _n();
    for (const t8 of this.symbolLevels)
      e9.symbolLevels.push(t8.clone());
    return e9;
  }
  splitAfter(e9) {
    const t8 = this._getDisplayList(e9.symbolLevel, e9.zOrder), n6 = t8.length, i7 = e9.indexFrom + e9.indexCount;
    for (let r6 = 0; r6 < n6; ++r6) {
      const n7 = t8[r6];
      if (n7.geometryType === e9.geometryType && i7 > n7.indexFrom && i7 <= n7.indexFrom + n7.indexCount) {
        if (i7 < n7.indexFrom + n7.indexCount) {
          const e10 = new o4();
          e10.geometryType = n7.geometryType, e10.materialKey = n7.materialKey, e10.indexFrom = i7, e10.indexCount = n7.indexFrom + n7.indexCount - i7, t8.splice(r6 + 1, 0, e10), n7.indexCount = i7 - n7.indexFrom;
        }
        return r6;
      }
    }
  }
  _addToList(e9, n6) {
    const i7 = e9.symbolLevel, r6 = e9.zOrder, l4 = this._getDisplayList(i7, r6), s8 = null != n6 ? n6 : l4.length - 1, m5 = s8 >= 0 && s8 < l4.length ? l4[s8] : null;
    if (null !== m5 && m5.materialKey === e9.materialKey && m5.indexFrom + m5.indexCount === e9.indexFrom && m5.geometryType === e9.geometryType)
      m5.indexCount += e9.indexCount;
    else {
      const n7 = new o4();
      n7.indexFrom = e9.indexFrom, n7.indexCount = e9.indexCount, n7.materialKey = e9.materialKey, n7.geometryType = e9.geometryType, t5(l4, s8 + 1, 0, n7);
    }
  }
  _removeFromList(e9) {
    const n6 = e9.symbolLevel, i7 = e9.zOrder, r6 = this._getDisplayList(n6, i7), l4 = r6.length;
    let s8;
    for (let t8 = 0; t8 < l4; ++t8) {
      const n7 = r6[t8];
      if (e9.indexFrom + e9.indexCount > n7.indexFrom && e9.indexFrom < n7.indexFrom + n7.indexCount && n7.geometryType === e9.geometryType) {
        s8 = t8;
        break;
      }
    }
    if (void 0 !== s8) {
      const n7 = r6[s8];
      if (e9.indexFrom === n7.indexFrom)
        return n7.indexCount -= e9.indexCount, n7.indexFrom += e9.indexCount, 0 === n7.indexCount && t5(r6, s8, 1), s8 - 1;
      if (e9.indexFrom + e9.indexCount === n7.indexFrom + n7.indexCount)
        return n7.indexCount -= e9.indexCount, 0 === n7.indexCount ? (t5(r6, s8, 1), s8 - 1) : s8;
      {
        const i8 = n7.indexFrom, l5 = e9.indexFrom - n7.indexFrom, m5 = e9.indexCount, y6 = n7.indexFrom + n7.indexCount - (e9.indexFrom + e9.indexCount);
        n7.indexCount = l5;
        const d6 = new o4();
        return d6.geometryType = n7.geometryType, d6.materialKey = n7.materialKey, d6.indexFrom = i8 + l5 + m5, d6.indexCount = y6, t5(r6, s8 + 1, 0, d6), s8;
      }
    }
    return null;
  }
  _getDisplayList(e9, t8) {
    let n6;
    const o7 = this.symbolLevels.length;
    for (let i7 = 0; i7 < o7; i7++)
      if (this.symbolLevels[i7].symbolLevel === e9) {
        n6 = this.symbolLevels[i7];
        break;
      }
    let s8;
    n6 || (n6 = new l3(), n6.symbolLevel = e9, this.symbolLevels.push(n6));
    const m5 = n6.zLevels.length;
    for (let i7 = 0; i7 < m5; i7++)
      if (n6.zLevels[i7].zLevel === t8) {
        s8 = n6.zLevels[i7];
        break;
      }
    return s8 || (s8 = new r4(), s8.geometryDPInfo = new i6(), s8.zLevel = t8, n6.zLevels.push(s8)), s8.geometryDPInfo.unified || (s8.geometryDPInfo.unified = []), s8.geometryDPInfo.unified;
  }
  getDPInfoType() {
    return "unified";
  }
};
var o4 = class _o {
  constructor() {
    this.materialKey = null, this.indexFrom = 0, this.indexCount = 0;
  }
  clone() {
    const e9 = new _o();
    return e9.geometryType = this.geometryType, e9.materialKey = this.materialKey, e9.indexFrom = this.indexFrom, e9.indexCount = this.indexCount, e9;
  }
};
var i6 = class _i {
  constructor() {
    this.fill = null, this.line = null, this.marker = null, this.text = null, this.label = null, this.unified = null;
  }
  clone() {
    const e9 = new _i();
    return e9.fill = this.fill && this.fill.map((e10) => e10.clone()), e9.line = this.line && this.line.map((e10) => e10.clone()), e9.marker = this.marker && this.marker.map((e10) => e10.clone()), e9.text = this.text && this.text.map((e10) => e10.clone()), e9.label = this.label && this.label.map((e10) => e10.clone()), e9.unified = this.unified && this.unified.map((e10) => e10.clone()), e9;
  }
};
var r4 = class _r {
  constructor() {
    this.geometryDPInfo = new i6();
  }
  clone() {
    const e9 = new _r();
    return e9.zLevel = this.zLevel, e9.geometryDPInfo = this.geometryDPInfo.clone(), e9;
  }
};
var l3 = class _l {
  constructor() {
    this.zLevels = [];
  }
  clone() {
    const e9 = new _l();
    e9.symbolLevel = this.symbolLevel;
    for (const t8 of this.zLevels)
      e9.zLevels.push(t8.clone());
    return e9;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/MeshData.js
var t6 = class {
  constructor() {
    this.vertexData = /* @__PURE__ */ new Map(), this.vertexCount = 0, this.indexData = [];
  }
  clear() {
    this.vertexData.clear(), this.vertexCount = 0, this.indexData = [];
  }
  update(t8, e9, a6) {
    for (const s8 in t8)
      this.vertexData.set(s8, t8[s8]);
    for (const s8 in this.vertexData)
      null === t8[s8] && this.vertexData.delete(s8);
    this.vertexCount = e9, this.indexData = a6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLDisplayRecord.js
var s6 = class _s {
  constructor(t8, e9, s8, i7 = 0, r6 = 0) {
    this.id = t8, this.geometryType = e9, this.materialKey = s8, this.minZoom = i7, this.maxZoom = r6, this.meshData = null, this.symbolLevel = 0, this.zOrder = 0, this.vertexFrom = 0, this.vertexCount = 0, this.indexFrom = 0, this.indexCount = 0, this._sortKey = null;
  }
  get sortKey() {
    return null == this._sortKey && this._computeSortKey(), this._sortKey;
  }
  clone() {
    return this.copy();
  }
  copy() {
    const t8 = new _s(this.id, this.geometryType, this.materialKey);
    return t8.vertexFrom = this.vertexFrom, t8.vertexCount = this.vertexCount, t8.indexFrom = this.indexFrom, t8.indexCount = this.indexCount, t8.zOrder = this.zOrder, t8.symbolLevel = this.symbolLevel, t8.meshData = this.meshData, t8.minZoom = this.minZoom, t8.maxZoom = this.maxZoom, t8;
  }
  setMeshDataFromBuffers(s8, i7, r6) {
    const o7 = new t6();
    for (const t8 in i7) {
      const r7 = i7[t8].stride, a6 = i7[t8].data;
      if (!a6)
        continue;
      const h5 = [], n6 = F2(r7);
      for (let t9 = 0; t9 < r7 * s8.vertexCount / n6; ++t9)
        h5[t9] = a6[t9 + r7 * s8.vertexFrom / n6];
      o7.vertexData.set(t8, h5);
    }
    o7.indexData.length = 0;
    for (let t8 = 0; t8 < s8.indexCount; ++t8)
      o7.indexData[t8] = r6[t8 + s8.indexFrom] - s8.vertexFrom;
    o7.vertexCount = s8.vertexCount, this.meshData = o7;
  }
  readMeshDataFromBuffers(s8, i7) {
    this.meshData ? this.meshData.clear() : this.meshData = new t6();
    for (const t8 in s8) {
      const i8 = s8[t8].stride, r6 = s8[t8].data, o7 = [], a6 = F2(i8);
      for (let t9 = 0; t9 < i8 * this.vertexCount / a6; ++t9)
        o7[t9] = r6[t9 + i8 * this.vertexFrom / a6];
      this.meshData.vertexData.set(t8, o7);
    }
    this.meshData.indexData.length = 0;
    for (let t8 = 0; t8 < this.indexCount; ++t8)
      this.meshData.indexData[t8] = i7[t8 + this.indexFrom] - this.vertexFrom;
    this.meshData.vertexCount = this.vertexCount;
  }
  writeMeshDataToBuffers(t8, s8, i7, r6) {
    if (this.meshData) {
      for (const i8 in s8) {
        const r7 = s8[i8].stride, o7 = this.meshData.vertexData.get(i8), a6 = s8[i8].data, h5 = F2(r7);
        for (let e9 = 0; e9 < r7 * this.meshData.vertexCount / h5; ++e9)
          a6[e9 + r7 * t8 / h5] = o7[e9];
      }
      for (let e9 = 0; e9 < this.meshData.indexData.length; ++e9)
        r6[e9 + i7] = this.meshData.indexData[e9] + t8;
      this.vertexFrom = t8, this.vertexCount = this.meshData.vertexCount, this.indexFrom = i7, this.indexCount = this.meshData.indexData.length;
    }
  }
  static writeAllMeshDataToBuffers(t8, e9, s8) {
    let i7 = 0, r6 = 0;
    for (const o7 of t8)
      o7.writeMeshDataToBuffers(i7, e9, r6, s8), i7 += o7.vertexCount, r6 += o7.indexCount;
  }
  _computeSortKey() {
    this._sortKey = (31 & this.symbolLevel) << 12 | (127 & this.zOrder) << 4 | 7 & this.geometryType;
  }
  serialize(t8) {
    return t8.push(this.geometryType), t8.push(this.materialKey), t8.push(this.vertexFrom), t8.push(this.vertexCount), t8.push(this.indexFrom), t8.push(this.indexCount), t8.push(this.minZoom), t8.push(this.maxZoom), t8;
  }
  static deserialize(t8, e9) {
    const i7 = t8.readInt32(), r6 = t8.readInt32(), o7 = new _s(e9.id, i7, r6);
    return o7.vertexFrom = t8.readInt32(), o7.vertexCount = t8.readInt32(), o7.indexFrom = t8.readInt32(), o7.indexCount = t8.readInt32(), o7.minZoom = t8.readInt32(), o7.maxZoom = t8.readInt32(), o7;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/serializationUtils.js
function e6(e9, n6) {
  if (null !== n6) {
    e9.push(n6.length);
    for (const r6 of n6)
      r6.serialize(e9);
    return e9;
  }
  e9.push(0);
}
function n5(e9, n6, r6) {
  const t8 = e9.readInt32(), o7 = new Array(t8);
  for (let i7 = 0; i7 < o7.length; i7++)
    o7[i7] = n6.deserialize(e9, r6);
  return o7;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLDisplayObject.js
var e7 = class _e {
  constructor(s8) {
    this.insertAfter = null, this.id = s8, this.displayRecords = [];
  }
  copy() {
    const s8 = new _e(this.id);
    return s8.set(this), s8;
  }
  clone() {
    const s8 = new _e(this.id);
    return s8.displayRecords = this.displayRecords.map((s9) => s9.clone()), s8.insertAfter = this.insertAfter, s8;
  }
  set(s8) {
    this.id = s8.id, this.displayRecords = s8.displayRecords, this.insertAfter = s8.insertAfter;
  }
  serialize(s8) {
    return s8.push(this.id), e6(s8, this.displayRecords), s8;
  }
  static deserialize(i7) {
    const r6 = i7.readInt32(), d6 = new _e(r6), o7 = { id: r6 };
    return d6.displayRecords = n5(i7, s6, o7) ?? [], d6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TileDisplayData.js
var e8 = class _e {
  constructor() {
    this.displayObjects = [], this._displayList = null;
  }
  get displayObjectRegistry() {
    if (!this._displayObjectRegistry) {
      this._displayObjectRegistry = /* @__PURE__ */ new Map();
      for (const s8 of this.displayObjects)
        this._displayObjectRegistry.set(s8.id, s8);
    }
    return this._displayObjectRegistry;
  }
  get displayList() {
    return this._displayList;
  }
  computeDisplayList() {
    this._displayList = new n4();
    for (const s8 of this.displayObjects)
      for (const t8 of s8.displayRecords)
        this._displayList.addToList(t8);
  }
  clone() {
    const s8 = new _e();
    return this.displayObjects && (s8.displayObjects = this.displayObjects.map((s9) => s9.clone())), s8;
  }
  serialize(s8) {
    return e6(s8, this.displayObjects), s8;
  }
  _deserializeObjects(s8) {
    const i7 = s8.readInt32(), e9 = new Array(i7), a6 = /* @__PURE__ */ new Map();
    for (let l4 = 0; l4 < e9.length; ++l4) {
      const i8 = e7.deserialize(s8);
      e9[l4] = i8, a6.set(i8.id, i8);
    }
    this.displayObjects = e9, this._displayList = null, this._displayObjectRegistry = a6;
  }
  static deserialize(s8) {
    const t8 = new _e();
    return t8._deserializeObjects(s8), t8;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/VertexBuffer.js
var t7 = class _t {
  constructor(e9, t8) {
    this.data = e9, this.stride = t8;
  }
  static decode(r6) {
    const s8 = x2(r6.data, r6.stride), n6 = r6.stride;
    return new _t(s8, n6);
  }
  static fromVertexVector(r6) {
    const s8 = x2(r6.data.buffer(), r6.stride), n6 = r6.stride;
    return new _t(s8, n6);
  }
};
var r5 = class _r {
  constructor(e9, t8, r6) {
    this.geometryType = e9, this.indexBuffer = new Uint32Array(t8), this.namedBuffers = r6;
  }
  static decode(e9) {
    const s8 = e9.geometryType, n6 = e9.indexBuffer, o7 = {};
    for (const r6 in e9.namedBuffers)
      o7[r6] = t7.decode(e9.namedBuffers[r6]);
    return new _r(s8, n6, o7);
  }
  static fromVertexData(s8, n6) {
    const o7 = s8.indices, c3 = x2(s8.vertices, s8.stride), i7 = s8.stride, d6 = { geometry: new t7(c3, i7) };
    return new _r(n6, o7, d6);
  }
  static fromVertexVectors(e9) {
    const s8 = e9.geometryType, n6 = e9.indexVector.buffer(), o7 = {};
    let c3;
    for (c3 in e9.namedVectors)
      o7[c3] = t7.fromVertexVector(e9.namedVectors[c3]);
    return new _r(s8, n6, o7);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/VertexVector.js
var s7 = class {
  get vertexCount() {
    const t8 = this.stride / 4, e9 = this.data.length / t8;
    return e9 !== (0 | e9) && console.debug("Corrupted stride"), e9;
  }
  constructor(t8, e9) {
    this.data = t8, this.stride = e9;
  }
  transfer(t8, e9) {
    const r6 = this.data.buffer();
    t8.vertexCount = this.vertexCount, t8.data = r6, t8.stride = this.stride, e9.push(r6);
  }
};
var o5 = class {
  constructor(e9, o7, n6) {
    this.geometryType = e9, this.indexVector = new e2(Uint32Array, 6 * o7), this.namedVectors = {};
    const i7 = R(e9, n6);
    for (const t8 in i7) {
      const e10 = i7[t8];
      let n7;
      switch (e10 % 4) {
        case 0:
        case 2:
          n7 = new e2(Uint32Array, e10 * o7);
          break;
        case 1:
        case 3:
          n7 = new e2(Uint8Array, e10 * o7);
      }
      this.namedVectors[t8] = new s7(n7, e10);
    }
  }
  get(t8) {
    return this.namedVectors[t8].data;
  }
  getVector(t8) {
    return this.namedVectors[t8];
  }
  transfer(t8, e9) {
    const r6 = this.indexVector.buffer(), s8 = {};
    let o7;
    for (o7 in e9.push(r6), this.namedVectors) {
      const t9 = this.namedVectors[o7];
      s8[o7] = {}, t9.transfer(s8[o7], e9);
    }
    t8.geometryType = this.geometryType, t8.indexBuffer = r6, t8.namedBuffers = s8, this.destroy();
  }
  intoBuffers() {
    const t8 = r5.fromVertexVectors(this);
    return this.destroy(), t8;
  }
  destroy() {
    this.indexVector = null, this.namedVectors = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TileData.js
var d4 = new e5();
var p2 = new e5();
var D = 5;
function h4(e9, t8) {
  const r6 = {};
  for (const s8 in e9) {
    const i7 = { data: P(t8, e9[s8]), stride: e9[s8] };
    r6[s8] = i7;
  }
  return r6;
}
function x5(e9) {
  return [e9.fill || {}, e9.line || {}, e9.icon || {}, e9.text || {}, e9.label || {}];
}
function y3(e9) {
  const t8 = [[], [], [], [], []], r6 = e9;
  for (const s8 of r6)
    for (const e10 of s8.displayRecords)
      t8[e10.geometryType].push(e10);
  return t8;
}
var B = class _B {
  constructor() {
    this.tileDisplayData = null, this.tileBufferData = null;
  }
  reshuffle() {
    var _a, _b, _c;
    if (d4.reset(), !this.tileDisplayData)
      return;
    const t8 = y3(this.tileDisplayData.displayObjects);
    for (const e9 of t8)
      for (const t9 of e9)
        t9 && d4.needMore(t9.geometryType, t9.meshData ? t9.meshData.vertexCount : t9.vertexCount, t9.meshData ? t9.meshData.indexData.length : t9.indexCount);
    const r6 = t8.length, i7 = new f5();
    for (let s8 = 0; s8 < r6; ++s8) {
      i7.geometries[s8].indexBuffer = new Uint32Array(Math.round(t * d4.indicesFor(s8)));
      const t9 = [], r7 = (_a = this.tileBufferData) == null ? void 0 : _a.geometries[s8].vertexBuffer;
      if (!r7)
        continue;
      for (const e9 in r7)
        t9.push(r7[e9].stride);
      const a6 = _B._computeVertexAlignment(t9), n7 = Math.round(t * d4.verticesFor(s8)), f9 = _B._align(n7, a6);
      for (const e9 in r7) {
        const t10 = r7[e9].stride;
        i7.geometries[s8].vertexBuffer[e9] = { stride: t10, data: P(f9, t10) };
      }
    }
    p2.reset(), (_b = this.tileDisplayData.displayList) == null ? void 0 : _b.clear();
    for (let e9 = 0; e9 < r6; ++e9) {
      const r7 = t8[e9];
      for (const t9 of r7) {
        if (t9.meshData)
          t9.writeMeshDataToBuffers(p2.verticesFor(e9), i7.geometries[e9].vertexBuffer, p2.indicesFor(e9), i7.geometries[e9].indexBuffer), t9.meshData = null;
        else {
          const r8 = (_c = this.tileBufferData) == null ? void 0 : _c.geometries[e9];
          if (r8) {
            const s8 = r8.vertexBuffer, o7 = r8.indexBuffer, n7 = i7.geometries[e9].vertexBuffer, f9 = i7.geometries[e9].indexBuffer, l4 = p2.verticesFor(e9), u5 = p2.indicesFor(e9);
            j2(l4, u5, n7, f9, t9, s8, o7), t9.vertexFrom = l4, t9.indexFrom = u5;
          }
        }
        p2.needMore(e9, t9.vertexCount, t9.indexCount);
      }
    }
    const { displayList: n6, displayObjects: f8 } = this.tileDisplayData;
    if (n6)
      for (const e9 of f8)
        n6.addToList(e9.displayRecords);
    this.tileBufferData = i7;
  }
  getStrides() {
    var _a;
    const e9 = [], t8 = (_a = this.tileBufferData) == null ? void 0 : _a.geometries;
    if (!t8)
      return e9;
    for (let r6 = 0; r6 < t8.length; ++r6) {
      const s8 = t8[r6];
      e9[r6] = {};
      for (const t9 in s8.vertexBuffer)
        e9[r6][t9] = s8.vertexBuffer[t9].stride;
    }
    return e9;
  }
  clone() {
    var _a, _b;
    const e9 = new _B();
    return e9.tileBufferData = ((_a = this.tileBufferData) == null ? void 0 : _a.clone()) ?? null, e9.tileDisplayData = ((_b = this.tileDisplayData) == null ? void 0 : _b.clone()) ?? null, e9;
  }
  _guessSize() {
    var _a;
    const e9 = ((_a = this.tileDisplayData) == null ? void 0 : _a.displayObjects) ?? [], t8 = Math.min(e9.length, 4), r6 = 12, s8 = 40;
    let i7 = 0;
    for (let o7 = 0; o7 < t8; o7++)
      i7 = Math.max(i7, e9[o7].displayRecords.length);
    return 2 * (e9.length * r6 + e9.length * i7 * s8);
  }
  serialize() {
    const e9 = this.tileBufferData.serialize(), t8 = this.tileBufferData.getBuffers(), r6 = this.tileDisplayData.serialize(new e2(Int32Array, this._guessSize())).buffer();
    return t8.push(r6), { result: { displayData: r6, bufferData: e9 }, transferList: t8 };
  }
  static fromVertexData(e9, r6) {
    const s8 = {}, i7 = /* @__PURE__ */ new Map();
    for (const t8 of r6)
      i7.set(t8.id, t8);
    return te((r7) => {
      const o7 = e9.data[r7];
      if (null != o7) {
        const e10 = r2.from(o7.records).getCursor();
        for (; e10.next(); ) {
          const t8 = e10.id, s9 = e10.materialKey, o8 = e10.indexFrom, a6 = e10.indexCount, n6 = e10.vertexFrom, l4 = e10.vertexCount, u5 = i7.get(t8), c3 = new s6(t8, r7, s9);
          c3.indexFrom = o8, c3.indexCount = a6, c3.vertexFrom = n6, c3.vertexCount = l4, u5.displayRecords.push(c3);
        }
        s8[r7] = r5.fromVertexData(o7, r7);
      } else
        s8[r7] = new o5(r7, 0, S.DEFAULT).intoBuffers();
    }), _B.fromMeshData({ displayObjects: r6, vertexBuffersMap: s8 });
  }
  static fromMeshData(e9) {
    const t8 = new _B(), r6 = new e8(), o7 = new f5();
    r6.displayObjects = e9.displayObjects;
    for (const s8 in e9.vertexBuffersMap) {
      const t9 = s8, r7 = e9.vertexBuffersMap[t9];
      o7.geometries[t9].indexBuffer = r7.indexBuffer, o7.geometries[t9].vertexBuffer = r7.namedBuffers;
    }
    return t8.tileDisplayData = r6, t8.tileBufferData = o7, t8;
  }
  static bind(e9, t8) {
    const r6 = new _B();
    return r6.tileDisplayData = e9, r6.tileBufferData = t8, r6;
  }
  static create(e9, t8) {
    const r6 = new _B();
    r6.tileDisplayData = new e8(), r6.tileDisplayData.displayObjects = e9;
    const o7 = [0, 0, 0, 0, 0], a6 = [0, 0, 0, 0, 0], n6 = [[], [], [], [], []];
    for (const s8 of e9)
      for (const e10 of s8.displayRecords)
        n6[e10.geometryType].push(e10), o7[e10.geometryType] += e10.meshData.vertexCount, a6[e10.geometryType] += e10.meshData.indexData.length;
    const l4 = new f5(), u5 = x5(t8);
    for (let s8 = 0; s8 < D; s8++) {
      const e10 = new Uint32Array(a6[s8]), t9 = h4(u5[s8], o7[s8]);
      s6.writeAllMeshDataToBuffers(n6[s8], t9, e10), l4.geometries[s8] = { indexBuffer: e10, vertexBuffer: t9 };
    }
    return r6.tileBufferData = l4, r6;
  }
  static _align(e9, t8) {
    const r6 = e9 % t8;
    return 0 === r6 ? e9 : e9 + (t8 - r6);
  }
  static _computeVertexAlignment(e9) {
    let t8 = false, r6 = false;
    for (const s8 of e9)
      s8 % 4 == 2 ? t8 = true : s8 % 4 != 0 && (r6 = true);
    return r6 ? 4 : t8 ? 2 : 1;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/GraphicsReader.js
var o6 = class _o extends h {
  static from(s8, n6, i7) {
    const c3 = S2.createInstance(), u5 = [], a6 = s8.filter((r6) => !!r6.geometry);
    for (const e9 of a6) {
      const s9 = v(e9.geometry);
      ot(u5, [e9], s9, false, false, n6);
    }
    return new _o(c3, u5, i7);
  }
  constructor(r6, t8, e9) {
    super(r6, t8, null), this._transform = e9;
  }
  get geometryType() {
    const r6 = this._current;
    return r6 ? r6.geometryType : null;
  }
  get insertAfter() {
    return this._current.insertAfter;
  }
  readGraphic() {
    return this._current;
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const r6 = new _o(this.instance, this._features, this._transform);
    return this.copyInto(r6), r6;
  }
};

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicStoreItem.js
var p3 = new t2();
var y4 = new t2();
var g3 = "esriGeometryPolyline";
function f6(t8) {
  t8.coords.length = 0, t8.lengths.length = 0;
}
var d5 = class _d {
  constructor() {
    this.bounds = u(), this.graphic = null;
  }
  static acquire(t8 = null, e9, s8, r6, i7) {
    let o7;
    return 0 === _d._pool.length ? o7 = new _d() : (o7 = _d._pool.pop(), this._set.delete(o7)), o7.acquire(t8, e9, s8, r6, i7), o7;
  }
  static release(t8) {
    t8 && !this._set.has(t8) && (t8.release(), this._pool.push(t8), this._set.add(t8));
  }
  static getCentroidQuantized(t8, e9) {
    if (f2(t8.geometry)) {
      const r6 = t8.symbol;
      if (null == r6)
        return null;
      if ((r6 == null ? void 0 : r6.layers.length) > 0 && r6.layers.some((t9) => "text" === t9.type || "marker" === t9.type)) {
        const r7 = l(t8.geometry);
        return null !== r7 ? L(e9, {}, { x: r7[0], y: r7[1] }, false, false) : null;
      }
    }
    return null;
  }
  acquire(t8 = null, e9, s8, r6, i7) {
    t8 && this.set(t8, e9, s8, r6, i7);
  }
  release() {
    this.graphic = null, this.symbolResource = null, this.geometry = null;
  }
  get symbol() {
    return this.symbolResource.symbol;
  }
  set(t8, e9, s8, r6, i7) {
    this.graphic = t8, this.geometry = s8, this.symbolResource = e9, this.bounds = r6, i7 && (this.size = i7);
  }
  getGeometryQuantized(t8, s8, r6, o7) {
    const c3 = this.geometry, d6 = v(c3);
    if (null == d6)
      return null;
    switch (d6) {
      case "esriGeometryPolygon": {
        const e9 = c3, { rings: s9 } = e9;
        if (!s9 || 0 === s9.length)
          return null;
        let r7;
        if (r7 = 1 === s9.length && 2 === s9[0].length ? d2(t8, { paths: [[s9[0][0], s9[0][1]]] }) : d2(t8, this.geometry), !r7) {
          const e10 = { x: s9[0][0][0], y: s9[0][0][1] };
          if (r7 = d2(t8, e10), r7) {
            const { x: t9, y: e11 } = r7;
            return { rings: [[[t9 - 1, e11], [1, -1], [1, 1], [-1, 1], [-1, -1]]] };
          }
        }
        return r7;
      }
      case "esriGeometryPolyline": {
        const e9 = c3;
        f6(p3), f6(y4);
        const s9 = e9.hasZ ?? false, r7 = e9.hasM ?? false;
        return C(p3, e9), dt(y4, p3, s9, r7, g3, t8.scale[0]), ht(p3, y4, s9, r7, g3, t8), $(p3, e9.hasZ ?? false, e9.hasM ?? false);
      }
      case "esriGeometryMultipoint": {
        const i7 = c3, u5 = 0.5 * o7 * Math.max(Math.abs(this.size[0]) + this.size[2] - this.size[0], Math.abs(this.size[1]) + this.size[3] - this.size[1]), h5 = G(r6);
        let a6 = i7.points;
        if (h5) {
          const [t9, r7] = h5.valid, i8 = r7 - t9;
          a6 = a6.filter((o8) => {
            if (o8[0] + u5 > r7 || o8[0] - u5 < t9) {
              const t10 = [...o8];
              return o8[0] + u5 > r7 ? t10[0] -= i8 : t10[0] += i8, q(s8, o8, u5) || q(s8, t10, u5);
            }
            return q(s8, o8, u5);
          });
        }
        return 0 === a6.length ? { points: a6 } : d2(t8, { points: a6 });
      }
    }
    return d2(t8, this.geometry);
  }
};
d5._pool = [], d5._set = /* @__PURE__ */ new Set();

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicStore.js
var m4 = { minX: 0, minY: 0, maxX: 0, maxY: 0 };
var p4 = u();
var g4 = 1e-5;
function f7(e9, t8, i7, r6, s8) {
  return m4.minX = t8, m4.minY = i7, m4.maxX = r6, m4.maxY = s8, e9.search(m4);
}
function _2(e9) {
  return { minX: e9.bounds[0], minY: e9.bounds[1], maxX: e9.bounds[2], maxY: e9.bounds[3] };
}
var b2 = class {
  constructor(e9, i7, r6, s8, o7, n6, l4) {
    this._graphics = s8, this._onAdd = o7, this._onRemove = n6, this._hashToCIM = l4, this._index = i5(9, _2), this._itemByGraphic = /* @__PURE__ */ new Map(), this._inflatedSizeHelper = new ie(), this._tileInfoView = e9, this._uidFieldName = r6;
    const u5 = e9.getClosestInfoForScale(i7);
    u5 && (this._resolution = this._tileInfoView.getTileResolution(u5.level));
  }
  setResourceManager(e9) {
    this._cimResourceManager = e9, this._hittestDrawHelper = new tt(e9);
  }
  hitTest(e9, t8, s8, o7, l4) {
    var _a;
    e9 = L2(e9, this._tileInfoView.spatialReference);
    const u5 = 0.5 * o7 * window.devicePixelRatio * s8;
    p4[0] = e9 - u5, p4[1] = t8 - u5, p4[2] = e9 + u5, p4[3] = t8 + u5;
    const h5 = 0.5 * o7 * (s8 + f4), a6 = f7(this._index, e9 - h5, t8 - h5, e9 + h5, t8 + h5);
    if (!a6 || 0 === a6.length)
      return [];
    const d6 = [], m5 = u(), g5 = u();
    for (const i7 of a6) {
      const { geometry: e10, symbolResource: t9 } = i7;
      this._getSymbolBounds(m5, t9, e10, g5, l4), g5[3] = g5[2] = g5[1] = g5[0] = 0, E(m5, p4) && ((_a = i7.graphic) == null ? void 0 : _a.visible) && d6.push(i7);
    }
    if (0 === d6.length)
      return [];
    const _3 = this._hittestDrawHelper, b3 = [];
    for (const i7 of d6) {
      const { geometry: e10, symbolResource: t9 } = i7, { hash: r6, textInfo: s9 } = t9, n6 = this._hashToCIM.get(r6);
      n6 && (_3.hitTest(p4, n6.symbol, e10, s9, l4, o7) && b3.push(i7));
    }
    return b3.sort(y5), b3.map((e10) => e10.graphic);
  }
  getGraphicsData(e9, t8, i7) {
    const r6 = this._searchForItems(t8);
    if (0 === r6.length || 0 === i7.length)
      return [];
    r6.sort((e10, t9) => e10.zorder - t9.zorder), r6[0].insertAfter = -1;
    for (let a6 = 1; a6 < r6.length; a6++)
      r6[a6].insertAfter = r6[a6 - 1].graphic.uid;
    r6.sort((e10, t9) => e10.graphic.uid - t9.graphic.uid), i7.sort((e10, t9) => e10.uid - t9.uid);
    let s8, o7 = 0, n6 = 0;
    const l4 = t8.resolution, u5 = [], h5 = { originPosition: "upperLeft", scale: [l4, l4], translate: [t8.bounds[0], t8.bounds[3]] };
    for (const c3 of i7) {
      for (n6 = -2; o7 < r6.length; )
        if (s8 = r6[o7], o7++, c3.uid === s8.graphic.uid) {
          n6 = s8.insertAfter;
          break;
        }
      if (!(s8 == null ? void 0 : s8.geometry) || -2 === n6)
        continue;
      const i8 = s8.getGeometryQuantized(h5, t8.bounds, this._tileInfoView.spatialReference, l4), d6 = { ...s8.graphic.attributes };
      d6[this._uidFieldName] = c3.uid, null == s8.groupId && (s8.groupId = e9.createTemplateGroup(s8.symbol, null)), u5.push({ centroid: d5.getCentroidQuantized(s8, h5), geometry: i8, attributes: d6, symbol: s8.symbol, groupId: s8.groupId, insertAfter: n6, zorder: s8.zorder });
    }
    return u5.sort((e10, t9) => e10.zorder - t9.zorder), u5;
  }
  queryTileData(e9, t8) {
    if (0 === this._graphics.length)
      return [];
    const { bounds: i7, resolution: r6 } = t8, s8 = this._searchForItems(t8), o7 = [];
    return 0 === s8.length || this._createTileGraphics(o7, e9, s8, { originPosition: "upperLeft", scale: [r6, r6], translate: [i7[0], i7[3]] }, t8), o7;
  }
  has(e9) {
    return this._itemByGraphic.has(e9);
  }
  getBounds(e9) {
    const t8 = this._itemByGraphic.get(e9);
    return t8 ? t8.bounds : null;
  }
  getAllBounds() {
    return Array.from(this._itemByGraphic.values()).filter((e9) => e9.graphic.visible).map((e9) => e9.bounds);
  }
  addOrModify(e9, t8, i7) {
    if (!e9 || null == t8)
      return;
    this.has(e9) && this.remove(e9), this._onAdd(e9);
    const r6 = [0, 0, 0, 0], s8 = this._getSymbolBounds(null, t8, i7, r6, 0), o7 = d5.acquire(e9, t8, i7, null != s8 ? s8 : null, r6);
    return this._itemByGraphic.set(e9, o7), i7 && this._index.insert(o7), o7.bounds;
  }
  remove(e9) {
    if (!this._itemByGraphic.has(e9))
      return;
    this._onRemove(e9);
    const t8 = this._itemByGraphic.get(e9);
    (t8 == null ? void 0 : t8.bounds) && this._index.remove(t8), this._itemByGraphic.delete(e9);
  }
  updateZ() {
    const e9 = this._graphics.items;
    let t8, i7;
    for (let r6 = 0; r6 < e9.length; r6++)
      i7 = e9[r6], t8 = this._itemByGraphic.get(i7), t8 && (t8.zorder = r6);
  }
  update(e9, t8, i7) {
    const r6 = this._itemByGraphic.get(e9);
    r6.groupId = null;
    const o7 = i(r6.bounds);
    this._index.remove(r6);
    const n6 = this._getSymbolBounds(r6.bounds, t8, i7, r6.size, 0);
    return null != n6 && r6.set(e9, t8, i7, n6, r6.size), i7 && this._index.insert(r6), { oldBounds: o7, newBounds: r6.bounds };
  }
  updateLevel(e9) {
    if (this._resolution === e9)
      return;
    this._resolution = e9, this._index.clear();
    const t8 = this._itemByGraphic, i7 = [];
    for (const [r6, s8] of t8) {
      const e10 = this._getSymbolBounds(s8.bounds, s8.symbolResource, s8.geometry, s8.size, 0);
      s8.geometry && null != e10 && (s8.bounds = e10, i7.push(s8));
    }
    this._index.load(i7);
  }
  clear() {
    this._itemByGraphic.clear(), this._index.clear();
  }
  _createTileGraphics(e9, t8, i7, r6, s8) {
    const o7 = this._uidFieldName, n6 = this._tileInfoView.spatialReference, { bounds: l4, resolution: u5 } = s8;
    let h5, c3, d6, m5;
    i7.sort((e10, t9) => e10.zorder - t9.zorder);
    for (let p5 = 0; p5 < i7.length; p5++) {
      d6 = i7[p5], h5 = d6.graphic, c3 = d6.getGeometryQuantized(r6, l4, n6, u5), m5 = 0 === p5 ? -1 : i7[p5 - 1].graphic.uid;
      const s9 = { ...d6.graphic.attributes };
      s9[o7] = h5.uid, null == d6.groupId && (d6.groupId = t8.createTemplateGroup(d6.symbol, null)), e9.push({ centroid: d5.getCentroidQuantized(d6, r6), geometry: c3, attributes: s9, symbol: d6.symbol, groupId: d6.groupId, insertAfter: m5, zorder: d6.zorder });
    }
  }
  _searchForItems(e9) {
    const t8 = this._tileInfoView.spatialReference, r6 = e9.bounds, s8 = G(t8);
    if (s8 && t8.isWrappable) {
      const [t9, o7] = s8.valid, n6 = Math.abs(r6[2] - o7) < g4, l4 = Math.abs(r6[0] - t9) < g4;
      if ((!n6 || !l4) && (n6 || l4)) {
        const s9 = e9.resolution;
        let l5;
        l5 = u(n6 ? [t9, r6[1], t9 + s9 * f4, r6[3]] : [o7 - s9 * f4, r6[1], o7, r6[3]]);
        const u5 = f7(this._index, r6[0], r6[1], r6[2], r6[3]), h5 = f7(this._index, l5[0], l5[1], l5[2], l5[3]);
        return [.../* @__PURE__ */ new Set([...u5, ...h5])];
      }
    }
    return f7(this._index, r6[0], r6[1], r6[2], r6[3]);
  }
  _getSymbolBounds(t8, r6, s8, n6, l4) {
    if (!r6 || !r6.symbol || !s8)
      return null;
    if (t8 || (t8 = u()), a2(t8, s8), !n6 || 0 === n6[0] && 0 === n6[1] && 0 === n6[2] && 0 === n6[3]) {
      const { hash: t9, textInfo: i7 } = r6, s9 = this._hashToCIM.get(t9);
      if (!s9)
        return null;
      n6 || (n6 = [0, 0, 0, 0]);
      const o7 = this._inflatedSizeHelper.getSymbolInflateSize(n6, s9.symbol, this._cimResourceManager, l4, i7);
      n6[0] = u3(o7[0]), n6[1] = u3(o7[1]), n6[2] = u3(o7[2]), n6[3] = u3(o7[3]);
    }
    const u5 = this._resolution, a6 = ie.safeSize(n6);
    return t8[0] -= a6 * u5, t8[1] -= a6 * u5, t8[2] += a6 * u5, t8[3] += a6 * u5, t8;
  }
};
var y5 = (e9, t8) => {
  const i7 = h3(e9.graphic), r6 = h3(t8.graphic);
  return i7 === r6 ? t8.zorder - e9.zorder : i7 - r6;
};

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicsView2D.js
var te3 = has("esri-2d-graphic-debug");
function ie2(e9, t8, i7) {
  let s8 = i7.get(e9);
  return s8 || (s8 = { tile: t8, addedOrModified: [], removed: [] }, i7.set(e9, s8)), s8;
}
var se = class extends s4(g) {
  constructor(e9) {
    super(e9), this._storage = new r(), this._displayIds = /* @__PURE__ */ new Map(), this._controller = new AbortController(), this._tiles = /* @__PURE__ */ new Map(), this._graphicStoreUpdate = false, this._graphicsSet = /* @__PURE__ */ new Set(), this._matcher = Promise.resolve(null), this._tileUpdateSet = /* @__PURE__ */ new Set(), this._tilesToUpdate = /* @__PURE__ */ new Map(), this._graphicIdToAbortController = /* @__PURE__ */ new Map(), this._attached = false, this._updatingGraphicsTimer = null, this._hashToExpandedSymbol = /* @__PURE__ */ new Map(), this._hashToExpandedSymbolPromise = /* @__PURE__ */ new Map(), this._hashToCIMSymbolPromise = /* @__PURE__ */ new Map(), this._hashToCIM = /* @__PURE__ */ new Map(), this._processing = false, this._needsProcessing = false, this._pendingUpdate = { added: /* @__PURE__ */ new Set(), updated: /* @__PURE__ */ new Set(), removed: /* @__PURE__ */ new Set() }, this.lastUpdateId = -1, this.renderer = null, this.updateRequested = false, this.defaultPointSymbolEnabled = true, this.graphicUpdateHandler = this.graphicUpdateHandler.bind(this);
  }
  destroy() {
    this._updatingGraphicsTimer && (clearTimeout(this._updatingGraphicsTimer), this._updatingGraphicsTimer = null, this.notifyChange("updating")), this._controller.abort(), this.container.destroy(), this._set("graphics", null), this._graphicStore.clear(), this._attributeStore = null, this._hashToExpandedSymbol.clear(), this.view = null, this.renderer = null, this._hashToCIM.clear(), this._hashToCIMSymbolPromise.clear(), this._hashToExpandedSymbolPromise.clear();
  }
  _createMatcher(e9, t8, i7) {
    if (e9) {
      const s8 = T(e9), r6 = _({ indexCount: 0, fields: {} }, "feature", e9, s8);
      this._matcher = o(r6, t8, null, i7);
    }
  }
  _createDisplayId(e9) {
    let t8 = this._displayIds.get(e9);
    return t8 || (t8 = this._storage.createDisplayId(), this._displayIds.set(e9, t8)), t8;
  }
  initialize() {
    this._attributeStore = new k2({ type: "local", initialize: (e10) => Promise.resolve(this.container.attributeView.initialize(e10)), update: (e10) => this.container.attributeView.requestUpdate(e10), render: () => this.container.requestRender() }, n2("2d")), this.container.checkHighlight = () => this._attributeStore.hasHighlight;
    const e9 = (e10) => {
      this._createDisplayId(e10.uid), this._setFilterState(e10.uid, e10.visible);
    }, t8 = (e10) => {
      const t9 = this._displayIds.get(e10.uid);
      this._displayIds.delete(e10.uid), this._storage.releaseDisplayId(t9);
    }, i7 = new x3(this.container.getMaterialItems.bind(this.container), this.view.featuresTilingScheme.tileInfo);
    this._graphicStore = new b2(this.view.featuresTilingScheme, this.view.state.scale, this.uid, this.graphics, e9, t8, this._hashToCIM), this._meshFactory = new a3(null, this.uid, i7), this._templateStore = i7, this.addHandles([d(() => this._effectiveRenderer, (e10) => {
      this._createMatcher(e10, i7, this.container.stage.resourceManager);
      for (const t9 of this.graphics)
        this._pendingUpdate.updated.add(t9);
      this.requestUpdate();
    }), this.view.graphicsTileStore.on("update", this._onTileUpdate.bind(this)), this.container.on("attach", () => {
      te3 && this.container.enableRenderingBounds(() => this._graphicStore.getAllBounds()), this.graphics.items.length > 0 && this._graphicsChangeHandler({ target: this.graphics, added: this.graphics.items, removed: [], moved: [] }), this.addHandles(this.graphics.on("change", (e11) => this._graphicsChangeHandler(e11)), "graphics");
      const e10 = this.container.stage.resourceManager;
      this._createMatcher(this._effectiveRenderer, i7, e10), this._graphicStore.setResourceManager(e10), this._attached = true, this.notifyChange("updating");
    })]);
    const s8 = this.view.graphicsTileStore.tiles;
    this._onTileUpdate({ added: s8, removed: [] });
  }
  get _effectiveRenderer() {
    return "function" == typeof this.renderer ? this.renderer() : this.renderer;
  }
  get updating() {
    var _a;
    return !this._attached || null !== this._updatingGraphicsTimer || this._pendingUpdate.added.size > 0 || this._pendingUpdate.removed.size > 0 || this._pendingUpdate.updated.size > 0 || this._tileUpdateSet.size > 0 || this._tilesToUpdate.size > 0 || ((_a = this._attributeStore) == null ? void 0 : _a.updatingHandles.updating) || this._processing;
  }
  hitTest(e9) {
    if (!this.view || this.view.suspended)
      return [];
    const { resolution: t8, rotation: i7 } = this.view.state;
    return this._graphicStore.hitTest(e9.x, e9.y, 2, t8, i7);
  }
  update(e9) {
    s(this._controller.signal);
    const t8 = e9.state, { resolution: i7 } = t8;
    if (this._graphicStore.updateLevel(i7), this._graphicStoreUpdate = true, this.updateRequested = false, this._pendingUpdate.updated.size > 0) {
      if (!this._processing)
        return void this._updateGraphics();
      this._needsProcessing = true;
    }
  }
  viewChange() {
    this.requestUpdate();
  }
  requestUpdate() {
    this.updateRequested || (this.updateRequested = true, this.requestUpdateCallback());
  }
  processUpdate(e9) {
    this.updateRequested && (this.updateRequested = false, this.update(e9));
  }
  graphicUpdateHandler(e9) {
    const { graphic: t8, property: i7 } = e9;
    switch (i7) {
      case "attributes":
      case "geometry":
      case "symbol":
        this._pendingUpdate.updated.add(t8), this.requestUpdate();
        break;
      case "visible":
        this._setFilterState(t8.uid, t8.visible), this._attributeStore.sendUpdates();
    }
  }
  setHighlight(e9) {
    const t8 = e9.map((e10) => this._displayIds.get(e10)).filter(k);
    this._attributeStore.setHighlight(e9, t8);
  }
  _getIntersectingTiles(e9) {
    const t8 = this._graphicStore.getBounds(e9);
    if (!t8 || 0 === M(t8) || 0 === s2(t8))
      return [];
    const i7 = g2(t8, this.view.spatialReference);
    return null != i7 ? [.../* @__PURE__ */ new Set([...this.view.graphicsTileStore.boundsIntersections(i7[0]), ...this.view.graphicsTileStore.boundsIntersections(i7[1])])] : this.view.graphicsTileStore.boundsIntersections(t8);
  }
  async _updateTile(e9) {
    s(this._controller.signal);
    const t8 = e9.tile, i7 = this._getGraphicsData(this._templateStore, t8, e9.addedOrModified), s8 = await this._processGraphics(t8, i7);
    return s(this._controller.signal), this._patchTile(t8.key, { type: "update", addOrUpdate: s8, remove: e9.removed, end: true, clear: false, sort: false }), s8;
  }
  _patchTile(e9, t8) {
    const i7 = this._tiles.get(e9);
    i7 && (this.container.onTileData(i7, t8), this.container.requestRender());
  }
  _graphicsChangeHandler(e9) {
    const t8 = this._pendingUpdate;
    for (const i7 of e9.added)
      t8.added.add(i7);
    for (const i7 of e9.moved)
      t8.updated.add(i7);
    for (const i7 of e9.removed)
      this._pendingUpdate.added.has(i7) ? t8.added.delete(i7) : t8.removed.add(i7);
    this._processing ? this._needsProcessing = true : this._updateGraphics();
  }
  _getGraphicsToUpdate() {
    const e9 = { added: [], removed: [], updated: [] };
    if (!this.graphics)
      return e9;
    const t8 = this._pendingUpdate;
    for (const i7 of this.graphics.items)
      t8.added.has(i7) ? e9.added.push(i7) : t8.updated.has(i7) && e9.updated.push(i7);
    for (const i7 of t8.removed)
      this._graphicStore.has(i7) && e9.removed.push(i7);
    return t8.added.clear(), t8.removed.clear(), t8.updated.clear(), e9;
  }
  async _updateGraphics() {
    this._processing = true;
    const { added: e9, removed: t8, updated: i7 } = this._getGraphicsToUpdate(), s8 = this._tilesToUpdate;
    let r6;
    try {
      if (!this._graphicStoreUpdate) {
        const e10 = this.view.state, { resolution: t9 } = e10;
        this._graphicStore.updateLevel(t9);
      }
      const o7 = [], a6 = new Array(e9.length + t8.length);
      for (let e10 = 0; e10 < i7.length; e10++) {
        const t9 = i7[e10], n7 = this._getIntersectingTiles(t9);
        for (const e11 of n7) {
          r6 = e11.id;
          ie2(r6, e11, s8).removed.push(this._displayIds.get(t9.uid));
        }
        o7.push(this._updateGraphic(t9, null)), a6[e10] = t9;
      }
      const n6 = i7.length;
      for (let t9 = 0; t9 < e9.length; t9++) {
        const i8 = e9[t9];
        a6[n6 + t9] = i8, this._graphicsSet.add(i8), o7.push(this._addGraphic(i8));
      }
      for (const e10 of t8) {
        this._abortProcessingGraphic(e10.uid);
        const t9 = this._getIntersectingTiles(e10);
        for (const i8 of t9) {
          r6 = i8.id;
          ie2(r6, i8, s8).removed.push(this._displayIds.get(e10.uid));
        }
        this._graphicsSet.delete(e10), this._graphicStore.remove(e10);
      }
      let h5;
      this._flipUpdatingGraphics(), await Promise.all(o7);
      for (let e10 = 0; e10 < a6.length; e10++) {
        h5 = a6[e10];
        const t9 = this._getIntersectingTiles(h5);
        for (const e11 of t9) {
          r6 = e11.id;
          ie2(r6, e11, s8).addedOrModified.push(h5);
        }
      }
      this._graphicStore.updateZ();
      const l4 = [];
      for (const [e10, t9] of s8)
        l4.push(this._updateTile(t9));
      await Promise.all(l4);
    } catch (o7) {
      b(o7), 0;
    }
    for (const a6 of t8)
      try {
        const e10 = await this._getSymbolForGraphic(a6, null);
        if (e10) {
          const t9 = e10.hash();
          this._hashToExpandedSymbol.delete(t9);
        }
      } catch (o7) {
        b(o7), 0;
      }
    s8.clear(), this.notifyChange("updating"), this._processing = false, this._needsProcessing && (this._needsProcessing = false, this._updateGraphics());
  }
  _getArcadeInfo(e9) {
    const t8 = (e9.attributes ? Object.keys(e9.attributes) : []).map((t9) => ({ name: t9, alias: t9, type: "string" == typeof e9.attributes[t9] ? "esriFieldTypeString" : "esriFieldTypeDouble" }));
    return null == e9.geometry ? null : { geometryType: v(e9.geometry), spatialReference: f.fromJSON(e9.geometry.spatialReference), fields: t8 };
  }
  _getSymbolForGraphic(e9, t8) {
    return s(this._controller.signal), null != e9.symbol ? Promise.resolve(e9.symbol) : null != this._effectiveRenderer ? this._effectiveRenderer.getSymbolAsync(e9, { scale: this.view.state.scale, signal: null != t8 ? t8.signal : null }) : Promise.resolve(this._getNullSymbol(e9));
  }
  _getCIMSymbol(e9, t8, i7) {
    let s8 = this._hashToCIM.get(t8);
    if (s8)
      return Promise.resolve(s8);
    const r6 = te2(e9);
    if (null != r6) {
      if ("CIMSymbolReference" === r6.type)
        return s8 = r6, this._hashToCIM.set(t8, s8), Promise.resolve(s8);
      let e10 = this._hashToCIMSymbolPromise.get(t8);
      return e10 || (e10 = r6.fetchCIMSymbol(i7).then((e11) => (this._hashToCIM.set(t8, e11.data), this._hashToCIMSymbolPromise.delete(t8), e11)).catch((e11) => (this._hashToCIMSymbolPromise.delete(t8), a(e11), null)), this._hashToCIMSymbolPromise.set(t8, e10), e10);
    }
    return Promise.resolve(null);
  }
  _expandCIMSymbol(e9, t8, i7, s8) {
    const r6 = this._hashToExpandedSymbol.get(i7);
    if (r6)
      return Promise.resolve(r6);
    let o7 = this._hashToExpandedSymbolPromise.get(i7);
    if (o7)
      return o7;
    const a6 = this.container.stage, n6 = this._getArcadeInfo(t8), h5 = T(null), l4 = i4(e9, h5);
    return o7 = i3(l4, n6, a6.resourceManager, s8), this._hashToExpandedSymbolPromise.set(i7, o7), o7.then((e10) => (this._hashToExpandedSymbol.set(i7, e10), this._hashToExpandedSymbolPromise.delete(i7), e10)), o7;
  }
  async _getSymbolResources(e9, t8) {
    s(this._controller.signal);
    return this.container.stage ? this._getSymbolForGraphic(e9, t8).then((i7) => {
      if (!i7)
        return null;
      const r6 = i7.hash();
      return this._getCIMSymbol(i7, r6, t8).then((a6) => null == a6 ? null : this._expandCIMSymbol(a6, e9, r6, t8).then((e10) => {
        const t9 = e10.layers.filter((e11) => "text" === e11.type && "string" == typeof e11.text);
        if (t9 && t9.length > 0) {
          const a7 = new Array(t9.length);
          for (let e11 = 0; e11 < t9.length; e11++) {
            const r7 = t9[e11], o7 = [], [n7] = i2(r7.text);
            r7.text = n7, "text" === i7.type && (r7.lineWidth = i7.lineWidth);
            for (let e12 = 0; e12 < n7.length; e12++)
              o7.push(n7.charCodeAt(e12));
            a7[e11] = { symbol: r7, id: e11, glyphIds: o7 };
          }
          const n6 = /* @__PURE__ */ new Map();
          return this.container.getMaterialItems(a7).then((i8) => {
            n(i8);
            for (let e11 = 0; e11 < t9.length; e11++) {
              const s8 = t9[e11];
              n6.set(s8.cim, { text: s8.text, mosaicItem: i8[e11].mosaicItem });
            }
            return { symbol: e10, textInfo: n6, hash: r6 };
          });
        }
        return { symbol: e10, hash: r6 };
      }));
    }).catch((e10) => (a(e10), null)) : null;
  }
  async _projectAndNormalizeGeometry(e9, t8) {
    if (s(this._controller.signal), null == e9.geometry || "mesh" === e9.geometry.type)
      return null;
    let i7 = e9.geometry;
    if (f2(i7)) {
      const e10 = i7.rings;
      i7.rings = e10;
    } else if (s3(i7)) {
      const e10 = i7.paths;
      i7.paths = e10;
    } else if (m2(i7)) {
      const s9 = await this._getSymbolForGraphic(e9, t8);
      if (s(this._controller.signal), s9 && (p(s9.type) || u4(s9.type))) {
        i7 = i7.center;
      } else
        i7 = x4(i7);
    }
    await x(i7.spatialReference, this.view.spatialReference);
    const s8 = a4(i7), r6 = j(s8, i7.spatialReference, this.view.spatialReference);
    return r6 && m(r6), r6;
  }
  _onTileUpdate(e9) {
    const t8 = G(this.view.spatialReference);
    if (e9.added && e9.added.length > 0)
      for (const i7 of e9.added)
        this._addNewTile(i7, t8);
    if (e9.removed && e9.removed.length > 0)
      for (const i7 of e9.removed)
        this._removeTile(i7.key);
  }
  async _addGraphic(e9) {
    this._abortProcessingGraphic(e9.uid), s(this._controller.signal);
    const t8 = new AbortController();
    this._graphicIdToAbortController.set(e9.uid, t8);
    const i7 = { signal: t8.signal };
    try {
      await this._addOrUpdateGraphic(e9, i7), s(this._controller.signal), this._graphicIdToAbortController.delete(e9.uid);
    } catch (s8) {
      if (this._graphicIdToAbortController.delete(e9.uid), !b(s8))
        throw s8;
    }
  }
  _updateGraphic(e9, t8) {
    s(this._controller.signal);
    const i7 = this._projectAndNormalizeGeometry(e9, t8), s8 = this._getSymbolResources(e9, t8);
    return Promise.all([i7, s8]).then(([t9, i8]) => {
      s(this._controller.signal), this._graphicStore.addOrModify(e9, i8, t9);
    });
  }
  _addOrUpdateGraphic(e9, t8) {
    s(this._controller.signal);
    const i7 = this._projectAndNormalizeGeometry(e9, t8), s8 = this._getSymbolResources(e9, t8);
    return Promise.all([i7, s8]).then(([t9, i8]) => {
      s(this._controller.signal), this._graphicsSet.has(e9) && this._graphicStore.addOrModify(e9, i8, t9);
    });
  }
  _addTile(e9) {
    const t8 = this.view.featuresTilingScheme.getTileBounds(u(), e9), i7 = this.view.featuresTilingScheme.getTileResolution(e9.level), s8 = new a5(e9, i7, t8[0], t8[3]);
    return this._tiles.set(e9, s8), this.container.addChild(s8), s8;
  }
  async _addNewTile(e9, t8) {
    const i7 = this._addTile(e9.key), s8 = this._graphicStore.queryTileData(this._templateStore, e9);
    if (0 === s8.length)
      return;
    if (t8) {
      const i8 = Math.round((t8.valid[1] - t8.valid[0]) / e9.resolution);
      for (const e10 of s8)
        e10.geometry && (l2(e10.geometry) || u2(e10.geometry)) && this._wrapPoints(e10, i8);
    }
    const r6 = e9.key;
    this._tileUpdateSet.add(e9.key), this.notifyChange("updating");
    try {
      const t9 = { type: "update", clear: false, addOrUpdate: await this._processGraphics(e9, s8), remove: [], end: true, sort: false };
      i7.patch(t9), this._tileUpdateSet.delete(r6), this.notifyChange("updating");
    } catch (o7) {
      if (this._tileUpdateSet.delete(r6), this.notifyChange("updating"), !b(o7))
        throw o7;
    }
  }
  _removeTile(e9) {
    if (!this._tiles.has(e9))
      return;
    const t8 = this._tiles.get(e9);
    this.container.removeChild(t8), t8.destroy(), this._tiles.delete(e9);
  }
  _setFilterState(e9, t8) {
    const i7 = this._displayIds.get(e9), s8 = this._attributeStore.getHighlightFlag(e9);
    this._attributeStore.setData(i7, 0, 0, s8 | (t8 ? X : 0));
  }
  _getGraphicsData(e9, t8, i7) {
    const s8 = this.view, r6 = G(s8.spatialReference), o7 = this._graphicStore.getGraphicsData(e9, t8, i7);
    if (r6) {
      const e10 = Math.round((r6.valid[1] - r6.valid[0]) / t8.resolution);
      for (const t9 of o7)
        t9.geometry && (l2(t9.geometry) || u2(t9.geometry)) && this._wrapPoints(t9, e10);
    }
    return o7;
  }
  _wrapPoints(e9, t8) {
    const i7 = e9.geometry;
    u2(i7) ? this._wrapMultipoint(i7, t8) : this._wrapPoint(e9, t8);
  }
  _wrapMultipoint(e9, t8) {
    const i7 = e9.points, s8 = [];
    let r6 = 0, o7 = 0;
    for (const [a6, n6] of i7) {
      if (s8.push([a6 + r6, n6]), r6 = 0, t8 === c2) {
        const e10 = 5 * f4;
        a6 + o7 < e10 ? (s8.push([t8, 0]), r6 = -t8) : a6 + o7 > c2 - e10 && (s8.push([-t8, 0]), r6 = t8);
      } else
        a6 + o7 < -f4 ? (s8.push([t8, 0]), r6 = -t8) : a6 + o7 > c2 + f4 && (s8.push([-t8, 0]), r6 = t8);
      o7 += a6;
    }
    e9.points = s8;
  }
  _wrapPoint(e9, t8) {
    const i7 = e9.geometry;
    if (t8 === c2) {
      const s8 = 5 * f4;
      i7.x < s8 ? e9.geometry = { points: [[i7.x, i7.y], [t8, 0]] } : i7.x > c2 - s8 && (e9.geometry = { points: [[i7.x, i7.y], [-t8, 0]] });
    } else
      i7.x < -f4 ? e9.geometry = { points: [[i7.x, i7.y], [t8, 0]] } : i7.x > c2 + f4 && (e9.geometry = { points: [[i7.x, i7.y], [-t8, 0]] });
  }
  _processGraphics(e9, t8, i7) {
    if (!(t8 && t8.length) || !this._meshFactory)
      return Promise.resolve(null);
    const s8 = o6.from(t8, this.uid, e9.transform), r6 = this._meshFactory;
    return this._matcher.then((t9) => r6.analyzeGraphics(s8, this.container.stage.resourceManager, t9, null, null, i7).then(() => (this._attributeStore.sendUpdates(), this._processAnalyzedGraphics(e9, s8))));
  }
  _processAnalyzedGraphics(e9, t8) {
    const i7 = this._meshFactory, s8 = t8.getSize(), r6 = t8.getCursor(), o7 = { features: s8, records: s8, metrics: 0 }, a6 = new E2(e9.key.id, o7, S.DEFAULT, false, false), n6 = [];
    for (; r6.next(); ) {
      const t9 = r6.readGraphic();
      t9.insertAfter = -1 === t9.insertAfter ? -1 : this._displayIds.get(t9.insertAfter), t9.displayId = this._displayIds.get(t9.attributes[this.uid]);
      const s9 = new e7(t9.displayId);
      s9.insertAfter = t9.insertAfter, n6.push(s9), i7.writeGraphic(a6, r6, e9.level, this.container.stage.resourceManager);
    }
    const h5 = e9.tileInfoView.tileInfo.isWrappable, l4 = a6.serialize(h5);
    if (1 !== l4.length)
      return new B();
    const d6 = l4[0].message;
    return B.fromVertexData(d6, n6);
  }
  _abortProcessingGraphic(e9) {
    var _a;
    (_a = this._graphicIdToAbortController.get(e9)) == null ? void 0 : _a.abort();
  }
  _getNullSymbol(e9) {
    const t8 = e9.geometry;
    return s3(t8) ? O : f2(t8) || m2(t8) ? y2 : this.defaultPointSymbolEnabled ? N : null;
  }
  _flipUpdatingGraphics() {
    this._updatingGraphicsTimer && clearTimeout(this._updatingGraphicsTimer), this._updatingGraphicsTimer = setTimeout(() => {
      this._updatingGraphicsTimer = null, this.notifyChange("updating");
    }, 160), this.notifyChange("updating");
  }
};
e([y()], se.prototype, "_effectiveRenderer", null), e([y({ constructOnly: true })], se.prototype, "requestUpdateCallback", void 0), e([y()], se.prototype, "container", void 0), e([y({ constructOnly: true })], se.prototype, "graphics", void 0), e([y()], se.prototype, "renderer", void 0), e([y()], se.prototype, "updating", null), e([y()], se.prototype, "view", void 0), e([y()], se.prototype, "updateRequested", void 0), e([y()], se.prototype, "defaultPointSymbolEnabled", void 0), se = e([c("esri.views.2d.layers.support.GraphicsView2D")], se);
var re = se;

export {
  re
};
//# sourceMappingURL=chunk-FK3SCHPC.js.map
