import {
  $ as $2,
  C,
  L,
  W,
  f as f2,
  m,
  o,
  p2,
  s as s2
} from "./chunk-W24NOO6R.js";
import "./chunk-JZRUQED2.js";
import {
  D
} from "./chunk-3SRIDUXT.js";
import "./chunk-2SW44O36.js";
import {
  An
} from "./chunk-HRWSEGD5.js";
import "./chunk-TUPLUDES.js";
import "./chunk-4LO4DQ7K.js";
import "./chunk-7QTR2TBZ.js";
import "./chunk-6643GOM6.js";
import {
  N
} from "./chunk-Z3CHIB6Q.js";
import {
  $,
  F2 as F,
  G2 as G,
  H,
  Ie,
  M2 as M,
  Ne,
  O2 as O,
  P2 as P,
  R,
  U,
  a,
  ce,
  e,
  fe,
  n,
  ne,
  pe,
  q,
  r,
  r2,
  s,
  s3,
  se,
  u,
  v2 as v,
  w,
  z
} from "./chunk-24PJGGGS.js";
import "./chunk-IHXVTF6I.js";
import "./chunk-747B2TEO.js";
import "./chunk-4NEWABLH.js";
import "./chunk-FW2Y26A2.js";
import "./chunk-5WG7GACT.js";
import "./chunk-W4QVNWBV.js";
import "./chunk-XN6LAULS.js";
import "./chunk-CKGVKMVG.js";
import "./chunk-RP5SAUAF.js";
import "./chunk-GAJBN4TM.js";
import "./chunk-IYXYJAVC.js";
import "./chunk-NCLD32JB.js";
import "./chunk-24NOAXOQ.js";
import "./chunk-IRNKV32L.js";
import "./chunk-GAWSWBHO.js";
import "./chunk-SZAJDZCO.js";
import "./chunk-3DSKWYU4.js";
import "./chunk-ZZYUEH57.js";
import "./chunk-VTWXDFFD.js";
import "./chunk-IPCIO3PX.js";
import "./chunk-V2RPSCV3.js";
import "./chunk-OIIDE5GZ.js";
import "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import "./chunk-H7BKONNV.js";
import "./chunk-K6C6RVSV.js";
import "./chunk-KBJ5Z4R2.js";
import "./chunk-FN47E7YK.js";
import "./chunk-XZS3Q5K4.js";
import "./chunk-WZPOQGKL.js";
import "./chunk-CCXEAKIM.js";
import "./chunk-Y5D433JZ.js";
import {
  p
} from "./chunk-QNOCEWCR.js";
import "./chunk-WURET5CW.js";
import {
  f
} from "./chunk-QWPLZ3QH.js";
import "./chunk-HLGIRLYQ.js";
import "./chunk-N2K4VRZH.js";
import "./chunk-WL4VPODY.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import "./chunk-LXXF7K7W.js";
import "./chunk-SBW6NNVI.js";
import "./chunk-62CXLI6S.js";
import "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import "./chunk-WJ3HJKNC.js";
import "./chunk-4V6374PV.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/arcade/arcadeAsyncRuntime.js
function q2(e2) {
  return e2 && "function" == typeof e2.then;
}
var T = 100;
async function W2(e2, t) {
  const n2 = [];
  for (let r3 = 0; r3 < t.arguments.length; r3++)
    n2.push(await H2(e2, t.arguments[r3]));
  return n2;
}
async function V(e2, t, n2) {
  if (true === t.preparsed)
    return n2(e2, null, t.arguments);
  return n2(e2, t, await W2(e2, t));
}
var _ = class extends r2 {
  constructor(e2, t) {
    super(), this.definition = null, this.context = null, this.definition = e2, this.context = t;
  }
  createFunction(e2) {
    return (...t) => {
      const n2 = { spatialReference: this.context.spatialReference, console: this.context.console, lrucache: this.context.lrucache, timeZone: this.context.timeZone ?? null, exports: this.context.exports, libraryResolver: this.context.libraryResolver, interceptor: this.context.interceptor, localScope: {}, depthCounter: { depth: e2.depthCounter + 1 }, globalScope: this.context.globalScope };
      if (n2.depthCounter.depth > 64)
        throw new a(e2, r.MaximumCallDepth, null);
      return Pe(this.definition, n2, t, null);
    };
  }
  call(e2, t) {
    return Y(e2, t, (n2, a2, i) => {
      const l = { spatialReference: e2.spatialReference, services: e2.services, console: e2.console, libraryResolver: e2.libraryResolver, exports: e2.exports, lrucache: e2.lrucache, timeZone: e2.timeZone ?? null, interceptor: e2.interceptor, localScope: {}, abortSignal: e2.abortSignal, globalScope: e2.globalScope, depthCounter: { depth: e2.depthCounter.depth + 1 } };
      if (l.depthCounter.depth > 64)
        throw new a(e2, r.MaximumCallDepth, t);
      return Pe(this.definition, l, i, t);
    });
  }
  marshalledCall(e2, t, n2, r3) {
    return r3(e2, t, async (o2, a2, i) => {
      const l = { spatialReference: e2.spatialReference, globalScope: n2.globalScope, depthCounter: { depth: e2.depthCounter.depth + 1 }, libraryResolver: e2.libraryResolver, exports: e2.exports, console: e2.console, abortSignal: e2.abortSignal, lrucache: e2.lrucache, timeZone: e2.timeZone ?? null, interceptor: e2.interceptor, localScope: {} };
      return i = i.map((t2) => !v(t2) || t2 instanceof s3 ? t2 : n(t2, e2, r3)), n(await Pe(this.definition, l, i, t), n2, r3);
    });
  }
};
var z2 = class extends s {
  constructor(e2) {
    super(e2);
  }
  async global(e2) {
    const t = this.executingContext.globalScope[e2.toLowerCase()];
    if (t.valueset || (t.value = await H2(this.executingContext, t.node), t.valueset = true), v(t.value) && !(t.value instanceof s3)) {
      const e3 = new s3();
      e3.fn = t.value, e3.parameterEvaluator = Y, e3.context = this.executingContext, t.value = e3;
    }
    return t.value;
  }
  setGlobal(e2, t) {
    if (v(t))
      throw new a(null, r.AssignModuleFunction, null);
    this.executingContext.globalScope[e2.toLowerCase()] = { value: t, valueset: true, node: null };
  }
  hasGlobal(e2) {
    return void 0 === this.executingContext.exports[e2] && (e2 = e2.toLowerCase()), void 0 !== this.executingContext.exports[e2];
  }
  async loadModule(e2) {
    let n2 = e2.spatialReference;
    null == n2 && (n2 = new f({ wkid: 102100 })), this.moduleScope = Ge({}, e2.customfunctions, e2.timeZone), this.executingContext = { spatialReference: n2, services: e2.services, libraryResolver: new s2(e2.libraryResolver._moduleSingletons, this.source.syntax.loadedModules), exports: {}, abortSignal: void 0 === e2.abortSignal || null === e2.abortSignal ? { aborted: false } : e2.abortSignal, globalScope: this.moduleScope, console: e2.console ?? Ze, lrucache: e2.lrucache, timeZone: e2.timeZone ?? null, interceptor: e2.interceptor, localScope: null, depthCounter: { depth: 1 } }, await H2(this.executingContext, this.source.syntax);
  }
};
async function Y(e2, t, n2) {
  if (true === t.preparsed) {
    const r4 = n2(e2, null, t.arguments);
    return q2(r4), r4;
  }
  const r3 = n2(e2, t, await W2(e2, t));
  return q2(r3), r3;
}
async function H2(e2, t, n2) {
  if (t.breakpoint && true !== n2) {
    const n3 = t.breakpoint();
    return await n3, H2(e2, t, true);
  }
  try {
    switch (t == null ? void 0 : t.type) {
      case "VariableDeclarator":
        return await xe(e2, t);
      case "ImportDeclaration":
        return await ve(e2, t);
      case "ExportNamedDeclaration":
        return await be(e2, t);
      case "VariableDeclaration":
        return await Se(e2, t, 0);
      case "BlockStatement":
      case "Program":
        return await he(e2, t);
      case "FunctionDeclaration":
        return await ye(e2, t);
      case "ReturnStatement":
        return await ge(e2, t);
      case "IfStatement":
        return await de(e2, t);
      case "ExpressionStatement":
        return await we(e2, t);
      case "UpdateExpression":
        return await ue(e2, t);
      case "AssignmentExpression":
        return await pe2(e2, t);
      case "ForStatement":
        return await ne2(e2, t);
      case "WhileStatement":
        return await X(e2, t);
      case "ForInStatement":
        return await ce2(e2, t);
      case "BreakStatement":
        return O;
      case "EmptyStatement":
        return w;
      case "ContinueStatement":
        return R;
      case "TemplateElement":
        return await Le(e2, t);
      case "TemplateLiteral":
        return await Ee(e2, t);
      case "Identifier":
        return await Me(e2, t);
      case "MemberExpression":
        return await Ie2(e2, t);
      case "Literal":
        return t.value;
      case "CallExpression":
        return await je(e2, t);
      case "UnaryExpression":
        return await Fe(e2, t);
      case "BinaryExpression":
        return await Re(e2, t);
      case "LogicalExpression":
        return await Ae(e2, t);
      case "ArrayExpression":
        return await Ce(e2, t);
      case "ObjectExpression":
        return await J(e2, t);
      case "Property":
        return await Q(e2, t);
      default:
        throw new a(e2, r.Unrecognized, t);
    }
  } catch (i) {
    throw u(e2, t, i);
  }
}
async function J(e2, t) {
  const a2 = [];
  for (let n2 = 0; n2 < t.properties.length; n2++)
    a2[n2] = await H2(e2, t.properties[n2]);
  const i = {}, l = /* @__PURE__ */ new Map();
  for (let n2 = 0; n2 < a2.length; n2++) {
    const s5 = a2[n2];
    if (v(s5.value))
      throw new a(e2, r.NoFunctionInDictionary, t);
    if (false === P(s5.key))
      throw new a(e2, r.KeyMustBeString, t);
    let c = s5.key.toString();
    const u2 = c.toLowerCase();
    l.has(u2) ? c = l.get(u2) : l.set(u2, c), s5.value === w ? i[c] = null : i[c] = s5.value;
  }
  const s4 = new N(i);
  return s4.immutable = false, s4;
}
async function Q(e2, t) {
  const n2 = await H2(e2, t.value);
  if ("Identifier" === t.key.type)
    return { key: t.key.name, value: n2 };
  return { key: await H2(e2, t.key), value: n2 };
}
async function X(e2, t) {
  const n2 = { testResult: true, lastAction: w };
  if (n2.testResult = await H2(e2, t.test), false === n2.testResult)
    return w;
  if (true !== n2.testResult)
    throw new a(e2, r.BooleanConditionRequired, t);
  for (; true === n2.testResult && (n2.lastAction = await H2(e2, t.body), n2.lastAction !== O) && !(n2.lastAction instanceof F); )
    if (n2.testResult = await H2(e2, t.test), true !== n2.testResult && false !== n2.testResult)
      throw new a(e2, r.BooleanConditionRequired, t);
  return n2.lastAction instanceof F ? n2.lastAction : w;
}
async function $3(e2, t, n2) {
  const r3 = await H2(e2, t.body);
  return n2.lastAction = r3, n2.lastAction === O || n2.lastAction instanceof F ? (n2.testResult = false, n2) : null !== t.update ? (await H2(e2, t.update), n2) : n2;
}
async function ee(e2, t, n2) {
  var _a;
  if (null !== t.test) {
    const a2 = await H2(e2, t.test);
    if (true === ((_a = e2.abortSignal) == null ? void 0 : _a.aborted))
      throw new a(e2, r.Cancelled, t);
    if (n2.testResult = a2, false === n2.testResult)
      return n2;
    if (true !== n2.testResult)
      throw new a(e2, r.BooleanConditionRequired, t);
    return $3(e2, t, n2);
  }
  return $3(e2, t, n2);
}
function te(e2, t, n2, r3, o2, a2) {
  try {
    ee(e2, t, n2).then(() => {
      try {
        true === n2.testResult ? ++a2 > T ? (a2 = 0, setTimeout(() => {
          te(e2, t, n2, r3, o2, a2);
        }, 0)) : te(e2, t, n2, r3, o2, a2) : n2.lastAction instanceof F ? r3(n2.lastAction) : r3(w);
      } catch (i) {
        o2(i);
      }
    }, (e3) => {
      o2(e3);
    });
  } catch (i) {
    o2(i);
  }
}
function ne2(e2, t) {
  try {
    return null !== t.init ? H2(e2, t.init).then(() => new Promise((n2, r3) => {
      te(e2, t, { testResult: true, lastAction: w }, (e3) => {
        n2(e3);
      }, (e3) => {
        r3(e3);
      }, 0);
    })) : new Promise((n2, r3) => {
      te(e2, t, { testResult: true, lastAction: w }, (e3) => {
        n2(e3);
      }, (e3) => {
        r3(e3);
      }, 0);
    });
  } catch (n2) {
    return Promise.reject(n2);
  }
}
function re(e2, t, n2, r3, o2, a2, i, l, s4, c) {
  try {
    if (r3 <= a2)
      return void l(w);
    o2.value = "k" === i ? n2[a2] : a2, H2(e2, t.body).then((u2) => {
      try {
        u2 instanceof F ? l(u2) : u2 === O ? l(w) : ++c > T ? (c = 0, setTimeout(() => {
          re(e2, t, n2, r3, o2, a2 + 1, i, l, s4, c);
        }, 0)) : re(e2, t, n2, r3, o2, a2 + 1, i, l, s4, c);
      } catch (f3) {
        s4(f3);
      }
    }, (e3) => {
      s4(e3);
    });
  } catch (u2) {
    s4(u2);
  }
}
function oe(e2, t, n2, r3, o2, a2, i, l, s4) {
  try {
    if (n2.length() <= o2)
      return void i(w);
    r3.value = "k" === a2 ? n2.get(o2) : o2, H2(e2, t.body).then((c) => {
      c instanceof F ? i(c) : c === O ? i(w) : ++s4 > T ? (s4 = 0, setTimeout(() => {
        oe(e2, t, n2, r3, o2 + 1, a2, i, l, s4);
      }, 0)) : oe(e2, t, n2, r3, o2 + 1, a2, i, l, s4);
    }, (e3) => {
      l(e3);
    });
  } catch (c) {
    l(c);
  }
}
function ae(e2, t, n2, r3, o2, a2) {
  try {
    if (void 0 === a2 && (a2 = "i"), 0 === n2.length)
      return void r3.resolve(w);
    re(e2, t, n2, n2.length, o2, 0, a2, (e3) => {
      r3.resolve(e3);
    }, (e3) => {
      r3.reject(e3);
    }, 0);
  } catch (i) {
    r3.reject(i);
  }
}
function ie(e2, t, n2, r3, o2, a2) {
  try {
    if (void 0 === a2 && (a2 = "i"), 0 === n2.length)
      return void r3.resolve(w);
    oe(e2, t, n2, o2, 0, a2, (e3) => {
      r3.resolve(e3);
    }, (e3) => {
      r3.reject(e3);
    }, 0);
  } catch (i) {
    r3.reject(i);
  }
}
function le(e2, t, n2, r3, o2) {
  try {
    ae(e2, t, n2.keys(), r3, o2, "k");
  } catch (a2) {
    r3.reject(a2);
  }
}
function se2(e2, t, n2, r3, o2, a2, l, s4) {
  try {
    e2.next().then((c) => {
      try {
        if (null === c)
          a2(w);
        else {
          const u2 = D.createFromGraphicLikeObject(c.geometry, c.attributes, r3, t.timeZone);
          u2._underlyingGraphic = c, o2.value = u2;
          H2(t, n2.body).then((i) => {
            try {
              i === O ? a2(w) : i instanceof F ? a2(i) : ++s4 > T ? (s4 = 0, setTimeout(() => {
                se2(e2, t, n2, r3, o2, a2, l, s4);
              }, 0)) : se2(e2, t, n2, r3, o2, a2, l, s4);
            } catch (c2) {
              l(c2);
            }
          }, (e3) => {
            l(e3);
          });
        }
      } catch (u2) {
        l(u2);
      }
    }, (e3) => {
      l(e3);
    });
  } catch (c) {
    l(c);
  }
}
async function ce2(e2, t) {
  return new Promise((a2, i) => {
    H2(e2, t.right).then((l) => {
      try {
        let s4 = null;
        s4 = "VariableDeclaration" === t.left.type ? H2(e2, t.left) : Promise.resolve(), s4.then(() => {
          try {
            let s5 = "";
            if ("VariableDeclaration" === t.left.type) {
              const e3 = t.left.declarations[0].id;
              "Identifier" === e3.type && (s5 = e3.name);
            } else
              "Identifier" === t.left.type && (s5 = t.left.name);
            if (!s5)
              throw new a(e2, r.InvalidIdentifier, t);
            s5 = s5.toLowerCase();
            let c = null;
            if (null != e2.localScope && void 0 !== e2.localScope[s5] && (c = e2.localScope[s5]), null === c && void 0 !== e2.globalScope[s5] && (c = e2.globalScope[s5]), null === c)
              return void i(new a(e2, r.InvalidIdentifier, t));
            q(l) || P(l) ? ae(e2, t, l, { reject: i, resolve: a2 }, c) : $(l) ? ie(e2, t, l, { reject: i, resolve: a2 }, c) : l instanceof N || U(l) ? le(e2, t, l, { reject: i, resolve: a2 }, c) : H(l) ? se2(l.iterator(e2.abortSignal), e2, t, l, c, (e3) => {
              a2(e3);
            }, (e3) => {
              i(e3);
            }, 0) : ae(e2, t, [], { reject: i, resolve: a2 }, c);
          } catch (s5) {
            i(s5);
          }
        }, i);
      } catch (s4) {
        i(s4);
      }
    }, i);
  });
}
async function ue(e2, t) {
  const a2 = t.argument;
  if ("MemberExpression" === a2.type) {
    const i2 = { t: null }, l2 = await H2(e2, a2.object);
    let s4 = null;
    i2.t = l2, true === a2.computed ? s4 = await H2(e2, a2.property) : "Identifier" === a2.property.type && (s4 = a2.property.name);
    const c = i2.t;
    let u2;
    if (q(c)) {
      if (!z(s4))
        throw new a(e2, r.ArrayAccessorMustBeNumber, t);
      if (s4 < 0 && (s4 = c.length + s4), s4 < 0 || s4 >= c.length)
        throw new a(e2, r.OutOfBounds, t);
      u2 = pe(c[s4]), c[s4] = "++" === t.operator ? u2 + 1 : u2 - 1;
    } else if (c instanceof N) {
      if (false === P(s4))
        throw new a(e2, r.KeyAccessorMustBeString, t);
      if (true !== c.hasField(s4))
        throw new a(e2, r.FieldNotFound, t, { key: s4 });
      u2 = pe(c.field(s4)), c.setField(s4, "++" === t.operator ? u2 + 1 : u2 - 1);
    } else if (c instanceof z2) {
      if (false === P(s4))
        throw new a(e2, r.ModuleAccessorMustBeString, t);
      if (true !== c.hasGlobal(s4))
        throw new a(e2, r.ModuleExportNotFound, t);
      u2 = pe(await c.global(s4)), c.setGlobal(s4, "++" === t.operator ? u2 + 1 : u2 - 1);
    } else {
      if (!U(c))
        throw $(c) ? new a(e2, r.Immutable, t) : new a(e2, r.InvalidParameter, t);
      if (false === P(s4))
        throw new a(e2, r.KeyAccessorMustBeString, t);
      if (true !== c.hasField(s4))
        throw new a(e2, r.FieldNotFound, t, { key: s4 });
      u2 = pe(c.field(s4)), c.setField(s4, "++" === t.operator ? u2 + 1 : u2 - 1);
    }
    return false === t.prefix ? u2 : "++" === t.operator ? u2 + 1 : u2 - 1;
  }
  const i = "Identifier" === t.argument.type ? t.argument.name.toLowerCase() : "";
  if (!i)
    throw new a(e2, r.InvalidIdentifier, t);
  let l;
  if (null != e2.localScope && void 0 !== e2.localScope[i])
    return l = pe(e2.localScope[i].value), e2.localScope[i] = { value: "++" === t.operator ? l + 1 : l - 1, valueset: true, node: t }, false === t.prefix ? l : "++" === t.operator ? l + 1 : l - 1;
  if (void 0 !== e2.globalScope[i])
    return l = pe(e2.globalScope[i].value), e2.globalScope[i] = { value: "++" === t.operator ? l + 1 : l - 1, valueset: true, node: t }, false === t.prefix ? l : "++" === t.operator ? l + 1 : l - 1;
  throw new a(e2, r.InvalidIdentifier, t);
}
function fe2(e2, t, n2, a2, i) {
  switch (t) {
    case "=":
      return e2 === w ? null : e2;
    case "/=":
      return pe(n2) / pe(e2);
    case "*=":
      return pe(n2) * pe(e2);
    case "-=":
      return pe(n2) - pe(e2);
    case "+=":
      return P(n2) || P(e2) ? ce(n2) + ce(e2) : pe(n2) + pe(e2);
    case "%=":
      return pe(n2) % pe(e2);
    default:
      throw new a(i, r.UnsupportedOperator, a2);
  }
}
async function pe2(e2, t) {
  const a2 = t.left;
  if ("MemberExpression" === a2.type) {
    const i2 = await H2(e2, a2.object);
    let l = null;
    if (true === a2.computed)
      l = await H2(e2, a2.property);
    else {
      if ("Identifier" !== a2.property.type)
        throw new a(e2, r.InvalidIdentifier, t);
      l = a2.property.name;
    }
    const s4 = await H2(e2, t.right);
    if (q(i2)) {
      if (!z(l))
        throw new a(e2, r.ArrayAccessorMustBeNumber, t);
      if (l < 0 && (l = i2.length + l), l < 0 || l > i2.length)
        throw new a(e2, r.OutOfBounds, t);
      if (l === i2.length) {
        if ("=" !== t.operator)
          throw new a(e2, r.OutOfBounds, t);
        i2[l] = fe2(s4, t.operator, i2[l], t, e2);
      } else
        i2[l] = fe2(s4, t.operator, i2[l], t, e2);
    } else if (i2 instanceof N) {
      if (false === P(l))
        throw new a(e2, r.KeyAccessorMustBeString, t);
      if (true === i2.hasField(l))
        i2.setField(l, fe2(s4, t.operator, i2.field(l), t, e2));
      else {
        if ("=" !== t.operator)
          throw new a(e2, r.FieldNotFound, t, { key: l });
        i2.setField(l, fe2(s4, t.operator, null, t, e2));
      }
    } else if (i2 instanceof z2) {
      if (false === P(l))
        throw new a(e2, r.KeyAccessorMustBeString, t);
      if (true !== i2.hasGlobal(l))
        throw new a(e2, r.ModuleExportNotFound, t);
      i2.setGlobal(l, fe2(s4, t.operator, await i2.global(l), t, e2));
    } else {
      if (!U(i2))
        throw $(i2) ? new a(e2, r.Immutable, t) : new a(e2, r.InvalidParameter, t);
      if (false === P(l))
        throw new a(e2, r.KeyAccessorMustBeString, t);
      if (true === i2.hasField(l))
        i2.setField(l, fe2(s4, t.operator, i2.field(l), t, e2));
      else {
        if ("=" !== t.operator)
          throw new a(e2, r.FieldNotFound, t, { key: l });
        i2.setField(l, fe2(s4, t.operator, null, t, e2));
      }
    }
    return w;
  }
  const i = a2.name.toLowerCase();
  if (null != e2.localScope && void 0 !== e2.localScope[i]) {
    const n2 = await H2(e2, t.right);
    return e2.localScope[i] = { value: fe2(n2, t.operator, e2.localScope[i].value, t, e2), valueset: true, node: t.right }, w;
  }
  if (void 0 !== e2.globalScope[i]) {
    const n2 = await H2(e2, t.right);
    return e2.globalScope[i] = { value: fe2(n2, t.operator, e2.globalScope[i].value, t, e2), valueset: true, node: t.right }, w;
  }
  throw new a(e2, r.InvalidIdentifier, t);
}
async function we(e2, t) {
  if ("AssignmentExpression" === t.expression.type)
    return H2(e2, t.expression);
  if ("CallExpression" === t.expression.type) {
    const n3 = await H2(e2, t.expression);
    return n3 === w ? w : new M(n3);
  }
  const n2 = await H2(e2, t.expression);
  return n2 === w ? w : new M(n2);
}
async function de(e2, t) {
  const n2 = await H2(e2, t.test);
  if (true === n2)
    return H2(e2, t.consequent);
  if (false === n2)
    return null !== t.alternate ? H2(e2, t.alternate) : w;
  throw new a(e2, r.BooleanConditionRequired, t);
}
async function he(e2, t) {
  return me(e2, t, 0);
}
async function me(e2, t, n2) {
  if (n2 >= t.body.length)
    return w;
  const r3 = await H2(e2, t.body[n2]);
  return r3 instanceof F || r3 === O || r3 === R || n2 === t.body.length - 1 ? r3 : me(e2, t, n2 + 1);
}
async function ge(e2, t) {
  if (null === t.argument)
    return new F(w);
  const n2 = await H2(e2, t.argument);
  return new F(n2);
}
async function ye(e2, t) {
  const n2 = t.id.name.toLowerCase();
  return e2.globalScope[n2] = { valueset: true, node: null, value: new _(t, e2) }, w;
}
async function ve(e2, t) {
  var _a, _b;
  const n2 = t.specifiers[0].local.name.toLowerCase(), r3 = e2.libraryResolver.loadLibrary(n2);
  let o2 = null;
  return ((_a = e2.libraryResolver._moduleSingletons) == null ? void 0 : _a.has(r3.uri)) ? o2 = e2.libraryResolver._moduleSingletons.get(r3.uri) : (o2 = new z2(r3), await o2.loadModule(e2), (_b = e2.libraryResolver._moduleSingletons) == null ? void 0 : _b.set(r3.uri, o2)), e2.globalScope[n2] = { value: o2, valueset: true, node: t }, w;
}
async function be(e2, t) {
  if (await H2(e2, t.declaration), "FunctionDeclaration" === t.declaration.type)
    e2.exports[t.declaration.id.name.toLowerCase()] = "function";
  else if ("VariableDeclaration" === t.declaration.type)
    for (const n2 of t.declaration.declarations)
      e2.exports[n2.id.name.toLowerCase()] = "variable";
  return w;
}
async function Se(e2, t, n2) {
  return n2 >= t.declarations.length ? w : (await H2(e2, t.declarations[n2]), n2 === t.declarations.length - 1 || await Se(e2, t, n2 + 1), w);
}
async function xe(e2, t) {
  let n2 = null;
  if (n2 = null === t.init ? null : await H2(e2, t.init), null !== e2.localScope) {
    if (n2 === w && (n2 = null), "Identifier" !== t.id.type)
      throw new a(e2, r.InvalidIdentifier, t);
    const a3 = t.id.name.toLowerCase();
    return null != e2.localScope && (e2.localScope[a3] = { value: n2, valueset: true, node: t.init }), w;
  }
  if ("Identifier" !== t.id.type)
    throw new a(e2, r.InvalidIdentifier, t);
  const a2 = t.id.name.toLowerCase();
  return n2 === w && (n2 = null), e2.globalScope[a2] = { value: n2, valueset: true, node: t.init }, w;
}
async function Ie2(e2, t) {
  const a2 = await H2(e2, t.object);
  if (null === a2)
    throw new a(e2, r.MemberOfNull, t);
  if (false === t.computed) {
    if ("Identifier" === t.property.type) {
      if (a2 instanceof N || U(a2))
        return a2.field(t.property.name);
      if (a2 instanceof p)
        return L(a2, t.property.name, e2, t);
      if (a2 instanceof z2) {
        if (!a2.hasGlobal(t.property.name))
          throw new a(e2, r.InvalidIdentifier, t);
        return a2.global(t.property.name);
      }
      throw new a(e2, r.InvalidMemberAccessKey, t);
    }
    throw new a(e2, r.InvalidMemberAccessKey, t);
  }
  let i = await H2(e2, t.property);
  if (a2 instanceof N || U(a2)) {
    if (P(i))
      return a2.field(i);
    throw new a(e2, r.InvalidMemberAccessKey, t);
  }
  if (a2 instanceof z2) {
    if (P(i))
      return a2.global(i);
    throw new a(e2, r.InvalidMemberAccessKey, t);
  }
  if (a2 instanceof p) {
    if (P(i))
      return L(a2, i, e2, t);
    throw new a(e2, r.InvalidMemberAccessKey, t);
  }
  if (q(a2)) {
    if (z(i) && isFinite(i) && Math.floor(i) === i) {
      if (i < 0 && (i = a2.length + i), i >= a2.length || i < 0)
        throw new a(e2, r.OutOfBounds, t);
      return a2[i];
    }
    throw new a(e2, r.InvalidMemberAccessKey, t);
  }
  if ($(a2)) {
    if (z(i) && isFinite(i) && Math.floor(i) === i) {
      if (i < 0 && (i = a2.length() + i), i >= a2.length() || i < 0)
        throw new a(e2, r.OutOfBounds, t);
      return a2.get(i);
    }
    throw new a(e2, r.InvalidMemberAccessKey, t);
  }
  if (P(a2)) {
    if (z(i) && isFinite(i) && Math.floor(i) === i) {
      if (i < 0 && (i = a2.length + i), i >= a2.length || i < 0)
        throw new a(e2, r.OutOfBounds, t);
      return a2[i];
    }
    throw new a(e2, r.InvalidMemberAccessKey, t);
  }
  throw new a(e2, r.InvalidMemberAccessKey, t);
}
async function Fe(e2, t) {
  const n2 = await H2(e2, t.argument);
  if (G(n2)) {
    if ("!" === t.operator)
      return !n2;
    if ("-" === t.operator)
      return -1 * pe(n2);
    if ("+" === t.operator)
      return 1 * pe(n2);
    if ("~" === t.operator)
      return ~pe(n2);
    throw new a(e2, r.UnsupportedUnaryOperator, t);
  }
  if ("-" === t.operator)
    return -1 * pe(n2);
  if ("+" === t.operator)
    return 1 * pe(n2);
  if ("~" === t.operator)
    return ~pe(n2);
  throw new a(e2, r.UnsupportedUnaryOperator, t);
}
async function Ce(e2, t) {
  const n2 = [];
  for (let r3 = 0; r3 < t.elements.length; r3++)
    n2.push(await H2(e2, t.elements[r3]));
  for (let a2 = 0; a2 < n2.length; a2++) {
    if (v(n2[a2]))
      throw new a(e2, r.NoFunctionInArray, t);
    n2[a2] === w && (n2[a2] = null);
  }
  return n2;
}
async function Re(e2, t) {
  const n2 = [];
  n2[0] = await H2(e2, t.left), n2[1] = await H2(e2, t.right);
  const a2 = n2[0], i = n2[1];
  switch (t.operator) {
    case "|":
    case "<<":
    case ">>":
    case ">>>":
    case "^":
    case "&":
      return Ie(pe(a2), pe(i), t.operator);
    case "==":
      return fe(a2, i);
    case "!=":
      return !fe(a2, i);
    case "<":
    case ">":
    case "<=":
    case ">=":
      return se(a2, i, t.operator);
    case "+":
      return P(a2) || P(i) ? ce(a2) + ce(i) : pe(a2) + pe(i);
    case "-":
      return pe(a2) - pe(i);
    case "*":
      return pe(a2) * pe(i);
    case "/":
      return pe(a2) / pe(i);
    case "%":
      return pe(a2) % pe(i);
    default:
      throw new a(e2, r.UnsupportedOperator, t);
  }
}
async function Ae(e2, t) {
  const n2 = await H2(e2, t.left);
  let a2 = null;
  if (!G(n2))
    throw new a(e2, r.LogicalExpressionOnlyBoolean, t);
  switch (t.operator) {
    case "||":
      if (true === n2)
        return n2;
      if (a2 = await H2(e2, t.right), G(a2))
        return a2;
      throw new a(e2, r.LogicExpressionOrAnd, t);
    case "&&":
      if (false === n2)
        return n2;
      if (a2 = await H2(e2, t.right), G(a2))
        return a2;
      throw new a(e2, r.LogicExpressionOrAnd, t);
    default:
      throw new a(e2, r.LogicExpressionOrAnd, t);
  }
}
async function Me(e2, t) {
  const n2 = t.name.toLowerCase();
  if (null != e2.localScope && void 0 !== e2.localScope[n2]) {
    const t2 = e2.localScope[n2];
    if (true === t2.valueset)
      return t2.value;
    if (null !== t2.d)
      return t2.d;
    t2.d = H2(e2, t2.node);
    const r3 = await t2.d;
    return t2.value = r3, t2.valueset = true, r3;
  }
  if (void 0 !== e2.globalScope[n2]) {
    const t2 = e2.globalScope[n2];
    if (true === t2.valueset)
      return t2.value;
    if (null !== t2.d)
      return t2.d;
    t2.d = H2(e2, t2.node);
    const r3 = await t2.d;
    return t2.value = r3, t2.valueset = true, r3;
  }
  throw new a(e2, r.InvalidIdentifier, t);
}
async function je(e2, t) {
  if ("MemberExpression" === t.callee.type) {
    const n2 = await H2(e2, t.callee.object);
    if (!(n2 instanceof z2))
      throw new a(e2, r.FunctionNotFound, t);
    const a2 = false === t.callee.computed ? t.callee.property.name : await H2(e2, t.callee.property);
    if (!n2.hasGlobal(a2))
      throw new a(e2, r.FunctionNotFound, t);
    const i = await n2.global(a2);
    if (!v(i))
      throw new a(e2, r.CallNonFunction, t);
    return i.call(e2, t);
  }
  if ("Identifier" !== t.callee.type)
    throw new a(e2, r.FunctionNotFound, t);
  if (null != e2.localScope && void 0 !== e2.localScope[t.callee.name.toLowerCase()]) {
    const n2 = e2.localScope[t.callee.name.toLowerCase()];
    if (v(n2.value))
      return n2.value.call(e2, t);
    throw new a(e2, r.CallNonFunction, t);
  }
  if (void 0 !== e2.globalScope[t.callee.name.toLowerCase()]) {
    const n2 = e2.globalScope[t.callee.name.toLowerCase()];
    if (v(n2.value))
      return n2.value.call(e2, t);
    throw new a(e2, r.CallNonFunction, t);
  }
  throw new a(e2, r.FunctionNotFound, t);
}
async function Le(e2, t) {
  return t.value ? t.value.cooked : "";
}
function ke(e2, t, n2) {
  if (v(e2))
    throw new a(t, r.NoFunctionInTemplateLiteral, n2);
  return e2;
}
async function Ee(e2, t) {
  const n2 = [];
  for (let a2 = 0; a2 < t.expressions.length; a2++) {
    const r4 = await H2(e2, t.expressions[a2]);
    n2[a2] = ce(r4);
  }
  let r3 = "", o2 = 0;
  for (const a2 of t.quasis)
    if (r3 += a2.value ? a2.value.cooked : "", false === a2.tail) {
      r3 += n2[o2] ? ke(n2[o2], e2, t) : "", o2++;
    }
  return r3;
}
var Ne2 = {};
async function Oe(e2, t, n2, r3) {
  const o2 = await H2(e2, t.arguments[n2]);
  if (fe(o2, r3))
    return H2(e2, t.arguments[n2 + 1]);
  const a2 = t.arguments.length - n2;
  return 1 === a2 ? H2(e2, t.arguments[n2]) : 2 === a2 ? null : 3 === a2 ? H2(e2, t.arguments[n2 + 2]) : Oe(e2, t, n2 + 2, r3);
}
async function Be(e2, t, n2, a2) {
  if (true === a2)
    return H2(e2, t.arguments[n2 + 1]);
  if (3 === t.arguments.length - n2)
    return H2(e2, t.arguments[n2 + 2]);
  const i = await H2(e2, t.arguments[n2 + 2]);
  if (false === G(i))
    throw new a(e2, r.ModuleExportNotFound, t.arguments[n2 + 2]);
  return Be(e2, t, n2 + 2, i);
}
async function Pe(e2, t, n2, a2) {
  const i = e2.body;
  if (n2.length !== e2.params.length)
    throw new a(t, r.WrongNumberOfParameters, null);
  for (let r3 = 0; r3 < n2.length; r3++) {
    const o2 = e2.params[r3];
    "Identifier" === o2.type && null != t.localScope && (t.localScope[o2.name.toLowerCase()] = { d: null, value: n2[r3], valueset: true, node: null });
  }
  const l = await H2(t, i);
  if (l instanceof F)
    return l.value;
  if (l === O)
    throw new a(t, r.UnexpectedToken, a2);
  if (l === R)
    throw new a(t, r.UnexpectedToken, a2);
  return l instanceof M ? l.value : l;
}
C(Ne2, V), $2(Ne2, V), m(Ne2, V), W(Ne2, V), f2(Ne2, V), An({ functions: Ne2, compiled: false, signatures: null, evaluateIdentifier: null, mode: "async", standardFunction: V, standardFunctionAsync: Y }), Ne2.iif = async function(e2, t) {
  ne(null === t.arguments ? [] : t.arguments, 3, 3, e2, t);
  const n2 = await H2(e2, t.arguments[0]);
  if (false === G(n2))
    throw new a(e2, r.BooleanConditionRequired, t);
  return H2(e2, n2 ? t.arguments[1] : t.arguments[2]);
}, Ne2.decode = async function(e2, t) {
  if (t.arguments.length < 2)
    throw new a(e2, r.WrongNumberOfParameters, t);
  if (2 === t.arguments.length)
    return H2(e2, t.arguments[1]);
  if ((t.arguments.length - 1) % 2 == 0)
    throw new a(e2, r.WrongNumberOfParameters, t);
  return Oe(e2, t, 1, await H2(e2, t.arguments[0]));
}, Ne2.when = async function(e2, t) {
  if (t.arguments.length < 3)
    throw new a(e2, r.WrongNumberOfParameters, t);
  if (t.arguments.length % 2 == 0)
    throw new a(e2, r.WrongNumberOfParameters, t);
  const n2 = await H2(e2, t.arguments[0]);
  if (false === G(n2))
    throw new a(e2, r.BooleanConditionRequired, t.arguments[0]);
  return Be(e2, t, 0, n2);
};
var Ke = { fixSpatialReference: Ne, parseArguments: W2, standardFunction: V, standardFunctionAsync: Y, evaluateIdentifier: Me };
for (const We in Ne2)
  Ne2[We] = { value: new e(Ne2[We]), valueset: true, node: null };
var De = function() {
};
function Ge(e2, t, r3) {
  const o2 = new De();
  null == e2 && (e2 = {}), null == t && (t = {});
  const a2 = new N({ newline: "\n", tab: "	", singlequote: "'", doublequote: '"', forwardslash: "/", backwardslash: "\\" });
  a2.immutable = false, o2.textformatting = { value: a2, valueset: true, node: null };
  for (const n2 in t)
    o2[n2] = { value: new e(t[n2]), native: true, valueset: true, node: null };
  for (const n2 in e2)
    e2[n2] && "esri.Graphic" === e2[n2].declaredClass ? o2[n2] = { value: D.createFromGraphic(e2[n2], r3), valueset: true, node: null } : o2[n2] = { value: e2[n2], valueset: true, node: null };
  return o2;
}
function Ze(e2) {
  console.log(e2);
}
De.prototype = Ne2, De.prototype.infinity = { value: Number.POSITIVE_INFINITY, valueset: true, node: null }, De.prototype.pi = { value: Math.PI, valueset: true, node: null };
var Ue = Ke;
function qe(e2) {
  const t = { mode: "async", compiled: false, functions: {}, signatures: [], standardFunction: V, standardFunctionAsync: Y, evaluateIdentifier: Me };
  for (let n2 = 0; n2 < e2.length; n2++)
    e2[n2].registerFunctions(t);
  for (const n2 in t.functions)
    Ne2[n2] = { value: new e(t.functions[n2]), valueset: true, node: null }, De.prototype[n2] = Ne2[n2];
  for (let n2 = 0; n2 < t.signatures.length; n2++)
    o(t.signatures[n2], "async");
}
async function Te(e2, n2) {
  let a2 = n2.spatialReference;
  null == a2 && (a2 = new f({ wkid: 102100 }));
  let i = null;
  e2.usesModules && (i = new s2(/* @__PURE__ */ new Map(), e2.loadedModules));
  const l = Ge(n2.vars, n2.customfunctions, n2.timeZone), s4 = { spatialReference: a2, services: n2.services, exports: {}, libraryResolver: i, abortSignal: void 0 === n2.abortSignal || null === n2.abortSignal ? { aborted: false } : n2.abortSignal, globalScope: l, console: n2.console ?? Ze, timeZone: n2.timeZone ?? null, lrucache: n2.lrucache, interceptor: n2.interceptor, localScope: null, depthCounter: { depth: 1 } };
  let c = await H2(s4, e2);
  if (c instanceof F && (c = c.value), c instanceof M && (c = c.value), c === w && (c = null), c === O)
    throw new a(s4, r.IllegalResult, null);
  if (c === R)
    throw new a(s4, r.IllegalResult, null);
  if (v(c))
    throw new a(s4, r.IllegalResult, null);
  return c;
}
qe([p2]);
export {
  Te as executeScript,
  qe as extend,
  Ue as functionHelper
};
//# sourceMappingURL=arcadeAsyncRuntime-7LFNKGKT.js.map
