import {
  B2 as B,
  C,
  M as M2,
  a as a2,
  a3,
  c as c3,
  d,
  h,
  l as l2,
  m as m2,
  p as p3,
  s as s5,
  u as u2,
  w as w2,
  x as x2
} from "./chunk-OEIWJN32.js";
import {
  c as c2,
  f as f2,
  g,
  i,
  l,
  n,
  o as o3,
  p as p2,
  r as r2,
  s as s4,
  u2 as u,
  w,
  y as y2
} from "./chunk-ABKJC2RS.js";
import {
  y as y3
} from "./chunk-XZLDDXLF.js";
import {
  m,
  p
} from "./chunk-64EQFPYJ.js";
import {
  o as o2
} from "./chunk-V2RPSCV3.js";
import {
  D
} from "./chunk-MKW4ORPJ.js";
import {
  M
} from "./chunk-Y5D433JZ.js";
import {
  x2 as x
} from "./chunk-QNOCEWCR.js";
import {
  o
} from "./chunk-WURET5CW.js";
import {
  r
} from "./chunk-QWPLZ3QH.js";
import {
  s as s3
} from "./chunk-OMPEZIP5.js";
import {
  s as s2
} from "./chunk-EUTNDAIV.js";
import {
  f
} from "./chunk-NSRXJNTS.js";
import {
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  a,
  s3 as s
} from "./chunk-WJ3HJKNC.js";

// node_modules/@arcgis/core/layers/support/rasterFunctions/BaseFunctionArguments.js
var e2 = class extends f {
  constructor() {
    super(...arguments), this.raster = void 0;
  }
};
e([y({ json: { write: true } })], e2.prototype, "raster", void 0), e2 = e([c("esri.layers.support.rasterFunctions.AspectFunctionArguments")], e2);
var p4 = e2;

// node_modules/@arcgis/core/layers/support/rasterFunctions/AspectFunctionArguments.js
var e3;
var t = e3 = class extends p4 {
  clone() {
    return new e3({ raster: this.raster });
  }
};
t = e3 = e([c("esri.layers.support.rasterFunctions.AspectFunctionArguments")], t);
var c4 = t;

// node_modules/@arcgis/core/layers/support/rasterFunctions/BaseRasterFunction.js
var a4 = /* @__PURE__ */ new Set(["slope", "aspect", "curvature", "hillshade", "shadedrelief", "statistics"]);
var u3 = class extends f {
  constructor() {
    super(...arguments), this.functionArguments = null, this.readingBufferSize = 0, this.id = -1, this.isNoopProcess = false, this.rawInputBandIds = [], this.isInputBandIdsSwizzled = false, this.swizzledBandSelection = [], this.isBranch = false, this._bindingResult = null;
  }
  get supportsGPU() {
    return this._bindingResult.supportsGPU;
  }
  get flatWebGLFunctionChain() {
    const t5 = this.getWebGLProcessorDefinition();
    if (!t5)
      return null;
    const s11 = [t5], { parameters: e9 } = t5;
    let r7 = e9.rasters || e9.raster && [e9.raster];
    for (; r7 == null ? void 0 : r7.length; ) {
      s11.unshift(...r7);
      const t6 = [];
      for (let s12 = 0; s12 < r7.length; s12++) {
        const { parameters: e10 } = r7[s12], n20 = e10.rasters || e10.raster && [e10.raster];
        (n20 == null ? void 0 : n20.length) && t6.push(...n20);
      }
      r7 = t6;
    }
    for (let o13 = s11.length - 1; o13 >= 0; o13--)
      s11[o13].isNoopProcess && s11.splice(o13, 1);
    let n19 = false;
    for (let o13 = 0; o13 < s11.length; o13++) {
      const t6 = s11[o13];
      t6.id = s11.length - o13 - 1;
      const { rasters: e10 } = t6.parameters;
      n19 = n19 || null != e10 && e10.length > 1;
    }
    const i20 = s11.some(({ name: t6 }) => a4.has(t6.toLowerCase()));
    return { functions: s11, hasBranches: n19, hasFocalFunction: i20 };
  }
  bind(t5, s11 = false, e9 = -1) {
    this.id = e9 + 1;
    const r7 = this._getRasterValues();
    let n19 = true;
    for (let i20 = 0; i20 < r7.length; i20++) {
      const e10 = r7[i20];
      if (null != e10 && this._isRasterFunctionValue(e10)) {
        const r8 = e10.bind(t5, s11, this.id + i20);
        if (!r8.success)
          return this._bindingResult = r8, r8;
        n19 = n19 && r8.supportsGPU;
      }
    }
    return !this.rasterInfo || s11 ? (this.sourceRasterInfos = this._getSourceRasterInfos(t5), this._bindingResult = this._bindSourceRasters(), this._bindingResult.success && this._patchRasterInfo(), this._bindingResult.supportsGPU = n19 && this._bindingResult.supportsGPU, this.processInputBandIds(), this._bindingResult) : (this._bindingResult = { success: true, supportsGPU: true }, this.processInputBandIds(), this._bindingResult);
  }
  process(t5) {
    const s11 = this._getRasterValues(), e9 = 0 === s11.length ? t5.pixelBlocks ?? t5.primaryPixelBlocks : s11.map((s12) => this._readRasterValue(s12, t5));
    return this._processPixels({ ...t5, pixelBlocks: e9 });
  }
  processInputBandIds() {
    const t5 = this._getRasterValues().filter(this._isRasterFunctionValue);
    let s11;
    if (t5.length > 1) {
      const s12 = t5.map((t6) => t6.processInputBandIds()[0]);
      this.rawInputBandIds = s12, this.isInputBandIdsSwizzled = this.rawInputBandIds.some((t6, s13) => t6 !== s13);
      const e10 = t5.filter((t6) => "ExtractBand" === t6.functionName);
      return e10.length && e10.forEach((t6, s13) => {
        t6.isInputBandIdsSwizzled = true, t6.swizzledBandSelection = [s13, s13, s13];
      }), this.rawInputBandIds;
    }
    const e9 = t5[0];
    if (e9) {
      if (s11 = e9.processInputBandIds(), e9.isInputBandIdsSwizzled)
        return this.rawInputBandIds = s11, s11;
    } else {
      s11 = [];
      const { bandCount: t6 } = this.sourceRasterInfos[0];
      for (let e10 = 0; e10 < t6; e10++)
        s11.push(e10);
    }
    const r7 = this._getInputBandIds(s11);
    return this.isInputBandIdsSwizzled = r7.some((t6, s12) => t6 !== s12), this.rawInputBandIds = r7, this.rawInputBandIds;
  }
  getPrimaryRasters() {
    const t5 = [], s11 = [];
    return this._getPrimaryRasters(this, t5, s11), { rasters: t5, rasterIds: s11 };
  }
  getWebGLProcessorDefinition() {
    const t5 = this._getWebGLParameters(), { raster: s11, rasters: e9 } = this.functionArguments;
    return e9 && Array.isArray(e9) && e9.length ? (t5.rasters = e9.map((t6) => this._isRasterFunctionValue(t6) ? t6.getWebGLProcessorDefinition() : "number" == typeof t6 ? { name: "Constant", parameters: { value: t6 }, pixelType: "f32", id: -1, isNoopProcess: false } : { name: "Identity", parameters: { value: t6 }, pixelType: "f32", id: -1, isNoopProcess: false }), t5.rasters.some((t6) => null != t6) || (t5.rasters = null)) : this._isRasterFunctionValue(s11) && (t5.raster = s11.getWebGLProcessorDefinition()), { name: this.functionName, parameters: t5, pixelType: this.outputPixelType, id: this.id, isNoopProcess: this.isNoopProcess };
  }
  _getOutputPixelType(t5) {
    return "unknown" === this.outputPixelType ? t5 : this.outputPixelType ?? t5;
  }
  _getWebGLParameters() {
    return {};
  }
  _getInputBandIds(t5) {
    return t5;
  }
  _isOutputRoundingNeeded() {
    const { outputPixelType: t5 } = this;
    return ((t5 == null ? void 0 : t5.startsWith("u")) || (t5 == null ? void 0 : t5.startsWith("s"))) ?? false;
  }
  _getRasterValues() {
    const { rasterArgumentNames: t5 } = this;
    return "rasters" === t5[0] ? this.functionArguments.rasters ?? [] : t5.flatMap((t6) => this.functionArguments[t6]);
  }
  _getSourceRasterInfos(t5) {
    const s11 = this._getRasterValues(), { rasterInfos: e9, rasterIds: r7 } = t5;
    if (0 === s11.length)
      return e9;
    const n19 = s11.map((t6) => t6 && "object" == typeof t6 && "bind" in t6 && t6.rasterInfo ? t6.rasterInfo : "string" == typeof t6 && r7.includes(t6) ? e9[r7.indexOf(t6)] : "number" != typeof t6 ? e9[0] : void 0), i20 = n19.find((t6) => t6) ?? e9[0];
    return n19.forEach((t6, s12) => {
      void 0 === t6 && (n19[s12] = i20);
    }), n19;
  }
  _getPrimaryRasterId(t5) {
    return t5 == null ? void 0 : t5.url;
  }
  _getPrimaryRasters(t5, s11 = [], e9 = []) {
    for (let r7 = 0; r7 < t5.sourceRasters.length; r7++) {
      const n19 = t5.sourceRasters[r7];
      if ("number" != typeof n19)
        if ("bind" in n19)
          this._getPrimaryRasters(n19, s11, e9);
        else {
          const t6 = n19, r8 = this._getPrimaryRasterId(t6);
          if (null == r8)
            continue;
          e9.includes(r8) || (this.mainPrimaryRasterId === r8 ? (s11.unshift(t6), e9.unshift(r8)) : (s11.push(t6), e9.push(r8)));
        }
    }
  }
  _isRasterFunctionValue(t5) {
    return null != t5 && "object" == typeof t5 && "getWebGLProcessorDefinition" in t5;
  }
  _readRasterValue(t5, s11) {
    const { primaryPixelBlocks: e9 } = s11;
    if (null == t5 || "$$" === t5) {
      const t6 = e9[0];
      return null == t6 ? null : t6.clone();
    }
    if ("string" == typeof t5) {
      const r7 = s11.primaryRasterIds.indexOf(t5);
      return -1 === r7 ? null : e9[r7];
    }
    if ("number" == typeof t5) {
      const s12 = e9[0];
      if (null == s12)
        return null;
      const { width: r7, height: n19, pixelType: o13, mask: a26 } = s12, u16 = a26 ? new Uint8Array(a26) : null, p23 = new Float32Array(r7 * n19);
      p23.fill(t5);
      const l15 = this.sourceRasterInfos[0].bandCount, c28 = new Array(l15).fill(p23);
      return new u({ width: r7, height: n19, pixelType: o13, pixels: c28, mask: u16 });
    }
    return t5.process(s11);
  }
  _patchRasterInfo() {
    const { rasterInfo: t5 } = this;
    if (!(t5 == null ? void 0 : t5.keyProperties))
      return;
    const { bandCount: s11, keyProperties: e9, statistics: r7, histograms: n19 } = t5, i20 = e9.BandProperties;
    i20 && i20.length !== s11 && (t5.keyProperties = { ...e9, BandProperties: void 0 }), r7 && r7.length !== s11 && (t5.statistics = r7.length > s11 ? r7.slice(0, s11) : null), n19 && n19.length !== s11 && (t5.histograms = n19.length > s11 ? n19.slice(0, s11) : null), e9.BAND_COUNT && Number(e9.BAND_COUNT) !== s11 && (t5.keyProperties = { ...e9, BAND_COUNT: "string" == typeof e9.BAND_COUNT ? String(s11) : s11 });
  }
};
e([y({ json: { write: true } })], u3.prototype, "functionName", void 0), e([y({ json: { write: true } })], u3.prototype, "functionArguments", void 0), e([y()], u3.prototype, "rasterArgumentNames", void 0), e([y({ json: { write: true } }), s3((t5) => t5 == null ? void 0 : t5.toLowerCase())], u3.prototype, "outputPixelType", void 0), e([y({ json: { write: true } })], u3.prototype, "mainPrimaryRasterId", void 0), e([y()], u3.prototype, "sourceRasters", void 0), e([y({ type: [m2], json: { write: true } })], u3.prototype, "sourceRasterInfos", void 0), e([y({ json: { write: true } })], u3.prototype, "rasterInfo", void 0), e([y({ json: { write: true } })], u3.prototype, "readingBufferSize", void 0), e([y({ json: { write: true } })], u3.prototype, "id", void 0), e([y()], u3.prototype, "isNoopProcess", void 0), e([y()], u3.prototype, "supportsGPU", null), e([y()], u3.prototype, "rawInputBandIds", void 0), e([y()], u3.prototype, "isInputBandIdsSwizzled", void 0), e([y()], u3.prototype, "swizzledBandSelection", void 0), e([y()], u3.prototype, "isBranch", void 0), e([y()], u3.prototype, "flatWebGLFunctionChain", null), e([y()], u3.prototype, "_bindingResult", void 0), u3 = e([c("esri.layers.support.rasterFunctions.BaseRasterFunction")], u3);
var p5 = u3;

// node_modules/@arcgis/core/layers/support/rasterFunctions/AspectFunction.js
var n2 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Aspect", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isGCS = false;
  }
  _bindSourceRasters() {
    var _a;
    const t5 = this.sourceRasterInfos[0];
    this.isGCS = ((_a = t5.spatialReference) == null ? void 0 : _a.isGeographic) ?? false, this.outputPixelType = this._getOutputPixelType("f32");
    const s11 = t5.clone();
    return s11.pixelType = this.outputPixelType, s11.statistics = [{ min: -1, max: 360, avg: 180, stddev: 30 }], s11.histograms = null, s11.colormap = null, s11.attributeTable = null, s11.bandCount = 1, this.rasterInfo = s11, { success: true, supportsGPU: true };
  }
  _processPixels(t5) {
    var _a;
    const s11 = (_a = t5.pixelBlocks) == null ? void 0 : _a[0];
    if (null == s11)
      return null;
    const { extent: e9, primaryPixelSizes: r7 } = t5, o13 = r7 == null ? void 0 : r7[0], n19 = o13 ?? (e9 ? { x: e9.width / s11.width, y: e9.height / s11.height } : { x: 1, y: 1 });
    return h(s11, { resolution: n19 });
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], n2.prototype, "functionName", void 0), e([y({ type: c4, json: { write: true, name: "rasterFunctionArguments" } })], n2.prototype, "functionArguments", void 0), e([y()], n2.prototype, "rasterArgumentNames", void 0), e([y({ json: { write: true } })], n2.prototype, "isGCS", void 0), n2 = e([c("esri.layers.support.rasterFunctions.AspectFunction")], n2);
var p6 = n2;

// node_modules/@arcgis/core/layers/support/rasterFunctions/customBandIndexUtils.js
var e4 = /* @__PURE__ */ new Set(["+", "-", "*", "/", "(", ")"]);
function t2(t5, n19) {
  (t5 = t5.replaceAll(" ", "")).startsWith("-") && (t5 = "0" + t5), t5.startsWith("+") && (t5 = t5.slice(1, t5.length));
  const r7 = t5.split(""), l15 = [], o13 = [];
  let s11 = "";
  for (let a26 = 0; a26 < r7.length; a26++) {
    const t6 = r7[a26];
    if (e4.has(t6))
      "" !== s11 && o13.push(parseFloat(s11)), l15.push(t6), s11 = "";
    else {
      if ("b" === t6.toLowerCase()) {
        a26++, s11 = t6.concat(r7[a26]), o13.push(n19[parseInt(s11[1], 10) - 1]), s11 = "";
        continue;
      }
      s11 = s11.concat(t6), a26 === r7.length - 1 && o13.push(parseFloat(s11));
    }
  }
  return { ops: l15, nums: o13 };
}
function n3(e9, t5, n19, r7) {
  if ("number" == typeof n19 && "number" == typeof r7)
    return n19 + r7;
  let l15, o13, s11;
  "number" == typeof n19 ? (s11 = r7, l15 = s11.length, o13 = new Float32Array(l15), o13.fill(n19)) : (l15 = n19.length, o13 = n19, r7.constructor === Number ? (s11 = new Float32Array(l15), s11.fill(r7)) : s11 = r7);
  const a26 = new Float32Array(l15);
  switch (t5) {
    case "+":
      for (let t6 = 0; t6 < l15; t6++)
        (null == e9 || e9[t6]) && (a26[t6] = o13[t6] + s11[t6]);
      break;
    case "-":
      for (let t6 = 0; t6 < l15; t6++)
        (null == e9 || e9[t6]) && (a26[t6] = o13[t6] - s11[t6]);
      break;
    case "*":
      for (let t6 = 0; t6 < l15; t6++)
        (null == e9 || e9[t6]) && (a26[t6] = o13[t6] * s11[t6]);
      break;
    case "/":
      for (let t6 = 0; t6 < l15; t6++)
        (null == e9 || e9[t6]) && s11[t6] && (a26[t6] = o13[t6] / s11[t6]);
      break;
    case "(":
    case ")":
      throw new Error("encountered error with custom band index equation");
  }
  return a26;
}
function r3(e9, t5) {
  e9.splice(t5, 1);
  let n19 = 0, r7 = 0;
  do {
    n19 = 0, r7 = 0;
    for (let t6 = 0; t6 < e9.length; t6++)
      if ("(" === e9[t6])
        n19 = t6;
      else if (")" === e9[t6]) {
        r7 = t6;
        break;
      }
    r7 === n19 + 1 && e9.splice(n19, 2);
  } while (r7 === n19 + 1);
  return e9;
}
function l3(e9) {
  if (1 === e9.length)
    return { opIndex: 0, numIndex: 0 };
  let t5 = 0, n19 = 0;
  for (let s11 = 0; s11 < e9.length; s11++)
    if ("(" === e9[s11])
      t5 = s11;
    else if (")" === e9[s11]) {
      n19 = s11;
      break;
    }
  const r7 = 0 === n19 ? e9 : e9.slice(t5 + 1, n19);
  let l15 = -1;
  for (let s11 = 0; s11 < r7.length; s11++)
    if ("*" === r7[s11] || "/" === r7[s11]) {
      l15 = s11;
      break;
    }
  if (l15 > -1)
    n19 > 0 && (l15 += t5 + 1);
  else {
    for (let e10 = 0; e10 < r7.length; e10++)
      if ("+" === r7[e10] || "-" === r7[e10]) {
        l15 = e10;
        break;
      }
    n19 > 0 && (l15 += t5 + 1);
  }
  let o13 = 0;
  for (let s11 = 0; s11 < l15; s11++)
    "(" === e9[s11] && o13++;
  return { opIndex: l15, numIndex: l15 - o13 };
}
function o4(e9, o13, s11) {
  let a26, { ops: f6, nums: i20 } = t2(s11, o13);
  if (0 === f6.length) {
    const e10 = 1 === i20.length ? i20[0] : o13[0];
    if (e10 instanceof Float32Array)
      return [e10];
    const t5 = new Float32Array(o13[0].length);
    return "number" == typeof e10 ? t5.fill(e10) : t5.set(e10), [t5];
  }
  for (; f6.length > 0; ) {
    const { numIndex: t5, opIndex: o14 } = l3(f6);
    if (a26 = n3(e9, f6[o14], i20[t5], i20[t5 + 1]), 1 === f6.length)
      break;
    f6 = r3(f6, o14), i20.splice(t5, 2, a26);
  }
  return [a26];
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/bandIndexUtils.js
var a5 = new s2({ 0: "custom", 1: "ndvi", 2: "savi", 3: "tsavi", 4: "msavi", 5: "gemi", 6: "pvi", 7: "gvitm", 8: "sultan", 9: "vari", 10: "gndvi", 11: "sr", 12: "ndvi-re", 13: "sr-re", 14: "mtvi2", 15: "rtvi-core", 16: "ci-re", 17: "ci-g", 18: "ndwi", 19: "evi", 20: "iron-oxide", 21: "ferrous-minerals", 22: "clay-minerals", 23: "wndwi", 24: "bai", 25: "nbr", 26: "ndbi", 27: "ndmi", 28: "ndsi", 29: "mndwi" }, { useNumericKeys: true });
function o5(n19, a26) {
  if (!o3(n19))
    return n19;
  const { equation: o13, method: s11 } = a26, i20 = a26.bandIndexes.map((n20) => n20 - 1), { pixels: x5, mask: j3 } = n19;
  let q2;
  switch (s11) {
    case "gndvi":
    case "nbr":
    case "ndbi":
    case "ndvi":
    case "ndvi-re":
    case "ndsi":
    case "ndmi":
    case "mndwi":
      q2 = l4(j3, x5[i20[0]], x5[i20[1]]);
      break;
    case "ndwi":
      q2 = l4(j3, x5[i20[1]], x5[i20[0]]);
      break;
    case "sr":
    case "sr-re":
    case "iron-oxide":
    case "ferrous-minerals":
    case "clay-minerals":
      q2 = c5(j3, x5[i20[0]], x5[i20[1]]);
      break;
    case "ci-g":
    case "ci-re":
      q2 = u4(j3, x5[i20[0]], x5[i20[1]]);
      break;
    case "savi":
      q2 = f3(j3, x5[i20[0]], x5[i20[1]], i20[2] + 1);
      break;
    case "tsavi":
      q2 = w3(j3, x5[i20[0]], x5[i20[1]], i20[2] + 1, i20[3] + 1, i20[4] + 1);
      break;
    case "msavi":
      q2 = h2(j3, x5[i20[0]], x5[i20[1]]);
      break;
    case "gemi":
      q2 = m3(j3, x5[i20[0]], x5[i20[1]]);
      break;
    case "pvi":
      q2 = d2(j3, x5[i20[0]], x5[i20[1]], i20[2] + 1, i20[3] + 1);
      break;
    case "gvitm":
      q2 = g2(j3, [x5[i20[0]], x5[i20[1]], x5[i20[2]], x5[i20[3]], x5[i20[4]], x5[i20[5]]]);
      break;
    case "sultan":
      q2 = y4(j3, [x5[i20[0]], x5[i20[1]], x5[i20[2]], x5[i20[3]], x5[i20[4]], x5[i20[5]]]);
      break;
    case "vari":
      q2 = b(j3, [x5[i20[0]], x5[i20[1]], x5[i20[2]]]);
      break;
    case "mtvi2":
      q2 = v(j3, [x5[i20[0]], x5[i20[1]], x5[i20[2]]]);
      break;
    case "rtvi-core":
      q2 = k(j3, [x5[i20[0]], x5[i20[1]], x5[i20[2]]]);
      break;
    case "evi":
      q2 = A(j3, [x5[i20[0]], x5[i20[1]], x5[i20[2]]]);
      break;
    case "wndwi":
      q2 = p7(j3, [x5[i20[0]], x5[i20[1]], x5[i20[2]]], i20[3] ? i20[3] + 1 : 0.5);
      break;
    case "bai":
      q2 = F(j3, x5[i20[0]], x5[i20[1]]);
      break;
    case "custom":
      q2 = o4(j3, x5, o13);
      break;
    default:
      return n19;
  }
  const M5 = null != j3 ? new Uint8Array(j3.length) : null;
  null != j3 && null != M5 && M5.set(j3);
  const U2 = new u({ width: n19.width, height: n19.height, pixelType: "f32", pixels: q2, mask: M5 });
  return U2.updateStatistics(), U2;
}
function s6(n19, e9, r7, a26) {
  const { mask: o13, pixels: s11, width: i20, height: l15 } = n19, c28 = s11[r7], u16 = s11[e9], f6 = u16.length, w6 = a26 ? new Uint8Array(f6) : new Float32Array(f6), h6 = a26 ? 100 : 1, m8 = a26 ? 100.5 : 0;
  for (let t5 = 0; t5 < f6; t5++)
    if (null == o13 || o13[t5]) {
      const n20 = c28[t5], e10 = u16[t5], r8 = n20 + e10;
      r8 && (w6[t5] = (n20 - e10) / r8 * h6 + m8);
    }
  const d6 = new u({ width: i20, height: l15, mask: o13, pixelType: a26 ? "u8" : "f32", pixels: [w6] });
  return d6.updateStatistics(), d6;
}
function i2(n19) {
  const t5 = new Float32Array(9);
  return t5[3 * n19[0]] = 1, t5[3 * n19[1] + 1] = 1, t5[3 * n19[2] + 2] = 1, t5;
}
function l4(n19, t5, e9) {
  const r7 = e9.length, a26 = new Float32Array(r7);
  for (let o13 = 0; o13 < r7; o13++)
    if (null == n19 || n19[o13]) {
      const n20 = t5[o13], r8 = e9[o13], s11 = n20 + r8;
      s11 && (a26[o13] = (n20 - r8) / s11);
    }
  return [a26];
}
function c5(n19, t5, e9) {
  const r7 = e9.length, a26 = new Float32Array(r7);
  for (let o13 = 0; o13 < r7; o13++)
    if (null == n19 || n19[o13]) {
      const n20 = t5[o13], r8 = e9[o13];
      r8 && (a26[o13] = n20 / r8);
    }
  return [a26];
}
function u4(n19, t5, e9) {
  const r7 = t5.length, a26 = new Float32Array(r7);
  for (let o13 = 0; o13 < r7; o13++)
    if (null == n19 || n19[o13]) {
      const n20 = t5[o13], r8 = e9[o13];
      r8 && (a26[o13] = n20 / r8 - 1);
    }
  return [a26];
}
function f3(n19, t5, e9, r7) {
  const a26 = e9.length, o13 = new Float32Array(a26);
  for (let s11 = 0; s11 < a26; s11++)
    if (null == n19 || n19[s11]) {
      const n20 = e9[s11], a27 = t5[s11], i20 = a27 + n20 + r7;
      i20 && (o13[s11] = (a27 - n20) / i20 * (1 + r7));
    }
  return [o13];
}
function w3(n19, t5, e9, r7, a26, o13) {
  const s11 = e9.length, i20 = new Float32Array(s11), l15 = -a26 * r7 + o13 * (1 + r7 * r7);
  for (let c28 = 0; c28 < s11; c28++)
    if (null == n19 || n19[c28]) {
      const n20 = e9[c28], o14 = t5[c28], s12 = a26 * o14 + n20 + l15;
      s12 && (i20[c28] = r7 * (o14 - r7 * n20 - a26) / s12);
    }
  return [i20];
}
function h2(n19, t5, e9) {
  const r7 = e9.length, a26 = new Float32Array(r7);
  for (let o13 = 0; o13 < r7; o13++)
    if (null == n19 || n19[o13]) {
      const n20 = e9[o13], r8 = t5[o13];
      a26[o13] = 0.5 * (2 * (r8 + 1) - Math.sqrt((2 * r8 + 1) ** 2 - 8 * (r8 - n20)));
    }
  return [a26];
}
function m3(n19, t5, e9) {
  const r7 = e9.length, a26 = new Float32Array(r7);
  for (let o13 = 0; o13 < r7; o13++)
    if (null == n19 || n19[o13]) {
      const n20 = e9[o13], r8 = t5[o13];
      if (1 !== n20) {
        const t6 = (2 * (r8 * r8 - n20 * n20) + 1.5 * r8 + 0.5 * n20) / (r8 + n20 + 0.5);
        a26[o13] = t6 * (1 - 0.25 * t6) - (n20 - 0.125) / (1 - n20);
      }
    }
  return [a26];
}
function d2(n19, t5, e9, r7, a26) {
  const o13 = e9.length, s11 = new Float32Array(o13), i20 = Math.sqrt(1 + r7 * r7);
  for (let l15 = 0; l15 < o13; l15++)
    if (null == n19 || n19[l15]) {
      const n20 = e9[l15], o14 = t5[l15];
      s11[l15] = (o14 - r7 * n20 - a26) / i20;
    }
  return [s11];
}
function g2(n19, t5) {
  const [e9, r7, a26, o13, s11, i20] = t5, l15 = e9.length, c28 = new Float32Array(l15);
  for (let u16 = 0; u16 < l15; u16++)
    (null == n19 || n19[u16]) && (c28[u16] = -0.2848 * e9[u16] - 0.2435 * r7[u16] - 0.5436 * a26[u16] + 0.7243 * o13[u16] + 0.084 * s11[u16] - 1.18 * i20[u16]);
  return [c28];
}
function y4(n19, t5) {
  const [e9, , r7, a26, o13, s11] = t5, i20 = e9.length, l15 = new Float32Array(i20), c28 = new Float32Array(i20), u16 = new Float32Array(i20);
  for (let f6 = 0; f6 < i20; f6++)
    (null == n19 || n19[f6]) && (l15[f6] = s11[f6] ? o13[f6] / s11[f6] * 100 : 0, c28[f6] = e9[f6] ? o13[f6] / e9[f6] * 100 : 0, u16[f6] = a26[f6] ? r7[f6] / a26[f6] * (o13[f6] / a26[f6]) * 100 : 0);
  return [l15, c28, u16];
}
function b(n19, t5) {
  const [e9, r7, a26] = t5, o13 = e9.length, s11 = new Float32Array(o13);
  for (let i20 = 0; i20 < o13; i20++)
    if (null == n19 || n19[i20])
      for (i20 = 0; i20 < o13; i20++) {
        const n20 = e9[i20], t6 = r7[i20], o14 = t6 + n20 - a26[i20];
        o14 && (s11[i20] = (t6 - n20) / o14);
      }
  return [s11];
}
function v(n19, t5) {
  const [e9, r7, a26] = t5, o13 = e9.length, s11 = new Float32Array(o13);
  for (let i20 = 0; i20 < o13; i20++)
    if (null == n19 || n19[i20])
      for (i20 = 0; i20 < o13; i20++) {
        const n20 = e9[i20], t6 = r7[i20], o14 = a26[i20], l15 = Math.sqrt((2 * n20 + 1) ** 2 - 6 * n20 - 5 * Math.sqrt(t6) - 0.5);
        s11[i20] = 1.5 * (1.2 * (n20 - o14) - 2.5 * (t6 - o14)) * l15;
      }
  return [s11];
}
function k(n19, t5) {
  const [e9, r7, a26] = t5, o13 = e9.length, s11 = new Float32Array(o13);
  for (let i20 = 0; i20 < o13; i20++)
    if (null == n19 || n19[i20])
      for (i20 = 0; i20 < o13; i20++) {
        const n20 = e9[i20], t6 = r7[i20], o14 = a26[i20];
        s11[i20] = 100 * (n20 - t6) - 10 * (n20 - o14);
      }
  return [s11];
}
function A(n19, t5) {
  const [e9, r7, a26] = t5, o13 = e9.length, s11 = new Float32Array(o13);
  for (let i20 = 0; i20 < o13; i20++)
    if (null == n19 || n19[i20])
      for (i20 = 0; i20 < o13; i20++) {
        const n20 = e9[i20], t6 = r7[i20], o14 = n20 + 6 * t6 - 7.5 * a26[i20] + 1;
        o14 && (s11[i20] = 2.5 * (n20 - t6) / o14);
      }
  return [s11];
}
function p7(n19, t5, e9 = 0.5) {
  const [r7, a26, o13] = t5, s11 = a26.length, i20 = new Float32Array(s11);
  for (let l15 = 0; l15 < s11; l15++)
    if (null == n19 || n19[l15])
      for (l15 = 0; l15 < s11; l15++) {
        const n20 = r7[l15], t6 = a26[l15], s12 = o13[l15], c28 = n20 + e9 * t6 + (1 - e9) * s12;
        c28 && (i20[l15] = (n20 - e9 * t6 - (1 - e9) * s12) / c28);
      }
  return [i20];
}
function F(n19, t5, e9) {
  const r7 = e9.length, a26 = new Float32Array(r7);
  for (let o13 = 0; o13 < r7; o13++)
    if (null == n19 || n19[o13])
      for (o13 = 0; o13 < r7; o13++) {
        const n20 = (0.1 - t5[o13]) ** 2 + (0.06 - e9[o13]) ** 2;
        n20 && (a26[o13] = 1 / n20);
      }
  return [a26];
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/BandArithmeticFunctionArguments.js
var p8;
var a6 = p8 = class extends p4 {
  constructor() {
    super(...arguments), this.method = "custom";
  }
  clone() {
    return new p8({ method: this.method, bandIndexes: this.bandIndexes, raster: a(this.raster) });
  }
};
e([y({ json: { type: String, write: true } })], a6.prototype, "bandIndexes", void 0), e([o2(a5)], a6.prototype, "method", void 0), a6 = p8 = e([c("esri.layers.support.rasterFunctions.BandArithmeticFunctionArguments")], a6);
var i3 = a6;

// node_modules/@arcgis/core/layers/support/rasterFunctions/BandArithmeticFunction.js
var o6 = /* @__PURE__ */ new Set(["vari", "mtvi2", "rtvi-core", "evi"]);
var c6 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "BandArithmetic", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    this.outputPixelType = this._getOutputPixelType("f32");
    const e9 = this.sourceRasterInfos[0];
    if (e9.bandCount < 2)
      return { success: false, supportsGPU: false, error: "band-arithmetic-function: source raster has insufficient amount of raster bands" };
    const s11 = e9.clone();
    s11.pixelType = this.outputPixelType, s11.statistics = null, s11.histograms = null, s11.bandCount = "sultan" === this.functionArguments.method ? 3 : 1, s11.keyProperties = { ...s11.keyProperties, BandProperties: void 0 }, this.rasterInfo = s11;
    return { success: true, supportsGPU: !["custom", "gvitm", "sultan"].includes(this.functionArguments.method) };
  }
  _processPixels(e9) {
    var _a;
    const s11 = (_a = e9.pixelBlocks) == null ? void 0 : _a[0];
    if (null == s11)
      return s11;
    const { method: t5, bandIndexes: r7 } = this.functionArguments, i20 = r7.split(" ").map((e10) => parseFloat(e10));
    return o5(s11, { method: t5, bandIndexes: i20, equation: r7 });
  }
  _getWebGLParameters() {
    const e9 = this.functionArguments.bandIndexes.split(" ").map((e10) => parseFloat(e10) - 1);
    2 === e9.length && e9.push(0);
    const s11 = this.isInputBandIdsSwizzled ? [0, 1, 2] : e9;
    let t5, r7;
    const n19 = new Float32Array(3), { method: a26 } = this.functionArguments;
    switch (a26) {
      case "gndvi":
      case "nbr":
      case "ndbi":
      case "ndvi":
      case "ndvi-re":
      case "ndsi":
      case "ndmi":
      case "mndwi":
        t5 = i2([s11[0], s11[1], 0]), r7 = "ndxi";
        break;
      case "ndwi":
        t5 = i2([s11[1], s11[0], 0]), r7 = "ndxi";
        break;
      case "sr":
      case "sr-re":
      case "iron-oxide":
      case "ferrous-minerals":
      case "clay-minerals":
        t5 = i2([s11[0], s11[1], 0]), r7 = "sr";
        break;
      case "ci-g":
      case "ci-re":
        t5 = i2([s11[0], s11[1], 0]), r7 = "ci";
        break;
      case "savi":
        t5 = i2([s11[0], s11[1], 0]), r7 = "savi", n19[0] = e9[2] + 1;
        break;
      case "tsavi":
        t5 = i2([s11[0], s11[1], 0]), r7 = "tsavi", n19[0] = e9[2] + 1, n19[1] = e9[3] + 1, n19[2] = e9[4] + 1;
        break;
      case "msavi":
        t5 = i2([s11[0], s11[1], 0]), r7 = "msavi";
        break;
      case "gemi":
        t5 = i2([s11[0], s11[1], 0]), r7 = "gemi";
        break;
      case "pvi":
        t5 = i2([s11[0], s11[1], 0]), r7 = "tsavi", n19[0] = e9[2] + 1, n19[1] = e9[3] + 1;
        break;
      case "vari":
        t5 = i2([s11[0], s11[1], s11[2]]), r7 = "vari";
        break;
      case "mtvi2":
        t5 = i2([s11[0], s11[1], s11[2]]), r7 = "mtvi2";
        break;
      case "rtvi-core":
        t5 = i2([s11[0], s11[1], s11[2]]), r7 = "rtvicore";
        break;
      case "evi":
        t5 = i2([s11[0], s11[1], s11[2]]), r7 = "evi";
        break;
      case "wndwi":
        t5 = i2([s11[0], s11[1], 0]), r7 = "wndwi", n19[0] = e9[3] ? e9[3] + 1 : 0.5;
        break;
      case "bai":
        t5 = i2([s11[1], s11[0], 0]), r7 = "bai";
        break;
      default:
        t5 = i2([0, 1, 2]), r7 = "custom";
    }
    return { bandIndexMat3: t5, indexType: r7, adjustments: n19 };
  }
  _getInputBandIds(e9) {
    if ("custom" === this.functionArguments.method)
      return e9;
    const s11 = this.functionArguments.bandIndexes.split(" ").map((e10) => parseFloat(e10) - 1), t5 = e9.length, r7 = s11.map((e10) => e10 >= t5 ? t5 - 1 : e10), n19 = o6.has(this.functionArguments.method) ? 3 : 2, i20 = r7.slice(0, n19).map((s12) => e9[s12]);
    return 2 === i20.length && i20.push(0), i20;
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], c6.prototype, "functionName", void 0), e([y({ type: i3, json: { write: true, name: "rasterFunctionArguments" } })], c6.prototype, "functionArguments", void 0), e([y()], c6.prototype, "rasterArgumentNames", void 0), c6 = e([c("esri.layers.support.rasterFunctions.BandArithmeticFunction")], c6);
var u5 = c6;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ColormapFunctionArguments.js
var i4;
var u6 = i4 = class extends p4 {
  castColormapName(o13) {
    if (!o13)
      return null;
    const r7 = o13.toLowerCase();
    return C.includes(r7) ? r7 : null;
  }
  readColorRamp(o13) {
    return p(o13);
  }
  readColorRampName(o13, r7) {
    if (!o13)
      return null;
    const e9 = a2.jsonValues.find((r8) => r8.toLowerCase() === o13.toLowerCase());
    return e9 ? a2.fromJSON(e9) : null;
  }
  clone() {
    var _a;
    return new i4({ colormap: a(this.colormap), colormapName: this.colormapName, colorRamp: (_a = this.colorRamp) == null ? void 0 : _a.clone(), colorRampName: this.colorRampName });
  }
};
e([y({ type: [[Number]], json: { write: true } })], u6.prototype, "colormap", void 0), e([y({ type: String, json: { write: true } })], u6.prototype, "colormapName", void 0), e([s3("colormapName")], u6.prototype, "castColormapName", null), e([y({ types: m, json: { write: true } })], u6.prototype, "colorRamp", void 0), e([o("colorRamp")], u6.prototype, "readColorRamp", null), e([y({ type: a2.apiValues, json: { type: a2.jsonValues, write: a2.write } })], u6.prototype, "colorRampName", void 0), e([o("colorRampName")], u6.prototype, "readColorRampName", null), u6 = i4 = e([c("esri.layers.support.rasterFunctions.ColormapFunctionArguments")], u6);
var d3 = u6;

// node_modules/@arcgis/core/layers/support/rasterFunctions/colormaps.js
var t3 = [[36, 0, 255], [36, 0, 255], [36, 0, 255], [36, 0, 255], [112, 75, 3], [113, 76, 3], [114, 77, 3], [115, 77, 3], [116, 78, 3], [117, 79, 3], [118, 79, 3], [119, 80, 3], [121, 81, 4], [122, 82, 4], [123, 82, 4], [124, 83, 4], [125, 84, 4], [126, 84, 4], [127, 85, 4], [128, 86, 4], [129, 86, 4], [130, 87, 4], [131, 88, 4], [132, 89, 4], [133, 89, 4], [134, 90, 4], [135, 91, 4], [136, 91, 4], [137, 92, 4], [138, 93, 4], [139, 94, 4], [140, 94, 4], [142, 95, 5], [143, 96, 5], [144, 96, 5], [145, 97, 5], [146, 98, 5], [147, 99, 5], [148, 99, 5], [149, 100, 5], [150, 101, 5], [151, 101, 5], [152, 102, 5], [153, 103, 5], [154, 104, 5], [155, 104, 5], [156, 105, 5], [157, 106, 5], [158, 106, 5], [159, 107, 5], [160, 108, 5], [161, 108, 5], [162, 109, 5], [164, 110, 6], [165, 111, 6], [166, 111, 6], [167, 112, 6], [168, 113, 6], [169, 113, 6], [170, 114, 6], [171, 115, 6], [172, 116, 6], [173, 116, 6], [174, 117, 6], [245, 0, 0], [245, 5, 0], [245, 10, 0], [246, 15, 0], [246, 20, 0], [246, 25, 0], [246, 30, 0], [247, 35, 0], [247, 40, 0], [247, 45, 0], [247, 50, 0], [247, 55, 0], [248, 60, 0], [248, 65, 0], [248, 70, 0], [248, 75, 0], [249, 81, 0], [249, 86, 0], [249, 91, 0], [249, 96, 0], [250, 101, 0], [250, 106, 0], [250, 111, 0], [250, 116, 0], [250, 121, 0], [251, 126, 0], [251, 131, 0], [251, 136, 0], [251, 141, 0], [252, 146, 0], [252, 151, 0], [252, 156, 0], [252, 156, 0], [251, 159, 0], [250, 162, 0], [249, 165, 0], [248, 168, 0], [247, 171, 0], [246, 174, 0], [245, 177, 0], [245, 179, 0], [244, 182, 0], [243, 185, 0], [242, 188, 0], [241, 191, 0], [240, 194, 0], [239, 197, 0], [238, 200, 0], [237, 203, 0], [236, 206, 0], [235, 209, 0], [234, 212, 0], [233, 215, 0], [232, 218, 0], [231, 221, 0], [230, 224, 0], [230, 226, 0], [229, 229, 0], [228, 232, 0], [227, 235, 0], [226, 238, 0], [225, 241, 0], [224, 244, 0], [223, 247, 0], [165, 247, 0], [163, 244, 0], [161, 240, 0], [158, 237, 0], [156, 233, 1], [154, 230, 1], [152, 227, 1], [149, 223, 1], [147, 220, 1], [145, 216, 1], [143, 213, 1], [140, 210, 2], [138, 206, 2], [136, 203, 2], [134, 200, 2], [132, 196, 2], [129, 193, 2], [127, 189, 2], [125, 186, 3], [123, 183, 3], [120, 179, 3], [118, 176, 3], [116, 172, 3], [114, 169, 3], [111, 166, 3], [109, 162, 4], [107, 159, 4], [105, 155, 4], [103, 152, 4], [100, 149, 4], [98, 145, 4], [96, 142, 4], [94, 138, 5], [91, 135, 5], [89, 132, 5], [87, 128, 5], [85, 125, 5], [82, 121, 5], [80, 118, 5], [78, 115, 6], [76, 111, 6], [73, 108, 6], [71, 105, 6], [69, 101, 6], [67, 98, 6], [65, 94, 6], [62, 91, 7], [60, 88, 7], [58, 84, 7], [56, 81, 7], [53, 77, 7], [51, 74, 7], [49, 71, 7], [47, 67, 8], [44, 64, 8], [42, 60, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8]];
var o7 = [[36, 0, 255], [36, 0, 255], [36, 0, 255], [36, 0, 255], [245, 20, 0], [245, 24, 0], [245, 29, 0], [245, 31, 0], [247, 33, 0], [247, 33, 0], [247, 37, 0], [247, 41, 0], [247, 41, 0], [247, 41, 0], [247, 45, 0], [247, 45, 0], [247, 47, 0], [247, 49, 0], [247, 49, 0], [247, 54, 0], [247, 54, 0], [247, 56, 0], [247, 58, 0], [247, 58, 0], [250, 62, 0], [250, 62, 0], [250, 62, 0], [250, 67, 0], [250, 67, 0], [250, 67, 0], [250, 69, 0], [250, 71, 0], [250, 71, 0], [250, 75, 0], [250, 75, 0], [250, 78, 0], [250, 79, 0], [250, 79, 0], [250, 79, 0], [250, 81, 0], [250, 83, 0], [250, 83, 0], [250, 87, 0], [250, 87, 0], [250, 90, 0], [250, 92, 0], [252, 93, 0], [252, 93, 0], [252, 97, 0], [252, 97, 0], [252, 97, 0], [252, 97, 0], [252, 101, 0], [252, 101, 0], [252, 101, 0], [252, 101, 0], [252, 105, 0], [252, 105, 0], [252, 107, 0], [252, 109, 0], [252, 109, 0], [252, 113, 13], [255, 118, 20], [255, 119, 23], [255, 121, 25], [255, 126, 33], [255, 132, 38], [255, 133, 40], [255, 135, 43], [255, 141, 48], [255, 144, 54], [255, 150, 59], [255, 152, 61], [255, 153, 64], [255, 159, 69], [255, 163, 77], [255, 165, 79], [255, 168, 82], [255, 174, 87], [255, 176, 92], [255, 181, 97], [255, 183, 99], [255, 186, 102], [255, 191, 107], [255, 197, 115], [255, 201, 120], [255, 203, 123], [255, 205, 125], [255, 209, 130], [255, 214, 138], [255, 216, 141], [255, 218, 143], [255, 224, 150], [255, 228, 156], [255, 234, 163], [255, 236, 165], [255, 238, 168], [255, 243, 173], [255, 248, 181], [255, 252, 186], [253, 252, 186], [250, 252, 187], [244, 250, 180], [238, 247, 176], [234, 246, 173], [231, 245, 169], [223, 240, 163], [217, 237, 157], [211, 235, 150], [205, 233, 146], [200, 230, 142], [195, 227, 136], [189, 224, 132], [184, 222, 126], [180, 220, 123], [174, 217, 119], [169, 214, 114], [163, 212, 108], [160, 210, 105], [154, 207, 101], [148, 204, 96], [143, 201, 93], [138, 199, 88], [134, 197, 84], [130, 194, 81], [126, 191, 77], [117, 189, 70], [115, 186, 68], [112, 184, 64], [106, 181, 60], [100, 179, 55], [94, 176, 49], [92, 174, 47], [90, 173, 45], [81, 168, 37], [75, 166, 33], [71, 163, 28], [66, 160, 24], [62, 158, 21], [56, 156, 14], [51, 153, 0], [51, 153, 0], [51, 153, 0], [50, 150, 0], [50, 150, 0], [50, 150, 0], [50, 150, 0], [49, 148, 0], [49, 148, 0], [49, 148, 0], [48, 145, 0], [48, 145, 0], [48, 145, 0], [48, 145, 0], [48, 143, 0], [48, 143, 0], [48, 143, 0], [48, 143, 0], [47, 140, 0], [47, 140, 0], [47, 140, 0], [47, 140, 0], [46, 138, 0], [46, 138, 0], [46, 138, 0], [46, 138, 0], [45, 135, 0], [45, 135, 0], [45, 135, 0], [45, 135, 0], [44, 133, 0], [44, 133, 0], [44, 133, 0], [43, 130, 0], [43, 130, 0], [43, 130, 0], [43, 130, 0], [43, 130, 0], [43, 130, 0], [42, 128, 0], [42, 128, 0], [42, 128, 0], [42, 125, 0], [42, 125, 0], [42, 125, 0], [42, 125, 0], [41, 122, 0], [41, 122, 0], [41, 122, 0], [41, 122, 0], [40, 120, 0], [40, 120, 0], [40, 120, 0], [40, 120, 0], [40, 120, 0], [39, 117, 0], [39, 117, 0], [39, 117, 0], [39, 117, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0]];
function e5(t5, o13) {
  const e9 = [], n19 = [];
  for (let r7 = 0; r7 < t5.length - 1; r7++)
    e9.push({ type: "algorithmic", algorithm: "esriHSVAlgorithm", fromColor: t5[r7].slice(1), toColor: t5[r7 + 1].slice(1) }), n19.push(t5[r7 + 1][0] - t5[r7][0]);
  const s11 = t5[t5.length - 1][0];
  return w2({ type: "multipart", colorRamps: e9 }, { numColors: s11, weights: o13 = o13 ?? n19 });
}
function n4() {
  return e5([[0, 0, 191, 191], [51, 0, 0, 255], [102, 255, 0, 255], [153, 255, 0, 127], [204, 191, 63, 127], [256, 20, 20, 20]]);
}
function s7() {
  const r7 = e5([[0, 255, 255, 255], [70, 0, 255, 0], [80, 205, 173, 193], [100, 150, 150, 150], [110, 120, 51, 100], [130, 120, 100, 200], [140, 28, 3, 144], [160, 6, 0, 55], [180, 10, 25, 30], [201, 6, 7, 27]]);
  for (let t5 = r7.length; t5 < 256; t5++)
    r7.push([6, 27, 7]);
  return r7;
}
function l5() {
  return w2({ type: "algorithmic", algorithm: "esriHSVAlgorithm", fromColor: [0, 0, 0], toColor: [255, 255, 255] });
}
function i5() {
  const r7 = [];
  for (let t5 = 0; t5 < 256; t5++) {
    const t6 = [];
    for (let r8 = 0; r8 < 3; r8++)
      t6.push(Math.round(255 * Math.random()));
    r7.push(t6);
  }
  return r7;
}
function a7() {
  return e5([[0, 38, 41, 54], [69, 79, 82, 90], [131, 156, 156, 156], [256, 253, 253, 241]], [0.268, 0.238, 0.495]);
}
function c7(r7) {
  let e9;
  switch (r7) {
    case "elevation":
      e9 = n4();
      break;
    case "gray":
      e9 = l5();
      break;
    case "hillshade":
      e9 = a7();
      break;
    case "ndvi":
      e9 = t3;
      break;
    case "ndvi2":
      e9 = s7();
      break;
    case "ndvi3":
      e9 = o7;
      break;
    case "random":
      e9 = i5();
  }
  return e9 ? (e9 = e9.map((r8, t5) => [t5, ...r8]), e9) : null;
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/ColormapFunction.js
var c8 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Colormap", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isNoopProcess = true;
  }
  _bindSourceRasters() {
    const o13 = this.sourceRasterInfos[0];
    if (o13.bandCount > 1)
      return { success: false, supportsGPU: false, error: "colormap-function: source data must be single band" };
    let { colormap: r7, colormapName: s11, colorRamp: t5, colorRampName: e9 } = this.functionArguments;
    if (!(r7 == null ? void 0 : r7.length))
      if (t5)
        r7 = B(t5, { interpolateAlpha: true });
      else if (e9) {
        const o14 = d(e9);
        o14 && (r7 = B(o14));
      } else
        s11 && (r7 = c7(s11));
    if (!(r7 == null ? void 0 : r7.length))
      return { success: false, supportsGPU: false, error: "colormap-function: missing colormap argument" };
    this.outputPixelType = this._getOutputPixelType("u8");
    const c28 = o13.clone();
    return c28.pixelType = this.outputPixelType, c28.colormap = r7, c28.bandCount = 1, this.rasterInfo = c28, { success: true, supportsGPU: true };
  }
  _processPixels(o13) {
    var _a;
    return (_a = o13.pixelBlocks) == null ? void 0 : _a[0];
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], c8.prototype, "functionName", void 0), e([y({ type: d3, json: { write: true, name: "rasterFunctionArguments" } })], c8.prototype, "functionArguments", void 0), e([y()], c8.prototype, "rasterArgumentNames", void 0), e([y()], c8.prototype, "isNoopProcess", void 0), e([y({ json: { write: true } })], c8.prototype, "indexedColormap", void 0), c8 = e([c("esri.layers.support.rasterFunctions.ColormapFunction")], c8);
var u7 = c8;

// node_modules/@arcgis/core/layers/support/rasterFunctions/CompositeBandFunctionArguments.js
var a8;
var c9 = a8 = class extends p4 {
  constructor() {
    super(...arguments), this.rasters = [];
  }
  writeRasters(r7, s11) {
    s11.rasters = r7.map((r8) => "number" == typeof r8 || "string" == typeof r8 ? r8 : r8.toJSON());
  }
  clone() {
    return new a8({ rasters: a(this.rasters) });
  }
};
e([y({ json: { write: true } })], c9.prototype, "rasters", void 0), e([r("rasters")], c9.prototype, "writeRasters", null), c9 = a8 = e([c("esri.layers.support.rasterFunctions.CompositeBandFunctionArguments")], c9);
var n5 = c9;

// node_modules/@arcgis/core/layers/support/rasterFunctions/CompositeBandFunction.js
var i6 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "CompositeBand", this.functionArguments = null, this.rasterArgumentNames = ["rasters"];
  }
  _bindSourceRasters() {
    const { sourceRasterInfos: t5 } = this, e9 = t5[0];
    this.outputPixelType = this._getOutputPixelType(e9.pixelType);
    const s11 = e9.clone();
    if (s11.attributeTable = null, s11.colormap = null, s11.pixelType = this.outputPixelType, s11.bandCount = t5.map(({ bandCount: t6 }) => t6).reduce((t6, e10) => t6 + e10), t5.every(({ statistics: t6 }) => null != t6 && t6.length)) {
      const e10 = [];
      t5.forEach(({ statistics: t6 }) => null != t6 && e10.push(...t6)), s11.statistics = e10;
    }
    if (t5.every(({ histograms: t6 }) => null != t6 && t6.length)) {
      const e10 = [];
      t5.forEach(({ histograms: t6 }) => null != t6 && e10.push(...t6)), s11.histograms = e10;
    }
    s11.bandCount > 1 && (s11.colormap = null, s11.attributeTable = null);
    const r7 = t5.every((t6) => {
      var _a;
      return (_a = t6.keyProperties.BandProperties) == null ? void 0 : _a.length;
    }) ? t5.flatMap((t6) => t6.keyProperties.BandProperties) : void 0;
    s11.keyProperties = { ...s11.keyProperties, BandProperties: r7 }, this.rasterInfo = s11;
    return { success: true, supportsGPU: s11.bandCount <= 3 };
  }
  _processPixels(t5) {
    const { pixelBlocks: e9 } = t5;
    if (!e9)
      return null;
    const s11 = e9 == null ? void 0 : e9[0];
    return null == s11 ? null : r2(e9);
  }
  _getWebGLParameters() {
    return { bandCount: this.rasterInfo.bandCount };
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], i6.prototype, "functionName", void 0), e([y({ type: n5, json: { write: true, name: "rasterFunctionArguments" } })], i6.prototype, "functionArguments", void 0), e([y()], i6.prototype, "rasterArgumentNames", void 0), i6 = e([c("esri.layers.support.rasterFunctions.CompositeBandFunction")], i6);
var a9 = i6;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ContrastBrightnessFunctionArguments.js
var o8;
var n6 = o8 = class extends p4 {
  constructor() {
    super(...arguments), this.contrastOffset = 0, this.brightnessOffset = 0;
  }
  clone() {
    return new o8({ contrastOffset: this.contrastOffset, brightnessOffset: this.brightnessOffset, raster: this.raster });
  }
};
e([y({ json: { write: true } })], n6.prototype, "contrastOffset", void 0), e([y({ json: { write: true } })], n6.prototype, "brightnessOffset", void 0), n6 = o8 = e([c("esri.layers.support.rasterFunctions.ContrastBrightnessFunctionArguments")], n6);
var c10 = n6;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ContrastBrightnessFunction.js
var u8 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "ContrastBrightness", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.lookup = null;
  }
  _bindSourceRasters() {
    const { sourceRasterInfos: t5 } = this, s11 = t5[0];
    if ("u8" !== s11.pixelType)
      return { success: false, supportsGPU: false, error: "Only unsigned 8 bit raster is supported by ContrastBrightness function." };
    this.outputPixelType = this._getOutputPixelType("u8");
    const r7 = s11.clone();
    r7.colormap = null, r7.statistics = null, r7.histograms = null, this.rasterInfo = r7;
    const { contrastOffset: o13, brightnessOffset: e9 } = this.functionArguments;
    return this.lookup = l2(o13, e9), { success: true, supportsGPU: true };
  }
  _processPixels(t5) {
    var _a;
    const s11 = (_a = t5.pixelBlocks) == null ? void 0 : _a[0];
    return null == s11 ? null : f2(s11, { lut: s11.pixels.map(() => this.lookup), offset: 0, outputPixelType: "u8" });
  }
  _getWebGLParameters() {
    const { contrastOffset: t5, brightnessOffset: s11 } = this.functionArguments;
    return { contrastOffset: t5, brightnessOffset: s11 };
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], u8.prototype, "functionName", void 0), e([y({ type: c10, json: { write: true, name: "rasterFunctionArguments" } })], u8.prototype, "functionArguments", void 0), e([y()], u8.prototype, "rasterArgumentNames", void 0), e([y({ json: { write: true } })], u8.prototype, "lookup", void 0), u8 = e([c("esri.layers.support.rasterFunctions.ContrastBrightnessFunction")], u8);
var p9 = u8;

// node_modules/@arcgis/core/layers/support/rasterFunctionConstants.js
var l6 = { userDefined: -1, lineDetectionHorizontal: 0, lineDetectionVertical: 1, lineDetectionLeftDiagonal: 2, lineDetectionRightDiagonal: 3, gradientNorth: 4, gradientWest: 5, gradientEast: 6, gradientSouth: 7, gradientNorthEast: 8, gradientNorthWest: 9, smoothArithmeticMean: 10, smoothing3x3: 11, smoothing5x5: 12, sharpening3x3: 13, sharpening5x5: 14, laplacian3x3: 15, laplacian5x5: 16, sobelHorizontal: 17, sobelVertical: 18, sharpen: 19, sharpen2: 20, pointSpread: 21, none: 255 };
var D2 = { plus: 1, minus: 2, times: 3, sqrt: 4, power: 5, abs: 10, divide: 23, exp: 25, exp10: 26, exp2: 27, int: 30, float: 32, ln: 35, log10: 36, log2: 37, mod: 44, negate: 45, roundDown: 48, roundUp: 49, square: 53, floatDivide: 64, floorDivide: 65 };
var h3 = { bitwiseAnd: 11, bitwiseLeftShift: 12, bitwiseNot: 13, bitwiseOr: 14, bitwiseRightShift: 15, bitwiseXOr: 16, booleanAnd: 17, booleanNot: 18, booleanOr: 19, booleanXOr: 20, equalTo: 24, greaterThan: 28, greaterThanEqual: 29, lessThan: 33, lessThanEqual: 34, isNull: 31, notEqual: 46 };
var u9 = { acos: 6, asin: 7, atan: 8, atanh: 9, cos: 21, cosh: 22, sin: 51, sinh: 52, tan: 56, tanh: 57, acosh: 59, asinh: 60, atan2: 61 };
var s8 = { majority: 38, max: 39, mean: 40, med: 41, min: 42, minority: 43, range: 47, stddev: 54, sum: 55, variety: 58, majorityIgnoreNoData: 66, maxIgnoreNoData: 67, meanIgnoreNoData: 68, medIgnoreNoData: 69, minIgnoreNoData: 70, minorityIgnoreNoData: 71, rangeIgnoreNoData: 72, stddevIgnoreNoData: 73, sumIgnoreNoData: 74, varietyIgnoreNoData: 75 };
var d4 = { setNull: 50, conditional: 78 };
var p10 = { ...D2, ...h3, ...u9, ...s8, ...d4 };

// node_modules/@arcgis/core/layers/support/rasterFunctions/mirror.js
function o9(o13, t5, f6, r7, l15) {
  const e9 = Math.floor(r7 / 2);
  for (let c28 = 0; c28 < e9; c28++)
    for (let r8 = 0; r8 < t5; r8++)
      o13[c28 * t5 + r8] = o13[(l15 - 1 - c28) * t5 + r8], o13[(f6 - 1 - c28) * t5 + r8] = o13[(f6 - l15 + c28) * t5 + r8];
  const n19 = Math.floor(l15 / 2);
  for (let c28 = 0; c28 < f6; c28++) {
    const f7 = c28 * t5;
    for (let r8 = 0; r8 < n19; r8++)
      o13[f7 + r8] = o13[f7 + l15 - 1 - r8], o13[f7 + t5 - r8 - 1] = o13[f7 + t5 + r8 - l15];
  }
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/convolutionUtils.js
var l7 = /* @__PURE__ */ new Map();
function o10(e9) {
  const t5 = Math.sqrt(e9.length), n19 = e9.slice(0, t5), l15 = [1];
  for (let o13 = 1; o13 < t5; o13++) {
    let n20 = null;
    for (let l16 = 0; l16 < t5; l16++) {
      const r7 = e9[l16 + o13 * t5], s11 = e9[l16];
      if (null == n20)
        if (0 === s11) {
          if (r7)
            return { separable: false, row: null, col: null };
        } else
          n20 = r7 / s11;
      else if (r7 / s11 !== n20)
        return { separable: false, row: null, col: null };
    }
    if (null == n20)
      return { separable: false, row: null, col: null };
    l15.push(n20);
  }
  return { separable: true, row: n19, col: l15 };
}
function r4(e9, t5, n19, l15, o13, r7, s11) {
  const i20 = new Float32Array(t5 * n19), a26 = r7.length, h6 = s11 ? 0 : l15, c28 = s11 ? l15 : 0, p23 = s11 ? 1 : t5;
  for (let u16 = h6; u16 < n19 - h6; u16++) {
    const n20 = u16 * t5;
    for (let s12 = c28; s12 < t5 - c28; s12++) {
      if (o13 && !o13[n20 + s12])
        continue;
      let t6 = 0;
      for (let o14 = 0; o14 < a26; o14++)
        t6 += e9[n20 + s12 + (o14 - l15) * p23] * r7[o14];
      i20[n20 + s12] = t6;
    }
  }
  return i20;
}
function s9(e9, t5, n19, l15, o13, r7, s11) {
  const i20 = new Float32Array(t5 * n19), a26 = Math.floor(l15 / 2), h6 = Math.floor(o13 / 2);
  for (let c28 = a26; c28 < n19 - a26; c28++) {
    const n20 = c28 * t5;
    for (let c29 = h6; c29 < t5 - h6; c29++) {
      if (r7 && !r7[n20 + c29])
        continue;
      let p23 = 0;
      for (let r8 = 0; r8 < l15; r8++)
        for (let l16 = 0; l16 < o13; l16++)
          p23 += e9[n20 + c29 + (r8 - a26) * t5 + l16 - h6] * s11[r8 * o13 + l16];
      i20[n20 + c29] = p23;
    }
  }
  return i20;
}
function i7(t5, l15, o13 = true) {
  const { pixels: r7, width: i20, height: a26, pixelType: h6, mask: c28 } = t5, p23 = r7.length, u16 = [], { kernel: f6, rows: g5, cols: m8 } = l15;
  for (let e9 = 0; e9 < p23; e9++) {
    const t6 = s9(r7[e9], i20, a26, g5, m8, c28, f6);
    o13 && o9(t6, i20, a26, g5, m8), u16.push(t6);
  }
  return new u({ width: i20, height: a26, pixelType: h6, pixels: u16, mask: c28 });
}
function a10(t5, l15, o13, s11 = true) {
  const { pixels: i20, width: a26, height: h6, pixelType: c28, mask: p23 } = t5, u16 = i20.length, f6 = [], g5 = l15.length, m8 = o13.length, x5 = Math.floor(g5 / 2), w6 = Math.floor(m8 / 2);
  for (let e9 = 0; e9 < u16; e9++) {
    let t6 = r4(i20[e9], a26, h6, x5, p23, l15, true);
    t6 = r4(t6, a26, h6, w6, p23, o13, false), s11 && o9(t6, a26, h6, g5, m8), f6.push(t6);
  }
  return new u({ width: a26, height: h6, pixelType: c28, pixels: f6, mask: p23 });
}
function h4(e9, t5) {
  const n19 = o10(t5.kernel), l15 = false !== t5.mirrorEdges, r7 = n19.separable ? a10(e9, n19.row, n19.col, l15) : i7(e9, t5, l15), { outputPixelType: s11 } = t5;
  return s11 && r7.clamp(s11), r7;
}
l7.set(l6.none, [0, 0, 0, 0, 1, 0, 0, 0, 0]), l7.set(l6.lineDetectionHorizontal, [-1, -1, -1, 2, 2, 2, -1, -1, -1]), l7.set(l6.lineDetectionVertical, [-1, 2, -1, -1, 2, -1, -1, 2, -1]), l7.set(l6.lineDetectionLeftDiagonal, [2, -1, -1, -1, 2, -1, -1, -1, 2]), l7.set(l6.lineDetectionRightDiagonal, [-1, -1, 2, -1, 2, -1, 2, -1, -1]), l7.set(l6.gradientNorth, [-1, -2, -1, 0, 0, 0, 1, 2, 1]), l7.set(l6.gradientWest, [-1, 0, 1, -2, 0, 2, -1, 0, 1]), l7.set(l6.gradientEast, [1, 0, -1, 2, 0, -2, 1, 0, -1]), l7.set(l6.gradientSouth, [1, 2, 1, 0, 0, 0, -1, -2, -1]), l7.set(l6.gradientNorthEast, [0, -1, -2, 1, 0, -1, 2, 1, 0]), l7.set(l6.gradientNorthWest, [-2, -1, 0, -1, 0, 1, 0, 1, 2]), l7.set(l6.smoothArithmeticMean, [0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111]), l7.set(l6.smoothing3x3, [0.0625, 0.125, 0.0625, 0.125, 0.25, 0.125, 0.0625, 0.125, 0.0625]), l7.set(l6.smoothing5x5, [1, 1, 1, 1, 1, 1, 4, 4, 4, 1, 1, 4, 12, 4, 1, 1, 4, 4, 4, 1, 1, 1, 1, 1, 1]), l7.set(l6.sharpening3x3, [-1, -1, -1, -1, 9, -1, -1, -1, -1]), l7.set(l6.sharpening5x5, [-1, -3, -4, -3, -1, -3, 0, 6, 0, -3, -4, 6, 21, 6, -4, -3, 0, 6, 0, -3, -1, -3, -4, -3, -1]), l7.set(l6.laplacian3x3, [0, -1, 0, -1, 4, -1, 0, -1, 0]), l7.set(l6.laplacian5x5, [0, 0, -1, 0, 0, 0, -1, -2, -1, 0, -1, -2, 17, -2, -1, 0, -1, -2, -1, 0, 0, 0, -1, 0, 0]), l7.set(l6.sobelHorizontal, [-1, -2, -1, 0, 0, 0, 1, 2, 1]), l7.set(l6.sobelVertical, [-1, 0, 1, -2, 0, 2, -1, 0, 1]), l7.set(l6.sharpen, [0, -0.25, 0, -0.25, 2, -0.25, 0, -0.25, 0]), l7.set(l6.sharpen2, [-0.25, -0.25, -0.25, -0.25, 3, -0.25, -0.25, -0.25, -0.25]), l7.set(l6.pointSpread, [-0.627, 0.352, -0.627, 0.352, 2.923, 0.352, -0.627, 0.352, -0.627]);

// node_modules/@arcgis/core/layers/support/rasterFunctions/ConvolutionFunctionArguments.js
var p11;
var c11 = p11 = class extends p4 {
  constructor() {
    super(...arguments), this.rows = 3, this.cols = 3, this.kernel = [0, 0, 0, 0, 1, 0, 0, 0, 0];
  }
  set convolutionType(o13) {
    this._set("convolutionType", o13);
    const t5 = l7.get(o13);
    if (!t5 || o13 === l6.userDefined || o13 === l6.none)
      return;
    const s11 = Math.sqrt(t5.length);
    this._set("kernel", t5), this._set("cols", s11), this._set("rows", s11);
  }
  clone() {
    return new p11({ cols: this.cols, rows: this.rows, kernel: [...this.kernel], convolutionType: this.convolutionType, raster: a(this.raster) });
  }
};
e([y({ json: { type: Number, write: true } })], c11.prototype, "rows", void 0), e([y({ json: { type: Number, write: true } })], c11.prototype, "cols", void 0), e([y({ json: { name: "type", type: Number, write: true } })], c11.prototype, "convolutionType", null), e([y({ json: { type: [Number], write: true } })], c11.prototype, "kernel", void 0), c11 = p11 = e([c("esri.layers.support.rasterFunctions.ConvolutionFunctionArguments")], c11);
var u10 = c11;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ConvolutionFunction.js
var c12 = 25;
var p12 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Convolution", this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    const { convolutionType: t5, rows: e9, cols: s11, kernel: r7 } = this.functionArguments;
    if (!Object.values(l6).includes(t5))
      return { success: false, supportsGPU: false, error: `convolution-function: the specified kernel type is not supported ${t5}` };
    if (t5 !== l6.none && e9 * s11 !== r7.length)
      return { success: false, supportsGPU: false, error: "convolution-function: the specified rows and cols do not match the length of the kernel" };
    const n19 = this.sourceRasterInfos[0];
    this.outputPixelType = this._getOutputPixelType(n19.pixelType);
    const i20 = n19.clone();
    i20.pixelType = this.outputPixelType;
    const u16 = [l6.none, l6.sharpen, l6.sharpen2, l6.sharpening3x3, l6.sharpening5x5];
    "u8" === this.outputPixelType || u16.includes(t5) || (i20.statistics = null, i20.histograms = null), i20.colormap = null, i20.attributeTable = null, this.rasterInfo = i20;
    return { success: true, supportsGPU: r7.length <= c12 };
  }
  _processPixels(t5) {
    var _a;
    const e9 = (_a = t5.pixelBlocks) == null ? void 0 : _a[0];
    if (null == e9 || this.functionArguments.convolutionType === l6.none)
      return e9;
    let { kernel: s11, rows: r7, cols: n19 } = this.functionArguments;
    const i20 = s11.reduce((t6, e10) => t6 + e10);
    return 0 !== i20 && 1 !== i20 && (s11 = s11.map((t6) => t6 / i20)), h4(e9, { kernel: s11, rows: r7, cols: n19, outputPixelType: this.outputPixelType });
  }
  _getWebGLParameters() {
    let { kernel: t5 } = this.functionArguments;
    const e9 = t5.reduce((t6, e10) => t6 + e10);
    0 !== e9 && 1 !== e9 && (t5 = t5.map((t6) => t6 / e9));
    const s11 = new Float32Array(c12);
    return s11.set(t5), { kernelRows: this.functionArguments.rows, kernelCols: this.functionArguments.cols, kernel: s11, clampRange: s4(this.outputPixelType) };
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], p12.prototype, "functionName", void 0), e([y({ type: u10, json: { write: true, name: "rasterFunctionArguments" } })], p12.prototype, "functionArguments", void 0), e([y()], p12.prototype, "rasterArgumentNames", void 0), p12 = e([c("esri.layers.support.rasterFunctions.ConvolutionFunction")], p12);
var l8 = p12;

// node_modules/@arcgis/core/layers/support/rasterFunctions/CurvatureFunctionArguments.js
var c13;
var u11 = new s2({ 0: "standard", 1: "platform", 2: "profile" }, { useNumericKeys: true });
var i8 = c13 = class extends p4 {
  constructor() {
    super(...arguments), this.curvatureType = "standard", this.zFactor = 1;
  }
  readCurvatureType(r7, e9) {
    return u11.fromJSON(e9.type ?? e9.curvatureType ?? 0);
  }
  clone() {
    return new c13({ curvatureType: this.curvatureType, zFactor: this.zFactor, raster: this.raster });
  }
};
e([y({ json: { write: { target: "type" } } }), o2(u11)], i8.prototype, "curvatureType", void 0), e([o("curvatureType", ["type", "curvatureType"])], i8.prototype, "readCurvatureType", null), e([y({ type: Number, json: { write: true } })], i8.prototype, "zFactor", void 0), i8 = c13 = e([c("esri.layers.support.rasterFunctions.CurvatureFunctionArguments")], i8);
var n7 = i8;

// node_modules/@arcgis/core/layers/support/rasterFunctions/CurvatureFunction.js
var n8 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Curvature", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isGCS = false;
  }
  _bindSourceRasters() {
    var _a;
    this.outputPixelType = this._getOutputPixelType("f32");
    const t5 = this.sourceRasterInfos[0].clone();
    return t5.pixelType = this.outputPixelType, t5.statistics = null, t5.histograms = null, t5.colormap = null, t5.attributeTable = null, t5.bandCount = 1, this.rasterInfo = t5, this.isGCS = ((_a = t5.spatialReference) == null ? void 0 : _a.isGeographic) ?? false, { success: true, supportsGPU: true };
  }
  _processPixels(t5) {
    var _a;
    const r7 = (_a = t5.pixelBlocks) == null ? void 0 : _a[0];
    if (null == r7)
      return null;
    const { zFactor: s11, curvatureType: e9 } = this.functionArguments, { extent: o13, primaryPixelSizes: n19 } = t5, a26 = n19 == null ? void 0 : n19[0], c28 = a26 ?? (o13 ? { x: o13.width / r7.width, y: o13.height / r7.height } : { x: 1, y: 1 }), p23 = this.isGCS && s11 >= 1 ? s11 * s5 : s11;
    return u2(r7, { zFactor: p23, curvatureType: e9, resolution: c28 });
  }
  _getWebGLParameters() {
    const { zFactor: t5, curvatureType: r7 } = this.functionArguments;
    return { curvatureType: r7, zFactor: this.isGCS && t5 >= 1 ? t5 * s5 : t5 };
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], n8.prototype, "functionName", void 0), e([y({ type: n7, json: { write: true, name: "rasterFunctionArguments" } })], n8.prototype, "functionArguments", void 0), e([y()], n8.prototype, "rasterArgumentNames", void 0), e([y({ json: { write: true } })], n8.prototype, "isGCS", void 0), n8 = e([c("esri.layers.support.rasterFunctions.CurvatureFunction")], n8);
var a11 = n8;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ExtractBandFunctionArguments.js
var a12;
var i9 = a12 = class extends p4 {
  constructor() {
    super(...arguments), this.bandIds = [], this.bandNames = [], this.bandWavelengths = [], this.missingBandAction = l.bestMatch;
  }
  clone() {
    var _a, _b, _c;
    return new a12({ bandIds: (_a = this.bandIds) == null ? void 0 : _a.slice(), bandNames: (_b = this.bandNames) == null ? void 0 : _b.slice(), bandWavelengths: (_c = this.bandWavelengths) == null ? void 0 : _c.slice(), missingBandAction: this.missingBandAction, method: this.method, wavelengthMatchTolerance: this.wavelengthMatchTolerance });
  }
};
e([y({ json: { write: true } })], i9.prototype, "bandIds", void 0), e([y({ json: { write: true } })], i9.prototype, "bandNames", void 0), e([y({ json: { write: true } })], i9.prototype, "bandWavelengths", void 0), e([o2({ 0: "name", 1: "wavelength", 2: "id" })], i9.prototype, "method", void 0), e([y({ json: { write: true } })], i9.prototype, "missingBandAction", void 0), e([y({ json: { write: true } })], i9.prototype, "wavelengthMatchTolerance", void 0), i9 = a12 = e([c("esri.layers.support.rasterFunctions.ExtractBandFunctionArguments")], i9);
var c14 = i9;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ExtractBandFunction.js
var i10 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "ExtractBand", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    var _a;
    const { functionArguments: t5, sourceRasterInfos: e9 } = this, n19 = e9[0], { method: s11, bandNames: r7, bandWavelengths: a26, bandIds: i20, missingBandAction: l15 } = t5, u16 = (r7 == null ? void 0 : r7.length) && ("name" === s11 || "id" !== s11 && !(i20 == null ? void 0 : i20.length)), c28 = (a26 == null ? void 0 : a26.length) && ("wavelength" === s11 || "id" !== s11 && !(i20 == null ? void 0 : i20.length)), h6 = l15 === l.fail, d6 = u16 ? this._matchBandNames(n19, r7) : c28 ? this._matchBandWavelengths(n19, a26, h6) : this._matchBandIds(n19, i20, h6);
    if (null == d6) {
      return { success: false, supportsGPU: false, error: `extract-band-function: Invalid ${u16 ? "band names" : c28 ? "band wavelengths" : "band ids"} for the imagery data source` };
    }
    this.functionArguments.bandIds = d6, this.functionArguments.method = "id", this.outputPixelType = this._getOutputPixelType("f32");
    const m8 = n19.clone();
    m8.pixelType = this.outputPixelType, m8.bandCount = d6.length;
    const { statistics: p23, histograms: g5 } = m8;
    null != p23 && p23.length && (m8.statistics = d6.map((t6) => p23[t6] || p23[p23.length - 1])), null != g5 && g5.length && (m8.histograms = d6.map((t6) => g5[t6] || g5[g5.length - 1]));
    let f6 = (_a = m8.keyProperties) == null ? void 0 : _a.BandProperties;
    (f6 == null ? void 0 : f6.length) && (f6 = d6.map((t6) => t6 >= f6.length ? f6[f6.length - 1] : f6[t6]), m8.keyProperties = { ...m8.keyProperties, BandProperties: f6 }), this.rasterInfo = m8;
    return { success: true, supportsGPU: m8.bandCount <= 3 };
  }
  _processPixels(t5) {
    var _a;
    const e9 = (_a = t5.pixelBlocks) == null ? void 0 : _a[0];
    if (null == e9)
      return null;
    const n19 = e9.pixels.length, s11 = this.functionArguments.bandIds.map((t6) => t6 >= n19 ? n19 - 1 : t6);
    return e9.extractBands(s11);
  }
  _getWebGLParameters() {
    let t5;
    if (this.isInputBandIdsSwizzled)
      t5 = this.swizzledBandSelection.length ? this.swizzledBandSelection : [0, 1, 2];
    else {
      t5 = [...this.functionArguments.bandIds], 0 === t5.length ? t5 = [0, 1, 2] : t5.length < 3 && (t5[1] = t5[1] ?? t5[0], t5[2] = t5[2] ?? t5[1]);
      for (let e9 = 0; e9 < 3; e9++)
        t5[e9] = Math.min(t5[e9], 2);
    }
    return { bandIndexMat3: i2(t5) };
  }
  _getInputBandIds(t5) {
    const e9 = t5.length;
    return this.functionArguments.bandIds.map((t6) => t6 >= e9 ? e9 - 1 : t6).map((e10) => t5[e10]);
  }
  _matchBandNames(t5, e9) {
    const n19 = t5.bandInfos.map(({ name: t6 }) => t6.toLowerCase()), s11 = [];
    for (let r7 = 0; r7 < e9.length; r7++) {
      const t6 = e9[r7].toLowerCase();
      let a26 = n19.indexOf(t6);
      if (-1 === a26 && "nearinfrared" === t6 && (a26 = n19.findIndex((t7) => t7.startsWith("nearinfrared_1")), -1 === a26 && (a26 = n19.findIndex((t7) => t7.startsWith("nearinfrared")))), -1 === a26)
        return null;
      s11.push(a26);
    }
    return s11;
  }
  _matchBandIds(t5, e9, n19) {
    const { bandCount: s11 } = t5;
    return !(e9 == null ? void 0 : e9.length) || n19 && e9.some((t6) => t6 < 0 || t6 >= s11) ? null : e9;
  }
  _matchBandWavelengths(t5, e9, n19) {
    const { bandInfos: s11 } = t5, r7 = [];
    for (let i20 = 0; i20 < s11.length; i20++) {
      const { minWavelength: t6, maxWavelength: e10 } = s11[i20];
      if (!t6 || !e10)
        return null;
      r7.push({ minWavelength: t6, maxWavelength: e10 });
    }
    const { wavelengthMatchTolerance: a26 } = this.functionArguments, o13 = [];
    for (let i20 = 0; i20 < e9.length; i20++) {
      const t6 = e9[i20];
      let s12 = false, l15 = -1, u16 = Number.MAX_VALUE;
      for (let e10 = 0; e10 < r7.length; e10++) {
        const n20 = r7[e10], a27 = t6 >= n20.minWavelength && t6 <= n20.maxWavelength, o14 = Math.abs(t6 - (n20.minWavelength + n20.maxWavelength) / 2);
        a27 ? o14 < u16 && (s12 = true, l15 = e10, u16 = o14) : !s12 && o14 < u16 && (l15 = e10, u16 = o14);
      }
      if (!s12 && a26 && u16 < a26 && (s12 = true), !s12 && n19)
        return null;
      o13.push(l15);
    }
    return o13;
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], i10.prototype, "functionName", void 0), e([y({ type: c14, json: { write: true, name: "rasterFunctionArguments" } })], i10.prototype, "functionArguments", void 0), e([y()], i10.prototype, "rasterArgumentNames", void 0), i10 = e([c("esri.layers.support.rasterFunctions.ExtractBandFunction")], i10);
var l9 = i10;

// node_modules/@arcgis/core/layers/support/rasterFunctions/LocalFunctionArguments.js
var a13;
var i11 = a13 = class extends p4 {
  constructor() {
    super(...arguments), this.rasters = [], this.processAsMultiband = true;
  }
  writeRasters(r7, s11) {
    s11.rasters = r7.map((r8) => "number" == typeof r8 || "string" == typeof r8 ? r8 : r8.toJSON());
  }
  clone() {
    return new a13({ operation: this.operation, processAsMultiband: this.processAsMultiband, rasters: a(this.rasters) });
  }
};
e([y({ json: { write: true } })], i11.prototype, "operation", void 0), e([y({ json: { write: true } })], i11.prototype, "rasters", void 0), e([r("rasters")], i11.prototype, "writeRasters", null), e([y({ json: { write: true } })], i11.prototype, "processAsMultiband", void 0), i11 = a13 = e([c("esri.layers.support.rasterFunctions.LocalFunctionArguments")], i11);
var c15 = i11;

// node_modules/@arcgis/core/layers/support/rasterFunctions/localUtils.js
var o11 = /* @__PURE__ */ new Map();
function a14(t5) {
  return o11.get(t5);
}
o11.set(u9.acos, [0, Math.PI]), o11.set(u9.asin, [-Math.PI / 2, Math.PI / 2]), o11.set(u9.atan, [-Math.PI / 2, Math.PI / 2]), o11.set(u9.cos, [-1, 1]), o11.set(u9.sin, [-1, 1]), o11.set(h3.booleanAnd, [0, 1]), o11.set(h3.booleanNot, [0, 1]), o11.set(h3.booleanOr, [0, 1]), o11.set(h3.booleanXOr, [0, 1]), o11.set(h3.equalTo, [0, 1]), o11.set(h3.notEqual, [0, 1]), o11.set(h3.greaterThan, [0, 1]), o11.set(h3.greaterThanEqual, [0, 1]), o11.set(h3.lessThan, [0, 1]), o11.set(h3.lessThanEqual, [0, 1]), o11.set(h3.isNull, [0, 1]);
var l10 = [0, 2, 2, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 999, 999, 999, 999, 999, 999, 2, 1, 2, 999, 1, 1, 2, 1, 1, 1, 999, 999, 1, 1, 999, 1, 1, 2, 999, 999, 2, 2, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 3, 999, 3];
function c16(t5, e9 = false) {
  const n19 = t5.map((t6) => t6.mask), r7 = n19.filter((t6) => null != t6), s11 = t5[0].pixels[0].length;
  if (0 === r7.length)
    return new Uint8Array(s11).fill(255);
  const o13 = r7[0], a26 = new Uint8Array(o13);
  if (1 === r7.length)
    return a26;
  if (!e9) {
    for (let t6 = 1; t6 < r7.length; t6++) {
      const e10 = r7[t6];
      for (let t7 = 0; t7 < a26.length; t7++)
        a26[t7] && (a26[t7] = e10[t7] ? 255 : 0);
    }
    return a26;
  }
  if (r7.length !== n19.length)
    return new Uint8Array(s11).fill(255);
  for (let l15 = 1; l15 < r7.length; l15++) {
    const t6 = r7[l15];
    for (let e10 = 0; e10 < a26.length; e10++)
      0 === a26[e10] && (a26[e10] = t6[e10] ? 255 : 0);
  }
  return a26;
}
function f4(e9, n19, r7) {
  const [s11, o13] = e9, a26 = s11.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    n19 && !n19[t5] || (l15[t5] = s11[t5] + o13[t5]);
  return l15;
}
function u12(e9, n19, r7) {
  const [s11] = e9, o13 = s11.length, a26 = u.createEmptyBand("f32", o13);
  return a26.set(s11), a26;
}
function h5(e9, n19, r7) {
  const [s11, o13] = e9, a26 = s11.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    n19 && !n19[t5] || (l15[t5] = s11[t5] - o13[t5]);
  return l15;
}
function i12(e9, n19, r7) {
  const [s11, o13] = e9, a26 = s11.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    n19 && !n19[t5] || (l15[t5] = s11[t5] * o13[t5]);
  return l15;
}
function g3(e9, n19, r7) {
  const [s11] = e9, o13 = s11.length, a26 = u.createEmptyBand(r7, o13);
  for (let t5 = 0; t5 < o13; t5++)
    n19 && !n19[t5] || (a26[t5] = Math.sign(s11[t5]) * Math.floor(Math.abs(s11[t5])));
  return a26;
}
function p13(e9, n19, r7) {
  const [s11, o13] = e9, a26 = s11.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    n19 && !n19[t5] || (l15[t5] = s11[t5] / o13[t5]);
  return l15;
}
function m4(t5, e9, n19) {
  return p13(t5, e9, "f32");
}
function y5(e9, n19, r7) {
  const [s11, o13] = e9, a26 = s11.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    n19 && !n19[t5] || (l15[t5] = Math.floor(s11[t5] / o13[t5]));
  return l15;
}
function d5(n19, r7, s11, o13) {
  const a26 = n19[0], l15 = a26.length, c28 = u.createEmptyBand(s11, l15);
  if (o13 === u9.atanh) {
    for (let t5 = 0; t5 < l15; t5++)
      if (r7[t5]) {
        const e9 = a26[t5];
        Math.abs(e9) >= 1 ? r7[t5] = 0 : c28[t5] = Math.atanh(e9);
      }
    return c28;
  }
  const f6 = o13 === u9.asin ? Math.asin : Math.acos;
  for (let t5 = 0; t5 < l15; t5++)
    if (r7[t5]) {
      const e9 = a26[t5];
      Math.abs(e9) > 1 ? r7[t5] = 0 : c28[t5] = f6(e9);
    }
  return c28;
}
function M3(e9, n19, r7, s11) {
  const [o13] = e9, a26 = o13.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    n19 && !n19[t5] || (l15[t5] = s11(o13[t5]));
  return l15;
}
function E(e9, n19, r7, s11) {
  const [o13, a26] = e9, l15 = o13.length, c28 = u.createEmptyBand(r7, l15);
  for (let t5 = 0; t5 < l15; t5++)
    n19 && !n19[t5] || (c28[t5] = s11(o13[t5], a26[t5]));
  return c28;
}
function B2(e9, n19, r7) {
  const [s11, o13] = e9, a26 = s11.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    n19 && !n19[t5] || (l15[t5] = s11[t5] & o13[t5]);
  return l15;
}
function w4(e9, n19, r7) {
  const [s11, o13] = e9, a26 = s11.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    n19 && !n19[t5] || (l15[t5] = s11[t5] << o13[t5]);
  return l15;
}
function b2(e9, n19, r7) {
  const [s11] = e9, o13 = s11.length, a26 = u.createEmptyBand(r7, o13);
  for (let t5 = 0; t5 < o13; t5++)
    n19 && !n19[t5] || (a26[t5] = ~s11[t5]);
  return a26;
}
function x3(e9, n19, r7) {
  const [s11, o13] = e9, a26 = s11.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    n19 && !n19[t5] || (l15[t5] = s11[t5] | o13[t5]);
  return l15;
}
function A2(e9, n19, r7) {
  const [s11, o13] = e9, a26 = s11.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    n19 && !n19[t5] || (l15[t5] = s11[t5] >> o13[t5]);
  return l15;
}
function k2(e9, n19, r7) {
  const [s11, o13] = e9, a26 = s11.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    n19 && !n19[t5] || (l15[t5] = s11[t5] ^ o13[t5]);
  return l15;
}
function N(e9, n19, r7) {
  const [s11, o13] = e9, a26 = s11.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    n19 && !n19[t5] || (l15[t5] = s11[t5] && o13[t5] ? 1 : 0);
  return l15;
}
function P(e9, n19, r7) {
  const [s11] = e9, o13 = s11.length, a26 = u.createEmptyBand(r7, o13);
  for (let t5 = 0; t5 < o13; t5++)
    n19 && !n19[t5] || (a26[t5] = s11[t5] ? 0 : 1);
  return a26;
}
function T(e9, n19, r7) {
  const [s11, o13] = e9, a26 = s11.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    n19 && !n19[t5] || (l15[t5] = s11[t5] || o13[t5] ? 1 : 0);
  return l15;
}
function q(e9, n19, r7) {
  const [s11, o13] = e9, a26 = s11.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    n19 && !n19[t5] || (l15[t5] = (s11[t5] ? 1 : 0) ^ (o13[t5] ? 1 : 0));
  return l15;
}
function U(e9, n19, r7) {
  const [s11, o13] = e9, a26 = s11.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    n19 && !n19[t5] || (l15[t5] = s11[t5] === o13[t5] ? 1 : 0);
  return l15;
}
function I(e9, n19, r7, s11) {
  const [o13] = e9, a26 = o13.length, l15 = u.createEmptyBand(r7, a26), c28 = s11 === Math.E;
  for (let t5 = 0; t5 < a26; t5++)
    n19 && !n19[t5] || (l15[t5] = c28 ? Math.exp(o13[t5]) : s11 ** o13[t5]);
  return l15;
}
function F2(t5, e9, n19) {
  return I(t5, e9, n19, 10);
}
function j(t5, e9, n19) {
  return I(t5, e9, n19, 2);
}
function z(t5, e9, n19) {
  return I(t5, e9, n19, Math.E);
}
function O(e9, n19, r7, s11) {
  const [o13] = e9, a26 = o13.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    n19 && !n19[t5] || (o13[t5] <= 0 ? n19[t5] = 0 : l15[t5] = s11(o13[t5]));
  return l15;
}
function W(t5, e9, n19) {
  return O(t5, e9, n19, Math.log10);
}
function C2(t5, e9, n19) {
  return O(t5, e9, n19, Math.log2);
}
function R(t5, e9, n19) {
  return O(t5, e9, n19, Math.log);
}
function S(e9, n19, r7) {
  const [s11, o13] = e9, a26 = s11.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    n19 && !n19[t5] || (l15[t5] = s11[t5] > o13[t5] ? 1 : 0);
  return l15;
}
function X(e9, n19, r7) {
  const [s11, o13] = e9, a26 = s11.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    n19 && !n19[t5] || (l15[t5] = s11[t5] >= o13[t5] ? 1 : 0);
  return l15;
}
function v2(e9, n19, r7) {
  const [s11, o13] = e9, a26 = s11.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    n19 && !n19[t5] || (l15[t5] = s11[t5] < o13[t5] ? 1 : 0);
  return l15;
}
function D3(e9, n19, r7) {
  const [s11, o13] = e9, a26 = s11.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    n19 && !n19[t5] || (l15[t5] = s11[t5] <= o13[t5] ? 1 : 0);
  return l15;
}
function G(e9, n19, r7) {
  const [s11] = e9, o13 = s11.length, a26 = u.createEmptyBand(r7, o13);
  if (!n19)
    return a26;
  for (let t5 = 0; t5 < o13; t5++)
    a26[t5] = n19[t5] ? 0 : 1;
  return a26;
}
function H(e9, n19, r7) {
  const [s11, o13] = e9, a26 = s11.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    n19 && !n19[t5] || (l15[t5] = s11[t5] % o13[t5]);
  return l15;
}
function J(e9, n19, r7) {
  const [s11] = e9, o13 = s11.length, a26 = u.createEmptyBand(r7, o13);
  for (let t5 = 0; t5 < o13; t5++)
    n19 && !n19[t5] || (a26[t5] = -s11[t5]);
  return a26;
}
function K(e9, n19, r7) {
  const [s11, o13] = e9, a26 = s11.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    n19 && !n19[t5] || (l15[t5] = s11[t5] === o13[t5] ? 0 : 1);
  return l15;
}
function L(e9, n19, r7) {
  const [s11, o13] = e9, a26 = s11.length, l15 = u.createEmptyBand(r7, a26), c28 = new Uint8Array(a26);
  for (let t5 = 0; t5 < a26; t5++)
    null != n19 && !n19[t5] || 0 !== s11[t5] || (l15[t5] = o13[t5], c28[t5] = 255);
  return { band: l15, mask: c28 };
}
function Q(e9, n19, r7) {
  const [s11, o13, a26] = e9, l15 = s11.length, c28 = u.createEmptyBand(r7, l15);
  for (let t5 = 0; t5 < l15; t5++)
    n19 && !n19[t5] || (c28[t5] = s11[t5] ? o13[t5] : a26[t5]);
  return c28;
}
function V(e9, n19, r7) {
  const s11 = e9.length;
  if (s11 < 2)
    return e9[0];
  const [o13] = e9, a26 = o13.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    if (!n19 || n19[t5]) {
      let n20 = o13[t5];
      for (let r8 = 1; r8 < s11; r8++) {
        const s12 = e9[r8][t5];
        n20 < s12 && (n20 = s12);
      }
      l15[t5] = n20;
    }
  return l15;
}
function Y(e9, n19, r7) {
  const s11 = e9.length;
  if (s11 < 2)
    return e9[0];
  const [o13] = e9, a26 = o13.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    if (!n19 || n19[t5]) {
      let n20 = o13[t5];
      for (let r8 = 1; r8 < s11; r8++) {
        const s12 = e9[r8][t5];
        n20 > s12 && (n20 = s12);
      }
      l15[t5] = n20;
    }
  return l15;
}
function Z(e9, n19, r7) {
  const s11 = e9.length;
  if (s11 < 2)
    return e9[0];
  const [o13] = e9, a26 = o13.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    if (!n19 || n19[t5]) {
      let n20 = o13[t5], r8 = n20;
      for (let o14 = 1; o14 < s11; o14++) {
        const s12 = e9[o14][t5];
        r8 < s12 ? r8 = s12 : n20 > s12 && (n20 = s12);
      }
      l15[t5] = r8 - n20;
    }
  return l15;
}
function $(e9, n19, r7) {
  const s11 = e9.length;
  if (s11 < 2)
    return e9[0];
  const [o13] = e9, a26 = o13.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    if (!n19 || n19[t5]) {
      let n20 = 0;
      for (let r8 = 0; r8 < s11; r8++)
        n20 += e9[r8][t5];
      l15[t5] = n20 / s11;
    }
  return l15;
}
function _(e9, n19, r7) {
  const s11 = e9.length;
  if (s11 < 2)
    return e9[0];
  const [o13] = e9, a26 = o13.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    if (!n19 || n19[t5])
      for (let n20 = 0; n20 < s11; n20++) {
        const r8 = e9[n20];
        l15[t5] += r8[t5];
      }
  return l15;
}
function tt(e9, n19, r7) {
  const s11 = e9.length;
  if (s11 < 2)
    return e9[0];
  const [o13] = e9, a26 = o13.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    if (!n19 || n19[t5]) {
      const n20 = new Float32Array(s11);
      let r8 = 0;
      for (let a27 = 0; a27 < s11; a27++) {
        const s12 = e9[a27];
        r8 += s12[t5], n20[a27] = s12[t5];
      }
      r8 /= s11;
      let o14 = 0;
      for (let t6 = 0; t6 < s11; t6++)
        o14 += (n20[t6] - r8) ** 2;
      l15[t5] = Math.sqrt(o14 / s11);
    }
  return l15;
}
function et(e9, n19, r7) {
  const s11 = e9.length;
  if (s11 < 2)
    return e9[0];
  const o13 = Math.floor(s11 / 2), [a26] = e9, l15 = a26.length, c28 = u.createEmptyBand(r7, l15), f6 = new Float32Array(s11), u16 = s11 % 2 == 1;
  for (let t5 = 0; t5 < l15; t5++)
    if (!n19 || n19[t5]) {
      for (let n20 = 0; n20 < s11; n20++)
        f6[n20] = e9[n20][t5];
      f6.sort(), c28[t5] = u16 ? f6[o13] : (f6[o13] + f6[o13 - 1]) / 2;
    }
  return c28;
}
function nt(e9, n19, r7) {
  const [s11, o13] = e9;
  if (null == o13)
    return s11;
  const a26 = s11.length, l15 = u.createEmptyBand(r7, a26);
  for (let t5 = 0; t5 < a26; t5++)
    n19[t5] && (s11[t5] === o13[t5] ? l15[t5] = s11[t5] : n19[t5] = 0);
  return l15;
}
function rt(e9, n19, r7) {
  const s11 = e9.length;
  if (s11 <= 2)
    return nt(e9, n19, r7);
  const o13 = e9[0].length, a26 = u.createEmptyBand(r7, o13), l15 = /* @__PURE__ */ new Map();
  for (let t5 = 0; t5 < o13; t5++)
    if (!n19 || n19[t5]) {
      let n20;
      l15.clear();
      for (let a27 = 0; a27 < s11; a27++)
        n20 = e9[a27][t5], l15.set(n20, l15.has(n20) ? l15.get(n20) + 1 : 1);
      let r8 = 0, o14 = 0;
      for (const t6 of l15.keys())
        r8 = l15.get(t6), r8 > o14 && (o14 = r8, n20 = t6);
      a26[t5] = n20;
    }
  return a26;
}
function st(e9, n19, r7) {
  const s11 = e9.length;
  if (s11 <= 2)
    return nt(e9, n19, r7);
  const o13 = e9[0].length, a26 = u.createEmptyBand(r7, o13), l15 = /* @__PURE__ */ new Map();
  for (let t5 = 0; t5 < o13; t5++)
    if (!n19 || n19[t5]) {
      let n20;
      l15.clear();
      for (let a27 = 0; a27 < s11; a27++)
        n20 = e9[a27][t5], l15.set(n20, l15.has(n20) ? l15.get(n20) + 1 : 1);
      let r8 = 0, o14 = e9.length;
      for (const t6 of l15.keys())
        r8 = l15.get(t6), r8 < o14 && (o14 = r8, n20 = t6);
      a26[t5] = n20;
    }
  return a26;
}
function ot(e9, n19, r7) {
  const s11 = e9.length;
  if (s11 < 2)
    return e9[0];
  const [o13] = e9, a26 = o13.length, l15 = u.createEmptyBand(r7, a26), c28 = /* @__PURE__ */ new Set();
  for (let t5 = 0; t5 < a26; t5++)
    if (!n19 || n19[t5]) {
      let n20;
      c28.clear();
      for (let r8 = 0; r8 < s11; r8++)
        n20 = e9[r8][t5], c28.add(n20);
      l15[t5] = c28.size;
    }
  return l15;
}
var at = /* @__PURE__ */ new Map();
var lt = /* @__PURE__ */ new Map();
var ct = /* @__PURE__ */ new Map();
var ft = /* @__PURE__ */ new Map();
function ut() {
  at.size || (at.set(4, Math.sqrt), at.set(6, Math.acos), at.set(7, Math.asin), at.set(8, Math.atan), at.set(9, Math.atanh), at.set(10, Math.abs), at.set(21, Math.cos), at.set(22, Math.cosh), at.set(48, Math.floor), at.set(49, Math.ceil), at.set(51, Math.sin), at.set(52, Math.sinh), at.set(56, Math.tan), at.set(57, Math.tanh), at.set(59, Math.acosh), at.set(60, Math.asinh), at.set(65, Math.floor), lt.set(5, Math.pow), lt.set(61, Math.atan2), ct.set(1, f4), ct.set(2, h5), ct.set(3, i12), ct.set(11, B2), ct.set(12, w4), ct.set(13, b2), ct.set(14, x3), ct.set(15, A2), ct.set(16, k2), ct.set(17, N), ct.set(18, P), ct.set(19, T), ct.set(20, q), ct.set(23, p13), ct.set(24, U), ct.set(25, z), ct.set(26, F2), ct.set(27, j), ct.set(28, S), ct.set(29, X), ct.set(30, g3), ct.set(31, G), ct.set(32, u12), ct.set(33, v2), ct.set(34, D3), ct.set(35, R), ct.set(36, W), ct.set(37, C2), ct.set(44, H), ct.set(45, J), ct.set(46, K), ct.set(64, m4), ct.set(65, y5), ct.set(76, Q), ct.set(78, Q), ft.set(38, rt), ft.set(39, V), ft.set(40, $), ft.set(41, et), ft.set(42, Y), ft.set(43, st), ft.set(47, Z), ft.set(54, tt), ft.set(55, _), ft.set(58, ot), ft.set(66, rt), ft.set(67, V), ft.set(68, $), ft.set(69, et), ft.set(70, Y), ft.set(71, st), ft.set(72, Z), ft.set(73, tt), ft.set(74, _), ft.set(75, ot));
}
function ht(t5, e9, n19, r7) {
  let [o13, a26] = s4(n19);
  const l15 = n19.startsWith("u") || n19.startsWith("s");
  l15 && (o13 -= 1e-5, a26 += 1e-5);
  for (let s11 = 0; s11 < e9.length; s11++)
    if (e9[s11]) {
      const n20 = t5[s11];
      isNaN(n20) || n20 < o13 || n20 > a26 ? e9[s11] = 0 : r7[s11] = l15 ? Math.round(n20) : n20;
    }
}
function it(s11, a26, l15 = {}) {
  ut();
  let f6 = c16(s11, a26 >= 66 && a26 <= 75);
  const { outputPixelType: u16 = "f32" } = l15, h6 = !ft.has(a26) || l15.processAsMultiband, i20 = h6 ? s11[0].pixels.length : 1, g5 = [];
  for (let c28 = 0; c28 < i20; c28++) {
    const l16 = ft.has(a26) && !h6 ? s11.flatMap((t5) => t5.pixels) : s11.map((t5) => t5.pixels[c28]);
    let i21, p24 = true;
    if (a26 === d4.setNull) {
      const t5 = L(l16, f6, u16);
      i21 = t5.band, f6 = t5.mask, p24 = false;
    } else if (ct.has(a26)) {
      i21 = ct.get(a26)(l16, f6, "f64");
    } else if (at.has(a26))
      i21 = a26 === u9.asin || a26 === u9.acos || a26 === u9.atanh ? d5(l16, f6, "f64", a26) : M3(l16, f6, "f64", at.get(a26));
    else if (lt.has(a26))
      i21 = E(l16, f6, "f64", lt.get(a26));
    else if (ft.has(a26)) {
      i21 = ft.get(a26)(l16, f6, "f64");
    } else
      i21 = l16[0], p24 = false;
    if (p24 && a26 !== h3.isNull && !o11.has(a26)) {
      const e9 = u.createEmptyBand(u16, i21.length);
      f6 || (f6 = new Uint8Array(i21.length).fill(255)), ht(i21, f6, u16, e9), i21 = e9;
    }
    g5.push(i21);
  }
  const p23 = s11[0];
  return new u({ width: p23.width, height: p23.height, pixelType: u16, mask: a26 === h3.isNull ? null : f6, pixels: g5 });
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/LocalFunction.js
var p14 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Local", this.functionArguments = null, this.rasterArgumentNames = ["rasters"];
  }
  _bindSourceRasters() {
    const { sourceRasterInfos: t5 } = this, s11 = t5[0], { bandCount: o13 } = s11, { processAsMultiband: e9 } = this.functionArguments;
    if (t5.some((t6) => t6.bandCount !== o13))
      return { success: false, supportsGPU: false, error: "local-function: input rasters do not have same band count" };
    const { operation: r7, rasters: n19 } = this.functionArguments, i20 = l10[r7];
    if (!(999 === i20 || n19.length === i20 || n19.length <= 1 && 1 === i20))
      return { success: false, supportsGPU: false, error: `local-function: the length of functionArguments.rasters does not match operation's requirement: ${i20}` };
    this.outputPixelType = this._getOutputPixelType("f32");
    const c28 = s11.clone();
    c28.pixelType = this.outputPixelType, c28.statistics = null, c28.histograms = null, c28.colormap = null, c28.attributeTable = null, c28.bandCount = 999 !== i20 || e9 ? o13 : 1;
    const p23 = a14(r7);
    if (p23) {
      c28.statistics = [];
      for (let t6 = 0; t6 < c28.bandCount; t6++)
        c28.statistics[t6] = { min: p23[0], max: p23[1], avg: (p23[0] + p23[1]) / 2, stddev: (p23[0] + p23[1]) / 10 };
    }
    this.rasterInfo = c28;
    return { success: true, supportsGPU: 1 === c28.bandCount && i20 <= 3 && (r7 < 11 || r7 > 16) };
  }
  _processPixels(t5) {
    const { pixelBlocks: s11 } = t5;
    return null == s11 || s11.some((t6) => null == t6) ? null : it(s11, this.functionArguments.operation, { processAsMultiband: this.functionArguments.processAsMultiband, outputPixelType: this.outputPixelType ?? void 0 });
  }
  _getWebGLParameters() {
    var _a;
    const { operation: t5 } = this.functionArguments, s11 = l10[t5], o13 = ((_a = Object.keys(p10).find((s12) => p10[s12] === t5)) == null ? void 0 : _a.toLowerCase()) ?? "undefined", n19 = this.outputPixelType ?? "f32";
    let [i20, a26] = s4(n19);
    const c28 = n19.startsWith("u") || n19.startsWith("s");
    return c28 && (i20 -= 1e-4, a26 += 1e-4), { imageCount: s11, operationName: o13, domainRange: [i20, a26], isOutputRounded: c28 };
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], p14.prototype, "functionName", void 0), e([y({ type: c15, json: { write: true, name: "rasterFunctionArguments" } })], p14.prototype, "functionArguments", void 0), e([y()], p14.prototype, "rasterArgumentNames", void 0), p14 = e([c("esri.layers.support.rasterFunctions.LocalFunction")], p14);
var l11 = p14;

// node_modules/@arcgis/core/layers/support/rasterFunctions/MaskFunctionArguments.js
var n9;
var a15 = n9 = class extends p4 {
  constructor() {
    super(...arguments), this.includedRanges = null, this.noDataValues = null, this.noDataInterpretation = n.matchAny;
  }
  get normalizedNoDataValues() {
    const { noDataValues: t5 } = this;
    if (!(t5 == null ? void 0 : t5.length))
      return null;
    let e9 = false;
    const r7 = t5.map((t6) => {
      if ("number" == typeof t6)
        return e9 = true, [t6];
      if ("string" == typeof t6) {
        const r8 = t6.trim().split(" ").filter((t7) => "" !== t7.trim()).map((t7) => Number(t7));
        return e9 = e9 || r8.length > 0, 0 === r8.length ? null : r8;
      }
      return null;
    });
    return e9 ? r7 : null;
  }
  clone() {
    var _a, _b;
    return new n9({ includedRanges: ((_a = this.includedRanges) == null ? void 0 : _a.slice()) ?? [], noDataValues: ((_b = this.noDataValues) == null ? void 0 : _b.slice()) ?? [], noDataInterpretation: this.noDataInterpretation });
  }
};
e([y({ json: { write: true } })], a15.prototype, "includedRanges", void 0), e([y({ json: { write: true } })], a15.prototype, "noDataValues", void 0), e([y()], a15.prototype, "normalizedNoDataValues", null), e([y({ json: { write: true } })], a15.prototype, "noDataInterpretation", void 0), a15 = n9 = e([c("esri.layers.support.rasterFunctions.MaskFunctionArguments")], a15);
var i13 = a15;

// node_modules/@arcgis/core/layers/support/rasterFunctions/MaskFunction.js
var c17 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Mask", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    const t5 = this.sourceRasterInfos[0].clone(), { pixelType: e9 } = t5;
    this.outputPixelType = this._getOutputPixelType(e9), t5.pixelType = this.outputPixelType, this.rasterInfo = t5;
    const { includedRanges: s11, normalizedNoDataValues: o13 } = this.functionArguments;
    if (!(s11 == null ? void 0 : s11.length) && !(o13 == null ? void 0 : o13.length))
      return { success: false, supportsGPU: false, error: "missing includedRanges or noDataValues argument" };
    let r7 = [];
    for (let a26 = 0; a26 < t5.bandCount; a26++) {
      const t6 = w(e9, s11 == null ? void 0 : s11.slice(2 * a26, 2 * a26 + 2), o13 == null ? void 0 : o13[a26]);
      if (null == t6) {
        r7 = null;
        break;
      }
      r7.push(t6);
    }
    this.lookups = r7;
    const n19 = null != o13 && o13.every((t6) => {
      var _a;
      return (t6 == null ? void 0 : t6.length) === ((_a = o13[0]) == null ? void 0 : _a.length);
    });
    return { success: true, supportsGPU: (!s11 || s11.length <= 2 * i) && (!o13 || n19 && o13[0].length <= i) };
  }
  _processPixels(t5) {
    var _a;
    const e9 = (_a = t5.pixelBlocks) == null ? void 0 : _a[0];
    if (null == e9)
      return null;
    const { outputPixelType: s11, lookups: o13 } = this, { includedRanges: r7, noDataInterpretation: n19, normalizedNoDataValues: u16 } = this.functionArguments, a26 = n19 === n.matchAll;
    return g(e9, { includedRanges: r7, noDataValues: u16, outputPixelType: s11, matchAll: a26, lookups: o13 });
  }
  _getWebGLParameters() {
    var _a;
    const { includedRanges: t5, normalizedNoDataValues: s11 } = this.functionArguments, o13 = new Float32Array(i);
    o13.fill(D), ((_a = s11 == null ? void 0 : s11[0]) == null ? void 0 : _a.length) && o13.set(s11[0]);
    const r7 = new Float32Array(i);
    for (let n19 = 0; n19 < r7.length; n19 += 2)
      r7[n19] = (t5 == null ? void 0 : t5[n19]) ?? -D, r7[n19 + 1] = (t5 == null ? void 0 : t5[n19 + 1]) ?? D;
    return t5 && t5.length && r7.set(t5), { bandCount: this.sourceRasterInfos[0].bandCount, noDataValues: o13, includedRanges: r7 };
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], c17.prototype, "functionName", void 0), e([y({ type: i13, json: { write: true, name: "rasterFunctionArguments" } })], c17.prototype, "functionArguments", void 0), e([y()], c17.prototype, "rasterArgumentNames", void 0), e([y({ json: { write: true } })], c17.prototype, "lookups", void 0), c17 = e([c("esri.layers.support.rasterFunctions.MaskFunction")], c17);
var p15 = c17;

// node_modules/@arcgis/core/layers/support/rasterFunctions/NDVIFunctionArguments.js
var e6;
var i14 = e6 = class extends p4 {
  constructor() {
    super(...arguments), this.visibleBandID = 0, this.infraredBandID = 1, this.scientificOutput = false;
  }
  clone() {
    const { visibleBandID: r7, infraredBandID: s11, scientificOutput: t5 } = this;
    return new e6({ visibleBandID: r7, infraredBandID: s11, scientificOutput: t5 });
  }
};
e([y({ json: { write: true } })], i14.prototype, "visibleBandID", void 0), e([y({ json: { write: true } })], i14.prototype, "infraredBandID", void 0), e([y({ json: { write: true } })], i14.prototype, "scientificOutput", void 0), i14 = e6 = e([c("esri.layers.support.rasterFunctions.NDVIFunctionArguments")], i14);
var n10 = i14;

// node_modules/@arcgis/core/layers/support/rasterFunctions/NDVIFunction.js
var u13 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "NDVI", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    const { scientificOutput: t5, visibleBandID: s11, infraredBandID: r7 } = this.functionArguments;
    this.outputPixelType = this._getOutputPixelType(t5 ? "f32" : "u8");
    const e9 = this.sourceRasterInfos[0], n19 = Math.max(s11, r7);
    if (e9.bandCount < 2 || n19 >= e9.bandCount)
      return { success: false, supportsGPU: false, error: "ndvi-function: source raster has insufficient amount of raster bands" };
    const o13 = e9.clone();
    o13.pixelType = this.outputPixelType, o13.colormap = null, o13.histograms = null, o13.bandCount = 1, o13.keyProperties = { ...o13.keyProperties, BandProperties: void 0 };
    const [i20, u16, a26, c28] = t5 ? [-1, 1, 0, 0.1] : [0, 200, 100, 10];
    return o13.statistics = [{ min: i20, max: u16, avg: a26, stddev: c28 }], this.rasterInfo = o13, { success: true, supportsGPU: true };
  }
  _processPixels(t5) {
    var _a;
    const s11 = (_a = t5.pixelBlocks) == null ? void 0 : _a[0];
    if (null == s11)
      return null;
    const { visibleBandID: r7, infraredBandID: n19, scientificOutput: o13 } = this.functionArguments;
    return s6(s11, r7, n19, !o13);
  }
  _getWebGLParameters() {
    const { visibleBandID: t5, infraredBandID: s11, scientificOutput: r7 } = this.functionArguments, e9 = this.isInputBandIdsSwizzled ? [0, 1, 2] : [s11, t5, 0];
    return { bandIndexMat3: i2(e9), scaled: !r7 };
  }
  _getInputBandIds(t5) {
    const { visibleBandID: s11, infraredBandID: r7 } = this.functionArguments;
    return [r7, s11, 0].map((s12) => t5[s12]);
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], u13.prototype, "functionName", void 0), e([y({ type: n10, json: { write: true, name: "rasterFunctionArguments" } })], u13.prototype, "functionArguments", void 0), e([y()], u13.prototype, "rasterArgumentNames", void 0), u13 = e([c("esri.layers.support.rasterFunctions.NDVIFunction")], u13);
var a16 = u13;

// node_modules/@arcgis/core/layers/support/rasterFunctions/RemapFunctionArguments.js
var n11;
var r5 = n11 = class extends p4 {
  constructor() {
    super(...arguments), this.inputRanges = null, this.outputValues = null, this.noDataRanges = null, this.allowUnmatched = false, this.isLastInputRangeInclusive = false;
  }
  clone() {
    return new n11({ inputRanges: [...this.inputRanges], outputValues: [...this.outputValues], noDataRanges: [...this.noDataRanges], allowUnmatched: this.allowUnmatched, isLastInputRangeInclusive: this.isLastInputRangeInclusive });
  }
};
e([y({ json: { write: true } })], r5.prototype, "inputRanges", void 0), e([y({ json: { write: true } })], r5.prototype, "outputValues", void 0), e([y({ json: { write: true } })], r5.prototype, "noDataRanges", void 0), e([y({ json: { write: true } })], r5.prototype, "allowUnmatched", void 0), e([y({ json: { write: true } })], r5.prototype, "isLastInputRangeInclusive", void 0), r5 = n11 = e([c("esri.layers.support.rasterFunctions.RemapFunctionArguments")], r5);
var a17 = r5;

// node_modules/@arcgis/core/layers/support/rasterFunctions/RemapFunction.js
var m5 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Remap", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.lookup = null;
  }
  _bindSourceRasters() {
    const t5 = this.sourceRasterInfos[0].clone(), { pixelType: e9 } = t5;
    this.outputPixelType = this._getOutputPixelType(e9), t5.pixelType = this.outputPixelType, t5.colormap = null, t5.histograms = null, t5.bandCount = 1, t5.attributeTable = null;
    const { statistics: s11 } = t5, { allowUnmatched: n19, outputValues: o13, inputRanges: a26, noDataRanges: i20, isLastInputRangeInclusive: l15 } = this.functionArguments;
    if (null != s11 && s11.length && (o13 == null ? void 0 : o13.length))
      if (n19) {
        const e10 = Math.min.apply(null, [...o13, s11[0].min]), n20 = Math.max.apply(null, [...o13, s11[0].max]);
        t5.statistics = [{ ...s11[0], min: e10, max: n20 }];
      } else {
        let e10 = o13[0], n20 = e10;
        for (let t6 = 0; t6 < o13.length; t6++)
          e10 = e10 > o13[t6] ? o13[t6] : e10, n20 = n20 > o13[t6] ? n20 : o13[t6];
        t5.statistics = [{ ...s11[0], min: e10, max: n20 }];
      }
    this.rasterInfo = t5, this.lookup = n19 ? null : y2({ srcPixelType: e9, inputRanges: a26, outputValues: o13, noDataRanges: i20, allowUnmatched: n19, isLastInputRangeInclusive: l15, outputPixelType: this.outputPixelType });
    return { success: true, supportsGPU: (!o13 || o13.length <= i) && (!i20 || i20.length <= i) };
  }
  _processPixels(t5) {
    var _a;
    const e9 = (_a = t5.pixelBlocks) == null ? void 0 : _a[0];
    if (null == e9)
      return null;
    const { lookup: s11, outputPixelType: n19 } = this;
    if (s11) {
      const t6 = f2(e9, { lut: [s11.lut], offset: s11.offset, outputPixelType: n19 });
      return null != t6 && s11.mask && (t6.mask = c2(e9.pixels[0], e9.mask, s11.mask, s11.offset, "u8")), t6;
    }
    const { inputRanges: o13, outputValues: a26, noDataRanges: u16, allowUnmatched: r7, isLastInputRangeInclusive: c28 } = this.functionArguments;
    return p2(e9, { inputRanges: o13, outputValues: a26, noDataRanges: u16, outputPixelType: n19, allowUnmatched: r7, isLastInputRangeInclusive: c28 });
  }
  _getWebGLParameters() {
    const { allowUnmatched: t5, noDataRanges: s11, isLastInputRangeInclusive: n19 } = this.functionArguments, a26 = new Float32Array(3 * i), u16 = 1e-5, i20 = this.functionArguments.inputRanges ?? [], l15 = this.functionArguments.outputValues ?? [], p23 = l15.length;
    for (let o13 = 0; o13 < i; o13++)
      a26[3 * o13] = i20[2 * o13] ?? D - 1, a26[3 * o13 + 1] = i20[2 * o13 + 1] ?? D, a26[3 * o13 + 2] = l15[o13] ?? 0, o13 < p23 && (o13 > 0 && (a26[3 * o13] -= u16), (o13 < p23 - 1 || !n19) && (a26[3 * o13 + 1] -= u16));
    const c28 = new Float32Array(2 * i);
    c28.fill(D), (s11 == null ? void 0 : s11.length) && c28.set(s11);
    return { allowUnmatched: t5, rangeMaps: a26, noDataRanges: c28, clampRange: s4(this.outputPixelType) };
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], m5.prototype, "functionName", void 0), e([y({ type: a17, json: { write: true, name: "rasterFunctionArguments" } })], m5.prototype, "functionArguments", void 0), e([y()], m5.prototype, "rasterArgumentNames", void 0), e([y({ json: { write: true } })], m5.prototype, "lookup", void 0), m5 = e([c("esri.layers.support.rasterFunctions.RemapFunction")], m5);
var g4 = m5;

// node_modules/@arcgis/core/layers/support/rasterFunctions/SlopeFunctionArguments.js
var i15;
var c18 = new s2({ 1: "degree", 2: "percent-rise", 3: "adjusted" }, { useNumericKeys: true });
var a18 = i15 = class extends p4 {
  constructor() {
    super(...arguments), this.slopeType = "degree", this.zFactor = 1, this.pixelSizePower = 0.664, this.pixelSizeFactor = 0.024, this.removeEdgeEffect = false;
  }
  clone() {
    return new i15({ slopeType: this.slopeType, zFactor: this.zFactor, pixelSizePower: this.pixelSizePower, pixelSizeFactor: this.pixelSizeFactor, removeEdgeEffect: this.removeEdgeEffect, raster: this.raster });
  }
};
e([o2(c18)], a18.prototype, "slopeType", void 0), e([y({ type: Number, json: { write: true } })], a18.prototype, "zFactor", void 0), e([y({ type: Number, json: { name: "psPower", write: true } })], a18.prototype, "pixelSizePower", void 0), e([y({ type: Number, json: { name: "psZFactor", write: true } })], a18.prototype, "pixelSizeFactor", void 0), e([y({ type: Boolean, json: { write: true } })], a18.prototype, "removeEdgeEffect", void 0), a18 = i15 = e([c("esri.layers.support.rasterFunctions.SlopeFunctionArguments")], a18);
var n12 = a18;

// node_modules/@arcgis/core/layers/support/rasterFunctions/SlopeFunction.js
var p16 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Slope", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isGCS = false;
  }
  _bindSourceRasters() {
    var _a;
    this.outputPixelType = this._getOutputPixelType("f32");
    const e9 = this.sourceRasterInfos[0].clone();
    return e9.pixelType = this.outputPixelType, e9.statistics = "percent-rise" !== this.functionArguments.slopeType ? [{ min: 0, max: 90, avg: 1, stddev: 1 }] : null, e9.histograms = null, e9.colormap = null, e9.attributeTable = null, e9.bandCount = 1, this.rasterInfo = e9, this.isGCS = ((_a = e9.spatialReference) == null ? void 0 : _a.isGeographic) ?? false, { success: true, supportsGPU: true };
  }
  _processPixels(e9) {
    var _a;
    const t5 = (_a = e9.pixelBlocks) == null ? void 0 : _a[0];
    if (null == t5)
      return null;
    const { zFactor: s11, slopeType: r7, pixelSizePower: o13, pixelSizeFactor: n19 } = this.functionArguments, { isGCS: p23 } = this, { extent: c28, primaryPixelSizes: u16 } = e9, a26 = u16 == null ? void 0 : u16[0], l15 = a26 ?? (c28 ? { x: c28.width / t5.width, y: c28.height / t5.height } : { x: 1, y: 1 });
    return c3(t5, { zFactor: s11, slopeType: r7, pixelSizePower: o13, pixelSizeFactor: n19, isGCS: p23, resolution: l15 });
  }
  _getWebGLParameters() {
    const { zFactor: e9, slopeType: t5, pixelSizeFactor: s11, pixelSizePower: r7 } = this.functionArguments;
    return { zFactor: this.isGCS && e9 >= 1 ? e9 * s5 : e9, slopeType: t5, pixelSizeFactor: s11 ?? 0, pixelSizePower: r7 ?? 0 };
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], p16.prototype, "functionName", void 0), e([y({ type: n12, json: { write: true, name: "rasterFunctionArguments" } })], p16.prototype, "functionArguments", void 0), e([y()], p16.prototype, "rasterArgumentNames", void 0), e([y({ json: { write: true } })], p16.prototype, "isGCS", void 0), p16 = e([c("esri.layers.support.rasterFunctions.SlopeFunction")], p16);
var c19 = p16;

// node_modules/@arcgis/core/layers/support/rasterFunctions/focalStatUtils.js
var n13 = new s2({ 1: "min", 2: "max", 3: "mean", 4: "stddev", 5: "median", 6: "majority", 7: "minority" }, { useNumericKeys: true });
function s10(t5, e9) {
  const { fillNoDataOnly: o13 } = e9, { band: n19, width: s11, height: r7, mask: i20, outBand: l15 } = t5;
  if (o13 && !i20)
    return void l15.set(n19);
  const { statisticsType: a26, kernelRows: f6, kernelCols: c28 } = e9, h6 = "stddev" === a26, u16 = s11 * r7, m8 = new Float64Array(u16), d6 = new Float64Array(u16), y7 = new Uint32Array(u16);
  for (let b3 = 0; b3 < r7; b3++) {
    const t6 = b3 * s11;
    let e10 = 0, o14 = 0, r8 = 0;
    for (let s12 = 0; s12 < c28; s12++)
      i20 && !i20[t6 + s12] || (e10 += n19[t6 + s12], h6 && (o14 += n19[t6 + s12] ** 2), r8++);
    m8[t6] = e10, d6[t6] = o14, y7[t6] = r8;
    for (let l16 = 1; l16 <= s11 - c28; l16++) {
      const s12 = t6 + l16 - 1, a27 = s12 + c28;
      i20 ? (i20[s12] && (r8--, e10 -= n19[s12], h6 && (o14 -= n19[s12] ** 2)), i20[a27] && (r8++, e10 += n19[a27], h6 && (o14 += n19[a27] ** 2))) : (e10 -= n19[s12], e10 += n19[a27], h6 && (o14 -= n19[s12] ** 2, o14 += n19[a27] ** 2)), m8[t6 + l16] = e10, y7[t6 + l16] = r8, h6 && (d6[t6 + l16] = o14);
    }
  }
  const w6 = new Float64Array(u16), k4 = new Float64Array(u16), p23 = new Uint32Array(u16), g5 = f6 * s11;
  for (let b3 = 0; b3 <= s11 - c28; b3++) {
    let t6 = 0, e10 = 0, o14 = 0;
    for (let n20 = 0; n20 < f6; n20++) {
      const r8 = n20 * s11 + b3;
      t6 += m8[r8], o14 += y7[r8], h6 && (e10 += d6[r8]);
    }
    w6[b3] = t6, k4[b3] = e10, p23[b3] = o14;
    for (let n20 = 1; n20 <= r7 - f6; n20++) {
      const r8 = (n20 - 1) * s11 + b3, i21 = r8 + g5;
      t6 -= m8[r8], t6 += m8[i21], o14 -= y7[r8], o14 += y7[i21], h6 && (e10 -= d6[r8], e10 += d6[i21]), w6[n20 * s11 + b3] = t6, k4[n20 * s11 + b3] = e10, p23[n20 * s11 + b3] = o14;
    }
  }
  const M5 = Math.floor(f6 / 2), A3 = Math.floor(c28 / 2);
  for (let b3 = M5; b3 < r7 - M5; b3++) {
    const t6 = b3 * s11;
    for (let e10 = A3; e10 < s11 - A3; e10++) {
      const n20 = (b3 - M5) * s11 + e10 - A3, r8 = p23[n20];
      if (0 === r8 || o13 && (!i20 || i20[t6 + e10]))
        continue;
      const a27 = w6[n20] / r8, f7 = h6 ? Math.sqrt((k4[n20] - w6[n20] * a27) / r8) : a27;
      l15[t6 + e10] = f7, i20 && (i20[t6 + e10] = 255);
    }
  }
}
function r6(t5, e9) {
  const { fillNoDataOnly: o13 } = e9, { band: n19, width: s11, height: r7, mask: i20, outBand: l15 } = t5;
  if (o13 && !i20)
    return void l15.set(n19);
  const { kernelRows: a26, kernelCols: f6, statisticsType: c28 } = e9, h6 = Math.floor(a26 / 2), u16 = Math.floor(f6 / 2), m8 = "min" === c28, d6 = l15.slice(), y7 = new Uint32Array(s11 * r7);
  for (let w6 = h6; w6 < r7 - h6; w6++) {
    const t6 = w6 * s11;
    for (let e10 = u16; e10 < s11 - u16; e10++) {
      let o14 = m8 ? Number.MAX_VALUE : -Number.MAX_VALUE, r8 = 0;
      for (let l16 = 0; l16 < a26; l16++)
        for (let a27 = 0; a27 < f6; a27++) {
          const f7 = t6 + e10 + (l16 - h6) * s11 + a27 - u16;
          i20 && !i20[f7] || (o14 = m8 ? Math.min(o14, n19[f7]) : Math.max(o14, n19[f7]), r8++);
        }
      i20 ? (d6[t6 + e10] = 0 === r8 ? 0 : o14, y7[t6 + e10] = r8) : l15[t6 + e10] = 0 === r8 ? 0 : o14;
    }
  }
  if (i20)
    for (let w6 = h6; w6 < r7 - h6; w6++) {
      const t6 = w6 * s11;
      for (let e10 = u16; e10 < s11 - u16; e10++)
        if (y7[t6 + e10]) {
          if (o13 && i20[t6 + e10])
            continue;
          l15[t6 + e10] = d6[t6 + e10], i20[t6 + e10] = 255;
        }
    }
}
function i16(t5, e9) {
  const { fillNoDataOnly: o13 } = e9, { band: n19, width: s11, height: r7, mask: i20, outBand: l15 } = t5;
  if (o13 && !i20)
    return void l15.set(n19);
  const { kernelRows: a26, kernelCols: f6 } = e9, c28 = Math.floor(a26 / 2), h6 = Math.floor(f6 / 2), u16 = l15.slice(), m8 = new Uint32Array(s11 * r7);
  for (let d6 = c28; d6 < r7 - c28; d6++) {
    const t6 = d6 * s11;
    for (let e10 = h6; e10 < s11 - h6; e10++) {
      if (o13 && i20 && i20[t6 + e10])
        continue;
      const r8 = [];
      for (let o14 = 0; o14 < a26; o14++)
        for (let l16 = 0; l16 < f6; l16++) {
          const a27 = t6 + e10 + (o14 - c28) * s11 + l16 - h6;
          i20 && !i20[a27] || r8.push(n19[a27]);
        }
      r8.length && (r8.sort((t7, e11) => t7 - e11), i20 ? (u16[t6 + e10] = r8[Math.floor((r8.length - 1) / 2)], m8[t6 + e10] = r8.length) : l15[t6 + e10] = r8[Math.floor((r8.length - 1) / 2)]);
    }
  }
  if (i20)
    for (let d6 = c28; d6 < r7 - c28; d6++) {
      const t6 = d6 * s11;
      for (let e10 = h6; e10 < s11 - h6; e10++)
        if (m8[t6 + e10]) {
          if (o13 && i20[t6 + e10])
            continue;
          l15[t6 + e10] = u16[t6 + e10], i20[t6 + e10] = 255;
        }
    }
}
function l12(t5, e9) {
  const { fillNoDataOnly: o13 } = e9, { band: n19, width: s11, height: r7, mask: i20, outBand: l15 } = t5;
  if (o13 && !i20)
    return void l15.set(n19);
  const { kernelRows: a26, kernelCols: f6 } = e9, c28 = Math.floor(a26 / 2), h6 = Math.floor(f6 / 2), u16 = "majority" === e9.statisticsType, m8 = a26 * f6, d6 = l15.slice(), y7 = new Uint32Array(s11 * r7);
  for (let w6 = c28; w6 < r7 - c28; w6++) {
    const t6 = w6 * s11;
    for (let e10 = h6; e10 < s11 - h6; e10++) {
      if (o13 && i20 && i20[t6 + e10])
        continue;
      const r8 = /* @__PURE__ */ new Map();
      for (let o14 = 0; o14 < a26; o14++)
        for (let l16 = 0; l16 < f6; l16++) {
          const a27 = t6 + e10 + (o14 - c28) * s11 + l16 - h6;
          if (i20 && !i20[a27])
            continue;
          const f7 = n19[a27];
          r8.set(f7, r8.has(f7) ? r8.get(f7) + 1 : 1);
        }
      if (0 === r8.size)
        continue;
      let w7 = 0, k4 = 0, p23 = u16 ? 0 : m8 + 1;
      for (const t7 of r8.keys())
        k4 = r8.get(t7), u16 === k4 > p23 && (p23 = k4, w7 = t7);
      i20 ? (d6[t6 + e10] = w7, y7[t6 + e10] = r8.size) : l15[t6 + e10] = w7;
    }
  }
  if (i20)
    for (let w6 = c28; w6 < r7 - c28; w6++) {
      const t6 = w6 * s11;
      for (let e10 = h6; e10 < s11 - h6; e10++)
        if (y7[t6 + e10]) {
          if (o13 && i20[t6 + e10])
            continue;
          l15[t6 + e10] = d6[t6 + e10], i20[t6 + e10] = 255;
        }
    }
}
function a19(t5, n19) {
  const { mask: a26 } = t5, { fillNoDataOnly: f6 } = n19;
  if (f6 && !a26)
    return t5;
  const { pixels: c28, width: h6, height: u16, bandMasks: m8, pixelType: d6 } = t5, y7 = c28.length, w6 = h6 * u16, k4 = [], { kernelRows: p23, kernelCols: g5, statisticsType: M5, mirrorEdges: A3 } = n19;
  if (f6 && !a26)
    return t5;
  const b3 = n19.outputPixelType ?? d6, x5 = [];
  for (let U2 = 0; U2 < y7; U2++) {
    const t6 = c28[U2], d7 = u.createEmptyBand(b3, w6);
    f6 && d7.set(t6);
    const y8 = (m8 == null ? void 0 : m8[U2]) ?? a26, j4 = (y8 == null ? void 0 : y8.slice()) ?? null, N4 = { band: t6, width: h6, height: u16, mask: j4, outBand: d7 };
    switch (M5) {
      case "min":
      case "max":
        r6(N4, n19);
        break;
      case "mean":
      case "stddev":
        s10(N4, n19);
        break;
      case "median":
        i16(N4, n19);
        break;
      case "majority":
      case "minority":
        l12(N4, n19);
    }
    A3 && !f6 && o9(d7, h6, u16, p23, g5), k4.push(d7), j4 && x5.push(j4);
  }
  let j3 = x5[0] ?? a26;
  if (x5.length !== y7 && (x5.length = 0), y7 > 1 && (m8 == null ? void 0 : m8.length)) {
    j3 = new Uint8Array(w6), j3.set(x5[0]);
    for (let t6 = 1; t6 < m8.length; t6++) {
      const e9 = m8[t6];
      for (let t7 = 0; t7 < e9.length; t7++)
        0 === e9[t7] && (j3[t7] = 0);
    }
  }
  const N3 = new u({ pixelType: b3, width: h6, height: u16, pixels: k4, bandMasks: m8 && x5.length ? x5 : null, mask: j3 });
  return N3.updateStatistics(), N3;
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/StatisticsFunctionArguments.js
var c20;
var p17 = c20 = class extends p4 {
  constructor() {
    super(...arguments), this.rows = 3, this.cols = 3, this.fillNoDataOnly = false, this.statisticsType = "min";
  }
  clone() {
    return new c20({ rows: this.rows, cols: this.cols, fillNoDataOnly: this.fillNoDataOnly, statisticsType: this.statisticsType, raster: a(this.raster) });
  }
};
e([y({ json: { write: true, read: { source: ["kernelRows", "rows"], reader: (s11, r7) => Number(s11 ?? (r7 == null ? void 0 : r7.kernelRows) ?? 3) } } })], p17.prototype, "rows", void 0), e([y({ json: { write: true, read: { source: ["kernelCols", "cols"], reader: (s11, r7) => Number(s11 ?? (r7 == null ? void 0 : r7.kernelCols) ?? 3) } } })], p17.prototype, "cols", void 0), e([y({ json: { write: true } })], p17.prototype, "fillNoDataOnly", void 0), e([y({ json: { read: { source: ["statisticsType", "type"], reader: (s11, r7) => n13.fromJSON((r7 == null ? void 0 : r7.statisticsType) ?? (r7 == null ? void 0 : r7.type)) ?? "min" }, write: { target: "type" } } }), o2(n13)], p17.prototype, "statisticsType", void 0), p17 = c20 = e([c("esri.layers.support.rasterFunctions.StatisticsFunctionArguments")], p17);
var l13 = p17;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StatisticsFunction.js
var a20 = /* @__PURE__ */ new Set(["min", "max", "mean", "median", "majority", "minority"]);
var c21 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Statistics", this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    const { type: t5 } = this.functionArguments.toJSON();
    if (t5 < 1 || t5 > 7)
      return { success: false, supportsGPU: false, error: `statistics-function: the given statistics type is not supported ${t5}` };
    const s11 = this.sourceRasterInfos[0];
    this.outputPixelType = this._getOutputPixelType(s11.pixelType);
    const e9 = s11.clone();
    e9.pixelType = this.outputPixelType;
    const { statisticsType: r7 } = this.functionArguments;
    a20.has(r7) || (e9.statistics = null, e9.histograms = null, e9.colormap = null, e9.attributeTable = null), this.rasterInfo = e9;
    return { success: true, supportsGPU: e9.bandCount <= 3 && t5 < 5 };
  }
  _processPixels(t5) {
    var _a;
    const s11 = (_a = t5.pixelBlocks) == null ? void 0 : _a[0];
    if (null == s11)
      return s11;
    const { statisticsType: e9, rows: r7, cols: o13, fillNoDataOnly: n19 } = this.functionArguments;
    return a19(s11, { kernelRows: r7, kernelCols: o13, fillNoDataOnly: n19, outputPixelType: this.outputPixelType, statisticsType: e9, mirrorEdges: true });
  }
  _getWebGLParameters() {
    const { rows: t5, cols: s11, statisticsType: e9, fillNoDataOnly: o13 } = this.functionArguments;
    return { fillNoDataOnly: o13, kernelRows: t5, kernelCols: s11, statisticsType: e9, clampRange: s4(this.outputPixelType) };
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], c21.prototype, "functionName", void 0), e([y({ type: l13, json: { write: true, name: "rasterFunctionArguments" } })], c21.prototype, "functionArguments", void 0), e([y()], c21.prototype, "rasterArgumentNames", void 0), c21 = e([c("esri.layers.support.rasterFunctions.StatisticsFunction")], c21);
var p18 = c21;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StatisticsHistogramFunctionArguments.js
var c22;
var n14 = c22 = class extends p4 {
  constructor() {
    super(...arguments), this.statistics = null, this.histograms = null;
  }
  readStatistics(t5, s11) {
    if (!(t5 == null ? void 0 : t5.length))
      return null;
    const r7 = [];
    return t5.forEach((t6) => {
      const s12 = { min: t6.min, max: t6.max, avg: t6.avg ?? t6.mean, stddev: t6.stddev ?? t6.standardDeviation };
      r7.push(s12);
    }), r7;
  }
  writeStatistics(t5, s11, r7) {
    if (!(t5 == null ? void 0 : t5.length))
      return;
    const o13 = [];
    t5.forEach((t6) => {
      const s12 = { ...t6, mean: t6.avg, standardDeviation: t6.stddev };
      delete s12.avg, delete s12.stddev, o13.push(s12);
    }), s11[r7] = o13;
  }
  clone() {
    return new c22({ statistics: a(this.statistics), histograms: a(this.histograms) });
  }
};
e([y({ json: { write: true } })], n14.prototype, "statistics", void 0), e([o("statistics")], n14.prototype, "readStatistics", null), e([r("statistics")], n14.prototype, "writeStatistics", null), e([y({ json: { write: true } })], n14.prototype, "histograms", void 0), n14 = c22 = e([c("esri.layers.support.rasterFunctions.StatisticsHistogramFunctionArguments")], n14);
var p19 = n14;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StatisticsHistogramFunction.js
var i17 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "StatisticsHistogram", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isNoopProcess = true;
  }
  _bindSourceRasters() {
    const s11 = this.sourceRasterInfos[0];
    this.outputPixelType = this._getOutputPixelType("u8");
    const t5 = s11.clone(), { statistics: r7, histograms: o13 } = this.functionArguments;
    return o13 && (t5.histograms = o13), r7 && (t5.statistics = r7), this.rasterInfo = t5, { success: true, supportsGPU: true };
  }
  _processPixels(s11) {
    var _a;
    return (_a = s11.pixelBlocks) == null ? void 0 : _a[0];
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], i17.prototype, "functionName", void 0), e([y({ type: p19, json: { write: true, name: "rasterFunctionArguments" } })], i17.prototype, "functionArguments", void 0), e([y()], i17.prototype, "rasterArgumentNames", void 0), e([y({ json: { write: true } })], i17.prototype, "indexedColormap", void 0), e([y()], i17.prototype, "isNoopProcess", void 0), i17 = e([c("esri.layers.support.rasterFunctions.StatisticsHistogramFunction")], i17);
var n15 = i17;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StretchFunctionArguments.js
var n16;
var p20 = new s2({ 0: "none", 3: "standard-deviation", 4: "histogram-equalization", 5: "min-max", 6: "percent-clip", 9: "sigmoid" }, { useNumericKeys: true });
var c23 = n16 = class extends p4 {
  constructor() {
    super(...arguments), this.computeGamma = false, this.dynamicRangeAdjustment = false, this.gamma = [], this.histograms = null, this.statistics = null, this.stretchType = "none", this.useGamma = false;
  }
  writeStatistics(t5, e9, o13) {
    (t5 == null ? void 0 : t5.length) && (Array.isArray(t5[0]) || (t5 = t5.map((t6) => [t6.min, t6.max, t6.avg, t6.stddev])), e9[o13] = t5);
  }
  clone() {
    return new n16({ stretchType: this.stretchType, outputMin: this.outputMin, outputMax: this.outputMax, useGamma: this.useGamma, computeGamma: this.computeGamma, statistics: a(this.statistics), gamma: a(this.gamma), sigmoidStrengthLevel: this.sigmoidStrengthLevel, numberOfStandardDeviations: this.numberOfStandardDeviations, minPercent: this.minPercent, maxPercent: this.maxPercent, histograms: a(this.histograms), dynamicRangeAdjustment: this.dynamicRangeAdjustment, raster: this.raster });
  }
};
e([y({ type: Boolean, json: { write: true } })], c23.prototype, "computeGamma", void 0), e([y({ type: Boolean, json: { name: "dra", write: true } })], c23.prototype, "dynamicRangeAdjustment", void 0), e([y({ type: [Number], json: { write: true } })], c23.prototype, "gamma", void 0), e([y()], c23.prototype, "histograms", void 0), e([y({ type: Number, json: { write: true } })], c23.prototype, "maxPercent", void 0), e([y({ type: Number, json: { write: true } })], c23.prototype, "minPercent", void 0), e([y({ type: Number, json: { write: true } })], c23.prototype, "numberOfStandardDeviations", void 0), e([y({ type: Number, json: { name: "max", write: true } })], c23.prototype, "outputMax", void 0), e([y({ type: Number, json: { name: "min", write: true } })], c23.prototype, "outputMin", void 0), e([y({ type: Number, json: { write: true } })], c23.prototype, "sigmoidStrengthLevel", void 0), e([y({ json: { type: [[Number]], write: true } })], c23.prototype, "statistics", void 0), e([r("statistics")], c23.prototype, "writeStatistics", null), e([o2(p20)], c23.prototype, "stretchType", void 0), e([y({ type: Boolean, json: { write: true } })], c23.prototype, "useGamma", void 0), c23 = n16 = e([c("esri.layers.support.rasterFunctions.StretchFunctionArguments")], c23);
var u14 = c23;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StretchFunction.js
var c24 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Stretch", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.lookup = null, this.cutOffs = null;
  }
  _bindSourceRasters() {
    this.lookup = null, this.cutOffs = null;
    const t5 = this.sourceRasterInfos[0], { pixelType: s11 } = t5, { functionArguments: e9 } = this, { dynamicRangeAdjustment: o13, gamma: r7, useGamma: u16 } = e9;
    if (!o13 && ["u8", "u16", "s8", "s16"].includes(s11)) {
      const o14 = p3(e9.toJSON(), { rasterInfo: t5 }), a27 = this._isOutputRoundingNeeded() ? "round" : "float";
      this.lookup = a3({ pixelType: s11, ...o14, gamma: u16 ? r7 : null, rounding: a27 }), this.cutOffs = o14;
    } else
      o13 || (this.cutOffs = p3(e9.toJSON(), { rasterInfo: t5 }));
    this.outputPixelType = this._getOutputPixelType(s11);
    const a26 = t5.clone();
    a26.pixelType = this.outputPixelType, a26.statistics = null, a26.histograms = null, a26.colormap = null, a26.attributeTable = null, "u8" === this.outputPixelType && (a26.keyProperties.DataType = "processed"), this.rasterInfo = a26;
    return { success: true, supportsGPU: !o13 };
  }
  _processPixels(t5) {
    var _a;
    const s11 = (_a = t5.pixelBlocks) == null ? void 0 : _a[0];
    if (null == s11)
      return s11;
    const { lookup: e9 } = this;
    if (e9)
      return f2(s11, { ...e9, outputPixelType: this.rasterInfo.pixelType });
    const { functionArguments: o13 } = this, u16 = this.cutOffs || p3(o13.toJSON(), { rasterInfo: this.sourceRasterInfos[0], pixelBlock: s11 }), i20 = o13.useGamma ? o13.gamma : null;
    return M2(s11, { ...u16, gamma: i20, outputPixelType: this.outputPixelType });
  }
  _getWebGLParameters() {
    const { outputMin: t5 = 0, outputMax: s11 = 255, gamma: e9, useGamma: o13 } = this.functionArguments, r7 = this.rasterInfo.bandCount >= 2 ? 3 : 1, u16 = o13 && (e9 == null ? void 0 : e9.length) ? x2(r7, e9) : [1, 1, 1], { minCutOff: n19, maxCutOff: i20 } = this.cutOffs ?? { minCutOff: [0, 0, 0], maxCutOff: [255, 255, 255] };
    1 === n19.length && (n19[1] = n19[2] = n19[0], i20[1] = i20[2] = i20[0]);
    const a26 = new Float32Array(r7);
    let c28;
    for (c28 = 0; c28 < r7; c28++)
      a26[c28] = (s11 - t5) / (i20[c28] - n19[c28]);
    const m8 = this._isOutputRoundingNeeded();
    return { bandCount: r7, outMin: t5, outMax: s11, minCutOff: n19, maxCutOff: i20, factor: a26, useGamma: o13, gamma: o13 && e9 ? e9 : [1, 1, 1], gammaCorrection: o13 && u16 ? u16 : [1, 1, 1], stretchType: this.functionArguments.stretchType, isOutputRounded: m8, type: "stretch" };
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], c24.prototype, "functionName", void 0), e([y({ type: u14, json: { write: true, name: "rasterFunctionArguments" } })], c24.prototype, "functionArguments", void 0), e([y()], c24.prototype, "rasterArgumentNames", void 0), e([y({ json: { write: true } })], c24.prototype, "lookup", void 0), e([y({ json: { write: true } })], c24.prototype, "cutOffs", void 0), c24 = e([c("esri.layers.support.rasterFunctions.StretchFunction")], c24);
var m6 = c24;

// node_modules/@arcgis/core/layers/support/rasterFunctions/TableFunctionArguments.js
var c25;
var a21 = c25 = class extends p4 {
  constructor() {
    super(...arguments), this.attributeTableAsRecordSet = null;
  }
  clone() {
    return new c25({ attributeTableAsRecordSet: a(this.attributeTableAsRecordSet) });
  }
};
e([y({ json: { write: true } })], a21.prototype, "attributeTableAsRecordSet", void 0), a21 = c25 = e([c("esri.layers.support.rasterFunctions.TableFunctionArguments")], a21);
var p21 = a21;

// node_modules/@arcgis/core/layers/support/rasterFunctions/TableFunction.js
var i18 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Table", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isNoopProcess = true;
  }
  _bindSourceRasters() {
    const t5 = this.sourceRasterInfos[0];
    if (t5.bandCount > 1 || t5.pixelType.startsWith("f"))
      return { success: false, supportsGPU: false, error: "table-function: Source data must be single band and integer pixel type." };
    const { attributeTableAsRecordSet: e9 } = this.functionArguments;
    if (!e9)
      return { success: false, supportsGPU: false, error: "table-function: Missing attributeTableAsRecordSet argument." };
    this.outputPixelType = this._getOutputPixelType(t5.pixelType);
    const s11 = t5.clone();
    return s11.pixelType = this.outputPixelType, s11.bandCount = 1, "thematic" !== s11.dataType && (s11.keyProperties = s11.keyProperties ? { ...s11.keyProperties, DataType: "thematic" } : { DataType: "thematic" }), this.rasterInfo = s11, { success: true, supportsGPU: true };
  }
  _processPixels(t5) {
    var _a;
    return (_a = t5.pixelBlocks) == null ? void 0 : _a[0];
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], i18.prototype, "functionName", void 0), e([y({ type: p21, json: { write: true, name: "rasterFunctionArguments" } })], i18.prototype, "functionArguments", void 0), e([y()], i18.prototype, "rasterArgumentNames", void 0), e([y()], i18.prototype, "isNoopProcess", void 0), i18 = e([c("esri.layers.support.rasterFunctions.TableFunction")], i18);
var n17 = i18;

// node_modules/@arcgis/core/layers/support/rasterFunctions/rasterFunctionHelper.js
var j2 = /* @__PURE__ */ new Map();
function C3(t5, e9) {
  const { rasterFunctionArguments: r7 } = t5;
  if (!r7)
    return;
  (r7.rasters || [r7.raster]).forEach((t6) => {
    t6 && "number" != typeof t6 && ("string" == typeof t6 ? t6.startsWith("http") && (e9.includes(t6) || e9.push(t6)) : "rasterFunctionArguments" in t6 && C3(t6, e9));
  });
}
function R2(t5, n19) {
  if (n19 = n19 ?? {}, "function" in (t5 = a(t5)) && "arguments" in t5 && t5.arguments) {
    const r7 = k3(t5, /* @__PURE__ */ new Map(), n19);
    if (x4(r7), !r7.renderingRule)
      throw new s("raster-function-helper", "Unsupported raster function json.");
    t5 = r7.renderingRule;
  }
  if ("rasterFunction" in t5)
    return v3(t5 = w5(t5), n19);
  throw new s("raster-function-helper", "unsupported raster function json.");
}
function N2(t5, e9) {
  return "rasters" === e9[0] && Array.isArray(t5.rasters) ? t5.rasters : e9.map((e10) => t5[e10]);
}
function S2(t5) {
  return !!(t5 && "object" == typeof t5 && t5.rasterFunction && t5.rasterFunctionArguments);
}
function w5(t5) {
  var _a;
  const { rasterFunction: e9, rasterFunctionArguments: r7 } = t5, n19 = {};
  for (const o13 in r7) {
    let t6 = r7[o13];
    const e10 = o13.toLowerCase();
    if ("rasters" === e10 && Array.isArray(t6))
      n19.rasters = t6.map((t7) => S2(t7) ? w5(t7) : t7);
    else
      switch (S2(t6) && (t6 = w5(t6)), e10) {
        case "dra":
          n19.dra = t6;
          break;
        case "pspower":
          n19.psPower = t6;
          break;
        case "pszfactor":
          n19.psZFactor = t6;
          break;
        case "bandids":
          n19.bandIds = t6;
          break;
        default:
          n19[o13[0].toLowerCase() + o13.slice(1)] = t6;
      }
  }
  return "Local" !== e9 || ((_a = n19.rasters) == null ? void 0 : _a.length) || (n19.rasters = ["$$"]), { ...t5, rasterFunctionArguments: n19 };
}
function v3(t5, r7) {
  var _a, _b;
  const { rasterFunction: n19, rasterFunctionArguments: o13 } = t5, s11 = (_a = t5.outputPixelType) == null ? void 0 : _a.toLowerCase();
  if (null == n19 || !j2.has(n19))
    throw new s("raster-function-helper", `unsupported raster function: ${n19}`);
  const a26 = j2.get(n19), i20 = ("function" == typeof a26.ctor ? a26.ctor : a26.ctor.default).fromJSON({ ...t5, outputPixelType: s11 }), { rasterArgumentNames: c28 } = i20, u16 = [], m8 = N2(o13, c28), l15 = "rasters" === c28[0], p23 = [];
  for (let e9 = 0; e9 < m8.length; e9++) {
    const t6 = m8[e9];
    let n20;
    null == t6 || "string" == typeof t6 && t6.startsWith("$") ? u16.push(r7 == null ? void 0 : r7.raster) : "string" == typeof t6 ? r7[t6] && u16.push(r7[t6]) : "number" != typeof t6 && "rasterFunction" in t6 && (n20 = v3(t6, r7), l15 || (i20.functionArguments[c28[e9]] = n20), u16.push(n20)), l15 && p23.push(n20 ?? t6);
  }
  if (l15 && (i20.functionArguments.rasters = p23), r7) {
    i20.sourceRasters = u16;
    const t6 = (_b = r7.raster) == null ? void 0 : _b.url;
    t6 && (i20.mainPrimaryRasterId = t6);
  }
  return i20;
}
function D4(t5, e9) {
  if (t5 && e9)
    for (const r7 in t5) {
      const n19 = t5[r7];
      n19 && "object" == typeof n19 && "type" in n19 && ("RasterFunctionTemplate" === n19.type ? D4(n19.arguments, e9) : "RasterFunctionVariable" === n19.type && null != e9[n19.name] && (n19.value = e9[n19.name]));
    }
}
function V2(t5, r7) {
  var _a;
  if (!t5 || "object" != typeof t5)
    return t5;
  const { value: n19 } = t5;
  if (!n19 || "object" != typeof n19)
    return t5.isDataset ? "$$" : n19;
  if (Array.isArray(n19))
    return 0 === n19.length ? [] : n19.map((t6) => "object" == typeof t6 && "RasterFunctionVariable" === t6.type ? V2(t6, r7) : t6);
  if ("value" in n19 && ["number", "string", "boolean"].includes(typeof n19.value))
    return n19.value;
  if (t5.isDataset && "Scalar" !== n19.type)
    return "$$";
  if (!("type" in n19))
    return n19;
  let o13 = n19;
  switch (n19.type) {
    case "Scalar":
      o13 = n19.value;
      break;
    case "AlgorithmicColorRamp":
      o13 = T2(n19);
      break;
    case "MultiPartColorRamp":
      o13 = { type: "multipart", colorRamps: n19.ArrayOfColorRamp.map(T2) };
      break;
    case "ArgumentArray":
      if (((_a = n19.elements) == null ? void 0 : _a.length) && "RasterStatistics" !== n19.elements[0].type) {
        const t6 = [];
        for (let o14 = 0; o14 < n19.elements.length; o14++) {
          const s11 = n19.elements[o14], { type: a26 } = s11;
          if (a26)
            if ("RasterFunctionTemplate" === a26) {
              const { renderingRule: e9 } = k3(s11, r7);
              t6.push(e9), null != s11._object_id && r7.set(s11._object_id, e9);
            } else {
              if ("RasterFunctionVariable" !== a26)
                throw new s("raster-function-helper", "unsupported raster function json.");
              {
                const e9 = V2(s11, r7);
                t6.push(e9), null != s11._object_id && r7.set(s11._object_id, e9);
              }
            }
          else
            t6.push(s11);
        }
        o13 = t6;
      } else
        o13 = n19.elements;
  }
  return null != n19._object_id && r7.set(n19._object_id, o13), o13;
}
function T2(e9) {
  const r7 = e9.algorithm ?? "esriHSVAlgorithm";
  let { FromColor: n19, ToColor: o13 } = e9;
  if (!Array.isArray(n19)) {
    const { r: e10, g: r8, b: o14 } = y3({ h: n19.Hue, s: n19.Saturation, v: n19.Value });
    n19 = [e10, r8, o14, n19.AlphaValue];
  }
  if (!Array.isArray(o13)) {
    const { r: e10, g: r8, b: n20 } = y3({ h: o13.Hue, s: o13.Saturation, v: o13.Value });
    o13 = [e10, r8, n20, o13.AlphaValue];
  }
  return { type: "algorithmic", algorithm: r7, fromColor: n19, toColor: o13 };
}
function k3(t5, e9, r7) {
  r7 && D4(t5, r7);
  const n19 = { renderingRule: {}, templates: e9 };
  return B3(t5, n19), n19;
}
function B3(t5, e9) {
  if (!t5 || !e9.renderingRule)
    return;
  const { renderingRule: r7, templates: n19 } = e9, { function: o13, arguments: s11, _object_id: a26 } = t5;
  if (!o13 || !s11)
    return;
  null != a26 && n19.set(a26, r7), r7.rasterFunction = o13.type.replace("Function", ""), r7.outputPixelType = o13.pixelType;
  const i20 = {};
  r7.rasterFunctionArguments = i20;
  for (const c28 in s11) {
    if ("type" === c28 || "object_id" === c28 || "_object_ref_id" === c28)
      continue;
    const t6 = s11[c28];
    t6 && "object" == typeof t6 && "type" in t6 && ("RasterFunctionTemplate" === t6.type || "RasterFunctionVariable" === t6.type) ? ("RasterFunctionVariable" === t6.type ? i20[c28] = V2(t6, n19) : (r7.rasterFunctionArguments[c28] = {}, B3(t6, { renderingRule: r7.rasterFunctionArguments[c28], templates: n19 })), null != t6._object_id && n19.set(t6._object_id, i20[c28])) : i20[c28] = t6;
  }
  switch (i20.DEM && !i20.Raster && (i20.Raster = i20.DEM, delete i20.DEM), r7.rasterFunction) {
    case "Stretch":
      E2(i20);
      break;
    case "Colormap":
      M4(i20);
      break;
    case "Convolution":
      $2(i20);
      break;
    case "Mask":
      L2(i20);
  }
}
function x4(t5) {
  const { renderingRule: r7, templates: n19 } = t5;
  if ("object" != typeof r7 || !(r7 == null ? void 0 : r7.rasterFunctionArguments) || !n19.size)
    return;
  const { rasterFunctionArguments: o13 } = r7;
  for (const s11 in o13) {
    const t6 = o13[s11], r8 = "_object_ref_id" === s11 ? t6 : t6 && "object" == typeof t6 && "_object_ref_id" in t6 ? t6._object_ref_id : null;
    if (null == r8)
      t6 && "object" == typeof t6 && (t6.rasterFunctionArguments && x4({ renderingRule: t6, templates: n19 }), Array.isArray(t6) && t6.forEach((o14, s12) => {
        if ("object" == typeof o14)
          if (null != o14._object_ref_id) {
            if (!n19.has(o14._object_ref_id))
              throw new s("raster-function-helper", `unsupported raster function json. _object_ref_id: ${t6} does not exist`);
            const a26 = n19.get(r8);
            a26 && "object" == typeof a26 ? Object.assign(o14, a26) : t6[s12] = a26;
          } else
            x4({ renderingRule: o14, templates: n19 });
      }));
    else {
      if (!n19.has(r8))
        throw new s("raster-function-helper", `unsupported raster function json. _object_ref_id: ${r8} does not exist`);
      const t7 = n19.get(r8);
      "_object_ref_id" !== s11 ? o13[s11] = t7 : t7 && "object" == typeof t7 && Object.assign(o13, t7);
    }
  }
}
function E2(t5) {
  var _a;
  ((_a = t5.Statistics) == null ? void 0 : _a.length) && "object" == typeof t5.Statistics && (t5.Statistics = t5.Statistics.map((t6) => [t6.min, t6.max, t6.mean, t6.standardDeviation])), null != t5.NumberOfStandardDeviation && (t5.NumberOfStandardDeviations = t5.NumberOfStandardDeviation, delete t5.NumberOfStandardDeviation);
}
function M4(t5) {
  var _a, _b;
  "randomcolorramp" === ((_b = (_a = t5.ColorRamp) == null ? void 0 : _a.type) == null ? void 0 : _b.toLowerCase()) && (delete t5.ColorRamp, t5.ColormapName = "Random"), 0 === t5.ColorSchemeType && delete t5.ColorRamp;
}
function $2(t5) {
  null != t5.ConvolutionType && (t5.Type = t5.ConvolutionType, delete t5.ConvolutionType);
}
function L2(t5) {
  var _a;
  ((_a = t5.NoDataValues) == null ? void 0 : _a.length) && "string" == typeof t5.NoDataValues[0] && (t5.NoDataValues = t5.NoDataValues.filter((t6) => "" !== t6).map((t6) => Number(t6)));
}
j2.set("Aspect", { desc: "Aspect Function", ctor: p6, rasterArgumentNames: ["raster"] }), j2.set("BandArithmetic", { desc: "Band Arithmetic Function", ctor: u5, rasterArgumentNames: ["raster"] }), j2.set("Colormap", { desc: "Colormap Function", ctor: u7, rasterArgumentNames: ["raster"] }), j2.set("CompositeBand", { desc: "CompositeBand Function", ctor: a9, rasterArgumentNames: ["rasters"] }), j2.set("Convolution", { desc: "Convolution Function", ctor: l8, rasterArgumentNames: ["raster"] }), j2.set("ContrastBrightness", { desc: "Contrast Brightness Function", ctor: p9, rasterArgumentNames: ["raster"] }), j2.set("ExtractBand", { desc: "ExtractBand Function", ctor: l9, rasterArgumentNames: ["raster"] }), j2.set("Curvature", { desc: "Curvature Function", ctor: a11, rasterArgumentNames: ["raster"] }), j2.set("Local", { desc: "Local Function", ctor: l11, rasterArgumentNames: ["rasters"] }), j2.set("Mask", { desc: "Mask Function", ctor: p15, rasterArgumentNames: ["raster"] }), j2.set("NDVI", { desc: "NDVI Function", ctor: a16, rasterArgumentNames: ["raster"] }), j2.set("Remap", { desc: "Remap Function", ctor: g4, rasterArgumentNames: ["raster"] }), j2.set("Slope", { desc: "Slope Function", ctor: c19, rasterArgumentNames: ["raster"] }), j2.set("Statistics", { desc: "Focal Statistics Function", ctor: p18, rasterArgumentNames: ["raster"] }), j2.set("StatisticsHistogram", { desc: "Statistics Histogram Function", ctor: n15, rasterArgumentNames: ["raster"] }), j2.set("Stretch", { desc: "Stretch Function", ctor: m6, rasterArgumentNames: ["raster"] }), j2.set("Table", { desc: "Attribute Table Function", ctor: n17, rasterArgumentNames: ["raster"] });

// node_modules/@arcgis/core/layers/support/rasterTransforms/BaseRasterTransform.js
var t4 = class extends f {
  get affectsPixelSize() {
    return false;
  }
  forwardTransform(r7) {
    return r7;
  }
  inverseTransform(r7) {
    return r7;
  }
};
e([y()], t4.prototype, "affectsPixelSize", null), e([y({ json: { write: true } })], t4.prototype, "spatialReference", void 0), t4 = e([c("esri.layers.support.rasterTransforms.BaseRasterTransform")], t4);
var a22 = t4;

// node_modules/@arcgis/core/layers/support/rasterTransforms/GCSShiftTransform.js
var a23;
var c26 = a23 = class extends a22 {
  constructor() {
    super(...arguments), this.type = "gcs-shift", this.tolerance = 1e-8;
  }
  forwardTransform(r7) {
    return "point" === (r7 = r7.clone()).type ? (r7.x > 180 + this.tolerance && (r7.x -= 360), r7) : (r7.xmin >= 180 - this.tolerance ? (r7.xmax -= 360, r7.xmin -= 360) : r7.xmax > 180 + this.tolerance && (r7.xmin = -180, r7.xmax = 180), r7);
  }
  inverseTransform(r7) {
    return "point" === (r7 = r7.clone()).type ? (r7.x < -this.tolerance && (r7.x += 360), r7) : (r7.xmin < -this.tolerance && (r7.xmin += 360, r7.xmax += 360), r7);
  }
  clone() {
    return new a23({ tolerance: this.tolerance });
  }
};
e([o2({ GCSShiftXform: "gcs-shift" })], c26.prototype, "type", void 0), e([y()], c26.prototype, "tolerance", void 0), c26 = a23 = e([c("esri.layers.support.rasterTransforms.GCSShiftTransform")], c26);
var n18 = c26;

// node_modules/@arcgis/core/layers/support/rasterTransforms/IdentityTransform.js
var e7;
var p22 = e7 = class extends a22 {
  constructor() {
    super(...arguments), this.type = "identity";
  }
  clone() {
    return new e7();
  }
};
e([o2({ IdentityXform: "identity" })], p22.prototype, "type", void 0), p22 = e7 = e([c("esri.layers.support.rasterTransforms.IdentityTransform")], p22);
var a24 = p22;

// node_modules/@arcgis/core/layers/support/rasterTransforms/PolynomialTransform.js
var l14;
function a25(e9, r7, o13) {
  const { x: t5, y: s11 } = r7;
  if (o13 < 2) {
    return { x: e9[0] + t5 * e9[2] + s11 * e9[4], y: e9[1] + t5 * e9[3] + s11 * e9[5] };
  }
  if (2 === o13) {
    const r8 = t5 * t5, o14 = s11 * s11, i21 = t5 * s11;
    return { x: e9[0] + t5 * e9[2] + s11 * e9[4] + r8 * e9[6] + i21 * e9[8] + o14 * e9[10], y: e9[1] + t5 * e9[3] + s11 * e9[5] + r8 * e9[7] + i21 * e9[9] + o14 * e9[11] };
  }
  const i20 = t5 * t5, n19 = s11 * s11, f6 = t5 * s11, p23 = i20 * t5, l15 = i20 * s11, a26 = t5 * n19, c28 = s11 * n19;
  return { x: e9[0] + t5 * e9[2] + s11 * e9[4] + i20 * e9[6] + f6 * e9[8] + n19 * e9[10] + p23 * e9[12] + l15 * e9[14] + a26 * e9[16] + c28 * e9[18], y: e9[1] + t5 * e9[3] + s11 * e9[5] + i20 * e9[7] + f6 * e9[9] + n19 * e9[11] + p23 * e9[13] + l15 * e9[15] + a26 * e9[17] + c28 * e9[19] };
}
function c27(e9, r7, o13) {
  const { xmin: t5, ymin: s11, xmax: i20, ymax: n19, spatialReference: f6 } = r7;
  let l15 = [];
  if (o13 < 2)
    l15.push({ x: t5, y: n19 }), l15.push({ x: i20, y: n19 }), l15.push({ x: t5, y: s11 }), l15.push({ x: i20, y: s11 });
  else {
    let e10 = 10;
    for (let r8 = 0; r8 < e10; r8++)
      l15.push({ x: t5, y: s11 + (n19 - s11) * r8 / (e10 - 1) }), l15.push({ x: i20, y: s11 + (n19 - s11) * r8 / (e10 - 1) });
    e10 = 8;
    for (let r8 = 1; r8 <= e10; r8++)
      l15.push({ x: t5 + (i20 - t5) * r8 / e10, y: s11 }), l15.push({ x: t5 + (i20 - t5) * r8 / e10, y: n19 });
  }
  l15 = l15.map((r8) => a25(e9, r8, o13));
  const c28 = l15.map((e10) => e10.x), u16 = l15.map((e10) => e10.y);
  return new M({ xmin: Math.min.apply(null, c28), xmax: Math.max.apply(null, c28), ymin: Math.min.apply(null, u16), ymax: Math.max.apply(null, u16), spatialReference: f6 });
}
function u15(e9) {
  const [r7, o13, t5, s11, i20, n19] = e9, f6 = t5 * n19 - i20 * s11, p23 = i20 * s11 - t5 * n19;
  return [(i20 * o13 - r7 * n19) / f6, (t5 * o13 - r7 * s11) / p23, n19 / f6, s11 / p23, -i20 / f6, -t5 / p23];
}
var m7 = l14 = class extends a22 {
  constructor() {
    super(...arguments), this.polynomialOrder = 1, this.type = "polynomial";
  }
  readForwardCoefficients(e9, r7) {
    const { coeffX: o13, coeffY: t5 } = r7;
    if (!(o13 == null ? void 0 : o13.length) || !(t5 == null ? void 0 : t5.length) || o13.length !== t5.length)
      return null;
    const s11 = [];
    for (let i20 = 0; i20 < o13.length; i20++)
      s11.push(o13[i20]), s11.push(t5[i20]);
    return s11;
  }
  writeForwardCoefficients(e9, r7, o13) {
    const t5 = [], s11 = [];
    for (let i20 = 0; i20 < (e9 == null ? void 0 : e9.length); i20++)
      i20 % 2 == 0 ? t5.push(e9[i20]) : s11.push(e9[i20]);
    r7.coeffX = t5, r7.coeffY = s11;
  }
  get inverseCoefficients() {
    let e9 = this._get("inverseCoefficients");
    const r7 = this._get("forwardCoefficients");
    return !e9 && r7 && this.polynomialOrder < 2 && (e9 = u15(r7)), e9;
  }
  set inverseCoefficients(e9) {
    this._set("inverseCoefficients", e9);
  }
  readInverseCoefficients(e9, r7) {
    const { inverseCoeffX: o13, inverseCoeffY: t5 } = r7;
    if (!(o13 == null ? void 0 : o13.length) || !(t5 == null ? void 0 : t5.length) || o13.length !== t5.length)
      return null;
    const s11 = [];
    for (let i20 = 0; i20 < o13.length; i20++)
      s11.push(o13[i20]), s11.push(t5[i20]);
    return s11;
  }
  writeInverseCoefficients(e9, r7, o13) {
    const t5 = [], s11 = [];
    for (let i20 = 0; i20 < (e9 == null ? void 0 : e9.length); i20++)
      i20 % 2 == 0 ? t5.push(e9[i20]) : s11.push(e9[i20]);
    r7.inverseCoeffX = t5, r7.inverseCoeffY = s11;
  }
  get affectsPixelSize() {
    return this.polynomialOrder > 0;
  }
  forwardTransform(e9) {
    if ("point" === e9.type) {
      const r7 = a25(this.forwardCoefficients, e9, this.polynomialOrder);
      return new x({ x: r7.x, y: r7.y, spatialReference: e9.spatialReference });
    }
    return c27(this.forwardCoefficients, e9, this.polynomialOrder);
  }
  inverseTransform(e9) {
    if ("point" === e9.type) {
      const r7 = a25(this.inverseCoefficients, e9, this.polynomialOrder);
      return new x({ x: r7.x, y: r7.y, spatialReference: e9.spatialReference });
    }
    return c27(this.inverseCoefficients, e9, this.polynomialOrder);
  }
  clone() {
    return new l14({ polynomialOrder: this.polynomialOrder, forwardCoefficients: this.forwardCoefficients ? [...this.forwardCoefficients] : null, inverseCoefficients: this.inverseCoefficients ? [...this.inverseCoefficients] : null });
  }
};
e([y({ json: { write: true } })], m7.prototype, "polynomialOrder", void 0), e([y()], m7.prototype, "forwardCoefficients", void 0), e([o("forwardCoefficients", ["coeffX", "coeffY"])], m7.prototype, "readForwardCoefficients", null), e([r("forwardCoefficients")], m7.prototype, "writeForwardCoefficients", null), e([y({ json: { write: true } })], m7.prototype, "inverseCoefficients", null), e([o("inverseCoefficients", ["inverseCoeffX", "inverseCoeffY"])], m7.prototype, "readInverseCoefficients", null), e([r("inverseCoefficients")], m7.prototype, "writeInverseCoefficients", null), e([y()], m7.prototype, "affectsPixelSize", null), e([o2({ PolynomialXform: "polynomial" })], m7.prototype, "type", void 0), m7 = l14 = e([c("esri.layers.support.rasterTransforms.PolynomialTransform")], m7);
var y6 = m7;

// node_modules/@arcgis/core/layers/support/rasterTransforms/utils.js
var o12 = { GCSShiftXform: n18, IdentityXform: a24, PolynomialXform: y6 };
var e8 = Object.keys(o12);
function f5(r7) {
  const t5 = r7 == null ? void 0 : r7.type;
  return !r7 || e8.includes(t5);
}
function i19(r7) {
  const t5 = r7 == null ? void 0 : r7.type;
  if (!t5)
    return null;
  const n19 = o12[r7 == null ? void 0 : r7.type];
  if (n19) {
    const t6 = new n19();
    return t6.read(r7), t6;
  }
  return null;
}

export {
  C3 as C,
  R2 as R,
  n18 as n,
  y6 as y,
  f5 as f,
  i19 as i
};
//# sourceMappingURL=chunk-LOFJKPMO.js.map
