import {
  s as s4
} from "./chunk-24NOAXOQ.js";
import {
  a2 as a,
  f,
  i
} from "./chunk-R5DM4YAB.js";
import {
  C,
  E,
  b,
  c2 as c,
  e,
  m,
  r,
  s as s3,
  t,
  u
} from "./chunk-RFPH3ZTZ.js";
import {
  l
} from "./chunk-WGO3VFQP.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import {
  has
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/core/workers/connectionRegistry.js
var n = new FinalizationRegistry((n3) => {
  n3.close();
});
function e2(e4, i4) {
  n.register(e4, i4, i4);
}
function i2(e4) {
  n.unregister(e4);
}

// node_modules/@arcgis/core/core/workers/registry.js
var r2 = { statsWorker: () => import("./statsWorker-VLAGD47T.js"), geometryEngineWorker: () => import("./geometryEngineWorker-SLS55IBG.js"), CSVSourceWorker: () => import("./CSVSourceWorker-CJRKYG6N.js"), EdgeProcessingWorker: () => import("./EdgeProcessingWorker-PHIF7OPE.js"), ElevationSamplerWorker: () => import("./ElevationSamplerWorker-2SUSM2Y5.js"), FeatureServiceSnappingSourceWorker: () => import("./FeatureServiceSnappingSourceWorker-ZRCHVM4L.js"), GeoJSONSourceWorker: () => import("./GeoJSONSourceWorker-ILIMR5JK.js"), LercWorker: () => import("./LercWorker-CBWIXLUB.js"), MemorySourceWorker: () => import("./MemorySourceWorker-MNGGHJAH.js"), PBFDecoderWorker: () => import("./PBFDecoderWorker-GAIXSOBH.js"), Pipeline: () => import("./Pipeline-TBSO4QUT.js"), PointCloudWorker: () => import("./PointCloudWorker-UJT6RLJ4.js"), RasterWorker: () => import("./RasterWorker-UM2M6CZD.js"), SceneLayerSnappingSourceWorker: () => import("./SceneLayerSnappingSourceWorker-JOHMJEO2.js"), SceneLayerWorker: () => import("./SceneLayerWorker-5NU4FK25.js"), WFSSourceWorker: () => import("./WFSSourceWorker-RCLF3RSU.js"), WorkerTileHandler: () => import("./WorkerTileHandler-MH2GCKTM.js") };

// node_modules/@arcgis/core/core/workers/utils.js
var t2;
!function(t3) {
  t3[t3.HANDSHAKE = 0] = "HANDSHAKE", t3[t3.OPEN = 1] = "OPEN", t3[t3.OPENED = 2] = "OPENED", t3[t3.RESPONSE = 3] = "RESPONSE", t3[t3.INVOKE = 4] = "INVOKE", t3[t3.ABORT = 5] = "ABORT", t3[t3.CLOSE = 6] = "CLOSE", t3[t3.OPEN_PORT = 7] = "OPEN_PORT", t3[t3.ON = 8] = "ON";
}(t2 || (t2 = {}));
var e3 = 0;
function r3() {
  return e3++;
}
function n2(t3) {
  return t3 && "object" == typeof t3 && ("result" in t3 || "transferList" in t3);
}
function s5(t3) {
  return t3 ? "string" == typeof t3 ? JSON.stringify({ name: "message", message: t3 }) : t3.toJSON ? JSON.stringify(t3) : JSON.stringify({ name: t3.name, message: t3.message, details: t3.details || { stack: t3.stack } }) : null;
}
function f2(e4, r4, i4, a3) {
  if (r4.type === t2.OPEN_PORT)
    return void e4.postMessage(r4, [r4.port]);
  if (r4.type !== t2.INVOKE && r4.type !== t2.RESPONSE)
    return void e4.postMessage(r4);
  let u2;
  if (n2(i4) ? (u2 = o(i4.transferList), r4.data = i4.result) : (u2 = o(a3), r4.data = i4), u2) {
    if (has("ff")) {
      for (const n3 of u2)
        if ("byteLength" in n3 && n3.byteLength > 267386880) {
          const n4 = "Worker call with large ArrayBuffer would crash Firefox";
          switch (r4.type) {
            case t2.INVOKE:
              throw n4;
            case t2.RESPONSE:
              return void f2(e4, { type: t2.RESPONSE, jobId: r4.jobId, error: s5(n4) });
          }
        }
    }
    e4.postMessage(r4, u2);
  } else
    e4.postMessage(r4);
}
function i3(t3) {
  if (!t3)
    return null;
  const e4 = t3.data;
  return e4 ? "string" == typeof e4 ? JSON.parse(e4) : e4 : null;
}
function o(t3) {
  if (!(t3 == null ? void 0 : t3.length))
    return null;
  if (has("esri-workers-arraybuffer-transfer"))
    return t3;
  const e4 = t3.filter((t4) => !a2(t4));
  return e4.length ? e4 : null;
}
function a2(t3) {
  var _a;
  return t3 instanceof ArrayBuffer || "ArrayBuffer" === ((_a = t3 == null ? void 0 : t3.constructor) == null ? void 0 : _a.name);
}

// node_modules/@arcgis/core/core/workers/RemoteClient.js
var { CLOSE: f3, ABORT: v, INVOKE: M, RESPONSE: k, OPEN_PORT: j, ON: y } = t2;
var I = 2;
var J = class {
  constructor(e4) {
    this._timer = null, this._cancelledJobIds = /* @__PURE__ */ new Set(), this._invokeMessages = [], this._invoke = e4, this._timer = null, this._process = this._process.bind(this);
  }
  push(e4) {
    e4.type === t2.ABORT ? this._cancelledJobIds.add(e4.jobId) : (this._invokeMessages.push(e4), null === this._timer && (this._timer = setTimeout(this._process, 0)));
  }
  clear() {
    this._invokeMessages.length = 0, this._cancelledJobIds.clear(), this._timer = null;
  }
  _process() {
    this._timer = null;
    for (const e4 of this._invokeMessages)
      this._cancelledJobIds.has(e4.jobId) || this._invoke(e4);
    this._cancelledJobIds.clear(), this._invokeMessages.length = 0;
  }
};
var w = class _w {
  static connect(e4) {
    const s6 = new MessageChannel();
    let t3;
    t3 = "function" == typeof e4 ? new e4() : "default" in e4 && "function" == typeof e4.default ? new e4.default() : e4;
    const o2 = new _w(s6.port1, { channel: s6, client: t3 });
    return "object" == typeof t3 && "remoteClient" in t3 && (t3.remoteClient = o2), _w.clients.set(o2, t3), s6.port2;
  }
  static loadWorker(e4) {
    const s6 = r2[e4];
    return s6 ? s6() : Promise.resolve(null);
  }
  constructor(e4, s6, t3) {
    this._port = e4, this._jobQueue = t3, this._outJobs = /* @__PURE__ */ new Map(), this._inJobs = /* @__PURE__ */ new Map(), this._invokeQueue = new J((e5) => this._onInvokeMessage(e5)), this._client = s6.client, this._onMessage = this._onMessage.bind(this), this._channel = s6.channel, this._schedule = s6.schedule, this._port.addEventListener("message", this._onMessage), this._port.start();
  }
  close() {
    this._post({ type: f3 }), this._close();
  }
  isBusy() {
    return this._outJobs.size > 0;
  }
  invoke(e4, t3, o2) {
    const a3 = o2 == null ? void 0 : o2.signal, h = o2 == null ? void 0 : o2.transferList;
    if (!this._port)
      return Promise.reject(new s2("worker:port-closed", `Cannot call invoke('${e4}'), port is closed`, { methodName: e4, data: t3 }));
    const c3 = r3();
    return new Promise((s6, o3) => {
      if (c(a3))
        return this._processWork(), void o3(u());
      const p = m(a3, () => {
        const e5 = this._outJobs.get(c3);
        e5 && (this._outJobs.delete(c3), this._processWork(), l(e5.abortHandle), this._post({ type: v, jobId: c3 }), o3(u()));
      }), _ = { resolve: s6, reject: o3, abortHandle: p, debugInfo: e4 };
      this._outJobs.set(c3, _), this._post({ type: M, jobId: c3, methodName: e4, abortable: null != a3 }, t3, h);
    });
  }
  on(e4, s6) {
    const t3 = new MessageChannel();
    function n3(e5) {
      s6(e5.data);
    }
    return this._port.postMessage({ type: t2.ON, eventType: e4, port: t3.port2 }, [t3.port2]), t3.port1.addEventListener("message", n3), t3.port1.start(), e(() => {
      t3.port1.postMessage({ type: t2.CLOSE }), t3.port1.close(), t3.port1.removeEventListener("message", n3);
    });
  }
  jobAdded() {
    this._processWork();
  }
  openPort() {
    const e4 = new MessageChannel();
    return this._post({ type: j, port: e4.port2 }), e4.port1;
  }
  _processWork() {
    var _a;
    if (this._outJobs.size >= I)
      return;
    const e4 = (_a = this._jobQueue) == null ? void 0 : _a.pop();
    if (!e4)
      return;
    const { methodName: s6, data: t3, invokeOptions: o2, resolver: n3 } = e4;
    this.invoke(s6, t3, o2).then((e5) => n3.resolve(e5)).catch((e5) => n3.reject(e5));
  }
  _close() {
    this._channel && (this._channel = void 0), this._port.removeEventListener("message", this._onMessage), this._port.close(), this._outJobs.forEach((e4) => {
      l(e4.abortHandle), e4.reject(u(`Worker closing, aborting job calling '${e4.debugInfo}'`));
    }), this._inJobs.clear(), this._outJobs.clear(), this._invokeQueue.clear(), this._port = null, this._client = null, this._schedule = null;
  }
  _onMessage(e4) {
    null != this._schedule ? this._schedule(() => this._processMessage(e4)) : this._processMessage(e4);
  }
  _processMessage(e4) {
    const s6 = i3(e4);
    if (s6)
      switch (s6.type) {
        case k:
          this._onResponseMessage(s6);
          break;
        case M:
          this._invokeQueue.push(s6);
          break;
        case v:
          this._onAbortMessage(s6);
          break;
        case f3:
          this._onCloseMessage();
          break;
        case j:
          this._onOpenPortMessage(s6);
          break;
        case y:
          this._onOnMessage(s6);
      }
  }
  _onAbortMessage(e4) {
    const s6 = this._inJobs, t3 = e4.jobId, o2 = s6.get(t3);
    this._invokeQueue.push(e4), o2 && (o2.controller && o2.controller.abort(), s6.delete(t3));
  }
  _onCloseMessage() {
    const e4 = this._client;
    this._close(), e4 && "destroy" in e4 && _w.clients.get(this) === e4 && e4.destroy(), _w.clients.delete(this), (e4 == null ? void 0 : e4.remoteClient) && (e4.remoteClient = null);
  }
  _onInvokeMessage(e4) {
    const { methodName: s6, jobId: t3, data: o2, abortable: n3 } = e4, r4 = n3 ? new AbortController() : null, i4 = this._inJobs;
    let l2, c3 = this._client, p = c3[s6];
    try {
      if (!p && s6 && s6.includes(".")) {
        const e5 = s6.split(".");
        for (let s7 = 0; s7 < e5.length - 1; s7++)
          c3 = c3[e5[s7]], p = c3[e5[s7 + 1]];
      }
      if ("function" != typeof p)
        throw new TypeError(`${s6} is not a function`);
      l2 = p.call(c3, o2, { client: this, signal: r4 ? r4.signal : null });
    } catch (_) {
      return void this._post({ type: k, jobId: t3, error: s5(_) });
    }
    E(l2) ? (i4.set(t3, { controller: r4, promise: l2 }), l2.then((e5) => {
      i4.has(t3) && (i4.delete(t3), this._post({ type: k, jobId: t3 }, e5));
    }, (e5) => {
      i4.has(t3) && (i4.delete(t3), b(e5) || this._post({ type: k, jobId: t3, error: s5(e5 || { message: `Error encountered at method ${s6}` }) }));
    })) : this._post({ type: k, jobId: t3 }, l2);
  }
  _onOpenPortMessage(e4) {
    new _w(e4.port, { client: this._client });
  }
  _onOnMessage(e4) {
    const { port: s6 } = e4, o2 = this._client.on(e4.eventType, (e5) => {
      s6.postMessage(e5);
    }), n3 = r(e4.port, "message", (e5) => {
      const t3 = i3(e5);
      (t3 == null ? void 0 : t3.type) === t2.CLOSE && (n3.remove(), o2.remove(), s6.close());
    });
  }
  _onResponseMessage(e4) {
    const { jobId: t3, error: o2, data: r4 } = e4, i4 = this._outJobs;
    if (!i4.has(t3))
      return;
    const l2 = i4.get(t3);
    i4.delete(t3), this._processWork(), l(l2.abortHandle), o2 ? l2.reject(s2.fromJSON(JSON.parse(o2))) : l2.resolve(r4);
  }
  _post(e4, s6, t3) {
    return f2(this._port, e4, s6, t3);
  }
};
w.kernelInfo = { buildDate: f, fullVersion: i, revision: a }, w.clients = /* @__PURE__ */ new Map();

// node_modules/@arcgis/core/core/workers/Connection.js
var c2 = class {
  constructor() {
    this._inUseClients = new Array(), this._clients = new Array(), this._clientPromises = new Array(), this._ongoingJobsQueue = new s4();
  }
  destroy() {
    this.close();
  }
  get closed() {
    var _a;
    return !((_a = this._clients) == null ? void 0 : _a.length);
  }
  open(e4, t3) {
    return new Promise((i4, n3) => {
      let r4 = true;
      const l2 = (e5) => {
        s3(t3.signal), r4 && (r4 = false, e5());
      };
      this._clients.length = e4.length, this._clientPromises.length = e4.length, this._inUseClients.length = e4.length;
      for (let o2 = 0; o2 < e4.length; ++o2) {
        const r5 = e4[o2];
        E(r5) ? this._clientPromises[o2] = r5.then((e5) => (this._clients[o2] = new w(e5, t3, this._ongoingJobsQueue), l2(i4), this._clients[o2]), () => (l2(n3), null)) : (this._clients[o2] = new w(r5, t3, this._ongoingJobsQueue), this._clientPromises[o2] = Promise.resolve(this._clients[o2]), l2(i4));
      }
    });
  }
  broadcast(e4, t3, s6) {
    const i4 = new Array(this._clientPromises.length);
    for (let n3 = 0; n3 < this._clientPromises.length; ++n3) {
      const o2 = this._clientPromises[n3];
      i4[n3] = o2.then((i5) => i5 == null ? void 0 : i5.invoke(e4, t3, s6));
    }
    return i4;
  }
  close() {
    let e4;
    for (; e4 = this._ongoingJobsQueue.pop(); )
      e4.resolver.reject(u(`Worker closing, aborting job calling '${e4.methodName}'`));
    for (const t3 of this._clientPromises)
      t3.then((e5) => e5 == null ? void 0 : e5.close());
    this._clients.length = 0, this._clientPromises.length = 0, this._inUseClients.length = 0, i2(this);
  }
  invoke(e4, s6, i4) {
    let o2;
    Array.isArray(i4) ? (s.getLogger("esri.core.workers.Connection").warn("invoke()", "The transferList parameter is deprecated, use the options object instead"), o2 = { transferList: i4 }) : o2 = i4;
    const r4 = C();
    this._ongoingJobsQueue.push({ methodName: e4, data: s6, invokeOptions: o2, resolver: r4 });
    for (let t3 = 0; t3 < this._clientPromises.length; t3++) {
      const e5 = this._clients[t3];
      e5 ? e5.jobAdded() : this._clientPromises[t3].then((e6) => e6 == null ? void 0 : e6.jobAdded());
    }
    return r4.promise;
  }
  on(t3, s6) {
    return Promise.all(this._clientPromises).then(() => t(this._clients.map((e4) => e4.on(t3, s6))));
  }
  openPorts() {
    return new Promise((e4) => {
      const t3 = new Array(this._clientPromises.length);
      let s6 = t3.length;
      for (let i4 = 0; i4 < this._clientPromises.length; ++i4) {
        this._clientPromises[i4].then((n3) => {
          n3 && (t3[i4] = n3.openPort()), 0 == --s6 && e4(t3);
        });
      }
    });
  }
  get test() {
    return { numClients: this._clients.length };
  }
};

export {
  e2 as e,
  t2 as t,
  r3 as r,
  s5 as s,
  f2 as f,
  i3 as i,
  w,
  c2 as c
};
//# sourceMappingURL=chunk-NCLD32JB.js.map
