import {
  H as H2
} from "./chunk-L7QWOCUD.js";
import {
  e as e3
} from "./chunk-ERRE3PWK.js";
import {
  e as e2
} from "./chunk-GLBAW5CR.js";
import {
  t as t2
} from "./chunk-PPQAHSM4.js";
import {
  C
} from "./chunk-RCLKRKWR.js";
import {
  M,
  l
} from "./chunk-MKW4ORPJ.js";
import {
  H,
  P,
  _2 as _,
  e2 as e,
  n,
  o,
  r2 as r,
  u2 as u,
  x,
  z
} from "./chunk-YTH6VA7N.js";
import {
  t,
  y
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/views/3d/support/buffer/glUtil.js
function r2(e5, r4 = 0) {
  const n3 = e5.stride;
  return Array.from(e5.fields.keys()).map((i) => {
    const s = e5.fields.get(i), u5 = s.constructor.ElementCount, f3 = o2(s.constructor.ElementType), c2 = s.offset, l3 = !(!s.optional || !s.optional.glNormalized);
    return new t2(i, u5, f3, c2, n3, l3, r4);
  });
}
function o2(e5) {
  const t4 = n2[e5];
  if (t4)
    return t4;
  throw new Error("BufferType not supported in WebGL");
}
var n2 = { u8: C.UNSIGNED_BYTE, u16: C.UNSIGNED_SHORT, u32: C.UNSIGNED_INT, i8: C.BYTE, i16: C.SHORT, i32: C.INT, f32: C.FLOAT };

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/bufferLayouts.js
var T = H2().vec3f(e2.POSITION).u16(e2.COMPONENTINDEX);
var A = H2().vec2u8(e2.SIDENESS);
var E = r2(A);
var e4 = H2().vec3f(e2.POSITION0).vec3f(e2.POSITION1).vec3f(e2.NORMAL).u16(e2.COMPONENTINDEX).u8(e2.VARIANTOFFSET, { glNormalized: true }).u8(e2.VARIANTSTROKE).u8(e2.VARIANTEXTENSION, { glNormalized: true });
var S = H2().vec3f(e2.POSITION0).vec3f(e2.POSITION1).vec3f(e2.NORMALA).vec3f(e2.NORMALB).u16(e2.COMPONENTINDEX).u8(e2.VARIANTOFFSET, { glNormalized: true }).u8(e2.VARIANTSTROKE).u8(e2.VARIANTEXTENSION, { glNormalized: true });
var r3 = /* @__PURE__ */ new Map([[e2.POSITION0, 0], [e2.POSITION1, 1], [e2.COMPONENTINDEX, 2], [e2.VARIANTOFFSET, 3], [e2.VARIANTSTROKE, 4], [e2.VARIANTEXTENSION, 5], [e2.NORMAL, 6], [e2.NORMALA, 6], [e2.NORMALB, 7], [e2.SIDENESS, 8]]);

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/edgePreprocessing.js
var m = -1;
var u2;
function p(n3, a3, i, l3 = V) {
  const f3 = n3.vertices.position, g3 = n3.vertices.componentIndex, u5 = M(l3.anglePlanar), p4 = M(l3.angleSignificantEdge), y4 = Math.cos(p4), E2 = Math.cos(u5), N = I.edge, S2 = N.position0, j = N.position1, x2 = N.faceNormal0, D = N.faceNormal1, F = w(n3), C2 = d(n3), L = C2.length / 4, b = a3.allocate(L);
  let k = 0;
  const H3 = L, K = i.allocate(H3);
  let M2 = 0, O = 0, P2 = 0;
  const T2 = y(0, L), U = new Float32Array(L);
  U.forEach((e5, t4, n4) => {
    f3.getVec(C2[4 * t4], S2), f3.getVec(C2[4 * t4 + 1], j), n4[t4] = x(S2, j);
  }), T2.sort((e5, t4) => U[t4] - U[e5]);
  const q = new Array(), z2 = new Array();
  for (let e5 = 0; e5 < L; e5++) {
    const t4 = T2[e5], n4 = U[t4], o3 = C2[4 * t4], l4 = C2[4 * t4 + 1], p5 = C2[4 * t4 + 2], d4 = C2[4 * t4 + 3], w3 = d4 === m;
    if (f3.getVec(o3, S2), f3.getVec(l4, j), w3)
      o(x2, F[3 * p5], F[3 * p5 + 1], F[3 * p5 + 2]), r(D, x2), N.componentIndex = g3.get(o3), N.cosAngle = P(x2, D);
    else {
      if (o(x2, F[3 * p5], F[3 * p5 + 1], F[3 * p5 + 2]), o(D, F[3 * d4], F[3 * d4 + 1], F[3 * d4 + 2]), N.componentIndex = g3.get(o3), N.cosAngle = P(x2, D), v(N, E2))
        continue;
      N.cosAngle < -0.9999 && r(D, x2);
    }
    O += n4, P2++, w3 || h(N, y4) ? (a3.write(b, k++, N), q.push(n4)) : A2(N, u5) && (i.write(K, M2++, N), z2.push(n4));
  }
  const B = new Float32Array(q.reverse()), G = new Float32Array(z2.reverse());
  return { regular: { instancesData: a3.trim(b, k), lodInfo: { lengths: B } }, silhouette: { instancesData: i.trim(K, M2), lodInfo: { lengths: G } }, averageEdgeLength: O / P2 };
}
function h(e5, t4) {
  return e5.cosAngle < t4;
}
function v(e5, t4) {
  return e5.cosAngle > t4;
}
function A2(e5, t4) {
  const o3 = l(e5.cosAngle), c2 = I.fwd, r4 = I.ortho;
  H(c2, e5.position1, e5.position0);
  return o3 * (P(_(r4, e5.faceNormal0, e5.faceNormal1), c2) > 0 ? -1 : 1) > t4;
}
function d(e5) {
  const t4 = e5.faces.length / 3, n3 = e5.faces, o3 = e5.neighbors;
  let c2 = 0;
  for (let a3 = 0; a3 < t4; a3++) {
    const e6 = o3[3 * a3], t5 = o3[3 * a3 + 1], r5 = o3[3 * a3 + 2], s2 = n3[3 * a3], i = n3[3 * a3 + 1], l3 = n3[3 * a3 + 2];
    c2 += e6 === m || s2 < i ? 1 : 0, c2 += t5 === m || i < l3 ? 1 : 0, c2 += r5 === m || l3 < s2 ? 1 : 0;
  }
  const r4 = new Int32Array(4 * c2);
  let s = 0;
  for (let a3 = 0; a3 < t4; a3++) {
    const e6 = o3[3 * a3], t5 = o3[3 * a3 + 1], c3 = o3[3 * a3 + 2], i = n3[3 * a3], l3 = n3[3 * a3 + 1], f3 = n3[3 * a3 + 2];
    (e6 === m || i < l3) && (r4[s++] = i, r4[s++] = l3, r4[s++] = a3, r4[s++] = e6), (t5 === m || l3 < f3) && (r4[s++] = l3, r4[s++] = f3, r4[s++] = a3, r4[s++] = t5), (c3 === m || f3 < i) && (r4[s++] = f3, r4[s++] = i, r4[s++] = a3, r4[s++] = c3);
  }
  return r4;
}
function w(e5) {
  const t4 = e5.faces.length / 3, n3 = e5.vertices.position, o3 = e5.faces, c2 = y2.v0, r4 = y2.v1, s = y2.v2, a3 = new Float32Array(3 * t4);
  for (let g3 = 0; g3 < t4; g3++) {
    const e6 = o3[3 * g3], t5 = o3[3 * g3 + 1], m4 = o3[3 * g3 + 2];
    n3.getVec(e6, c2), n3.getVec(t5, r4), n3.getVec(m4, s), e(r4, r4, c2), e(s, s, c2), _(c2, r4, s), z(c2, c2), a3[3 * g3] = c2[0], a3[3 * g3 + 1] = c2[1], a3[3 * g3 + 2] = c2[2];
  }
  return a3;
}
!function(e5) {
  e5[e5.SOLID = 0] = "SOLID", e5[e5.SKETCH = 1] = "SKETCH";
}(u2 || (u2 = {}));
var I = { edge: { position0: n(), position1: n(), faceNormal0: n(), faceNormal1: n(), componentIndex: 0, cosAngle: 0 }, ortho: n(), fwd: n() };
var y2 = { v0: n(), v1: n(), v2: n() };
var V = { anglePlanar: 4, angleSignificantEdge: 35 };

// node_modules/@arcgis/core/views/3d/support/meshProcessing.js
function t3(t4, o3, n3) {
  const r4 = o3 / 3, c2 = new Uint32Array(n3 + 1), e5 = new Uint32Array(n3 + 1), s = (t5, o4) => {
    t5 < o4 ? c2[t5 + 1]++ : e5[o4 + 1]++;
  };
  for (let x2 = 0; x2 < r4; x2++) {
    const o4 = t4[3 * x2], n4 = t4[3 * x2 + 1], r5 = t4[3 * x2 + 2];
    s(o4, n4), s(n4, r5), s(r5, o4);
  }
  let f3 = 0, l3 = 0;
  for (let x2 = 0; x2 < n3; x2++) {
    const t5 = c2[x2 + 1], o4 = e5[x2 + 1];
    c2[x2 + 1] = f3, e5[x2 + 1] = l3, f3 += t5, l3 += o4;
  }
  const i = new Uint32Array(6 * r4), a3 = c2[n3], w3 = (t5, o4, n4) => {
    if (t5 < o4) {
      const r5 = c2[t5 + 1]++;
      i[2 * r5] = o4, i[2 * r5 + 1] = n4;
    } else {
      const r5 = e5[o4 + 1]++;
      i[2 * a3 + 2 * r5] = t5, i[2 * a3 + 2 * r5 + 1] = n4;
    }
  };
  for (let x2 = 0; x2 < r4; x2++) {
    const o4 = t4[3 * x2], n4 = t4[3 * x2 + 1], r5 = t4[3 * x2 + 2];
    w3(o4, n4, x2), w3(n4, r5, x2), w3(r5, o4, x2);
  }
  const y4 = (t5, o4) => {
    const n4 = 2 * t5, r5 = o4 - t5;
    for (let c3 = 1; c3 < r5; c3++) {
      const t6 = i[n4 + 2 * c3], o5 = i[n4 + 2 * c3 + 1];
      let r6 = c3 - 1;
      for (; r6 >= 0 && i[n4 + 2 * r6] > t6; r6--)
        i[n4 + 2 * r6 + 2] = i[n4 + 2 * r6], i[n4 + 2 * r6 + 3] = i[n4 + 2 * r6 + 1];
      i[n4 + 2 * r6 + 2] = t6, i[n4 + 2 * r6 + 3] = o5;
    }
  };
  for (let x2 = 0; x2 < n3; x2++)
    y4(c2[x2], c2[x2 + 1]), y4(a3 + e5[x2], a3 + e5[x2 + 1]);
  const A3 = new Int32Array(3 * r4), U = (o4, n4) => o4 === t4[3 * n4] ? 0 : o4 === t4[3 * n4 + 1] ? 1 : o4 === t4[3 * n4 + 2] ? 2 : -1, u5 = (t5, o4) => {
    const n4 = U(t5, o4);
    A3[3 * o4 + n4] = -1;
  }, p4 = (t5, o4, n4, r5) => {
    const c3 = U(t5, o4);
    A3[3 * o4 + c3] = r5;
    const e6 = U(n4, r5);
    A3[3 * r5 + e6] = o4;
  };
  for (let x2 = 0; x2 < n3; x2++) {
    let t5 = c2[x2];
    const o4 = c2[x2 + 1];
    let n4 = e5[x2];
    const r5 = e5[x2 + 1];
    for (; t5 < o4 && n4 < r5; ) {
      const o5 = i[2 * t5], r6 = i[2 * a3 + 2 * n4];
      o5 === r6 ? (p4(x2, i[2 * t5 + 1], r6, i[2 * a3 + 2 * n4 + 1]), t5++, n4++) : o5 < r6 ? (u5(x2, i[2 * t5 + 1]), t5++) : (u5(r6, i[2 * a3 + 2 * n4 + 1]), n4++);
    }
    for (; t5 < o4; )
      u5(x2, i[2 * t5 + 1]), t5++;
    for (; n4 < r5; ) {
      u5(i[2 * a3 + 2 * n4], i[2 * a3 + 2 * n4 + 1]), n4++;
    }
  }
  return A3;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/edgeBufferWriters.js
var a = class {
  updateSettings(t4) {
    this.settings = t4, this._edgeHashFunction = t4.reducedPrecision ? f : p2;
  }
  write(t4, o3, e5) {
    const n3 = this._edgeHashFunction(e5);
    y3.seed = n3;
    const i = y3.getIntRange(0, 255), r4 = y3.getIntRange(0, this.settings.variants - 1), s = 0.7, a3 = y3.getFloat(), c2 = 255 * (0.5 * g(-(1 - Math.min(a3 / s, 1)) + Math.max(0, a3 - s) / (1 - s), 1.2) + 0.5);
    t4.position0.setVec(o3, e5.position0), t4.position1.setVec(o3, e5.position1), t4.componentIndex.set(o3, e5.componentIndex), t4.variantOffset.set(o3, i), t4.variantStroke.set(o3, r4), t4.variantExtension.set(o3, c2);
  }
  trim(t4, o3) {
    return t4.slice(0, o3);
  }
};
var c = new Float32Array(6);
var m2 = new Uint32Array(c.buffer);
var u3 = new Uint32Array(1);
function p2(t4) {
  const o3 = c;
  o3[0] = t4.position0[0], o3[1] = t4.position0[1], o3[2] = t4.position0[2], o3[3] = t4.position1[0], o3[4] = t4.position1[1], o3[5] = t4.position1[2], u3[0] = 5381;
  for (let e5 = 0; e5 < m2.length; e5++)
    u3[0] = 31 * u3[0] + m2[e5];
  return u3[0];
}
function f(t4) {
  const o3 = c;
  o3[0] = h2(t4.position0[0]), o3[1] = h2(t4.position0[1]), o3[2] = h2(t4.position0[2]), o3[3] = h2(t4.position1[0]), o3[4] = h2(t4.position1[1]), o3[5] = h2(t4.position1[2]), u3[0] = 5381;
  for (let e5 = 0; e5 < m2.length; e5++)
    u3[0] = 31 * u3[0] + m2[e5];
  return u3[0];
}
var l2 = 1e4;
function h2(t4) {
  return Math.round(t4 * l2) / l2;
}
function g(t4, o3) {
  const e5 = t4 < 0 ? -1 : 1;
  return Math.abs(t4) ** o3 * e5;
}
var d2 = class {
  constructor() {
    this._commonWriter = new a();
  }
  updateSettings(t4) {
    this._commonWriter.updateSettings(t4);
  }
  allocate(t4) {
    return e4.createBuffer(t4);
  }
  write(t4, n3, i) {
    this._commonWriter.write(t4, n3, i), u(_2, i.faceNormal0, i.faceNormal1), z(_2, _2), t4.normal.setVec(n3, _2);
  }
  trim(t4, o3) {
    return this._commonWriter.trim(t4, o3);
  }
};
d2.Layout = e4, d2.glLayout = r2(e4, 1);
var w2 = class {
  constructor() {
    this._commonWriter = new a();
  }
  updateSettings(t4) {
    this._commonWriter.updateSettings(t4);
  }
  allocate(t4) {
    return S.createBuffer(t4);
  }
  write(t4, o3, e5) {
    this._commonWriter.write(t4, o3, e5), t4.normalA.setVec(o3, e5.faceNormal0), t4.normalB.setVec(o3, e5.faceNormal1);
  }
  trim(t4, o3) {
    return this._commonWriter.trim(t4, o3);
  }
};
w2.Layout = S, w2.glLayout = r2(S, 1);
var _2 = n();
var y3 = new t();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/edgeProcessing.js
function f2(e5) {
  const t4 = u4(e5.data, e5.skipDeduplicate, e5.indices, e5.indicesLength);
  return g2.updateSettings(e5.writerSettings), a2.updateSettings(e5.writerSettings), p(t4, g2, a2);
}
function u4(r4, i, n3, o3) {
  if (i) {
    const e5 = t3(n3, o3, r4.count);
    return new p3(n3, o3, e5, r4);
  }
  const c2 = e3(r4.buffer, r4.stride / 4, { originalIndices: n3, originalIndicesLength: o3 }), f3 = t3(c2.indices, o3, c2.uniqueCount);
  return { faces: c2.indices, facesLength: c2.indices.length, neighbors: f3, vertices: T.createView(c2.buffer) };
}
var p3 = class {
  constructor(e5, t4, r4, i) {
    this.faces = e5, this.facesLength = t4, this.neighbors = r4, this.vertices = i;
  }
};
var g2 = new d2();
var a2 = new w2();
var d3 = H2().vec3f(e2.POSITION0).vec3f(e2.POSITION1);
var m3 = H2().vec3f(e2.POSITION0).vec3f(e2.POSITION1).u16(e2.COMPONENTINDEX);

export {
  T,
  p,
  f2 as f,
  u4 as u,
  d3 as d,
  m3 as m
};
//# sourceMappingURL=chunk-TNBDWKFN.js.map
