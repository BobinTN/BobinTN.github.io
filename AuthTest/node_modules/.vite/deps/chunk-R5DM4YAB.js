import {
  a as a2
} from "./chunk-NSRXJNTS.js";
import {
  b,
  c2 as c,
  m,
  u
} from "./chunk-RFPH3ZTZ.js";
import {
  a,
  s,
  s2,
  s3
} from "./chunk-WJ3HJKNC.js";
import {
  has,
  k
} from "./chunk-4V6374PV.js";

// node_modules/@arcgis/core/portal/support/urlUtils.js
var e = /^https:\/\/([a-z\d-]+)(\.maps([^.]*))?\.arcgis\.com/i;
var s4 = { devext: { customBaseUrl: "mapsdevext.arcgis.com", portalHostname: "devext.arcgis.com" }, qaext: { customBaseUrl: "mapsqa.arcgis.com", portalHostname: "qaext.arcgis.com" }, www: { customBaseUrl: "maps.arcgis.com", portalHostname: "www.arcgis.com" } };
function a3(a7) {
  const t5 = a7 == null ? void 0 : a7.match(e);
  if (!t5)
    return null;
  const [, r2, o, l3] = t5;
  if (!r2)
    return null;
  let c5 = null, m4 = null, n3 = null;
  const { devext: u3, qaext: i3, www: p2 } = s4;
  if (o)
    if (c5 = r2, l3)
      switch (l3.toLowerCase()) {
        case "devext":
          ({ customBaseUrl: m4, portalHostname: n3 } = u3);
          break;
        case "qa":
          ({ customBaseUrl: m4, portalHostname: n3 } = i3);
          break;
        default:
          return null;
      }
    else
      ({ customBaseUrl: m4, portalHostname: n3 } = p2);
  else
    switch (r2.toLowerCase()) {
      case "devext":
        ({ customBaseUrl: m4, portalHostname: n3 } = u3);
        break;
      case "qaext":
        ({ customBaseUrl: m4, portalHostname: n3 } = i3);
        break;
      case "www":
        ({ customBaseUrl: m4, portalHostname: n3 } = p2);
        break;
      default:
        return null;
    }
  return { customBaseUrl: m4, isPortal: false, portalHostname: n3, urlKey: c5 };
}
function t(e2) {
  return /\/(sharing|usrsvcs)\/(appservices|servers)\//i.test(e2);
}

// node_modules/@arcgis/core/support/base64Utils.js
function t2(t5) {
  const n3 = atob(t5), r2 = new Uint8Array(n3.length);
  for (let e2 = 0; e2 < n3.length; e2++)
    r2[e2] = n3.charCodeAt(e2);
  return r2.buffer;
}
function n(t5) {
  const n3 = new Uint8Array(t5);
  let r2 = "";
  for (let e2 = 0; e2 < n3.length; e2++)
    r2 += String.fromCharCode(n3[e2]);
  return btoa(r2);
}

// node_modules/@arcgis/core/core/urlUtils.js
var l = s2.getLogger("esri.core.urlUtils");
var c2 = s.request;
var f = "esri/config: esriConfig.request.proxyUrl is not set.";
var a4 = /^\s*[a-z][a-z0-9-+.]*:(?![0-9])/i;
var p = /^\s*http:/i;
var h = /^\s*https:/i;
var d = /^\s*file:/i;
var m2 = /:\d+$/;
var g = /^https?:\/\/[^/]+\.arcgis.com\/sharing(\/|$)/i;
var y = new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$");
var $ = new RegExp("^((([^\\[:]+):)?([^@]+)@)?(\\[([^\\]]+)\\]|([^\\[:]*))(:([0-9]+))?$");
var x = class {
  constructor(t5 = "") {
    this.uri = t5, this.scheme = null, this.authority = null, this.path = null, this.query = null, this.fragment = null, this.user = null, this.password = null, this.host = null, this.port = null;
    let n3 = this.uri.match(y);
    this.scheme = n3[2] || (n3[1] ? "" : null), this.authority = n3[4] || (n3[3] ? "" : null), this.path = n3[5], this.query = n3[7] || (n3[6] ? "" : null), this.fragment = n3[9] || (n3[8] ? "" : null), null != this.authority && (n3 = this.authority.match($), this.user = n3[3] || null, this.password = n3[4] || null, this.host = n3[6] || n3[7], this.port = n3[9] || null);
  }
  toString() {
    return this.uri;
  }
};
var w = {};
var O = new x(s.applicationUrl);
var U = O;
var R = j();
var b2 = R;
var C = () => U;
var q = () => b2;
function j() {
  const t5 = U.path, n3 = t5.substring(0, t5.lastIndexOf(t5.split("/")[t5.split("/").length - 1]));
  return `${`${U.scheme}://${U.host}${null != U.port ? `:${U.port}` : ""}`}${n3}`;
}
function I(t5) {
  if (!t5)
    return null;
  const n3 = { path: null, query: null }, e2 = new x(t5), r2 = t5.indexOf("?");
  return null === e2.query ? n3.path = t5 : (n3.path = t5.substring(0, r2), n3.query = A(e2.query)), e2.fragment && (n3.hash = e2.fragment, null === e2.query && (n3.path = n3.path.substring(0, n3.path.length - (e2.fragment.length + 1)))), n3;
}
function A(t5) {
  const n3 = t5.split("&"), e2 = {};
  for (const r2 of n3) {
    if (!r2)
      continue;
    const t6 = r2.indexOf("=");
    let n4, o;
    t6 < 0 ? (n4 = decodeURIComponent(r2), o = "") : (n4 = decodeURIComponent(r2.slice(0, t6)), o = decodeURIComponent(r2.slice(t6 + 1)));
    let s5 = e2[n4];
    "string" == typeof s5 && (s5 = e2[n4] = [s5]), Array.isArray(s5) ? s5.push(o) : e2[n4] = o;
  }
  return e2;
}
function v(t5, n3) {
  return t5 ? n3 && "function" == typeof n3 ? Object.keys(t5).map((e2) => encodeURIComponent(e2) + "=" + encodeURIComponent(n3(e2, t5[e2]))).join("&") : Object.keys(t5).map((e2) => {
    const o = t5[e2];
    if (null == o)
      return "";
    const s5 = encodeURIComponent(e2) + "=", i3 = n3 == null ? void 0 : n3[e2];
    return i3 ? s5 + encodeURIComponent(i3(o)) : Array.isArray(o) ? o.map((t6) => a2(t6) ? s5 + encodeURIComponent(JSON.stringify(t6)) : s5 + encodeURIComponent(t6)).join("&") : a2(o) ? s5 + encodeURIComponent(JSON.stringify(o)) : s5 + encodeURIComponent(o);
  }).filter((t6) => t6).join("&") : "";
}
function P(t5 = false) {
  let n3, r2 = c2.proxyUrl;
  if ("string" == typeof t5) {
    n3 = dt(t5);
    const e2 = T(t5);
    e2 && (r2 = e2.proxyUrl);
  } else
    n3 = !!t5;
  if (!r2)
    throw l.warn(f), new s3("urlutils:proxy-not-set", f);
  n3 && wt() && (r2 = $t(r2));
  return I(r2);
}
function S(t5) {
  const n3 = T(t5);
  let e2, r2;
  if (n3) {
    const t6 = E(n3.proxyUrl);
    e2 = t6.path, r2 = t6.query ? A(t6.query) : null;
  }
  if (e2) {
    const n4 = I(t5);
    t5 = e2 + "?" + n4.path;
    const o = v({ ...r2, ...n4.query });
    o && (t5 = `${t5}?${o}`);
  }
  return t5;
}
var k2 = { path: "", query: "" };
function E(t5) {
  const n3 = t5.indexOf("?");
  return -1 !== n3 ? (k2.path = t5.slice(0, n3), k2.query = t5.slice(n3 + 1)) : (k2.path = t5, k2.query = null), k2;
}
function B(t5) {
  return t5 = (t5 = Ot(t5 = Ct(t5 = E(t5).path), true)).toLowerCase();
}
function H(t5) {
  const n3 = { proxyUrl: t5.proxyUrl, urlPrefix: B(t5.urlPrefix) }, e2 = c2.proxyRules, r2 = n3.urlPrefix;
  let o = e2.length;
  for (let s5 = 0; s5 < e2.length; s5++) {
    const t6 = e2[s5].urlPrefix;
    if (0 === r2.indexOf(t6)) {
      if (r2.length === t6.length)
        return -1;
      o = s5;
      break;
    }
    0 === t6.indexOf(r2) && (o = s5 + 1);
  }
  return e2.splice(o, 0, n3), o;
}
function T(t5) {
  const n3 = c2.proxyRules, e2 = B(t5);
  for (let r2 = 0; r2 < n3.length; r2++)
    if (0 === e2.indexOf(n3[r2].urlPrefix))
      return n3[r2];
}
function W(t5, n3) {
  if (!t5 || !n3)
    return false;
  t5 = z(t5), n3 = z(n3);
  const e2 = a3(t5), r2 = a3(n3);
  return null != e2 && null != r2 ? e2.portalHostname === r2.portalHostname : null == e2 && null == r2 && F(t5, n3, true);
}
function N(t5, n3) {
  return t5 = z(t5), n3 = z(n3), Ot(t5) === Ot(n3);
}
function z(t5) {
  const n3 = (t5 = K(t5)).indexOf("/sharing");
  return n3 > 0 ? t5.substring(0, n3) : t5.replace(/\/+$/, "");
}
function D(t5) {
  const n3 = (n4) => null == n4 || n4 instanceof RegExp && n4.test(t5) || "string" == typeof n4 && t5.startsWith(n4), e2 = c2.interceptors;
  if (e2) {
    for (const r2 of e2)
      if (Array.isArray(r2.urls)) {
        if (r2.urls.some(n3))
          return r2;
      } else if (n3(r2.urls))
        return r2;
  }
  return null;
}
function F(t5, n3, e2 = false) {
  if (!t5 || !n3)
    return false;
  const r2 = vt(t5), o = vt(n3);
  return !(!e2 && r2.scheme !== o.scheme) && (null != r2.host && null != o.host && (r2.host.toLowerCase() === o.host.toLowerCase() && r2.port === o.port));
}
function M(t5) {
  if ("string" == typeof t5) {
    if (!Y(t5))
      return true;
    t5 = vt(t5);
  }
  if (F(t5, U))
    return true;
  const n3 = c2.trustedServers || [];
  for (let e2 = 0; e2 < n3.length; e2++) {
    const r2 = Q(n3[e2]);
    for (let n4 = 0; n4 < r2.length; n4++)
      if (F(t5, r2[n4]))
        return true;
  }
  return false;
}
function Q(t5) {
  return w[t5] || (ht(t5) || pt(t5) ? w[t5] = [new x(_(t5))] : w[t5] = [new x(`http://${t5}`), new x(`https://${t5}`)]), w[t5];
}
function _(t5, n3 = b2, e2) {
  return pt(t5) ? e2 && e2.preserveProtocolRelative ? t5 : "http" === U.scheme && U.authority === X(t5).slice(2) ? `http:${t5}` : `https:${t5}` : ht(t5) ? t5 : V("/" === t5[0] ? Ut(n3) : n3, t5);
}
function G(t5, n3 = b2, e2) {
  if (null == t5 || !Y(t5))
    return t5;
  const r2 = K(t5), o = r2.toLowerCase(), s5 = K(n3).toLowerCase().replace(/\/+$/, ""), i3 = e2 ? K(e2).toLowerCase().replace(/\/+$/, "") : null;
  if (i3 && 0 !== s5.indexOf(i3))
    return t5;
  const u3 = (t6, n4, e3) => -1 === (e3 = t6.indexOf(n4, e3)) ? t6.length : e3;
  let l3 = u3(o, "/", o.indexOf("//") + 2), c5 = -1;
  for (; o.slice(0, l3 + 1) === s5.slice(0, l3) + "/" && (c5 = l3 + 1, l3 !== o.length); )
    l3 = u3(o, "/", l3 + 1);
  if (-1 === c5)
    return t5;
  if (i3 && c5 < i3.length)
    return t5;
  t5 = r2.slice(c5);
  const f4 = s5.slice(c5 - 1).replaceAll(/[^/]+/g, "").length;
  if (f4 > 0)
    for (let a7 = 0; a7 < f4; a7++)
      t5 = `../${t5}`;
  else
    t5 = `./${t5}`;
  return t5;
}
function K(t5) {
  return t5 = It(t5 = Lt(t5 = jt(t5 = _(t5 = t5.trim()))));
}
function V(...t5) {
  const e2 = t5.filter(k);
  if (!(e2 == null ? void 0 : e2.length))
    return;
  const r2 = [];
  if (Y(e2[0])) {
    const t6 = e2[0], n3 = t6.indexOf("//");
    -1 !== n3 && (r2.push(t6.slice(0, n3 + 1)), gt(e2[0]) && (r2[0] += "/"), e2[0] = t6.slice(n3 + 2));
  } else
    "/" === e2[0][0] && r2.push("");
  const o = e2.reduce((t6, n3) => n3 ? t6.concat(n3.split("/")) : t6, []);
  for (let n3 = 0; n3 < o.length; n3++) {
    const t6 = o[n3];
    ".." === t6 && r2.length > 0 && ".." !== r2[r2.length - 1] ? r2.pop() : (!t6 && n3 === o.length - 1 || t6 && ("." !== t6 || 0 === r2.length)) && r2.push(t6);
  }
  return r2.join("/");
}
function X(t5, n3 = false) {
  if (null == t5 || Z(t5) || tt(t5))
    return null;
  let e2 = t5.indexOf("://");
  if (-1 === e2 && pt(t5))
    e2 = 2;
  else {
    if (-1 === e2)
      return null;
    e2 += 3;
  }
  const r2 = t5.indexOf("/", e2);
  return -1 !== r2 && (t5 = t5.slice(0, r2)), n3 && (t5 = Ot(t5, true)), t5;
}
function Y(t5) {
  return pt(t5) || ht(t5);
}
function Z(t5) {
  return null != t5 && "blob:" === t5.slice(0, 5);
}
function tt(t5) {
  return null != t5 && "data:" === t5.slice(0, 5);
}
function nt(t5) {
  const n3 = ot(t5);
  return n3 && n3.isBase64 ? t2(n3.data) : null;
}
function et(t5) {
  return n(t5).replaceAll("+", "-").replaceAll("/", "_").replace(/=+$/, "");
}
var rt = /^data:(.*?)(;base64)?,(.*)$/;
function ot(t5) {
  const n3 = t5.match(rt);
  if (!n3)
    return null;
  const [, e2, r2, o] = n3;
  return { mediaType: e2, isBase64: !!r2, data: o };
}
function st(t5) {
  return t5.isBase64 ? `data:${t5.mediaType};base64,${t5.data}` : `data:${t5.mediaType},${t5.data}`;
}
async function it(t5) {
  return (await fetch(t5)).blob();
}
function ut(t5) {
  const n3 = nt(t5);
  if (!n3)
    return null;
  const e2 = ot(t5);
  return new Blob([n3], { type: e2.mediaType });
}
function ct(t5, n3) {
  at(t5, n3);
}
function at(t5, n3) {
  if (!t5)
    return false;
  const e2 = document.createElement("a");
  if (!("download" in e2))
    return false;
  const r2 = URL.createObjectURL(t5);
  return e2.download = n3, e2.href = r2, e2.style.display = "none", document.body.appendChild(e2), e2.click(), document.body.removeChild(e2), URL.revokeObjectURL(r2), true;
}
function pt(t5) {
  return null != t5 && "/" === t5[0] && "/" === t5[1];
}
function ht(t5) {
  return null != t5 && a4.test(t5);
}
function dt(t5) {
  return null != t5 && h.test(t5) || "https" === U.scheme && pt(t5);
}
function mt(t5) {
  return null != t5 && p.test(t5) || "http" === U.scheme && pt(t5);
}
function gt(t5) {
  return null != t5 && d.test(t5);
}
function $t(t5) {
  return pt(t5) ? `https:${t5}` : t5.replace(p, "https:");
}
function xt() {
  return "http" === U.scheme;
}
function wt() {
  return "https" === U.scheme;
}
function Ot(t5, n3 = false) {
  return pt(t5) ? t5.slice(2) : (t5 = t5.replace(a4, ""), n3 && t5.length > 1 && "/" === t5[0] && "/" === t5[1] && (t5 = t5.slice(2)), t5);
}
function Ut(t5) {
  const n3 = t5.indexOf("//"), e2 = t5.indexOf("/", n3 + 2);
  return -1 === e2 ? t5 : t5.slice(0, e2);
}
function Rt(t5) {
  let n3 = 0;
  if (Y(t5)) {
    const e3 = t5.indexOf("//");
    -1 !== e3 && (n3 = e3 + 2);
  }
  const e2 = t5.lastIndexOf("/");
  return e2 < n3 ? t5 : t5.slice(0, e2 + 1);
}
function bt(t5, n3) {
  if (!t5)
    return "";
  const e2 = I(t5).path.replace(/\/+$/, ""), r2 = e2.substring(e2.lastIndexOf("/") + 1);
  if (!(n3 == null ? void 0 : n3.length))
    return r2;
  const o = new RegExp(`.(${n3.join("|")})$`, "ig");
  return r2.replace(o, "");
}
function Ct(t5) {
  return t5.endsWith("/") ? t5 : `${t5}/`;
}
function qt(t5) {
  return t5.replace(/\/+$/, "");
}
function jt(t5) {
  if (/^https?:\/\//i.test(t5)) {
    const n3 = E(t5);
    t5 = (t5 = n3.path.replaceAll(/\/{2,}/g, "/")).replace("/", "//"), n3.query && (t5 += `?${n3.query}`);
  }
  return t5;
}
function Lt(t5) {
  return t5.replace(/^(https?:\/\/)(arcgis\.com)/i, "$1www.$2");
}
function It(t5) {
  const n3 = c2.httpsDomains;
  if (!mt(t5))
    return t5;
  const e2 = t5.indexOf("/", 7);
  let r2;
  if (r2 = -1 === e2 ? t5 : t5.slice(0, e2), r2 = r2.toLowerCase().slice(7), m2.test(r2)) {
    if (!r2.endsWith(":80"))
      return t5;
    r2 = r2.slice(0, -3), t5 = t5.replace(":80", "");
  }
  return xt() && r2 === U.authority && !g.test(t5) || (wt() && r2 === U.authority || n3 && n3.some((t6) => r2 === t6 || r2.endsWith(`.${t6}`)) || wt() && !T(t5)) && (t5 = $t(t5)), t5;
}
function At(t5, n3, e2) {
  if (!(n3 && e2 && t5 && Y(t5)))
    return t5;
  const r2 = t5.indexOf("//"), o = t5.indexOf("/", r2 + 2), s5 = t5.indexOf(":", r2 + 2), i3 = Math.min(o < 0 ? t5.length : o, s5 < 0 ? t5.length : s5);
  if (t5.slice(r2 + 2, i3).toLowerCase() !== n3.toLowerCase())
    return t5;
  return `${t5.slice(0, r2 + 2)}${e2}${t5.slice(i3)}`;
}
function vt(t5) {
  return "string" == typeof t5 ? new x(_(t5)) : (t5.scheme || (t5.scheme = U.scheme), t5);
}
function Pt(t5) {
  return Nt.test(t5);
}
function St(t5, n3) {
  const e2 = I(t5), r2 = Object.keys(e2.query || {});
  return r2.length > 0 && n3 && n3.warn("removeQueryParameters()", `Url query parameters are not supported, the following parameters have been removed: ${r2.join(", ")}.`), e2.path;
}
function kt(t5, n3, e2) {
  const r2 = I(t5), o = r2.query || {};
  return o[n3] = String(e2), `${r2.path}?${v(o)}`;
}
function Et(t5, n3) {
  if (!n3)
    return t5;
  const e2 = I(t5), r2 = e2.query || {};
  for (const [s5, i3] of Object.entries(n3))
    null != i3 && (r2[s5] = i3);
  const o = v(r2);
  return o ? `${e2.path}?${o}` : e2.path;
}
function Ht(t5) {
  if (null == t5)
    return null;
  const n3 = t5.match(Jt);
  return n3 ? n3[2] : null;
}
function Tt(t5) {
  if (null == t5)
    return null;
  const n3 = t5.match(Jt);
  return n3 ? { path: n3[1], extension: n3[2] } : { path: t5, extension: null };
}
async function Wt(t5) {
  if ("string" == typeof t5) {
    return ot(t5) ?? { data: t5 };
  }
  return new Promise((n3, e2) => {
    const r2 = new FileReader();
    r2.readAsDataURL(t5), r2.onload = () => n3(ot(r2.result)), r2.onerror = (t6) => e2(t6);
  });
}
var Jt = /([^.]*)\.([^\/]*)$/;
var Nt = /(^data:image\/svg|\.svg$)/i;

// node_modules/@arcgis/core/support/revision.js
var f2 = "20231109";
var a5 = "bd3f0f31f667aa883ebe3002833f813cc4a75869";

// node_modules/@arcgis/core/kernel.js
Symbol.dispose ?? (Symbol.dispose = Symbol("Symbol.dispose")), Symbol.asyncDispose ?? (Symbol.asyncDispose = Symbol("Symbol.asyncDispose"));
var r = "4.28";
var t3;
var i = r;
i = "4.28.9";
function n2(o) {
  t3 = o;
}
function m3(s5) {
  const e2 = t3 == null ? void 0 : t3.findCredential(s5);
  return (e2 == null ? void 0 : e2.token) ? kt(s5, "token", e2.token) : s5;
}
has("host-webworker");

// node_modules/@arcgis/core/support/apiKeyUtils.js
var t4 = /* @__PURE__ */ new Set(["elevation3d.arcgis.com", "js.arcgis.com", "jsdev.arcgis.com", "jsqa.arcgis.com", "static.arcgis.com"]);
function c3(r2) {
  const c5 = X(r2, true);
  return !!c5 && (c5.endsWith(".arcgis.com") && !t4.has(c5) && !r2.endsWith("/sharing/rest/generateToken"));
}

// node_modules/@arcgis/core/support/requestUtils.js
function i2(e2, o, t5 = false, n3) {
  return new Promise((s5, i3) => {
    if (c(n3))
      return void i3(c4());
    let a7 = () => {
      l3(), i3(new Error(`Unable to load ${o}`));
    }, u3 = () => {
      const r2 = e2;
      l3(), s5(r2);
    }, m4 = () => {
      if (!e2)
        return;
      const r2 = e2;
      l3(), r2.src = "", i3(c4());
    };
    const l3 = () => {
      has("esri-image-decode") || (e2.removeEventListener("error", a7), e2.removeEventListener("load", u3)), a7 = null, u3 = null, e2 = null, null != n3 && n3.removeEventListener("abort", m4), m4 = null, t5 && URL.revokeObjectURL(o);
    };
    null != n3 && n3.addEventListener("abort", m4), has("esri-image-decode") ? e2.decode().then(u3, a7) : (e2.addEventListener("error", a7), e2.addEventListener("load", u3));
  });
}
function c4() {
  try {
    return new DOMException("Aborted", "AbortError");
  } catch {
    const e2 = new Error();
    return e2.name = "AbortError", e2;
  }
}
var a6 = "Timeout exceeded";
function u2() {
  return new Error(a6);
}
function l2(r2) {
  s.request.crossOriginNoCorsDomains || (s.request.crossOriginNoCorsDomains = {});
  const t5 = s.request.crossOriginNoCorsDomains;
  for (let e2 of r2)
    e2 = e2.toLowerCase(), /^https?:\/\//.test(e2) ? t5[X(e2) ?? ""] = 0 : (t5[X("http://" + e2) ?? ""] = 0, t5[X("https://" + e2) ?? ""] = 0);
}
function d2(r2) {
  const s5 = s.request.crossOriginNoCorsDomains;
  if (s5) {
    let e2 = X(r2);
    if (e2)
      return e2 = e2.toLowerCase(), !F(e2, C()) && s5[e2] < Date.now() - 36e5;
  }
  return false;
}
async function f3(r2) {
  var _a;
  const t5 = s.request.crossOriginNoCorsDomains, n3 = X(r2);
  t5 && n3 && (t5[n3.toLowerCase()] = Date.now());
  const i3 = I(r2);
  r2 = i3.path, "json" === ((_a = i3.query) == null ? void 0 : _a.f) && (r2 += "?f=json");
  try {
    await fetch(r2, { mode: "no-cors", credentials: "include" });
  } catch {
  }
}

// node_modules/@arcgis/core/request.js
async function j2(e2, t5) {
  var _a;
  e2 instanceof URL && (e2 = e2.toString()), (t5 == null ? void 0 : t5.query) instanceof URLSearchParams && (t5.query = A(t5.query.toString().replaceAll("+", " ")));
  const r2 = tt(e2), s5 = Z(e2);
  s5 || r2 || (e2 = K(e2));
  const a7 = { url: e2, requestOptions: { ...t5 } };
  let n3 = D(e2);
  if (n3) {
    const e3 = await J(n3, a7);
    if (null != e3)
      return { data: e3, getHeader: R2, httpStatus: 200, requestOptions: a7.requestOptions, url: a7.url };
    n3.after || n3.error || (n3 = null);
  }
  if (e2 = a7.url, "image" === (t5 = a7.requestOptions).responseType && (has("host-webworker") || has("host-node")))
    throw B2("request:invalid-parameters", new Error("responseType 'image' is not supported in Web Workers or Node environment"), a7);
  if ("head" === t5.method) {
    if (t5.body)
      throw B2("request:invalid-parameters", new Error("body parameter cannot be set when method is 'head'"), a7);
    if (r2 || s5)
      throw B2("request:invalid-parameters", new Error("data and blob URLs are not supported for method 'head'"), a7);
  }
  if (await $2(), P2)
    return P2.execute(e2, t5);
  const i3 = new AbortController();
  m(t5, () => i3.abort());
  const h2 = { controller: i3, credential: void 0, credentialToken: void 0, fetchOptions: void 0, hasToken: false, interceptor: n3, params: a7, redoRequest: false, useIdentity: D2.useIdentity, useProxy: false, useSSL: false, withCredentials: false }, m4 = await V2(h2);
  return (_a = n3 == null ? void 0 : n3.after) == null ? void 0 : _a.call(n3, m4), m4;
}
var P2;
var D2 = s.request;
var _2 = "FormData" in globalThis;
var A2 = /* @__PURE__ */ new Set([499, 498, 403, 401]);
var F2 = /* @__PURE__ */ new Set(["COM_0056", "COM_0057", "SB_0008"]);
var I2 = [/\/arcgis\/tokens/i, /\/sharing(\/rest)?\/generatetoken/i, /\/rest\/info/i];
var R2 = () => null;
var M2 = Symbol();
function H2(e2) {
  const t5 = X(e2);
  t5 && !j2._corsServers.includes(t5) && j2._corsServers.push(t5);
}
function N2(e2) {
  const t5 = X(e2);
  return !t5 || t5.endsWith(".arcgis.com") || j2._corsServers.includes(t5) || M(t5);
}
function B2(e2, t5, o, i3) {
  let l3 = "Error";
  const u3 = { url: o.url, requestOptions: o.requestOptions, getHeader: R2, ssl: false };
  if (t5 instanceof s3)
    return t5.details ? (t5.details = a(t5.details), t5.details.url = o.url, t5.details.requestOptions = o.requestOptions) : t5.details = u3, t5;
  if (t5) {
    const e3 = i3 && ((e4) => i3.headers.get(e4)), r2 = i3 == null ? void 0 : i3.status, s5 = t5.message;
    s5 && (l3 = s5), e3 && (u3.getHeader = e3), u3.httpStatus = (null != t5.httpCode ? t5.httpCode : t5.code) || r2 || 0, u3.subCode = t5.subcode, u3.messageCode = t5.messageCode, "string" == typeof t5.details ? u3.messages = [t5.details] : u3.messages = t5.details, u3.raw = M2 in t5 ? t5[M2] : t5;
  }
  return b(t5) ? u() : new s3(e2, l3, u3);
}
async function $2() {
  has("host-webworker") ? P2 || (P2 = await import("./request-4ZHZY5DH.js")) : j2._abortableFetch || (j2._abortableFetch = globalThis.fetch.bind(globalThis));
}
async function z2() {
  t3 || await import("./@arcgis_core_identity_IdentityManager.js");
}
async function K2(r2) {
  var _a;
  const s5 = r2.params.url, o = r2.params.requestOptions, a7 = r2.controller.signal, n3 = o.body;
  let l3 = null, u3 = null;
  if (_2 && "HTMLFormElement" in globalThis && (n3 instanceof FormData ? l3 = n3 : n3 instanceof HTMLFormElement && (l3 = new FormData(n3))), "string" == typeof n3 && (u3 = n3), r2.fetchOptions = { cache: o.cacheBust && !("polyfill" in j2._abortableFetch) ? "no-cache" : "default", credentials: "same-origin", headers: o.headers || {}, method: "head" === o.method ? "HEAD" : "GET", mode: "cors", priority: D2.priority, redirect: "follow", signal: a7 }, (l3 || u3) && (r2.fetchOptions.body = l3 || u3), "anonymous" === o.authMode && (r2.useIdentity = false), r2.hasToken = !!(/token=/i.test(s5) || ((_a = o.query) == null ? void 0 : _a.token) || (l3 == null ? void 0 : l3.get("token"))), !r2.hasToken && s.apiKey && c3(s5) && (o.query || (o.query = {}), o.query.token = s.apiKey, r2.hasToken = true), r2.useIdentity && !r2.hasToken && !r2.credentialToken && !W2(s5) && !c(a7)) {
    let e2;
    "immediate" === o.authMode ? (await z2(), e2 = await t3.getCredential(s5, { signal: a7 }), r2.credential = e2) : "no-prompt" === o.authMode ? (await z2(), e2 = await t3.getCredential(s5, { prompt: false, signal: a7 }).catch(() => {
    }), r2.credential = e2) : t3 && (e2 = t3.findCredential(s5)), e2 && (r2.credentialToken = e2.token, r2.useSSL = !!e2.ssl);
  }
}
function W2(e2) {
  return I2.some((t5) => t5.test(e2));
}
async function G2(e2) {
  let r2 = e2.params.url;
  const s5 = e2.params.requestOptions, o = e2.fetchOptions ?? {}, a7 = Z(r2) || tt(r2), i3 = s5.responseType || "json", l3 = a7 ? 0 : null != s5.timeout ? s5.timeout : D2.timeout;
  let d3 = false;
  if (!a7) {
    e2.useSSL && (r2 = $t(r2)), s5.cacheBust && "default" === o.cache && (r2 = kt(r2, "request.preventCache", Date.now()));
    let a8 = { ...s5.query };
    e2.credentialToken && (a8.token = e2.credentialToken);
    let n3 = v(a8);
    has("esri-url-encodes-apostrophe") && (n3 = n3.replaceAll("'", "%27"));
    const i4 = r2.length + 1 + n3.length;
    let l4;
    d3 = "delete" === s5.method || "post" === s5.method || "put" === s5.method || !!s5.body || i4 > D2.maxUrlLength;
    const u3 = s5.useProxy || !!T(r2);
    if (u3) {
      const e3 = P(r2);
      l4 = e3.path, !d3 && l4.length + 1 + i4 > D2.maxUrlLength && (d3 = true), e3.query && (a8 = { ...e3.query, ...a8 });
    }
    if ("HEAD" === o.method && (d3 || u3)) {
      if (d3) {
        if (i4 > D2.maxUrlLength)
          throw B2("request:invalid-parameters", new Error("URL exceeds maximum length"), e2.params);
        throw B2("request:invalid-parameters", new Error("cannot use POST request when method is 'head'"), e2.params);
      }
      if (u3)
        throw B2("request:invalid-parameters", new Error("cannot use proxy when method is 'head'"), e2.params);
    }
    if (d3 ? (o.method = "delete" === s5.method ? "DELETE" : "put" === s5.method ? "PUT" : "POST", s5.body ? r2 = Et(r2, a8) : (o.body = v(a8), o.headers || (o.headers = {}), o.headers["Content-Type"] = "application/x-www-form-urlencoded")) : r2 = Et(r2, a8), u3 && (e2.useProxy = true, r2 = `${l4}?${r2}`), a8.token && _2 && o.body instanceof FormData && !t(r2) && o.body.set("token", a8.token), s5.hasOwnProperty("withCredentials"))
      e2.withCredentials = s5.withCredentials;
    else if (!F(r2, C())) {
      if (M(r2))
        e2.withCredentials = true;
      else if (t3) {
        const s6 = t3.findServerInfo(r2);
        (s6 == null ? void 0 : s6.webTierAuth) && (e2.withCredentials = true);
      }
    }
    e2.withCredentials && (o.credentials = "include", d2(r2) && await f3(d3 ? Et(r2, a8) : r2));
  }
  let p2, C2, v2 = 0, U2 = false;
  l3 > 0 && (v2 = setTimeout(() => {
    U2 = true, e2.controller.abort();
  }, l3));
  try {
    if ("native-request-init" === s5.responseType)
      C2 = o, C2.url = r2;
    else if ("image" !== s5.responseType || "default" !== o.cache || "GET" !== o.method || d3 || X2(s5.headers) || !a7 && !e2.useProxy && D2.proxyUrl && !N2(r2)) {
      if (p2 = await j2._abortableFetch(r2, o), e2.useProxy || H2(r2), "native" === s5.responseType)
        C2 = p2;
      else if ("HEAD" !== o.method)
        if (p2.ok) {
          switch (i3) {
            case "array-buffer":
              C2 = await p2.arrayBuffer();
              break;
            case "blob":
            case "image":
              C2 = await p2.blob();
              break;
            default:
              C2 = await p2.text();
          }
          if (v2 && (clearTimeout(v2), v2 = 0), "json" === i3 || "xml" === i3 || "document" === i3)
            if (C2)
              switch (i3) {
                case "json":
                  C2 = JSON.parse(C2);
                  break;
                case "xml":
                  C2 = Q2(C2, "application/xml");
                  break;
                case "document":
                  C2 = Q2(C2, "text/html");
              }
            else
              C2 = null;
          if (C2) {
            if ("array-buffer" === i3 || "blob" === i3) {
              const e3 = p2.headers.get("Content-Type");
              if (e3 && /application\/json|text\/plain/i.test(e3) && C2["blob" === i3 ? "size" : "byteLength"] <= 750)
                try {
                  const e4 = await new Response(C2).json();
                  e4.error && (C2 = e4);
                } catch {
                }
            }
            "image" === i3 && C2 instanceof Blob && (C2 = await Z2(URL.createObjectURL(C2), e2, true));
          }
        } else {
          C2 = await p2.text();
          try {
            C2 = JSON.parse(C2);
          } catch {
          }
        }
    } else
      C2 = await Z2(r2, e2);
  } catch (P3) {
    if ("AbortError" === P3.name) {
      if (U2)
        throw u2();
      throw u("Request canceled");
    }
    if (!(!p2 && P3 instanceof TypeError && D2.proxyUrl) || s5.body || "delete" === s5.method || "head" === s5.method || "post" === s5.method || "put" === s5.method || e2.useProxy || N2(r2))
      throw P3;
    e2.redoRequest = true, H({ proxyUrl: D2.proxyUrl, urlPrefix: X(r2) ?? "" });
  } finally {
    v2 && clearTimeout(v2);
  }
  return [p2, C2];
}
async function J(e2, t5) {
  if (null != e2.responseData)
    return e2.responseData;
  if (e2.headers && (t5.requestOptions.headers = { ...t5.requestOptions.headers, ...e2.headers }), e2.query && (t5.requestOptions.query = { ...t5.requestOptions.query, ...e2.query }), e2.before) {
    let o, a7;
    try {
      a7 = await e2.before(t5);
    } catch (s5) {
      o = B2("request:interceptor", s5, t5);
    }
    if ((a7 instanceof Error || a7 instanceof s3) && (o = B2("request:interceptor", a7, t5)), o)
      throw e2.error && e2.error(o), o;
    return a7;
  }
}
function X2(e2) {
  if (e2) {
    for (const t5 of Object.getOwnPropertyNames(e2))
      if (e2[t5])
        return true;
  }
  return false;
}
function Q2(e2, t5) {
  let r2;
  try {
    r2 = new DOMParser().parseFromString(e2, t5);
  } catch {
  }
  if (!r2 || r2.getElementsByTagName("parsererror").length)
    throw new SyntaxError("XML Parse error");
  return r2;
}
async function V2(e2) {
  var _a, _b;
  let r2, s5;
  await K2(e2);
  try {
    do {
      [r2, s5] = await G2(e2);
    } while (!await Y2(e2, r2, s5));
  } catch (n3) {
    const t5 = B2("request:server", n3, e2.params, r2);
    throw t5.details.ssl = e2.useSSL, ((_a = e2.interceptor) == null ? void 0 : _a.error) && e2.interceptor.error(t5), t5;
  }
  const o = e2.params.url;
  if (s5 && /\/sharing\/rest\/(accounts|portals)\/self/i.test(o)) {
    if (!e2.hasToken && !e2.credentialToken && ((_b = s5.user) == null ? void 0 : _b.username) && !M(o)) {
      const e3 = X(o, true);
      e3 && D2.trustedServers.push(e3);
    }
    Array.isArray(s5.authorizedCrossOriginNoCorsDomains) && l2(s5.authorizedCrossOriginNoCorsDomains);
  }
  const a7 = e2.credential;
  if (a7 && t3) {
    const e3 = t3.findServerInfo(a7.server);
    let r3 = e3 == null ? void 0 : e3.owningSystemUrl;
    if (r3) {
      r3 = r3.replace(/\/?$/, "/sharing");
      const e4 = t3.findCredential(r3, a7.userId);
      e4 && -1 === t3._getIdenticalSvcIdx(r3, e4) && e4.resources.unshift(r3);
    }
  }
  return { data: s5, getHeader: r2 ? (e3) => r2 == null ? void 0 : r2.headers.get(e3) : R2, httpStatus: (r2 == null ? void 0 : r2.status) ?? 200, requestOptions: e2.params.requestOptions, ssl: e2.useSSL, url: e2.params.url };
}
async function Y2(e2, r2, s5) {
  var _a;
  if (e2.redoRequest)
    return e2.redoRequest = false, false;
  const o = e2.params.requestOptions;
  if (!r2 || "native" === o.responseType || "native-request-init" === o.responseType)
    return true;
  let a7, n3;
  if (s5 && (s5.error ? a7 = s5.error : "error" === s5.status && Array.isArray(s5.messages) && (a7 = { ...s5 }, a7[M2] = s5, a7.details = s5.messages)), !a7 && !r2.ok)
    throw a7 = new Error(`Unable to load ${r2.url} status: ${r2.status}`), a7[M2] = s5, a7;
  let i3, l3 = null;
  a7 && (n3 = Number(a7.code), l3 = a7.hasOwnProperty("subcode") ? Number(a7.subcode) : null, i3 = a7.messageCode, i3 = i3 == null ? void 0 : i3.toUpperCase());
  const u3 = o.authMode;
  if (403 === n3 && (4 === l3 || ((_a = a7.message) == null ? void 0 : _a.toLowerCase().includes("ssl")) && !a7.message.toLowerCase().includes("permission"))) {
    if (!e2.useSSL)
      return e2.useSSL = true, false;
  } else if (!e2.hasToken && e2.useIdentity && ("no-prompt" !== u3 || 498 === n3) && void 0 !== n3 && A2.has(n3) && !W2(e2.params.url) && (403 !== n3 || (!i3 || !F2.has(i3)) && (null == l3 || 2 === l3 && e2.credentialToken))) {
    await z2();
    try {
      const r3 = await t3.getCredential(e2.params.url, { error: B2("request:server", a7, e2.params), prompt: "no-prompt" !== u3, signal: e2.controller.signal, token: e2.credentialToken });
      return e2.credential = r3, e2.credentialToken = r3.token, e2.useSSL = e2.useSSL || r3.ssl, false;
    } catch (c5) {
      if ("no-prompt" === u3)
        return e2.credential = void 0, e2.credentialToken = void 0, false;
      a7 = c5;
    }
  }
  if (a7)
    throw a7;
  return true;
}
function Z2(e2, t5, r2 = false) {
  const s5 = t5.controller.signal, o = new Image();
  return t5.withCredentials ? o.crossOrigin = "use-credentials" : o.crossOrigin = "anonymous", o.alt = "", o.fetchPriority = D2.priority, o.src = e2, i2(o, e2, r2, s5);
}
j2._abortableFetch = null, j2._corsServers = ["https://server.arcgisonline.com", "https://services.arcgisonline.com"];

export {
  a3 as a,
  t,
  t2,
  x,
  C,
  q,
  I,
  A,
  v,
  S,
  T,
  W,
  N,
  D,
  F,
  _,
  G,
  K,
  V,
  Y,
  Z,
  tt,
  nt,
  et,
  ot,
  st,
  it,
  ut,
  ct,
  pt,
  dt,
  $t,
  Rt,
  bt,
  Ct,
  qt,
  At,
  Pt,
  St,
  kt,
  Et,
  Ht,
  Tt,
  Wt,
  f2 as f,
  a5 as a2,
  r,
  t3,
  i,
  n2 as n,
  m3 as m,
  c3 as c,
  i2,
  j2 as j
};
//# sourceMappingURL=chunk-R5DM4YAB.js.map
