import {
  t as t3
} from "./chunk-7SYCRLSC.js";
import {
  t
} from "./chunk-FW2Y26A2.js";
import {
  t as t2
} from "./chunk-5WG7GACT.js";
import {
  d2 as d,
  pe
} from "./chunk-GAWSWBHO.js";
import {
  k
} from "./chunk-HLGIRLYQ.js";
import {
  s3 as s
} from "./chunk-WJ3HJKNC.js";

// node_modules/@arcgis/core/layers/graphics/sources/geojson/geojson.js
var c = { LineString: "esriGeometryPolyline", MultiLineString: "esriGeometryPolyline", MultiPoint: "esriGeometryMultipoint", Point: "esriGeometryPoint", Polygon: "esriGeometryPolygon", MultiPolygon: "esriGeometryPolygon" };
function u(e) {
  return c[e];
}
function* l(e) {
  switch (e.type) {
    case "Feature":
      yield e;
      break;
    case "FeatureCollection":
      for (const t4 of e.features)
        t4 && (yield t4);
  }
}
function* f(e) {
  if (e)
    switch (e.type) {
      case "Point":
        yield e.coordinates;
        break;
      case "LineString":
      case "MultiPoint":
        yield* e.coordinates;
        break;
      case "MultiLineString":
      case "Polygon":
        for (const t4 of e.coordinates)
          yield* t4;
        break;
      case "MultiPolygon":
        for (const t4 of e.coordinates)
          for (const e2 of t4)
            yield* e2;
    }
}
function* p(e, t4 = {}) {
  const { geometryType: n, objectIdField: i } = t4;
  for (const s2 of e) {
    const { geometry: e2, properties: c2, id: l2 } = s2;
    if (e2 && u(e2.type) !== n)
      continue;
    const f2 = c2 || {};
    let p2;
    i && (p2 = f2[i], null == l2 || p2 || (f2[i] = p2 = l2));
    const a2 = new t(e2 ? h(new t2(), e2, t4) : null, f2, null, p2 ?? void 0);
    yield a2;
  }
}
function a(e) {
  for (const t4 of e)
    if (t4.length > 2)
      return true;
  return false;
}
function y(e) {
  return !g(e);
}
function d2(e) {
  return g(e);
}
function g(e) {
  let t4 = 0;
  for (let n = 0; n < e.length; n++) {
    const o = e[n], r = e[(n + 1) % e.length];
    t4 += o[0] * r[1] - r[0] * o[1];
  }
  return t4 <= 0;
}
function m(e) {
  const t4 = e[0], n = e[e.length - 1];
  return t4[0] === n[0] && t4[1] === n[1] && t4[2] === n[2] || e.push(t4), e;
}
function h(e, t4, n) {
  switch (t4.type) {
    case "LineString":
      return w(e, t4, n);
    case "MultiLineString":
      return P(e, t4, n);
    case "MultiPoint":
      return j(e, t4, n);
    case "MultiPolygon":
      return b(e, t4, n);
    case "Point":
      return S(e, t4, n);
    case "Polygon":
      return F(e, t4, n);
  }
}
function w(e, t4, n) {
  return M(e, t4.coordinates, n), e;
}
function P(e, t4, n) {
  for (const o of t4.coordinates)
    M(e, o, n);
  return e;
}
function j(e, t4, n) {
  return M(e, t4.coordinates, n), e;
}
function b(e, t4, n) {
  for (const o of t4.coordinates) {
    G(e, o[0], n);
    for (let t5 = 1; t5 < o.length; t5++)
      k2(e, o[t5], n);
  }
  return e;
}
function S(e, t4, n) {
  return O(e, t4.coordinates, n), e;
}
function F(e, t4, n) {
  const o = t4.coordinates;
  G(e, o[0], n);
  for (let r = 1; r < o.length; r++)
    k2(e, o[r], n);
  return e;
}
function G(e, t4, n) {
  const o = m(t4);
  y(o) ? T(e, o, n) : M(e, o, n);
}
function k2(e, t4, n) {
  const o = m(t4);
  d2(o) ? T(e, o, n) : M(e, o, n);
}
function M(e, t4, n) {
  for (const o of t4)
    O(e, o, n);
  e.lengths.push(t4.length);
}
function T(e, t4, n) {
  for (let o = t4.length - 1; o >= 0; o--)
    O(e, t4[o], n);
  e.lengths.push(t4.length);
}
function O(e, t4, n) {
  const [o, r, i] = t4;
  e.coords.push(o, r), n.hasZ && e.coords.push(i || 0);
}
function L(t4) {
  switch (typeof t4) {
    case "string":
      return t3(t4) ? "esriFieldTypeDate" : "esriFieldTypeString";
    case "number":
      return "esriFieldTypeDouble";
    default:
      return "unknown";
  }
}
function E(e, o = 4326) {
  if (!e)
    throw new s("geojson-layer:empty", "GeoJSON data is empty");
  if ("Feature" !== e.type && "FeatureCollection" !== e.type)
    throw new s("geojson-layer:unsupported-geojson-object", "missing or not supported GeoJSON object type", { data: e });
  const { crs: r } = e;
  if (!r)
    return;
  const i = "string" == typeof r ? r : "name" === r.type ? r.properties.name : "EPSG" === r.type ? r.properties.code : null, s2 = k({ wkid: o }) ? new RegExp(".*(CRS84H?|4326)$", "i") : new RegExp(`.*(${o})$`, "i");
  if (!i || !s2.test(i))
    throw new s("geojson:unsupported-crs", "unsupported GeoJSON 'crs' member", { crs: r });
}
function I(e, t4 = {}) {
  const n = [], o = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set();
  let c2, p2 = false, y2 = null, d3 = false, { geometryType: g2 = null } = t4, m2 = false;
  for (const s2 of l(e)) {
    const { geometry: e2, properties: t5, id: l2 } = s2;
    if (!e2 || (g2 || (g2 = u(e2.type)), u(e2.type) === g2)) {
      if (!p2) {
        p2 = a(f(e2));
      }
      if (d3 || (d3 = null != l2, d3 && (c2 = typeof l2, t5 && (y2 = Object.keys(t5).filter((e3) => t5[e3] === l2)))), t5 && y2 && d3 && null != l2 && (y2.length > 1 ? y2 = y2.filter((e3) => t5[e3] === l2) : 1 === y2.length && (y2 = t5[y2[0]] === l2 ? y2 : [])), !m2 && t5) {
        let e3 = true;
        for (const s3 in t5) {
          if (o.has(s3))
            continue;
          const c3 = t5[s3];
          if (null == c3) {
            e3 = false, r.add(s3);
            continue;
          }
          const u2 = L(c3);
          if ("unknown" === u2) {
            r.add(s3);
            continue;
          }
          r.delete(s3), o.add(s3);
          const l3 = d(s3);
          l3 && n.push({ name: l3, alias: s3, type: u2 });
        }
        m2 = e3;
      }
    }
  }
  const h2 = d(1 === (y2 == null ? void 0 : y2.length) && y2[0] || null) ?? void 0;
  if (h2) {
    for (const i of n)
      if (i.name === h2 && pe(i)) {
        i.type = "esriFieldTypeOID";
        break;
      }
  }
  return { fields: n, geometryType: g2, hasZ: p2, objectIdFieldName: h2, objectIdFieldType: c2, unknownFields: Array.from(r) };
}
function N(e, t4) {
  return Array.from(p(l(e), t4));
}

export {
  u,
  E,
  I,
  N
};
//# sourceMappingURL=chunk-O5L3AGFQ.js.map
