import {
  t
} from "./chunk-GAJBN4TM.js";
import {
  H,
  be,
  d2 as d,
  ge,
  pe,
  we,
  xe
} from "./chunk-GAWSWBHO.js";
import {
  f,
  i,
  r as r2
} from "./chunk-KBJ5Z4R2.js";
import {
  FixedOffsetZone,
  IANAZone
} from "./chunk-XZS3Q5K4.js";
import {
  a
} from "./chunk-NSRXJNTS.js";
import {
  r2 as r
} from "./chunk-SBW6NNVI.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";

// node_modules/@arcgis/core/layers/support/FieldsIndex.js
function y(e) {
  return "timeZone" in e;
}
function _(e) {
  return "timeZone" in e;
}
function g(e) {
  return "dateFieldsTimeZone" in e;
}
var T = /* @__PURE__ */ new Map();
var Z = class _Z {
  static fromJSON(e) {
    return new _Z(e.fields, e.timeZoneByFieldName);
  }
  static fromLayer(e) {
    return new _Z(e.fields ?? [], S(e));
  }
  static fromLayerJSON(e) {
    return new _Z(e.fields ?? [], S(e));
  }
  constructor(e = [], i2) {
    var _a;
    this._fieldsMap = /* @__PURE__ */ new Map(), this._normalizedFieldsMap = /* @__PURE__ */ new Map(), this._dateFieldsSet = /* @__PURE__ */ new Set(), this._numericFieldsSet = /* @__PURE__ */ new Set(), this._requiredFields = null, this.dateFields = [], this.numericFields = [], this.fields = e || [], this._timeZoneByFieldName = i2 ? new Map(i2) : null;
    const t2 = [];
    for (const s3 of this.fields) {
      const e2 = s3 == null ? void 0 : s3.name, i3 = M(e2);
      if (e2 && i3) {
        const n = w(e2);
        this._fieldsMap.set(e2, s3), this._fieldsMap.set(n, s3), this._normalizedFieldsMap.set(i3, s3), t2.push(`${n}:${s3.type}:${(_a = this._timeZoneByFieldName) == null ? void 0 : _a.get(e2)}`), ge(s3) ? (this.dateFields.push(s3), this._dateFieldsSet.add(s3)) : pe(s3) && (this._numericFieldsSet.add(s3), this.numericFields.push(s3)), we(s3) || xe(s3) || (s3.editable = null == s3.editable || !!s3.editable, s3.nullable = null == s3.nullable || !!s3.nullable);
      }
    }
    t2.sort(), this.uid = t2.join();
  }
  get requiredFields() {
    if (!this._requiredFields) {
      this._requiredFields = [];
      for (const e of this.fields)
        we(e) || xe(e) || e.nullable || void 0 !== H(e) || this._requiredFields.push(e);
    }
    return this._requiredFields;
  }
  equals(e) {
    return this.uid === (e == null ? void 0 : e.uid);
  }
  has(e) {
    return null != this.get(e);
  }
  get(e) {
    if (!e)
      return;
    let i2 = this._fieldsMap.get(e);
    return i2 || (i2 = this._fieldsMap.get(w(e)) ?? this._normalizedFieldsMap.get(M(e)), i2 && this._fieldsMap.set(e, i2), i2);
  }
  getTimeZone(i2) {
    const s3 = this.get(i2 && "string" != typeof i2 ? i2.name : i2);
    return s3 ? this._timeZoneByFieldName ? this._timeZoneByFieldName.get(s3.name) : "date" === s3.type || "esriFieldTypeDate" === s3.type ? (s.getLogger("esri.layers.support.FieldsIndex").error(new s2("getTimeZone:no-timezone-information", `no time zone information for field '${s3.name}'`)), i) : N.has(s3.type) ? r2 : null : null;
  }
  getLuxonTimeZone(e) {
    const i2 = this.getTimeZone(e);
    return i2 ? i2 === r2 ? t.instance : i2 === i ? FixedOffsetZone.utcInstance : r(T, i2, () => IANAZone.create(i2)) : null;
  }
  isDateField(e) {
    return this._dateFieldsSet.has(this.get(e));
  }
  isTimeOnlyField(e) {
    return be(this.get(e));
  }
  isNumericField(e) {
    return this._numericFieldsSet.has(this.get(e));
  }
  normalizeFieldName(e) {
    var _a;
    return ((_a = this.get(e)) == null ? void 0 : _a.name) ?? void 0;
  }
  toJSON() {
    return { fields: this.fields.map((e) => a(e) ? e.toJSON() : e), timeZoneByFieldName: this._timeZoneByFieldName ? Array.from(this._timeZoneByFieldName.entries()) : null };
  }
};
function w(e) {
  return e.trim().toLowerCase();
}
function M(e) {
  var _a;
  return ((_a = d(e)) == null ? void 0 : _a.toLowerCase()) ?? "";
}
var N = /* @__PURE__ */ new Set(["time-only", "date-only", "timestamp-offset", "esriFieldTypeDateOnly", "esriFieldTypeTimeOnly", "esriFieldTypeTimestampOffset"]);
function S(e) {
  const i2 = /* @__PURE__ */ new Map();
  if (!e.fields)
    return i2;
  const t2 = true === e.datesInUnknownTimezone, { timeInfo: s3, editFieldsInfo: n } = e, r3 = (s3 ? "startField" in s3 ? s3.startField : s3.startTimeField : "") ?? "", l = (s3 ? "endField" in s3 ? s3.endField : s3.endTimeField : "") ?? "", o = g(e) ? e.dateFieldsTimeZone ?? null : e.dateFieldsTimeReference ? f(e.dateFieldsTimeReference) : null, d2 = n ? y(n) ? n.timeZone ?? o : n.dateFieldsTimeReference ? f(n.dateFieldsTimeReference) : o ?? i : null, a2 = s3 ? _(s3) ? s3.timeZone ?? o : s3.timeReference ? f(s3.timeReference) : o : null, m = /* @__PURE__ */ new Map([[w((n == null ? void 0 : n.creationDateField) ?? ""), d2], [w((n == null ? void 0 : n.editDateField) ?? ""), d2], [w(r3), a2], [w(l), a2]]);
  for (const { name: u, type: f2 } of e.fields)
    if (N.has(f2))
      i2.set(u, r2);
    else if ("date" !== f2 && "esriFieldTypeDate" !== f2)
      i2.set(u, null);
    else if (t2)
      i2.set(u, r2);
    else {
      const e2 = m.get(w(u ?? "")) ?? o;
      i2.set(u, e2);
    }
  return i2;
}

export {
  Z
};
//# sourceMappingURL=chunk-CKGVKMVG.js.map
