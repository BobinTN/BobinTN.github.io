import {
  j as j4
} from "./chunk-O2KD3APD.js";
import "./chunk-WK4UDTKV.js";
import {
  l as l2,
  m as m2,
  s as s4,
  u as u3
} from "./chunk-XG6EA6F3.js";
import {
  E,
  P
} from "./chunk-RC6N7ZK6.js";
import {
  E as E2,
  p,
  x
} from "./chunk-WICI4OJR.js";
import "./chunk-ZKKM4KJT.js";
import "./chunk-LXYMQMWX.js";
import "./chunk-XJLKESB7.js";
import "./chunk-QLCCKKQG.js";
import "./chunk-673OQ2U7.js";
import "./chunk-DT2VHQBL.js";
import {
  i as i2
} from "./chunk-TKJNJ6KH.js";
import {
  l
} from "./chunk-36R5EC6A.js";
import {
  j as j3
} from "./chunk-KQ7MCWUF.js";
import {
  t
} from "./chunk-PIEUUBJ5.js";
import {
  u as u2
} from "./chunk-OTTMOIDW.js";
import {
  m
} from "./chunk-P5GW5DPX.js";
import {
  f as f2
} from "./chunk-WDO2BXGR.js";
import "./chunk-VA52CKTT.js";
import "./chunk-T3Y5GTKO.js";
import "./chunk-6B7VJB6C.js";
import "./chunk-BADPOP5P.js";
import {
  b
} from "./chunk-WETX22HQ.js";
import "./chunk-JHJVOI7Q.js";
import "./chunk-S6NERLXF.js";
import "./chunk-WOGT6UK2.js";
import "./chunk-BEALJUHO.js";
import "./chunk-GAWSWBHO.js";
import "./chunk-SZAJDZCO.js";
import "./chunk-3DSKWYU4.js";
import "./chunk-ZZYUEH57.js";
import "./chunk-VTWXDFFD.js";
import "./chunk-IPCIO3PX.js";
import "./chunk-V2RPSCV3.js";
import "./chunk-AOJ6OCPK.js";
import {
  i
} from "./chunk-LMT5JII2.js";
import "./chunk-A43TI6AT.js";
import "./chunk-2D3PORS4.js";
import {
  D,
  nn
} from "./chunk-4HKQSEUR.js";
import "./chunk-V3U4F2NL.js";
import "./chunk-ZB6PGKG5.js";
import {
  j as j2
} from "./chunk-OIIDE5GZ.js";
import "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import "./chunk-APYNYYQC.js";
import {
  C,
  v
} from "./chunk-TBSVVR6M.js";
import "./chunk-6TJWLWLO.js";
import "./chunk-H7BKONNV.js";
import "./chunk-K6C6RVSV.js";
import "./chunk-KBJ5Z4R2.js";
import {
  V
} from "./chunk-JUZJCTW2.js";
import "./chunk-423VNHLR.js";
import "./chunk-FN47E7YK.js";
import "./chunk-XZS3Q5K4.js";
import "./chunk-WZPOQGKL.js";
import "./chunk-CCXEAKIM.js";
import "./chunk-Y5D433JZ.js";
import "./chunk-QNOCEWCR.js";
import {
  o
} from "./chunk-WURET5CW.js";
import {
  r
} from "./chunk-QWPLZ3QH.js";
import "./chunk-HLGIRLYQ.js";
import "./chunk-N2K4VRZH.js";
import "./chunk-WL4VPODY.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import {
  I,
  j
} from "./chunk-R5DM4YAB.js";
import {
  f,
  u2 as u
} from "./chunk-NSRXJNTS.js";
import {
  y2 as y
} from "./chunk-LXXF7K7W.js";
import {
  c,
  s3
} from "./chunk-SBW6NNVI.js";
import {
  e
} from "./chunk-62CXLI6S.js";
import {
  a as a2
} from "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  a,
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import "./chunk-4V6374PV.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/support/SceneModification.js
var l3;
var y2 = l3 = class extends f {
  constructor(e2) {
    super(e2), this.geometry = null, this.type = "clip";
  }
  writeGeometry(e2, r2, o2, s5) {
    var _a;
    if (((_a = s5.layer) == null ? void 0 : _a.spatialReference) && !s5.layer.spatialReference.equals(this.geometry.spatialReference)) {
      if (!D(e2.spatialReference, s5.layer.spatialReference))
        return void ((s5 == null ? void 0 : s5.messages) && s5.messages.push(new s3("scenemodification:unsupported", "Scene modifications with incompatible spatial references are not supported", { modification: this, spatialReference: s5.layer.spatialReference, context: s5 })));
      const p2 = new j2();
      nn(e2, p2, s5.layer.spatialReference), r2[o2] = p2.toJSON(s5);
    } else
      r2[o2] = e2.toJSON(s5);
    delete r2[o2].spatialReference;
  }
  clone() {
    return new l3({ geometry: a(this.geometry), type: this.type });
  }
};
e([y({ type: j2 }), j4()], y2.prototype, "geometry", void 0), e([r(["web-scene", "portal-item"], "geometry")], y2.prototype, "writeGeometry", null), e([y({ type: ["clip", "mask", "replace"], nonNullable: true }), j4()], y2.prototype, "type", void 0), y2 = l3 = e([c("esri.layers.support.SceneModification")], y2);
var f3 = y2;

// node_modules/@arcgis/core/layers/support/SceneModifications.js
var a3;
var n = a3 = class extends u(V.ofType(f3)) {
  constructor(r2) {
    super(r2), this.url = null;
  }
  clone() {
    return new a3({ url: this.url, items: this.items.map((r2) => r2.clone()) });
  }
  toJSON(r2) {
    return this.toArray().map((o2) => o2.toJSON(r2)).filter((r3) => !!r3.geometry);
  }
  static fromJSON(r2, o2) {
    const t2 = new a3();
    for (const e2 of r2)
      t2.add(f3.fromJSON(e2, o2));
    return t2;
  }
  static async fromUrl(r2, t2, e2) {
    const i3 = { url: I(r2), origin: "service" }, c2 = await j(r2, { responseType: "json", signal: e2 == null ? void 0 : e2.signal }), n2 = t2.toJSON(), m4 = [];
    for (const o2 of c2.data)
      m4.push(f3.fromJSON({ ...o2, geometry: { ...o2.geometry, spatialReference: n2 } }, i3));
    return new a3({ url: r2, items: m4 });
  }
};
e([y({ type: String })], n.prototype, "url", void 0), n = a3 = e([c("esri.layers.support.SceneModifications")], n);
var m3 = n;

// node_modules/@arcgis/core/layers/IntegratedMeshLayer.js
var b2 = class extends E(l(u2(j3(t(m(i2(b))))))) {
  constructor(...e2) {
    super(...e2), this.geometryType = "mesh", this.operationalLayerType = "IntegratedMeshLayer", this.type = "integrated-mesh", this.nodePages = null, this.materialDefinitions = null, this.textureSetDefinitions = null, this.geometryDefinitions = null, this.serviceUpdateTimeStamp = null, this.profile = "mesh-pyramids", this.modifications = null, this._modificationsSource = null, this.path = null;
  }
  initialize() {
    this.addHandles(v(() => this.modifications, "after-changes", () => this.modifications = this.modifications, C));
  }
  normalizeCtorArgs(e2, t2) {
    return "string" == typeof e2 ? { url: e2, ...t2 } : e2;
  }
  readModifications(e2, t2, o2) {
    this._modificationsSource = { url: i(e2, o2), context: o2 };
  }
  set elevationInfo(e2) {
    this._set("elevationInfo", e2), this._validateElevationInfo();
  }
  async load(e2) {
    return this.addResolvingPromise(this._doLoad(e2)), this;
  }
  async _doLoad(e2) {
    const t2 = e2 == null ? void 0 : e2.signal;
    try {
      await this.loadFromPortal({ supportedTypes: ["Scene Service"] }, e2);
    } catch (o2) {
      a2(o2);
    }
    if (await this._fetchService(t2), null != this._modificationsSource) {
      const t3 = await m3.fromUrl(this._modificationsSource.url, this.spatialReference, e2);
      this.setAtOrigin("modifications", t3, this._modificationsSource.context.origin), this._modificationsSource = null;
    }
    await this._fetchIndexAndUpdateExtent(this.nodePages, t2);
  }
  beforeSave() {
    if (null != this._modificationsSource)
      return this.load().then(() => {
      }, () => {
      });
  }
  async saveAs(e2, t2) {
    return this._debouncedSaveOperations(P.SAVE_AS, { ...t2, getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "integrated-mesh" }, e2);
  }
  async save() {
    const e2 = { getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "integrated-mesh" };
    return this._debouncedSaveOperations(P.SAVE, e2);
  }
  validateLayer(e2) {
    if (e2.layerType && "IntegratedMesh" !== e2.layerType)
      throw new s2("integrated-mesh-layer:layer-type-not-supported", "IntegratedMeshLayer does not support this layer type", { layerType: e2.layerType });
    if (isNaN(this.version.major) || isNaN(this.version.minor))
      throw new s2("layer:service-version-not-supported", "Service version is not supported.", { serviceVersion: this.version.versionString, supportedVersions: "1.x" });
    if (this.version.major > 1)
      throw new s2("layer:service-version-too-new", "Service version is too new.", { serviceVersion: this.version.versionString, supportedVersions: "1.x" });
  }
  _getTypeKeywords() {
    return ["IntegratedMeshLayer"];
  }
  _validateElevationInfo() {
    const e2 = this.elevationInfo, t2 = "Integrated mesh layers";
    x(s.getLogger(this), p(t2, "absolute-height", e2)), x(s.getLogger(this), E2(t2, e2));
  }
};
e([y({ type: String, readOnly: true })], b2.prototype, "geometryType", void 0), e([y({ type: ["show", "hide"] })], b2.prototype, "listMode", void 0), e([y({ type: ["IntegratedMeshLayer"] })], b2.prototype, "operationalLayerType", void 0), e([y({ json: { read: false }, readOnly: true })], b2.prototype, "type", void 0), e([y({ type: s4, readOnly: true })], b2.prototype, "nodePages", void 0), e([y({ type: [l2], readOnly: true })], b2.prototype, "materialDefinitions", void 0), e([y({ type: [u3], readOnly: true })], b2.prototype, "textureSetDefinitions", void 0), e([y({ type: [m2], readOnly: true })], b2.prototype, "geometryDefinitions", void 0), e([y({ readOnly: true })], b2.prototype, "serviceUpdateTimeStamp", void 0), e([y({ type: m3 }), j4({ origins: ["web-scene", "portal-item"], type: "resource", prefix: "modifications" })], b2.prototype, "modifications", void 0), e([o(["web-scene", "portal-item"], "modifications")], b2.prototype, "readModifications", null), e([y(f2)], b2.prototype, "elevationInfo", null), e([y({ type: String, json: { origins: { "web-scene": { read: true, write: true }, "portal-item": { read: true, write: true } }, read: false } })], b2.prototype, "path", void 0), b2 = e([c("esri.layers.IntegratedMeshLayer")], b2);
var U = b2;
export {
  U as default
};
//# sourceMappingURL=IntegratedMeshLayer-ZI333ZI5.js.map
