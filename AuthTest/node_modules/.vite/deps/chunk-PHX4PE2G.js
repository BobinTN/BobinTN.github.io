import {
  c
} from "./chunk-E3I4MGUC.js";
import {
  p
} from "./chunk-SHFNNIVW.js";
import {
  A
} from "./chunk-IYYYQK4Y.js";
import {
  d
} from "./chunk-UTCX6DGX.js";
import {
  b as b2
} from "./chunk-45OAWGCA.js";
import {
  k2 as k
} from "./chunk-4NU7FZD7.js";
import {
  e
} from "./chunk-SZAJDZCO.js";
import {
  L
} from "./chunk-A43TI6AT.js";
import {
  b
} from "./chunk-6TJWLWLO.js";
import {
  s as s2
} from "./chunk-EUTNDAIV.js";
import {
  t3 as t
} from "./chunk-R5DM4YAB.js";
import {
  u3 as u
} from "./chunk-SBW6NNVI.js";
import {
  s3 as s
} from "./chunk-WJ3HJKNC.js";

// node_modules/@arcgis/core/layers/support/featureQueryAll.js
async function r(e2, r2, a2) {
  r2 = r2.clone(), e2.capabilities.query.supportsMaxRecordCountFactor && (r2.maxRecordCountFactor = u2(e2));
  const n = t2(e2), o = e2.capabilities.query.supportsPagination;
  r2.start = 0, r2.num = n;
  let i = null;
  for (; ; ) {
    const t3 = await e2.source.queryFeaturesJSON(r2, a2);
    if (null == i ? i = t3 : i.features = i.features.concat(t3.features), i.exceededTransferLimit = t3.exceededTransferLimit, !o || !t3.exceededTransferLimit)
      break;
    r2.start += n;
  }
  return i;
}
function t2(e2) {
  return u2(e2) * a(e2);
}
function a(e2) {
  return e2.capabilities.query.maxRecordCount || 2e3;
}
function u2(r2) {
  return r2.capabilities.query.supportsMaxRecordCountFactor ? b2.MAX_MAX_RECORD_COUNT_FACTOR : 1;
}

// node_modules/@arcgis/core/layers/support/featureLayerUtils.js
var f = new s2({ esriGeometryPoint: "point", esriGeometryMultipoint: "multipoint", esriGeometryPolyline: "polyline", esriGeometryPolygon: "polygon", esriGeometryMultiPatch: "multipatch" });
async function m(t3, e2, r2, o) {
  const a2 = await G(t3);
  if (await h(t3, e2, o), !a2.addAttachment)
    throw new s(o, "Layer source does not support addAttachment capability");
  return a2.addAttachment(e2, r2);
}
function h(t3, e2, r2) {
  var _a, _b;
  const { attributes: o } = e2, { objectIdField: a2 } = t3;
  return ((_b = (_a = t3.capabilities) == null ? void 0 : _a.data) == null ? void 0 : _b.supportsAttachment) ? e2 ? o ? a2 && o[a2] ? Promise.resolve() : Promise.reject(new s(r2, `feature is missing the identifying attribute ${a2}`)) : Promise.reject(new s(r2, "'attributes' are required on a feature to query attachments")) : Promise.reject(new s(r2, "A feature is required to add/delete/update attachments")) : Promise.reject(new s(r2, "this layer doesn't support attachments"));
}
async function w(t3, e2, r2, o, a2) {
  const s3 = await G(t3);
  if (await h(t3, e2, a2), !s3.updateAttachment)
    throw new s(a2, "Layer source does not support updateAttachment capability");
  return s3.updateAttachment(e2, r2, o);
}
async function b3(t3, e2, r2) {
  const { applyEdits: n } = await import("./editingSupport-DW4NKZPQ.js"), o = await t3.load(), { source: a2, globalIdField: s3 } = o;
  let i = r2;
  return ("feature" === o.type ? o.infoFor3D : null) && null != e2.deleteFeatures && null != s3 && (i = { ...i, globalIdToObjectId: await V(t3, e2.deleteFeatures, s3) }), n(o, a2, e2, r2);
}
async function g(t3, e2, r2) {
  const { uploadAssets: n } = await import("./editingSupport-DW4NKZPQ.js"), o = await t3.load();
  return n(o, o.source, e2, r2);
}
async function j(t3, e2, r2, o) {
  const a2 = await G(t3);
  if (await h(t3, e2, o), !a2.deleteAttachments)
    throw new s(o, "Layer source does not support deleteAttachments capability");
  return a2.deleteAttachments(e2, r2);
}
async function I(t3, e2, r2) {
  const o = (await t3.load({ signal: e2 == null ? void 0 : e2.signal })).source;
  if (!o.fetchRecomputedExtents)
    throw new s(r2, "Layer source does not support fetchUpdates capability");
  return o.fetchRecomputedExtents(e2);
}
async function q(t3, e2, r2, o) {
  var _a, _b;
  e2 = c.from(e2), await t3.load();
  const a2 = t3.source, s3 = t3.capabilities;
  if (!((_a = s3 == null ? void 0 : s3.data) == null ? void 0 : _a.supportsAttachment))
    throw new s(o, "this layer doesn't support attachments");
  const { attachmentTypes: i, objectIds: u3, globalIds: c2, num: l, size: d2, start: y, where: f2 } = e2;
  if (!((_b = s3 == null ? void 0 : s3.operations) == null ? void 0 : _b.supportsQueryAttachments)) {
    if ((i == null ? void 0 : i.length) > 0 || (c2 == null ? void 0 : c2.length) > 0 || (d2 == null ? void 0 : d2.length) > 0 || l || y || f2)
      throw new s(o, "when 'capabilities.operations.supportsQueryAttachments' is false, only objectIds is supported", e2);
  }
  if (!((u3 == null ? void 0 : u3.length) || (c2 == null ? void 0 : c2.length) || f2))
    throw new s(o, "'objectIds', 'globalIds', or 'where' are required to perform attachment query", e2);
  if (!a2.queryAttachments)
    throw new s(o, "Layer source does not support queryAttachments capability", e2);
  return a2.queryAttachments(e2);
}
async function F(t3, e2, r2, o) {
  const a2 = await G(t3);
  if (!a2.queryObjectIds)
    throw new s(o, "Layer source does not support queryObjectIds capability");
  return a2.queryObjectIds(b2.from(e2) ?? t3.createQuery(), r2);
}
async function A2(t3, e2, r2, o) {
  const a2 = await G(t3);
  if (!a2.queryFeatureCount)
    throw new s(o, "Layer source does not support queryFeatureCount capability");
  return a2.queryFeatureCount(b2.from(e2) ?? t3.createQuery(), r2);
}
async function O(t3, e2, r2, o) {
  const a2 = await G(t3);
  if (!a2.queryExtent)
    throw new s(o, "Layer source does not support queryExtent capability");
  return a2.queryExtent(b2.from(e2) ?? t3.createQuery(), r2);
}
async function P(t3, e2, r2, o) {
  const a2 = await G(t3);
  if (!a2.queryRelatedFeatures)
    throw new s(o, "Layer source does not support queryRelatedFeatures capability");
  return a2.queryRelatedFeatures(d.from(e2), r2);
}
async function E(t3, e2, r2, o) {
  const a2 = await G(t3);
  if (!a2.queryRelatedFeaturesCount)
    throw new s(o, "Layer source does not support queryRelatedFeaturesCount capability");
  return a2.queryRelatedFeaturesCount(d.from(e2), r2);
}
async function S(t3) {
  const e2 = t3.source;
  if (e2 == null ? void 0 : e2.refresh)
    try {
      const { dataChanged: r2, updates: n } = await e2.refresh();
      if (null != n && (t3.sourceJSON = { ...t3.sourceJSON, ...n }, t3.read(n, { origin: "service", url: t3.parsedUrl })), r2)
        return true;
    } catch {
    }
  if (t3.definitionExpression)
    try {
      return (await e(t3.definitionExpression, t3.fieldsIndex)).hasDateFunctions;
    } catch {
    }
  return false;
}
function x(t3) {
  var _a, _b;
  const e2 = new b2(), r2 = (_a = t3.capabilities) == null ? void 0 : _a.data, n = (_b = t3.capabilities) == null ? void 0 : _b.query;
  e2.historicMoment = t3.historicMoment, e2.gdbVersion = t3.gdbVersion, e2.returnGeometry = true, n && (e2.compactGeometryEnabled = n.supportsCompactGeometry, e2.defaultSpatialReferenceEnabled = n.supportsDefaultSpatialReference), r2 && (r2.supportsZ && null != t3.returnZ && (e2.returnZ = t3.returnZ), r2.supportsM && null != t3.returnM && (e2.returnM = t3.returnM)), e2.outFields = ["*"];
  const { timeOffset: o, timeExtent: a2 } = t3;
  return e2.timeExtent = null != o && null != a2 ? a2.offset(-o.value, o.unit) : a2 || null, e2.multipatchOption = "multipatch" === t3.geometryType ? "xyFootprint" : null, e2;
}
function R(t3) {
  const { globalIdField: e2, fields: r2 } = t3;
  if (e2)
    return e2;
  if (r2) {
    for (const n of r2)
      if ("esriFieldTypeGlobalID" === n.type)
        return n.name;
  }
}
function M(t3) {
  const { objectIdField: e2, fields: r2 } = t3;
  if (e2)
    return e2;
  if (r2) {
    for (const n of r2)
      if ("esriFieldTypeOID" === n.type)
        return n.name;
  }
}
function C(t3) {
  return t3.currentVersion ? t3.currentVersion : t3.hasOwnProperty("capabilities") || t3.hasOwnProperty("drawingInfo") || t3.hasOwnProperty("hasAttachments") || t3.hasOwnProperty("htmlPopupType") || t3.hasOwnProperty("relationships") || t3.hasOwnProperty("timeInfo") || t3.hasOwnProperty("typeIdField") || t3.hasOwnProperty("types") ? 10 : 9.3;
}
async function G(t3) {
  return (await t3.load()).source;
}
async function L2(e2, r2) {
  if (!t)
    return;
  if (t.findCredential(e2))
    return;
  let n;
  try {
    const o = await L(e2, r2);
    o && (n = await t.checkSignInStatus(`${o}/sharing`));
  } catch (o) {
  }
  if (n)
    try {
      const n2 = null != r2 ? r2.signal : null;
      await t.getCredential(e2, { signal: n2 });
    } catch (o) {
    }
}
async function Q(t3, e2, r2) {
  var _a;
  const n = (_a = t3.parsedUrl) == null ? void 0 : _a.path;
  n && t3.authenticationTriggerEvent === e2 && await L2(n, r2);
}
function T(t3) {
  var _a;
  return !((_a = t3.sourceJSON) == null ? void 0 : _a.isMultiServicesView) && (t3.userHasUpdateItemPrivileges || t3.editingEnabled);
}
var v = u({ types: k });
function D(t3, e2) {
  var _a;
  if (t3.defaultSymbol)
    return ((_a = t3.types) == null ? void 0 : _a.length) ? new A({ defaultSymbol: v(t3.defaultSymbol, t3, e2), field: t3.typeIdField, uniqueValueInfos: t3.types.map((t4) => ({ id: t4.id, symbol: v(t4.symbol, t4, e2) })) }) : new p({ symbol: v(t3.defaultSymbol, t3, e2) });
}
function U(t3) {
  var _a, _b, _c;
  let e2 = (_a = t3.sourceJSON) == null ? void 0 : _a.cacheMaxAge;
  if (!e2)
    return false;
  const r2 = (_c = (_b = t3.editingInfo) == null ? void 0 : _b.lastEditDate) == null ? void 0 : _c.getTime();
  return null == r2 || (e2 *= 1e3, Date.now() - r2 < e2);
}
async function V(t3, e2, n) {
  if (null == e2)
    return null;
  const o = [], { objectIdField: a2 } = t3;
  if (e2.forEach((t4) => {
    let e3 = null;
    if ("attributes" in t4) {
      const { attributes: r2 } = t4;
      e3 = { globalId: r2[n], objectId: null != r2[a2] && -1 !== r2[a2] ? r2[a2] : null };
    } else
      e3 = { globalId: t4.globalId, objectId: null != t4.objectId && -1 !== t4.objectId ? t4.objectId : null };
    null != e3.globalId && (null != e3.objectId && -1 !== e3.objectId || o.push(e3.globalId));
  }), 0 === o.length)
    return null;
  const s3 = t3.createQuery();
  s3.where = o.map((t4) => `${n}='${t4}'`).join(" OR "), s3.returnGeometry = false, s3.outFields = [a2, n], s3.cacheHint = false;
  const u3 = await b(r(t3, s3));
  if (!u3.ok)
    return null;
  const c2 = /* @__PURE__ */ new Map(), l = u3.value.features;
  for (const r2 of l) {
    const t4 = r2.attributes[n], e3 = r2.attributes[a2];
    null != t4 && null != e3 && -1 !== e3 && c2.set(t4, e3);
  }
  return c2;
}

export {
  r,
  f,
  m,
  w,
  b3 as b,
  g,
  j,
  I,
  q,
  F,
  A2 as A,
  O,
  P,
  E,
  S,
  x,
  R,
  M,
  C,
  Q,
  T,
  D,
  U,
  V
};
//# sourceMappingURL=chunk-PHX4PE2G.js.map
