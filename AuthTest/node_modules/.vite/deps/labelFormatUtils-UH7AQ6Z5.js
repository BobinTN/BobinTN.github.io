import {
  _,
  x
} from "./chunk-TTZWDXX5.js";
import {
  d,
  ge,
  pe
} from "./chunk-GAWSWBHO.js";
import {
  e
} from "./chunk-SZAJDZCO.js";
import {
  c
} from "./chunk-3DSKWYU4.js";
import "./chunk-ZZYUEH57.js";
import "./chunk-VTWXDFFD.js";
import "./chunk-IPCIO3PX.js";
import "./chunk-OIIDE5GZ.js";
import "./chunk-3XSRVKBX.js";
import "./chunk-WYBZLWIA.js";
import "./chunk-MKW4ORPJ.js";
import "./chunk-YTH6VA7N.js";
import "./chunk-GINTRQSD.js";
import {
  u
} from "./chunk-H7BKONNV.js";
import "./chunk-K6C6RVSV.js";
import {
  E,
  j
} from "./chunk-KBJ5Z4R2.js";
import "./chunk-XZS3Q5K4.js";
import "./chunk-Y5D433JZ.js";
import "./chunk-QNOCEWCR.js";
import "./chunk-WURET5CW.js";
import "./chunk-QWPLZ3QH.js";
import "./chunk-HLGIRLYQ.js";
import "./chunk-WL4VPODY.js";
import "./chunk-OMPEZIP5.js";
import "./chunk-EUTNDAIV.js";
import "./chunk-SJZIFARA.js";
import "./chunk-R5DM4YAB.js";
import "./chunk-NSRXJNTS.js";
import "./chunk-LXXF7K7W.js";
import "./chunk-SBW6NNVI.js";
import "./chunk-62CXLI6S.js";
import "./chunk-RFPH3ZTZ.js";
import "./chunk-WGO3VFQP.js";
import "./chunk-CQS47VN5.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-WJ3HJKNC.js";
import "./chunk-4V6374PV.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/support/labelFormatUtils.js
var m = s.getLogger("esri.layers.support.labelFormatUtils");
var p = { type: "simple", evaluate: () => null };
var d2 = { getAttribute: (e2, r) => e2.field(r) };
async function w(r, n, o) {
  if (!r || !r.symbol || !n)
    return p;
  const a = r.where, l = x(r);
  let i;
  if ("arcade" === l.type) {
    const r2 = await c(l.expression, o, n);
    if (null == r2)
      return p;
    i = { type: "arcade", evaluate(t, n2) {
      try {
        const e2 = "attributes" in t ? r2.repurposeFeature(t) : t;
        e2.contextTimeZone = n2 ?? null;
        const o2 = r2.evaluate({ $view: { timeZone: n2 }, $feature: e2 }, r2.services);
        if (null != o2)
          return o2.toString();
      } catch (o2) {
        m.error(new s2("arcade-expression-error", "Encountered an error when evaluating label expression for feature", { error: o2, feature: t, expression: l }));
      }
      return null;
    }, needsHydrationToEvaluate: () => null == _(l.expression) };
  } else
    i = { type: "simple", evaluate: (e2) => l.expression.replaceAll(/{[^}]*}/g, (r2) => {
      const t = r2.slice(1, -1), o2 = n.get(t);
      if (!o2)
        return r2;
      let a2 = null;
      if ("attributes" in e2) {
        e2 && e2.attributes && (a2 = e2.attributes[o2.name]);
      } else
        a2 = e2.field(o2.name);
      return null == a2 ? "" : g(a2, o2);
    }) };
  if (a) {
    let r2;
    try {
      r2 = await e(a, n);
    } catch (s3) {
      return m.error(new s2("bad-where-clause", "Encountered an error when evaluating where clause, ignoring", { where: a, error: s3 })), p;
    }
    const o2 = i.evaluate;
    i.evaluate = (t, n2) => {
      const l2 = "attributes" in t ? void 0 : d2;
      try {
        if (r2.testFeature(t, l2))
          return o2(t, n2);
      } catch (s3) {
        m.error(new s2("bad-where-clause", "Encountered an error when evaluating where clause for feature", { where: a, feature: t, error: s3 }));
      }
      return null;
    };
  }
  return i;
}
function g(e2, r) {
  if (null == e2)
    return "";
  const t = r.domain;
  if (t) {
    if ("codedValue" === t.type || "coded-value" === t.type) {
      const r2 = e2;
      for (const e3 of t.codedValues)
        if (e3.code === r2)
          return e3.name;
    } else if ("range" === t.type) {
      const { max: n, min: o } = d(r), a = +e2;
      if (null != o && null != n && o <= a && a <= n)
        return t.name;
    }
  }
  let u2 = e2;
  return ge(r) ? u2 = j(u2, E("short-date")) : pe(r) && (u2 = u(+u2)), u2 || "";
}
export {
  w as createLabelFunction,
  g as formatField
};
//# sourceMappingURL=labelFormatUtils-UH7AQ6Z5.js.map
